// ==UserScript==
// @name        bluesky-navigator
// @description Adds Vim-like navigation, read/unread post-tracking, and other features to Bluesky
// @version     1.0.31+351.eb25e702
// @author      https://bsky.app/profile/tonyc.org
// @namespace   https://tonyc.org/
// @match       https://bsky.app/*
// @require     https://code.jquery.com/jquery-3.7.1.min.js
// @require     https://raw.githubusercontent.com/sizzlemctwizzle/GM_config/refs/heads/master/gm_config.js
// @require     https:code.jquery.com/ui/1.12.1/jquery-ui.min.js
// @downloadURL https://github.com/tonycpsu/bluesky-navigator/raw/refs/heads/main/dist/bluesky-navigator.user.js
// @updateURL   https://github.com/tonycpsu/bluesky-navigator/raw/refs/heads/main/dist/bluesky-navigator.user.js
// @connect     clearsky.services
// @connect     surreal.cloud
// @grant       GM_setValue
// @grant       GM_getValue
// @grant       GM_addStyle
// @grant       GM_xmlhttpRequest
// @grant       GM_info
// @grant       unsafeWindow
// @grant       GM.getValue
// @grant       GM.setValue
// @grant       GM.xmlhttpRequest
// ==/UserScript==

(function() {
  "use strict";
  const constants$1 = {
    URL_MONITOR_INTERVAL: 500,
    STATE_KEY: "bluesky_state",
    DRAWER_MENU_SELECTOR: 'button[aria-label="Open drawer menu"]',
    SCREEN_SELECTOR: "main > div > div > div",
    HOME_SCREEN_SELECTOR: 'div[data-testid="HomeScreen"]',
    get FEED_TAB_SELECTOR() {
      return `${constants$1.HOME_SCREEN_SELECTOR} > div > div`;
    },
    get TOOLBAR_CONTAINER_SELECTOR() {
      return `${constants$1.FEED_TAB_SELECTOR} > div:first-child`;
    },
    LOAD_NEW_BUTTON_SELECTOR: "button[aria-label^='Load new']",
    get LOAD_NEW_INDICATOR_SELECTOR() {
      return `${constants$1.LOAD_NEW_BUTTON_SELECTOR} div[style*="border-color: rgb(197, 207, 217)"]`;
    },
    get FEED_CONTAINER_SELECTOR() {
      return `${constants$1.HOME_SCREEN_SELECTOR} div[data-testid$="FeedPage"] div[style*="removed-body-scroll-bar-size"] > div`;
    },
    get STATUS_BAR_CONTAINER_SELECTOR() {
      return `${constants$1.HOME_SCREEN_SELECTOR} div[data-testid$="FeedPage"] div[style*="removed-body-scroll-bar-size"]`;
    },
    FEED_ITEM_SELECTOR: 'div:not(.css-175oi2r) > div[tabindex="0"][role="link"]:not(.r-1awozwy)',
    LEFT_SIDEBAR_SELECTOR: 'nav[role="navigation"]',
    POST_ITEM_SELECTOR: 'div[data-testid^="postThreadItem-by-"]',
    POST_CONTENT_SELECTOR: 'div[data-testid="contentHider-post"]',
    WIDTH_SELECTOR: 'div[style*="removed-body-scroll-bar-size"][style*="width: 100%"]',
    PROFILE_SELECTOR: 'a[aria-label="View profile"]',
    LINK_SELECTOR: 'a[target="_blank"]',
    CLEARSKY_BLOCKED_ALL_CSS: { "background-color": "#ff8080" },
    CLEARSKY_BLOCKED_RECENT_CSS: { "background-color": "#cc4040" },
    SIDECAR_SVG_REPLY: `<svg fill="none" width="18" viewBox="0 0 24 24" height="18" style="color: rgb(111, 134, 159); pointer-events: none; flex-shrink: 0; display: block;"><path fill="hsl(211, 20%, 53%)" fill-rule="evenodd" clip-rule="evenodd" d="M2.002 6a3 3 0 0 1 3-3h14a3 3 0 0 1 3 3v10a3 3 0 0 1-3 3H12.28l-4.762 2.858A1 1 0 0 1 6.002 21v-2h-1a3 3 0 0 1-3-3V6Zm3-1a1 1 0 0 0-1 1v10a1 1 0 0 0 1 1h2a1 1 0 0 1 1 1v1.234l3.486-2.092a1 1 0 0 1 .514-.142h7a1 1 0 0 0 1-1V6a1 1 0 0 0-1-1h-14Z"></path></svg>`,
    SIDECAR_SVG_REPOST: [
      `<svg fill="none" width="18" viewBox="0 0 24 24" height="18" style="color: rgb(111, 134, 159); flex-shrink: 0; display: block;"><path fill="hsl(211, 20%, 53%)" fill-rule="evenodd" clip-rule="evenodd" d="M17.957 2.293a1 1 0 1 0-1.414 1.414L17.836 5H6a3 3 0 0 0-3 3v3a1 1 0 1 0 2 0V8a1 1 0 0 1 1-1h11.836l-1.293 1.293a1 1 0 0 0 1.414 1.414l2.47-2.47a1.75 1.75 0 0 0 0-2.474l-2.47-2.47ZM20 12a1 1 0 0 1 1 1v3a3 3 0 0 1-3 3H6.164l1.293 1.293a1 1 0 1 1-1.414 1.414l-2.47-2.47a1.75 1.75 0 0 1 0-2.474l2.47-2.47a1 1 0 0 1 1.414 1.414L6.164 17H18a1 1 0 0 0 1-1v-3a1 1 0 0 1 1-1Z"></path></svg>`,
      `<svg fill="none" width="18" viewBox="0 0 24 24" height="18" style="color: rgb(19, 195, 113); flex-shrink: 0; display: block;"><path fill="hsl(152, 82%, 42%)" fill-rule="evenodd" clip-rule="evenodd" d="M17.957 2.293a1 1 0 1 0-1.414 1.414L17.836 5H6a3 3 0 0 0-3 3v3a1 1 0 1 0 2 0V8a1 1 0 0 1 1-1h11.836l-1.293 1.293a1 1 0 0 0 1.414 1.414l2.47-2.47a1.75 1.75 0 0 0 0-2.474l-2.47-2.47ZM20 12a1 1 0 0 1 1 1v3a3 3 0 0 1-3 3H6.164l1.293 1.293a1 1 0 1 1-1.414 1.414l-2.47-2.47a1.75 1.75 0 0 1 0-2.474l2.47-2.47a1 1 0 0 1 1.414 1.414L6.164 17H18a1 1 0 0 0 1-1v-3a1 1 0 0 1 1-1Z"></path></svg>`
    ],
    SIDECAR_SVG_LIKE: [
      `<svg fill="none" width="18" viewBox="0 0 24 24" height="18" style="color: rgb(111, 134, 159); pointer-events: none; flex-shrink: 0; display: block;"><path fill="hsl(211, 20%, 53%)" fill-rule="evenodd" clip-rule="evenodd" d="M16.734 5.091c-1.238-.276-2.708.047-4.022 1.38a1 1 0 0 1-1.424 0C9.974 5.137 8.504 4.814 7.266 5.09c-1.263.282-2.379 1.206-2.92 2.556C3.33 10.18 4.252 14.84 12 19.348c7.747-4.508 8.67-9.168 7.654-11.7-.541-1.351-1.657-2.275-2.92-2.557Zm4.777 1.812c1.604 4-.494 9.69-9.022 14.47a1 1 0 0 1-.978 0C2.983 16.592.885 10.902 2.49 6.902c.779-1.942 2.414-3.334 4.342-3.764 1.697-.378 3.552.003 5.169 1.286 1.617-1.283 3.472-1.664 5.17-1.286 1.927.43 3.562 1.822 4.34 3.764Z"></path></svg>`,
      `<svg fill="none" width="18" viewBox="0 0 24 24" height="18" class="r-84gixx" style="flex-shrink: 0; display: block;"><path fill="#ec4899" fill-rule="evenodd" clip-rule="evenodd" d="M12.489 21.372c8.528-4.78 10.626-10.47 9.022-14.47-.779-1.941-2.414-3.333-4.342-3.763-1.697-.378-3.552.003-5.169 1.287-1.617-1.284-3.472-1.665-5.17-1.287-1.927.43-3.562 1.822-4.34 3.764-1.605 4 .493 9.69 9.021 14.47a1 1 0 0 0 .978 0Z"></path></svg>`
    ],
    WIDTH_OFFSET: 32
  };
  const DEFAULT_HISTORY_MAX = 5e3;
  class StateManager {
    constructor(key, defaultState = {}, config2 = {}) {
      this.key = key;
      this.config = config2;
      if (!this.config) {
        debugger;
      }
      this.listeners = [];
      this.debounceTimeout = null;
      this.maxEntries = this.config.maxEntries || DEFAULT_HISTORY_MAX;
      this.state = {};
      this.isLocalStateDirty = false;
      this.localSaveTimeout = null;
      this.remoteSyncTimeout = null;
      this.handleBlockListResponse = this.handleBlockListResponse.bind(this);
      this.saveStateImmediately = this.saveStateImmediately.bind(this);
      window.addEventListener("beforeunload", () => this.saveStateImmediately());
    }
    static async create(key, defaultState = {}, config2 = {}) {
      const instance = new StateManager(key, defaultState, config2);
      await instance.initializeState(defaultState);
      return instance;
    }
    async initializeState(defaultState) {
      this.state = await this.loadState(defaultState);
      this.ensureBlockState();
      this.updateBlockList();
    }
    ensureBlockState() {
      if (!this.state.blocks) {
        this.state.blocks = {
          all: { updated: null, handles: [] },
          recent: { updated: null, handles: [] }
        };
      }
    }
    setSyncStatus(status, title) {
      const overlay = $(".preferences-icon-overlay");
      if (!overlay) {
        console.log("no overlay");
        return;
      }
      $(overlay).attr("title", `sync: ${status} ${title || ""}`);
      for (const s of ["ready", "pending", "success", "failure"]) {
        $(overlay).removeClass(`preferences-icon-overlay-sync-${s}`);
      }
      $(overlay).addClass(`preferences-icon-overlay-sync-${status}`);
      if (status == "success") {
        setTimeout(() => this.setSyncStatus("ready"), 3e3);
      }
    }
    /**
     * Executes a query against the remote database.
     * @param {string} query - The query string to execute.
     * @param {string} successStatus - The status to set on successful execution (e.g., "success").
     * @returns {Promise<Object>} - Resolves with the parsed result of the query.
     */
    async executeRemoteQuery(query, successStatus = "success") {
      const { url, namespace = "bluesky_navigator", database = "state", username, password } = JSON.parse(this.config.stateSyncConfig);
      return new Promise((resolve, reject) => {
        GM_xmlhttpRequest({
          method: "POST",
          url: `${url.replace(/\/$/, "")}/sql`,
          headers: {
            "Accept": "application/json",
            "Authorization": "Basic " + btoa(`${username}:${password}`)
          },
          data: `USE NS ${namespace} DB ${database}; ${query}`,
          onload: (response) => {
            try {
              if (response.status !== 200) {
                throw new Error(response.statusText);
              }
              const result = JSON.parse(response.responseText)[1]?.result[0];
              this.setSyncStatus(successStatus);
              resolve(result);
            } catch (error) {
              console.error("Error executing query:", error.message);
              this.setSyncStatus("failure", error.message);
              reject(error);
            }
          },
          onerror: (error) => {
            console.error("Network error executing query:", error.message);
            this.setSyncStatus("failure", error.message);
            reject(error);
          }
        });
      });
    }
    async getRemoteStateUpdated() {
      const sinceResult = await this.executeRemoteQuery(`SELECT lastUpdated FROM state:current;`);
      sinceResult["lastUpdated"];
      return sinceResult["lastUpdated"];
    }
    /**
     * Loads state from storage or initializes with the default state.
     */
    async loadState(defaultState) {
      try {
        const savedState = JSON.parse(GM_getValue(this.key, "{}"));
        if (this.config.stateSyncEnabled) {
          const remoteState = await this.loadRemoteState(this.state.lastUpdated);
          return remoteState ? { ...defaultState, ...remoteState } : { ...defaultState, ...savedState };
        } else {
          return { ...defaultState, ...savedState };
        }
      } catch (error) {
        console.error("Error loading state, using defaults:", error);
        return defaultState;
      }
    }
    async loadRemoteState(since) {
      try {
        console.log("Loading remote state...");
        this.setSyncStatus("pending");
        const lastUpdated = await this.getRemoteStateUpdated();
        if (!since || !lastUpdated || new Date(since) < new Date(lastUpdated)) {
          console.log(`Remote state is newer: ${since} < ${lastUpdated}`);
          const result = await this.executeRemoteQuery("SELECT * FROM state:current;");
          const stateObj = result || {};
          delete stateObj.id;
          console.log("Remote state loaded successfully.");
          return stateObj;
        } else {
          console.log(`Local state is newer: ${since} >= ${lastUpdated}`);
          return null;
        }
      } catch (error) {
        console.error("Failed to load remote state:", error);
        return {};
      }
    }
    /**
     * Updates the state and schedules a chained local and remote save.
     */
    updateState(newState) {
      this.state = { ...this.state, ...newState };
      this.state.lastUpdated = (/* @__PURE__ */ new Date()).toISOString();
      this.isLocalStateDirty = true;
      this.scheduleLocalSave();
    }
    /**
     * Schedules a local state save after a 1-second delay.
     * Triggers remote sync only if local state is saved.
     */
    scheduleLocalSave() {
      clearTimeout(this.localSaveTimeout);
      this.localSaveTimeout = setTimeout(() => {
        const shouldSyncRemote = this.isLocalStateDirty;
        this.saveLocalState().then(() => {
          if (shouldSyncRemote) {
            this.scheduleRemoteSync();
          }
        });
      }, this.config.stateSaveTimeout);
    }
    /**
     * Saves the local state and resolves a promise.
     * @returns {Promise<void>}
     */
    async saveLocalState() {
      console.log("Saving local state...");
      this.cleanupState();
      GM_setValue(this.key, JSON.stringify(this.state));
      console.log("Local state saved.");
      this.isLocalStateDirty = false;
      this.notifyListeners();
    }
    /**
     * Schedules a remote state synchronization after a longer delay.
     */
    scheduleRemoteSync() {
      if (!this.config.stateSyncEnabled) {
        console.log("sync disabled");
        return;
      }
      clearTimeout(this.remoteSyncTimeout);
      this.remoteSyncTimeout = setTimeout(() => {
        this.saveRemoteState(this.state.lastUpdated);
      }, this.config.stateSyncTimeout);
    }
    /**
     * Saves the remote state if needed.
     */
    async saveRemoteState(since) {
      const { url, namespace = "bluesky_navigator", database = "state", username, password } = JSON.parse(this.config.stateSyncConfig);
      try {
        const lastUpdated = await this.getRemoteStateUpdated();
        if (!since || !lastUpdated || new Date(since) < new Date(lastUpdated)) {
          console.log("Not saving because remote state is newer.");
          return;
        }
        console.log("Saving remote state...");
        this.setSyncStatus("pending");
        await this.executeRemoteQuery(
          `UPSERT state:current MERGE {${JSON.stringify(this.state).slice(1, -1)}, created_at: time::now()}`,
          "success"
        );
      } catch (error) {
        console.error("Failed to save remote state:", error);
      }
    }
    /**
     * Immediately saves both local and remote states.
     */
    saveStateImmediately(saveLocal = true, saveRemote = false) {
      if (saveLocal) {
        this.saveLocalState();
      }
      if (this.config.stateSyncEnabled && saveRemote) {
        this.saveRemoteState(this.state.lastUpdated);
      }
    }
    /**
     * Keeps only the most recent N entries in the state.
     */
    cleanupState() {
      if (this.state.seen) {
        this.state.seen = this.keepMostRecentValues(this.state.seen, this.maxEntries);
      }
    }
    /**
     * Utility to keep only the most recent N entries in an object.
     * Assumes values are ISO date strings for sorting.
     * @param {Object} obj - The object to prune.
     * @param {number} maxEntries - The maximum number of entries to retain.
     */
    keepMostRecentValues(obj, maxEntries) {
      const entries = Object.entries(obj);
      entries.sort(([, dateA], [, dateB]) => new Date(dateB) - new Date(dateA));
      return Object.fromEntries(entries.slice(0, maxEntries));
    }
    /**
     * Resets state to the default value.
     * @param {Object} defaultState - The default state object.
     */
    resetState(defaultState = {}) {
      this.state = defaultState;
    }
    /**
     * Registers a listener for state changes.
     * @param {function} callback - The listener function to invoke on state change.
     */
    addListener(callback) {
      if (typeof callback === "function") {
        this.listeners.push(callback);
      }
    }
    /**
     * Notifies all registered listeners of a state change.
     */
    notifyListeners() {
      this.listeners.forEach((callback) => callback(this.state));
    }
    handleBlockListResponse(response, responseKey, stateKey) {
      var jsonResponse = $.parseJSON(response.response);
      try {
        this.state.blocks[stateKey].handles = jsonResponse.data[responseKey].map(
          (entry) => entry.Handle
        );
        this.state.blocks[stateKey].updated = Date.now();
      } catch (error) {
        console.warn("couldn't fetch block list");
      }
    }
    updateBlockList() {
      const blockConfig = {
        all: {
          url: "https://api.clearsky.services/api/v1/anon/lists/fun-facts",
          responseKey: "blocked"
        },
        recent: {
          url: "https://api.clearsky.services/api/v1/anon/lists/funer-facts",
          responseKey: "blocked24"
        }
      };
      for (const [stateKey, cfg] of Object.entries(blockConfig)) {
        if (this.state.blocks[stateKey].updated == null || Date.now() + constants.CLEARSKY_LIST_REFRESH_INTERVAL > this.state.blocks[stateKey].updated) {
          GM_xmlhttpRequest({
            method: "GET",
            url: cfg.url,
            headers: {
              Accept: "application/json"
            },
            onload: (response) => this.handleBlockListResponse(response, cfg.responseKey, stateKey)
          });
        }
      }
    }
  }
  const DEFAULT_STATE = {
    seen: {},
    lastUpdated: null,
    page: "home",
    "blocks": { "all": [], "recent": [] },
    feedSortReverse: false,
    feedHideRead: false
  };
  let stateManager;
  const target = {
    init(key, config2, onSuccess) {
      StateManager.create(key, DEFAULT_STATE, config2).then((initializedStateManager) => {
        stateManager = initializedStateManager;
        console.log("State initialized");
        console.dir(stateManager.state);
        onSuccess();
      }).catch((error) => {
        console.error("Failed to initialize StateManager:", error);
      });
    }
  };
  const state = new Proxy(target, {
    get(target2, prop, receiver) {
      if (prop in target2) {
        return typeof target2[prop] === "function" ? target2[prop].bind(receiver) : target2[prop];
      } else if (prop == "stateManager") {
        return stateManager;
      } else if (prop in stateManager.state) {
        return stateManager.state[prop];
      }
      console.warn(`State Warning: ${prop} is not defined`);
      return void 0;
    },
    set(target2, prop, value) {
      console.log(`State Update: ${prop} = ${value}`);
      stateManager.state[prop] = value;
      return true;
    }
  });
  function getDefaultExportFromCjs(x) {
    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
  }
  function getAugmentedNamespace(n) {
    if (n.__esModule) return n;
    var f = n.default;
    if (typeof f == "function") {
      var a = function a2() {
        if (this instanceof a2) {
          return Reflect.construct(f, arguments, this.constructor);
        }
        return f.apply(this, arguments);
      };
      a.prototype = f.prototype;
    } else a = {};
    Object.defineProperty(a, "__esModule", { value: true });
    Object.keys(n).forEach(function(k) {
      var d = Object.getOwnPropertyDescriptor(n, k);
      Object.defineProperty(a, k, d.get ? d : {
        enumerable: true,
        get: function() {
          return n[k];
        }
      });
    });
    return a;
  }
  var dist$5 = {};
  var dist$4 = {};
  var types$5 = {};
  var lib$1 = {};
  var external$1 = {};
  var errors = {};
  var en = {};
  var util$8 = {};
  var hasRequiredUtil$8;
  function requireUtil$8() {
    if (hasRequiredUtil$8) return util$8;
    hasRequiredUtil$8 = 1;
    (function(exports) {
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getParsedType = exports.ZodParsedType = exports.objectUtil = exports.util = void 0;
      var util2;
      (function(util3) {
        util3.assertEqual = (val) => val;
        function assertIs(_arg) {
        }
        util3.assertIs = assertIs;
        function assertNever(_x) {
          throw new Error();
        }
        util3.assertNever = assertNever;
        util3.arrayToEnum = (items) => {
          const obj = {};
          for (const item of items) {
            obj[item] = item;
          }
          return obj;
        };
        util3.getValidEnumValues = (obj) => {
          const validKeys = util3.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
          const filtered = {};
          for (const k of validKeys) {
            filtered[k] = obj[k];
          }
          return util3.objectValues(filtered);
        };
        util3.objectValues = (obj) => {
          return util3.objectKeys(obj).map(function(e) {
            return obj[e];
          });
        };
        util3.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
          const keys = [];
          for (const key in object) {
            if (Object.prototype.hasOwnProperty.call(object, key)) {
              keys.push(key);
            }
          }
          return keys;
        };
        util3.find = (arr, checker) => {
          for (const item of arr) {
            if (checker(item))
              return item;
          }
          return void 0;
        };
        util3.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
        function joinValues(array, separator = " | ") {
          return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
        }
        util3.joinValues = joinValues;
        util3.jsonStringifyReplacer = (_, value) => {
          if (typeof value === "bigint") {
            return value.toString();
          }
          return value;
        };
      })(util2 || (exports.util = util2 = {}));
      var objectUtil;
      (function(objectUtil2) {
        objectUtil2.mergeShapes = (first, second) => {
          return {
            ...first,
            ...second
            // second overwrites first
          };
        };
      })(objectUtil || (exports.objectUtil = objectUtil = {}));
      exports.ZodParsedType = util2.arrayToEnum([
        "string",
        "nan",
        "number",
        "integer",
        "float",
        "boolean",
        "date",
        "bigint",
        "symbol",
        "function",
        "undefined",
        "null",
        "array",
        "object",
        "unknown",
        "promise",
        "void",
        "never",
        "map",
        "set"
      ]);
      const getParsedType = (data) => {
        const t = typeof data;
        switch (t) {
          case "undefined":
            return exports.ZodParsedType.undefined;
          case "string":
            return exports.ZodParsedType.string;
          case "number":
            return isNaN(data) ? exports.ZodParsedType.nan : exports.ZodParsedType.number;
          case "boolean":
            return exports.ZodParsedType.boolean;
          case "function":
            return exports.ZodParsedType.function;
          case "bigint":
            return exports.ZodParsedType.bigint;
          case "symbol":
            return exports.ZodParsedType.symbol;
          case "object":
            if (Array.isArray(data)) {
              return exports.ZodParsedType.array;
            }
            if (data === null) {
              return exports.ZodParsedType.null;
            }
            if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
              return exports.ZodParsedType.promise;
            }
            if (typeof Map !== "undefined" && data instanceof Map) {
              return exports.ZodParsedType.map;
            }
            if (typeof Set !== "undefined" && data instanceof Set) {
              return exports.ZodParsedType.set;
            }
            if (typeof Date !== "undefined" && data instanceof Date) {
              return exports.ZodParsedType.date;
            }
            return exports.ZodParsedType.object;
          default:
            return exports.ZodParsedType.unknown;
        }
      };
      exports.getParsedType = getParsedType;
    })(util$8);
    return util$8;
  }
  var ZodError = {};
  var hasRequiredZodError;
  function requireZodError() {
    if (hasRequiredZodError) return ZodError;
    hasRequiredZodError = 1;
    Object.defineProperty(ZodError, "__esModule", { value: true });
    ZodError.ZodError = ZodError.quotelessJson = ZodError.ZodIssueCode = void 0;
    const util_1 = /* @__PURE__ */ requireUtil$8();
    ZodError.ZodIssueCode = util_1.util.arrayToEnum([
      "invalid_type",
      "invalid_literal",
      "custom",
      "invalid_union",
      "invalid_union_discriminator",
      "invalid_enum_value",
      "unrecognized_keys",
      "invalid_arguments",
      "invalid_return_type",
      "invalid_date",
      "invalid_string",
      "too_small",
      "too_big",
      "invalid_intersection_types",
      "not_multiple_of",
      "not_finite"
    ]);
    const quotelessJson = (obj) => {
      const json = JSON.stringify(obj, null, 2);
      return json.replace(/"([^"]+)":/g, "$1:");
    };
    ZodError.quotelessJson = quotelessJson;
    let ZodError$1 = class ZodError2 extends Error {
      get errors() {
        return this.issues;
      }
      constructor(issues) {
        super();
        this.issues = [];
        this.addIssue = (sub) => {
          this.issues = [...this.issues, sub];
        };
        this.addIssues = (subs = []) => {
          this.issues = [...this.issues, ...subs];
        };
        const actualProto = new.target.prototype;
        if (Object.setPrototypeOf) {
          Object.setPrototypeOf(this, actualProto);
        } else {
          this.__proto__ = actualProto;
        }
        this.name = "ZodError";
        this.issues = issues;
      }
      format(_mapper) {
        const mapper = _mapper || function(issue) {
          return issue.message;
        };
        const fieldErrors = { _errors: [] };
        const processError = (error) => {
          for (const issue of error.issues) {
            if (issue.code === "invalid_union") {
              issue.unionErrors.map(processError);
            } else if (issue.code === "invalid_return_type") {
              processError(issue.returnTypeError);
            } else if (issue.code === "invalid_arguments") {
              processError(issue.argumentsError);
            } else if (issue.path.length === 0) {
              fieldErrors._errors.push(mapper(issue));
            } else {
              let curr = fieldErrors;
              let i = 0;
              while (i < issue.path.length) {
                const el = issue.path[i];
                const terminal = i === issue.path.length - 1;
                if (!terminal) {
                  curr[el] = curr[el] || { _errors: [] };
                } else {
                  curr[el] = curr[el] || { _errors: [] };
                  curr[el]._errors.push(mapper(issue));
                }
                curr = curr[el];
                i++;
              }
            }
          }
        };
        processError(this);
        return fieldErrors;
      }
      static assert(value) {
        if (!(value instanceof ZodError2)) {
          throw new Error(`Not a ZodError: ${value}`);
        }
      }
      toString() {
        return this.message;
      }
      get message() {
        return JSON.stringify(this.issues, util_1.util.jsonStringifyReplacer, 2);
      }
      get isEmpty() {
        return this.issues.length === 0;
      }
      flatten(mapper = (issue) => issue.message) {
        const fieldErrors = {};
        const formErrors = [];
        for (const sub of this.issues) {
          if (sub.path.length > 0) {
            fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
            fieldErrors[sub.path[0]].push(mapper(sub));
          } else {
            formErrors.push(mapper(sub));
          }
        }
        return { formErrors, fieldErrors };
      }
      get formErrors() {
        return this.flatten();
      }
    };
    ZodError.ZodError = ZodError$1;
    ZodError$1.create = (issues) => {
      const error = new ZodError$1(issues);
      return error;
    };
    return ZodError;
  }
  var hasRequiredEn;
  function requireEn() {
    if (hasRequiredEn) return en;
    hasRequiredEn = 1;
    Object.defineProperty(en, "__esModule", { value: true });
    const util_1 = /* @__PURE__ */ requireUtil$8();
    const ZodError_1 = /* @__PURE__ */ requireZodError();
    const errorMap = (issue, _ctx) => {
      let message2;
      switch (issue.code) {
        case ZodError_1.ZodIssueCode.invalid_type:
          if (issue.received === util_1.ZodParsedType.undefined) {
            message2 = "Required";
          } else {
            message2 = `Expected ${issue.expected}, received ${issue.received}`;
          }
          break;
        case ZodError_1.ZodIssueCode.invalid_literal:
          message2 = `Invalid literal value, expected ${JSON.stringify(issue.expected, util_1.util.jsonStringifyReplacer)}`;
          break;
        case ZodError_1.ZodIssueCode.unrecognized_keys:
          message2 = `Unrecognized key(s) in object: ${util_1.util.joinValues(issue.keys, ", ")}`;
          break;
        case ZodError_1.ZodIssueCode.invalid_union:
          message2 = `Invalid input`;
          break;
        case ZodError_1.ZodIssueCode.invalid_union_discriminator:
          message2 = `Invalid discriminator value. Expected ${util_1.util.joinValues(issue.options)}`;
          break;
        case ZodError_1.ZodIssueCode.invalid_enum_value:
          message2 = `Invalid enum value. Expected ${util_1.util.joinValues(issue.options)}, received '${issue.received}'`;
          break;
        case ZodError_1.ZodIssueCode.invalid_arguments:
          message2 = `Invalid function arguments`;
          break;
        case ZodError_1.ZodIssueCode.invalid_return_type:
          message2 = `Invalid function return type`;
          break;
        case ZodError_1.ZodIssueCode.invalid_date:
          message2 = `Invalid date`;
          break;
        case ZodError_1.ZodIssueCode.invalid_string:
          if (typeof issue.validation === "object") {
            if ("includes" in issue.validation) {
              message2 = `Invalid input: must include "${issue.validation.includes}"`;
              if (typeof issue.validation.position === "number") {
                message2 = `${message2} at one or more positions greater than or equal to ${issue.validation.position}`;
              }
            } else if ("startsWith" in issue.validation) {
              message2 = `Invalid input: must start with "${issue.validation.startsWith}"`;
            } else if ("endsWith" in issue.validation) {
              message2 = `Invalid input: must end with "${issue.validation.endsWith}"`;
            } else {
              util_1.util.assertNever(issue.validation);
            }
          } else if (issue.validation !== "regex") {
            message2 = `Invalid ${issue.validation}`;
          } else {
            message2 = "Invalid";
          }
          break;
        case ZodError_1.ZodIssueCode.too_small:
          if (issue.type === "array")
            message2 = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
          else if (issue.type === "string")
            message2 = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
          else if (issue.type === "number")
            message2 = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
          else if (issue.type === "date")
            message2 = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
          else
            message2 = "Invalid input";
          break;
        case ZodError_1.ZodIssueCode.too_big:
          if (issue.type === "array")
            message2 = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
          else if (issue.type === "string")
            message2 = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
          else if (issue.type === "number")
            message2 = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
          else if (issue.type === "bigint")
            message2 = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
          else if (issue.type === "date")
            message2 = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
          else
            message2 = "Invalid input";
          break;
        case ZodError_1.ZodIssueCode.custom:
          message2 = `Invalid input`;
          break;
        case ZodError_1.ZodIssueCode.invalid_intersection_types:
          message2 = `Intersection results could not be merged`;
          break;
        case ZodError_1.ZodIssueCode.not_multiple_of:
          message2 = `Number must be a multiple of ${issue.multipleOf}`;
          break;
        case ZodError_1.ZodIssueCode.not_finite:
          message2 = "Number must be finite";
          break;
        default:
          message2 = _ctx.defaultError;
          util_1.util.assertNever(issue);
      }
      return { message: message2 };
    };
    en.default = errorMap;
    return en;
  }
  var hasRequiredErrors;
  function requireErrors() {
    if (hasRequiredErrors) return errors;
    hasRequiredErrors = 1;
    var __importDefault = errors && errors.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(errors, "__esModule", { value: true });
    errors.getErrorMap = errors.setErrorMap = errors.defaultErrorMap = void 0;
    const en_1 = __importDefault(/* @__PURE__ */ requireEn());
    errors.defaultErrorMap = en_1.default;
    let overrideErrorMap = en_1.default;
    function setErrorMap(map) {
      overrideErrorMap = map;
    }
    errors.setErrorMap = setErrorMap;
    function getErrorMap() {
      return overrideErrorMap;
    }
    errors.getErrorMap = getErrorMap;
    return errors;
  }
  var parseUtil = {};
  var hasRequiredParseUtil;
  function requireParseUtil() {
    if (hasRequiredParseUtil) return parseUtil;
    hasRequiredParseUtil = 1;
    (function(exports) {
      var __importDefault = parseUtil && parseUtil.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isAsync = exports.isValid = exports.isDirty = exports.isAborted = exports.OK = exports.DIRTY = exports.INVALID = exports.ParseStatus = exports.addIssueToContext = exports.EMPTY_PATH = exports.makeIssue = void 0;
      const errors_1 = /* @__PURE__ */ requireErrors();
      const en_1 = __importDefault(/* @__PURE__ */ requireEn());
      const makeIssue = (params) => {
        const { data, path, errorMaps, issueData } = params;
        const fullPath = [...path, ...issueData.path || []];
        const fullIssue = {
          ...issueData,
          path: fullPath
        };
        if (issueData.message !== void 0) {
          return {
            ...issueData,
            path: fullPath,
            message: issueData.message
          };
        }
        let errorMessage = "";
        const maps = errorMaps.filter((m) => !!m).slice().reverse();
        for (const map of maps) {
          errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
        }
        return {
          ...issueData,
          path: fullPath,
          message: errorMessage
        };
      };
      exports.makeIssue = makeIssue;
      exports.EMPTY_PATH = [];
      function addIssueToContext(ctx, issueData) {
        const overrideMap = (0, errors_1.getErrorMap)();
        const issue = (0, exports.makeIssue)({
          issueData,
          data: ctx.data,
          path: ctx.path,
          errorMaps: [
            ctx.common.contextualErrorMap,
            // contextual error map is first priority
            ctx.schemaErrorMap,
            // then schema-bound map if available
            overrideMap,
            // then global override map
            overrideMap === en_1.default ? void 0 : en_1.default
            // then global default map
          ].filter((x) => !!x)
        });
        ctx.common.issues.push(issue);
      }
      exports.addIssueToContext = addIssueToContext;
      class ParseStatus {
        constructor() {
          this.value = "valid";
        }
        dirty() {
          if (this.value === "valid")
            this.value = "dirty";
        }
        abort() {
          if (this.value !== "aborted")
            this.value = "aborted";
        }
        static mergeArray(status, results) {
          const arrayValue = [];
          for (const s of results) {
            if (s.status === "aborted")
              return exports.INVALID;
            if (s.status === "dirty")
              status.dirty();
            arrayValue.push(s.value);
          }
          return { status: status.value, value: arrayValue };
        }
        static async mergeObjectAsync(status, pairs) {
          const syncPairs = [];
          for (const pair of pairs) {
            const key = await pair.key;
            const value = await pair.value;
            syncPairs.push({
              key,
              value
            });
          }
          return ParseStatus.mergeObjectSync(status, syncPairs);
        }
        static mergeObjectSync(status, pairs) {
          const finalObject = {};
          for (const pair of pairs) {
            const { key, value } = pair;
            if (key.status === "aborted")
              return exports.INVALID;
            if (value.status === "aborted")
              return exports.INVALID;
            if (key.status === "dirty")
              status.dirty();
            if (value.status === "dirty")
              status.dirty();
            if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
              finalObject[key.value] = value.value;
            }
          }
          return { status: status.value, value: finalObject };
        }
      }
      exports.ParseStatus = ParseStatus;
      exports.INVALID = Object.freeze({
        status: "aborted"
      });
      const DIRTY = (value) => ({ status: "dirty", value });
      exports.DIRTY = DIRTY;
      const OK = (value) => ({ status: "valid", value });
      exports.OK = OK;
      const isAborted = (x) => x.status === "aborted";
      exports.isAborted = isAborted;
      const isDirty = (x) => x.status === "dirty";
      exports.isDirty = isDirty;
      const isValid2 = (x) => x.status === "valid";
      exports.isValid = isValid2;
      const isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
      exports.isAsync = isAsync;
    })(parseUtil);
    return parseUtil;
  }
  var typeAliases = {};
  var hasRequiredTypeAliases;
  function requireTypeAliases() {
    if (hasRequiredTypeAliases) return typeAliases;
    hasRequiredTypeAliases = 1;
    Object.defineProperty(typeAliases, "__esModule", { value: true });
    return typeAliases;
  }
  var types$4 = {};
  var errorUtil = {};
  var hasRequiredErrorUtil;
  function requireErrorUtil() {
    if (hasRequiredErrorUtil) return errorUtil;
    hasRequiredErrorUtil = 1;
    Object.defineProperty(errorUtil, "__esModule", { value: true });
    errorUtil.errorUtil = void 0;
    var errorUtil$1;
    (function(errorUtil2) {
      errorUtil2.errToObj = (message2) => typeof message2 === "string" ? { message: message2 } : message2 || {};
      errorUtil2.toString = (message2) => typeof message2 === "string" ? message2 : message2 === null || message2 === void 0 ? void 0 : message2.message;
    })(errorUtil$1 || (errorUtil.errorUtil = errorUtil$1 = {}));
    return errorUtil;
  }
  var hasRequiredTypes$5;
  function requireTypes$5() {
    if (hasRequiredTypes$5) return types$4;
    hasRequiredTypes$5 = 1;
    var __classPrivateFieldGet = types$4 && types$4.__classPrivateFieldGet || function(receiver, state2, kind, f) {
      if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
      if (typeof state2 === "function" ? receiver !== state2 || !f : !state2.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state2.get(receiver);
    };
    var __classPrivateFieldSet = types$4 && types$4.__classPrivateFieldSet || function(receiver, state2, value, kind, f) {
      if (kind === "m") throw new TypeError("Private method is not writable");
      if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
      if (typeof state2 === "function" ? receiver !== state2 || !f : !state2.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state2.set(receiver, value), value;
    };
    var _ZodEnum_cache, _ZodNativeEnum_cache;
    Object.defineProperty(types$4, "__esModule", { value: true });
    types$4.boolean = types$4.bigint = types$4.array = types$4.any = types$4.coerce = types$4.ZodFirstPartyTypeKind = types$4.late = types$4.ZodSchema = types$4.Schema = types$4.custom = types$4.ZodReadonly = types$4.ZodPipeline = types$4.ZodBranded = types$4.BRAND = types$4.ZodNaN = types$4.ZodCatch = types$4.ZodDefault = types$4.ZodNullable = types$4.ZodOptional = types$4.ZodTransformer = types$4.ZodEffects = types$4.ZodPromise = types$4.ZodNativeEnum = types$4.ZodEnum = types$4.ZodLiteral = types$4.ZodLazy = types$4.ZodFunction = types$4.ZodSet = types$4.ZodMap = types$4.ZodRecord = types$4.ZodTuple = types$4.ZodIntersection = types$4.ZodDiscriminatedUnion = types$4.ZodUnion = types$4.ZodObject = types$4.ZodArray = types$4.ZodVoid = types$4.ZodNever = types$4.ZodUnknown = types$4.ZodAny = types$4.ZodNull = types$4.ZodUndefined = types$4.ZodSymbol = types$4.ZodDate = types$4.ZodBoolean = types$4.ZodBigInt = types$4.ZodNumber = types$4.ZodString = types$4.datetimeRegex = types$4.ZodType = void 0;
    types$4.NEVER = types$4.void = types$4.unknown = types$4.union = types$4.undefined = types$4.tuple = types$4.transformer = types$4.symbol = types$4.string = types$4.strictObject = types$4.set = types$4.record = types$4.promise = types$4.preprocess = types$4.pipeline = types$4.ostring = types$4.optional = types$4.onumber = types$4.oboolean = types$4.object = types$4.number = types$4.nullable = types$4.null = types$4.never = types$4.nativeEnum = types$4.nan = types$4.map = types$4.literal = types$4.lazy = types$4.intersection = types$4.instanceof = types$4.function = types$4.enum = types$4.effect = types$4.discriminatedUnion = types$4.date = void 0;
    const errors_1 = /* @__PURE__ */ requireErrors();
    const errorUtil_1 = /* @__PURE__ */ requireErrorUtil();
    const parseUtil_1 = /* @__PURE__ */ requireParseUtil();
    const util_1 = /* @__PURE__ */ requireUtil$8();
    const ZodError_1 = /* @__PURE__ */ requireZodError();
    class ParseInputLazyPath {
      constructor(parent, value, path, key) {
        this._cachedPath = [];
        this.parent = parent;
        this.data = value;
        this._path = path;
        this._key = key;
      }
      get path() {
        if (!this._cachedPath.length) {
          if (this._key instanceof Array) {
            this._cachedPath.push(...this._path, ...this._key);
          } else {
            this._cachedPath.push(...this._path, this._key);
          }
        }
        return this._cachedPath;
      }
    }
    const handleResult = (ctx, result) => {
      if ((0, parseUtil_1.isValid)(result)) {
        return { success: true, data: result.value };
      } else {
        if (!ctx.common.issues.length) {
          throw new Error("Validation failed but no issues detected.");
        }
        return {
          success: false,
          get error() {
            if (this._error)
              return this._error;
            const error = new ZodError_1.ZodError(ctx.common.issues);
            this._error = error;
            return this._error;
          }
        };
      }
    };
    function processCreateParams(params) {
      if (!params)
        return {};
      const { errorMap, invalid_type_error, required_error, description } = params;
      if (errorMap && (invalid_type_error || required_error)) {
        throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
      }
      if (errorMap)
        return { errorMap, description };
      const customMap = (iss, ctx) => {
        var _a, _b;
        const { message: message2 } = params;
        if (iss.code === "invalid_enum_value") {
          return { message: message2 !== null && message2 !== void 0 ? message2 : ctx.defaultError };
        }
        if (typeof ctx.data === "undefined") {
          return { message: (_a = message2 !== null && message2 !== void 0 ? message2 : required_error) !== null && _a !== void 0 ? _a : ctx.defaultError };
        }
        if (iss.code !== "invalid_type")
          return { message: ctx.defaultError };
        return { message: (_b = message2 !== null && message2 !== void 0 ? message2 : invalid_type_error) !== null && _b !== void 0 ? _b : ctx.defaultError };
      };
      return { errorMap: customMap, description };
    }
    class ZodType {
      get description() {
        return this._def.description;
      }
      _getType(input) {
        return (0, util_1.getParsedType)(input.data);
      }
      _getOrReturnCtx(input, ctx) {
        return ctx || {
          common: input.parent.common,
          data: input.data,
          parsedType: (0, util_1.getParsedType)(input.data),
          schemaErrorMap: this._def.errorMap,
          path: input.path,
          parent: input.parent
        };
      }
      _processInputParams(input) {
        return {
          status: new parseUtil_1.ParseStatus(),
          ctx: {
            common: input.parent.common,
            data: input.data,
            parsedType: (0, util_1.getParsedType)(input.data),
            schemaErrorMap: this._def.errorMap,
            path: input.path,
            parent: input.parent
          }
        };
      }
      _parseSync(input) {
        const result = this._parse(input);
        if ((0, parseUtil_1.isAsync)(result)) {
          throw new Error("Synchronous parse encountered promise.");
        }
        return result;
      }
      _parseAsync(input) {
        const result = this._parse(input);
        return Promise.resolve(result);
      }
      parse(data, params) {
        const result = this.safeParse(data, params);
        if (result.success)
          return result.data;
        throw result.error;
      }
      safeParse(data, params) {
        var _a;
        const ctx = {
          common: {
            issues: [],
            async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
            contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
          },
          path: (params === null || params === void 0 ? void 0 : params.path) || [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data,
          parsedType: (0, util_1.getParsedType)(data)
        };
        const result = this._parseSync({ data, path: ctx.path, parent: ctx });
        return handleResult(ctx, result);
      }
      "~validate"(data) {
        var _a, _b;
        const ctx = {
          common: {
            issues: [],
            async: !!this["~standard"].async
          },
          path: [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data,
          parsedType: (0, util_1.getParsedType)(data)
        };
        if (!this["~standard"].async) {
          try {
            const result = this._parseSync({ data, path: [], parent: ctx });
            return (0, parseUtil_1.isValid)(result) ? {
              value: result.value
            } : {
              issues: ctx.common.issues
            };
          } catch (err) {
            if ((_b = (_a = err === null || err === void 0 ? void 0 : err.message) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === null || _b === void 0 ? void 0 : _b.includes("encountered")) {
              this["~standard"].async = true;
            }
            ctx.common = {
              issues: [],
              async: true
            };
          }
        }
        return this._parseAsync({ data, path: [], parent: ctx }).then((result) => (0, parseUtil_1.isValid)(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        });
      }
      async parseAsync(data, params) {
        const result = await this.safeParseAsync(data, params);
        if (result.success)
          return result.data;
        throw result.error;
      }
      async safeParseAsync(data, params) {
        const ctx = {
          common: {
            issues: [],
            contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
            async: true
          },
          path: (params === null || params === void 0 ? void 0 : params.path) || [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data,
          parsedType: (0, util_1.getParsedType)(data)
        };
        const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
        const result = await ((0, parseUtil_1.isAsync)(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
        return handleResult(ctx, result);
      }
      refine(check2, message2) {
        const getIssueProperties = (val) => {
          if (typeof message2 === "string" || typeof message2 === "undefined") {
            return { message: message2 };
          } else if (typeof message2 === "function") {
            return message2(val);
          } else {
            return message2;
          }
        };
        return this._refinement((val, ctx) => {
          const result = check2(val);
          const setError = () => ctx.addIssue({
            code: ZodError_1.ZodIssueCode.custom,
            ...getIssueProperties(val)
          });
          if (typeof Promise !== "undefined" && result instanceof Promise) {
            return result.then((data) => {
              if (!data) {
                setError();
                return false;
              } else {
                return true;
              }
            });
          }
          if (!result) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      refinement(check2, refinementData) {
        return this._refinement((val, ctx) => {
          if (!check2(val)) {
            ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
            return false;
          } else {
            return true;
          }
        });
      }
      _refinement(refinement) {
        return new ZodEffects({
          schema: this,
          typeName: ZodFirstPartyTypeKind.ZodEffects,
          effect: { type: "refinement", refinement }
        });
      }
      superRefine(refinement) {
        return this._refinement(refinement);
      }
      constructor(def) {
        this.spa = this.safeParseAsync;
        this._def = def;
        this.parse = this.parse.bind(this);
        this.safeParse = this.safeParse.bind(this);
        this.parseAsync = this.parseAsync.bind(this);
        this.safeParseAsync = this.safeParseAsync.bind(this);
        this.spa = this.spa.bind(this);
        this.refine = this.refine.bind(this);
        this.refinement = this.refinement.bind(this);
        this.superRefine = this.superRefine.bind(this);
        this.optional = this.optional.bind(this);
        this.nullable = this.nullable.bind(this);
        this.nullish = this.nullish.bind(this);
        this.array = this.array.bind(this);
        this.promise = this.promise.bind(this);
        this.or = this.or.bind(this);
        this.and = this.and.bind(this);
        this.transform = this.transform.bind(this);
        this.brand = this.brand.bind(this);
        this.default = this.default.bind(this);
        this.catch = this.catch.bind(this);
        this.describe = this.describe.bind(this);
        this.pipe = this.pipe.bind(this);
        this.readonly = this.readonly.bind(this);
        this.isNullable = this.isNullable.bind(this);
        this.isOptional = this.isOptional.bind(this);
        this["~standard"] = {
          version: 1,
          vendor: "zod",
          validate: (data) => this["~validate"](data)
        };
      }
      optional() {
        return ZodOptional.create(this, this._def);
      }
      nullable() {
        return ZodNullable.create(this, this._def);
      }
      nullish() {
        return this.nullable().optional();
      }
      array() {
        return ZodArray.create(this);
      }
      promise() {
        return ZodPromise.create(this, this._def);
      }
      or(option) {
        return ZodUnion.create([this, option], this._def);
      }
      and(incoming) {
        return ZodIntersection.create(this, incoming, this._def);
      }
      transform(transform) {
        return new ZodEffects({
          ...processCreateParams(this._def),
          schema: this,
          typeName: ZodFirstPartyTypeKind.ZodEffects,
          effect: { type: "transform", transform }
        });
      }
      default(def) {
        const defaultValueFunc = typeof def === "function" ? def : () => def;
        return new ZodDefault({
          ...processCreateParams(this._def),
          innerType: this,
          defaultValue: defaultValueFunc,
          typeName: ZodFirstPartyTypeKind.ZodDefault
        });
      }
      brand() {
        return new ZodBranded({
          typeName: ZodFirstPartyTypeKind.ZodBranded,
          type: this,
          ...processCreateParams(this._def)
        });
      }
      catch(def) {
        const catchValueFunc = typeof def === "function" ? def : () => def;
        return new ZodCatch({
          ...processCreateParams(this._def),
          innerType: this,
          catchValue: catchValueFunc,
          typeName: ZodFirstPartyTypeKind.ZodCatch
        });
      }
      describe(description) {
        const This = this.constructor;
        return new This({
          ...this._def,
          description
        });
      }
      pipe(target2) {
        return ZodPipeline.create(this, target2);
      }
      readonly() {
        return ZodReadonly.create(this);
      }
      isOptional() {
        return this.safeParse(void 0).success;
      }
      isNullable() {
        return this.safeParse(null).success;
      }
    }
    types$4.ZodType = ZodType;
    types$4.Schema = ZodType;
    types$4.ZodSchema = ZodType;
    const cuidRegex = /^c[^\s-]{8,}$/i;
    const cuid2Regex = /^[0-9a-z]+$/;
    const ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
    const uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
    const nanoidRegex = /^[a-z0-9_-]{21}$/i;
    const jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
    const durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
    const emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
    const _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
    let emojiRegex;
    const ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
    const ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
    const ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
    const ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
    const base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
    const base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
    const dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
    const dateRegex = new RegExp(`^${dateRegexSource}$`);
    function timeRegexSource(args) {
      let regex = `([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d`;
      if (args.precision) {
        regex = `${regex}\\.\\d{${args.precision}}`;
      } else if (args.precision == null) {
        regex = `${regex}(\\.\\d+)?`;
      }
      return regex;
    }
    function timeRegex(args) {
      return new RegExp(`^${timeRegexSource(args)}$`);
    }
    function datetimeRegex(args) {
      let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
      const opts = [];
      opts.push(args.local ? `Z?` : `Z`);
      if (args.offset)
        opts.push(`([+-]\\d{2}:?\\d{2})`);
      regex = `${regex}(${opts.join("|")})`;
      return new RegExp(`^${regex}$`);
    }
    types$4.datetimeRegex = datetimeRegex;
    function isValidIP(ip, version2) {
      if ((version2 === "v4" || !version2) && ipv4Regex.test(ip)) {
        return true;
      }
      if ((version2 === "v6" || !version2) && ipv6Regex.test(ip)) {
        return true;
      }
      return false;
    }
    function isValidJWT(jwt, alg) {
      if (!jwtRegex.test(jwt))
        return false;
      try {
        const [header] = jwt.split(".");
        const base642 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
        const decoded = JSON.parse(atob(base642));
        if (typeof decoded !== "object" || decoded === null)
          return false;
        if (!decoded.typ || !decoded.alg)
          return false;
        if (alg && decoded.alg !== alg)
          return false;
        return true;
      } catch (_a) {
        return false;
      }
    }
    function isValidCidr(ip, version2) {
      if ((version2 === "v4" || !version2) && ipv4CidrRegex.test(ip)) {
        return true;
      }
      if ((version2 === "v6" || !version2) && ipv6CidrRegex.test(ip)) {
        return true;
      }
      return false;
    }
    class ZodString extends ZodType {
      _parse(input) {
        if (this._def.coerce) {
          input.data = String(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.string) {
          const ctx2 = this._getOrReturnCtx(input);
          (0, parseUtil_1.addIssueToContext)(ctx2, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.string,
            received: ctx2.parsedType
          });
          return parseUtil_1.INVALID;
        }
        const status = new parseUtil_1.ParseStatus();
        let ctx = void 0;
        for (const check2 of this._def.checks) {
          if (check2.kind === "min") {
            if (input.data.length < check2.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.too_small,
                minimum: check2.value,
                type: "string",
                inclusive: true,
                exact: false,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "max") {
            if (input.data.length > check2.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.too_big,
                maximum: check2.value,
                type: "string",
                inclusive: true,
                exact: false,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "length") {
            const tooBig = input.data.length > check2.value;
            const tooSmall = input.data.length < check2.value;
            if (tooBig || tooSmall) {
              ctx = this._getOrReturnCtx(input, ctx);
              if (tooBig) {
                (0, parseUtil_1.addIssueToContext)(ctx, {
                  code: ZodError_1.ZodIssueCode.too_big,
                  maximum: check2.value,
                  type: "string",
                  inclusive: true,
                  exact: true,
                  message: check2.message
                });
              } else if (tooSmall) {
                (0, parseUtil_1.addIssueToContext)(ctx, {
                  code: ZodError_1.ZodIssueCode.too_small,
                  minimum: check2.value,
                  type: "string",
                  inclusive: true,
                  exact: true,
                  message: check2.message
                });
              }
              status.dirty();
            }
          } else if (check2.kind === "email") {
            if (!emailRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                validation: "email",
                code: ZodError_1.ZodIssueCode.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "emoji") {
            if (!emojiRegex) {
              emojiRegex = new RegExp(_emojiRegex, "u");
            }
            if (!emojiRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                validation: "emoji",
                code: ZodError_1.ZodIssueCode.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "uuid") {
            if (!uuidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                validation: "uuid",
                code: ZodError_1.ZodIssueCode.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "nanoid") {
            if (!nanoidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                validation: "nanoid",
                code: ZodError_1.ZodIssueCode.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "cuid") {
            if (!cuidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                validation: "cuid",
                code: ZodError_1.ZodIssueCode.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "cuid2") {
            if (!cuid2Regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                validation: "cuid2",
                code: ZodError_1.ZodIssueCode.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "ulid") {
            if (!ulidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                validation: "ulid",
                code: ZodError_1.ZodIssueCode.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "url") {
            try {
              new URL(input.data);
            } catch (_a) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                validation: "url",
                code: ZodError_1.ZodIssueCode.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "regex") {
            check2.regex.lastIndex = 0;
            const testResult = check2.regex.test(input.data);
            if (!testResult) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                validation: "regex",
                code: ZodError_1.ZodIssueCode.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "trim") {
            input.data = input.data.trim();
          } else if (check2.kind === "includes") {
            if (!input.data.includes(check2.value, check2.position)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_string,
                validation: { includes: check2.value, position: check2.position },
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "toLowerCase") {
            input.data = input.data.toLowerCase();
          } else if (check2.kind === "toUpperCase") {
            input.data = input.data.toUpperCase();
          } else if (check2.kind === "startsWith") {
            if (!input.data.startsWith(check2.value)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_string,
                validation: { startsWith: check2.value },
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "endsWith") {
            if (!input.data.endsWith(check2.value)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_string,
                validation: { endsWith: check2.value },
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "datetime") {
            const regex = datetimeRegex(check2);
            if (!regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_string,
                validation: "datetime",
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "date") {
            const regex = dateRegex;
            if (!regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_string,
                validation: "date",
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "time") {
            const regex = timeRegex(check2);
            if (!regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_string,
                validation: "time",
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "duration") {
            if (!durationRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                validation: "duration",
                code: ZodError_1.ZodIssueCode.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "ip") {
            if (!isValidIP(input.data, check2.version)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                validation: "ip",
                code: ZodError_1.ZodIssueCode.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "jwt") {
            if (!isValidJWT(input.data, check2.alg)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                validation: "jwt",
                code: ZodError_1.ZodIssueCode.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "cidr") {
            if (!isValidCidr(input.data, check2.version)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                validation: "cidr",
                code: ZodError_1.ZodIssueCode.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "base64") {
            if (!base64Regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                validation: "base64",
                code: ZodError_1.ZodIssueCode.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "base64url") {
            if (!base64urlRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                validation: "base64url",
                code: ZodError_1.ZodIssueCode.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else {
            util_1.util.assertNever(check2);
          }
        }
        return { status: status.value, value: input.data };
      }
      _regex(regex, validation2, message2) {
        return this.refinement((data) => regex.test(data), {
          validation: validation2,
          code: ZodError_1.ZodIssueCode.invalid_string,
          ...errorUtil_1.errorUtil.errToObj(message2)
        });
      }
      _addCheck(check2) {
        return new ZodString({
          ...this._def,
          checks: [...this._def.checks, check2]
        });
      }
      email(message2) {
        return this._addCheck({ kind: "email", ...errorUtil_1.errorUtil.errToObj(message2) });
      }
      url(message2) {
        return this._addCheck({ kind: "url", ...errorUtil_1.errorUtil.errToObj(message2) });
      }
      emoji(message2) {
        return this._addCheck({ kind: "emoji", ...errorUtil_1.errorUtil.errToObj(message2) });
      }
      uuid(message2) {
        return this._addCheck({ kind: "uuid", ...errorUtil_1.errorUtil.errToObj(message2) });
      }
      nanoid(message2) {
        return this._addCheck({ kind: "nanoid", ...errorUtil_1.errorUtil.errToObj(message2) });
      }
      cuid(message2) {
        return this._addCheck({ kind: "cuid", ...errorUtil_1.errorUtil.errToObj(message2) });
      }
      cuid2(message2) {
        return this._addCheck({ kind: "cuid2", ...errorUtil_1.errorUtil.errToObj(message2) });
      }
      ulid(message2) {
        return this._addCheck({ kind: "ulid", ...errorUtil_1.errorUtil.errToObj(message2) });
      }
      base64(message2) {
        return this._addCheck({ kind: "base64", ...errorUtil_1.errorUtil.errToObj(message2) });
      }
      base64url(message2) {
        return this._addCheck({
          kind: "base64url",
          ...errorUtil_1.errorUtil.errToObj(message2)
        });
      }
      jwt(options) {
        return this._addCheck({ kind: "jwt", ...errorUtil_1.errorUtil.errToObj(options) });
      }
      ip(options) {
        return this._addCheck({ kind: "ip", ...errorUtil_1.errorUtil.errToObj(options) });
      }
      cidr(options) {
        return this._addCheck({ kind: "cidr", ...errorUtil_1.errorUtil.errToObj(options) });
      }
      datetime(options) {
        var _a, _b;
        if (typeof options === "string") {
          return this._addCheck({
            kind: "datetime",
            precision: null,
            offset: false,
            local: false,
            message: options
          });
        }
        return this._addCheck({
          kind: "datetime",
          precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
          offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,
          local: (_b = options === null || options === void 0 ? void 0 : options.local) !== null && _b !== void 0 ? _b : false,
          ...errorUtil_1.errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
        });
      }
      date(message2) {
        return this._addCheck({ kind: "date", message: message2 });
      }
      time(options) {
        if (typeof options === "string") {
          return this._addCheck({
            kind: "time",
            precision: null,
            message: options
          });
        }
        return this._addCheck({
          kind: "time",
          precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
          ...errorUtil_1.errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
        });
      }
      duration(message2) {
        return this._addCheck({ kind: "duration", ...errorUtil_1.errorUtil.errToObj(message2) });
      }
      regex(regex, message2) {
        return this._addCheck({
          kind: "regex",
          regex,
          ...errorUtil_1.errorUtil.errToObj(message2)
        });
      }
      includes(value, options) {
        return this._addCheck({
          kind: "includes",
          value,
          position: options === null || options === void 0 ? void 0 : options.position,
          ...errorUtil_1.errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
        });
      }
      startsWith(value, message2) {
        return this._addCheck({
          kind: "startsWith",
          value,
          ...errorUtil_1.errorUtil.errToObj(message2)
        });
      }
      endsWith(value, message2) {
        return this._addCheck({
          kind: "endsWith",
          value,
          ...errorUtil_1.errorUtil.errToObj(message2)
        });
      }
      min(minLength, message2) {
        return this._addCheck({
          kind: "min",
          value: minLength,
          ...errorUtil_1.errorUtil.errToObj(message2)
        });
      }
      max(maxLength, message2) {
        return this._addCheck({
          kind: "max",
          value: maxLength,
          ...errorUtil_1.errorUtil.errToObj(message2)
        });
      }
      length(len, message2) {
        return this._addCheck({
          kind: "length",
          value: len,
          ...errorUtil_1.errorUtil.errToObj(message2)
        });
      }
      /**
       * Equivalent to `.min(1)`
       */
      nonempty(message2) {
        return this.min(1, errorUtil_1.errorUtil.errToObj(message2));
      }
      trim() {
        return new ZodString({
          ...this._def,
          checks: [...this._def.checks, { kind: "trim" }]
        });
      }
      toLowerCase() {
        return new ZodString({
          ...this._def,
          checks: [...this._def.checks, { kind: "toLowerCase" }]
        });
      }
      toUpperCase() {
        return new ZodString({
          ...this._def,
          checks: [...this._def.checks, { kind: "toUpperCase" }]
        });
      }
      get isDatetime() {
        return !!this._def.checks.find((ch) => ch.kind === "datetime");
      }
      get isDate() {
        return !!this._def.checks.find((ch) => ch.kind === "date");
      }
      get isTime() {
        return !!this._def.checks.find((ch) => ch.kind === "time");
      }
      get isDuration() {
        return !!this._def.checks.find((ch) => ch.kind === "duration");
      }
      get isEmail() {
        return !!this._def.checks.find((ch) => ch.kind === "email");
      }
      get isURL() {
        return !!this._def.checks.find((ch) => ch.kind === "url");
      }
      get isEmoji() {
        return !!this._def.checks.find((ch) => ch.kind === "emoji");
      }
      get isUUID() {
        return !!this._def.checks.find((ch) => ch.kind === "uuid");
      }
      get isNANOID() {
        return !!this._def.checks.find((ch) => ch.kind === "nanoid");
      }
      get isCUID() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid");
      }
      get isCUID2() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid2");
      }
      get isULID() {
        return !!this._def.checks.find((ch) => ch.kind === "ulid");
      }
      get isIP() {
        return !!this._def.checks.find((ch) => ch.kind === "ip");
      }
      get isCIDR() {
        return !!this._def.checks.find((ch) => ch.kind === "cidr");
      }
      get isBase64() {
        return !!this._def.checks.find((ch) => ch.kind === "base64");
      }
      get isBase64url() {
        return !!this._def.checks.find((ch) => ch.kind === "base64url");
      }
      get minLength() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min;
      }
      get maxLength() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max;
      }
    }
    types$4.ZodString = ZodString;
    ZodString.create = (params) => {
      var _a;
      return new ZodString({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodString,
        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
        ...processCreateParams(params)
      });
    };
    function floatSafeRemainder(val, step) {
      const valDecCount = (val.toString().split(".")[1] || "").length;
      const stepDecCount = (step.toString().split(".")[1] || "").length;
      const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
      const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
      const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
      return valInt % stepInt / Math.pow(10, decCount);
    }
    class ZodNumber extends ZodType {
      constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
        this.step = this.multipleOf;
      }
      _parse(input) {
        if (this._def.coerce) {
          input.data = Number(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.number) {
          const ctx2 = this._getOrReturnCtx(input);
          (0, parseUtil_1.addIssueToContext)(ctx2, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.number,
            received: ctx2.parsedType
          });
          return parseUtil_1.INVALID;
        }
        let ctx = void 0;
        const status = new parseUtil_1.ParseStatus();
        for (const check2 of this._def.checks) {
          if (check2.kind === "int") {
            if (!util_1.util.isInteger(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: "integer",
                received: "float",
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "min") {
            const tooSmall = check2.inclusive ? input.data < check2.value : input.data <= check2.value;
            if (tooSmall) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.too_small,
                minimum: check2.value,
                type: "number",
                inclusive: check2.inclusive,
                exact: false,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "max") {
            const tooBig = check2.inclusive ? input.data > check2.value : input.data >= check2.value;
            if (tooBig) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.too_big,
                maximum: check2.value,
                type: "number",
                inclusive: check2.inclusive,
                exact: false,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "multipleOf") {
            if (floatSafeRemainder(input.data, check2.value) !== 0) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.not_multiple_of,
                multipleOf: check2.value,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "finite") {
            if (!Number.isFinite(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.not_finite,
                message: check2.message
              });
              status.dirty();
            }
          } else {
            util_1.util.assertNever(check2);
          }
        }
        return { status: status.value, value: input.data };
      }
      gte(value, message2) {
        return this.setLimit("min", value, true, errorUtil_1.errorUtil.toString(message2));
      }
      gt(value, message2) {
        return this.setLimit("min", value, false, errorUtil_1.errorUtil.toString(message2));
      }
      lte(value, message2) {
        return this.setLimit("max", value, true, errorUtil_1.errorUtil.toString(message2));
      }
      lt(value, message2) {
        return this.setLimit("max", value, false, errorUtil_1.errorUtil.toString(message2));
      }
      setLimit(kind, value, inclusive, message2) {
        return new ZodNumber({
          ...this._def,
          checks: [
            ...this._def.checks,
            {
              kind,
              value,
              inclusive,
              message: errorUtil_1.errorUtil.toString(message2)
            }
          ]
        });
      }
      _addCheck(check2) {
        return new ZodNumber({
          ...this._def,
          checks: [...this._def.checks, check2]
        });
      }
      int(message2) {
        return this._addCheck({
          kind: "int",
          message: errorUtil_1.errorUtil.toString(message2)
        });
      }
      positive(message2) {
        return this._addCheck({
          kind: "min",
          value: 0,
          inclusive: false,
          message: errorUtil_1.errorUtil.toString(message2)
        });
      }
      negative(message2) {
        return this._addCheck({
          kind: "max",
          value: 0,
          inclusive: false,
          message: errorUtil_1.errorUtil.toString(message2)
        });
      }
      nonpositive(message2) {
        return this._addCheck({
          kind: "max",
          value: 0,
          inclusive: true,
          message: errorUtil_1.errorUtil.toString(message2)
        });
      }
      nonnegative(message2) {
        return this._addCheck({
          kind: "min",
          value: 0,
          inclusive: true,
          message: errorUtil_1.errorUtil.toString(message2)
        });
      }
      multipleOf(value, message2) {
        return this._addCheck({
          kind: "multipleOf",
          value,
          message: errorUtil_1.errorUtil.toString(message2)
        });
      }
      finite(message2) {
        return this._addCheck({
          kind: "finite",
          message: errorUtil_1.errorUtil.toString(message2)
        });
      }
      safe(message2) {
        return this._addCheck({
          kind: "min",
          inclusive: true,
          value: Number.MIN_SAFE_INTEGER,
          message: errorUtil_1.errorUtil.toString(message2)
        })._addCheck({
          kind: "max",
          inclusive: true,
          value: Number.MAX_SAFE_INTEGER,
          message: errorUtil_1.errorUtil.toString(message2)
        });
      }
      get minValue() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min;
      }
      get maxValue() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max;
      }
      get isInt() {
        return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util_1.util.isInteger(ch.value));
      }
      get isFinite() {
        let max = null, min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
            return true;
          } else if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          } else if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return Number.isFinite(min) && Number.isFinite(max);
      }
    }
    types$4.ZodNumber = ZodNumber;
    ZodNumber.create = (params) => {
      return new ZodNumber({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodNumber,
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        ...processCreateParams(params)
      });
    };
    class ZodBigInt extends ZodType {
      constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
      }
      _parse(input) {
        if (this._def.coerce) {
          try {
            input.data = BigInt(input.data);
          } catch (_a) {
            return this._getInvalidInput(input);
          }
        }
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.bigint) {
          return this._getInvalidInput(input);
        }
        let ctx = void 0;
        const status = new parseUtil_1.ParseStatus();
        for (const check2 of this._def.checks) {
          if (check2.kind === "min") {
            const tooSmall = check2.inclusive ? input.data < check2.value : input.data <= check2.value;
            if (tooSmall) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.too_small,
                type: "bigint",
                minimum: check2.value,
                inclusive: check2.inclusive,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "max") {
            const tooBig = check2.inclusive ? input.data > check2.value : input.data >= check2.value;
            if (tooBig) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.too_big,
                type: "bigint",
                maximum: check2.value,
                inclusive: check2.inclusive,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "multipleOf") {
            if (input.data % check2.value !== BigInt(0)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.not_multiple_of,
                multipleOf: check2.value,
                message: check2.message
              });
              status.dirty();
            }
          } else {
            util_1.util.assertNever(check2);
          }
        }
        return { status: status.value, value: input.data };
      }
      _getInvalidInput(input) {
        const ctx = this._getOrReturnCtx(input);
        (0, parseUtil_1.addIssueToContext)(ctx, {
          code: ZodError_1.ZodIssueCode.invalid_type,
          expected: util_1.ZodParsedType.bigint,
          received: ctx.parsedType
        });
        return parseUtil_1.INVALID;
      }
      gte(value, message2) {
        return this.setLimit("min", value, true, errorUtil_1.errorUtil.toString(message2));
      }
      gt(value, message2) {
        return this.setLimit("min", value, false, errorUtil_1.errorUtil.toString(message2));
      }
      lte(value, message2) {
        return this.setLimit("max", value, true, errorUtil_1.errorUtil.toString(message2));
      }
      lt(value, message2) {
        return this.setLimit("max", value, false, errorUtil_1.errorUtil.toString(message2));
      }
      setLimit(kind, value, inclusive, message2) {
        return new ZodBigInt({
          ...this._def,
          checks: [
            ...this._def.checks,
            {
              kind,
              value,
              inclusive,
              message: errorUtil_1.errorUtil.toString(message2)
            }
          ]
        });
      }
      _addCheck(check2) {
        return new ZodBigInt({
          ...this._def,
          checks: [...this._def.checks, check2]
        });
      }
      positive(message2) {
        return this._addCheck({
          kind: "min",
          value: BigInt(0),
          inclusive: false,
          message: errorUtil_1.errorUtil.toString(message2)
        });
      }
      negative(message2) {
        return this._addCheck({
          kind: "max",
          value: BigInt(0),
          inclusive: false,
          message: errorUtil_1.errorUtil.toString(message2)
        });
      }
      nonpositive(message2) {
        return this._addCheck({
          kind: "max",
          value: BigInt(0),
          inclusive: true,
          message: errorUtil_1.errorUtil.toString(message2)
        });
      }
      nonnegative(message2) {
        return this._addCheck({
          kind: "min",
          value: BigInt(0),
          inclusive: true,
          message: errorUtil_1.errorUtil.toString(message2)
        });
      }
      multipleOf(value, message2) {
        return this._addCheck({
          kind: "multipleOf",
          value,
          message: errorUtil_1.errorUtil.toString(message2)
        });
      }
      get minValue() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min;
      }
      get maxValue() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max;
      }
    }
    types$4.ZodBigInt = ZodBigInt;
    ZodBigInt.create = (params) => {
      var _a;
      return new ZodBigInt({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodBigInt,
        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
        ...processCreateParams(params)
      });
    };
    class ZodBoolean extends ZodType {
      _parse(input) {
        if (this._def.coerce) {
          input.data = Boolean(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.boolean) {
          const ctx = this._getOrReturnCtx(input);
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.boolean,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
      }
    }
    types$4.ZodBoolean = ZodBoolean;
    ZodBoolean.create = (params) => {
      return new ZodBoolean({
        typeName: ZodFirstPartyTypeKind.ZodBoolean,
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        ...processCreateParams(params)
      });
    };
    class ZodDate extends ZodType {
      _parse(input) {
        if (this._def.coerce) {
          input.data = new Date(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.date) {
          const ctx2 = this._getOrReturnCtx(input);
          (0, parseUtil_1.addIssueToContext)(ctx2, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.date,
            received: ctx2.parsedType
          });
          return parseUtil_1.INVALID;
        }
        if (isNaN(input.data.getTime())) {
          const ctx2 = this._getOrReturnCtx(input);
          (0, parseUtil_1.addIssueToContext)(ctx2, {
            code: ZodError_1.ZodIssueCode.invalid_date
          });
          return parseUtil_1.INVALID;
        }
        const status = new parseUtil_1.ParseStatus();
        let ctx = void 0;
        for (const check2 of this._def.checks) {
          if (check2.kind === "min") {
            if (input.data.getTime() < check2.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.too_small,
                message: check2.message,
                inclusive: true,
                exact: false,
                minimum: check2.value,
                type: "date"
              });
              status.dirty();
            }
          } else if (check2.kind === "max") {
            if (input.data.getTime() > check2.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.too_big,
                message: check2.message,
                inclusive: true,
                exact: false,
                maximum: check2.value,
                type: "date"
              });
              status.dirty();
            }
          } else {
            util_1.util.assertNever(check2);
          }
        }
        return {
          status: status.value,
          value: new Date(input.data.getTime())
        };
      }
      _addCheck(check2) {
        return new ZodDate({
          ...this._def,
          checks: [...this._def.checks, check2]
        });
      }
      min(minDate, message2) {
        return this._addCheck({
          kind: "min",
          value: minDate.getTime(),
          message: errorUtil_1.errorUtil.toString(message2)
        });
      }
      max(maxDate, message2) {
        return this._addCheck({
          kind: "max",
          value: maxDate.getTime(),
          message: errorUtil_1.errorUtil.toString(message2)
        });
      }
      get minDate() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min != null ? new Date(min) : null;
      }
      get maxDate() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max != null ? new Date(max) : null;
      }
    }
    types$4.ZodDate = ZodDate;
    ZodDate.create = (params) => {
      return new ZodDate({
        checks: [],
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        typeName: ZodFirstPartyTypeKind.ZodDate,
        ...processCreateParams(params)
      });
    };
    class ZodSymbol extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.symbol) {
          const ctx = this._getOrReturnCtx(input);
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.symbol,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
      }
    }
    types$4.ZodSymbol = ZodSymbol;
    ZodSymbol.create = (params) => {
      return new ZodSymbol({
        typeName: ZodFirstPartyTypeKind.ZodSymbol,
        ...processCreateParams(params)
      });
    };
    class ZodUndefined extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.undefined) {
          const ctx = this._getOrReturnCtx(input);
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.undefined,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
      }
    }
    types$4.ZodUndefined = ZodUndefined;
    ZodUndefined.create = (params) => {
      return new ZodUndefined({
        typeName: ZodFirstPartyTypeKind.ZodUndefined,
        ...processCreateParams(params)
      });
    };
    class ZodNull extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.null) {
          const ctx = this._getOrReturnCtx(input);
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.null,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
      }
    }
    types$4.ZodNull = ZodNull;
    ZodNull.create = (params) => {
      return new ZodNull({
        typeName: ZodFirstPartyTypeKind.ZodNull,
        ...processCreateParams(params)
      });
    };
    class ZodAny extends ZodType {
      constructor() {
        super(...arguments);
        this._any = true;
      }
      _parse(input) {
        return (0, parseUtil_1.OK)(input.data);
      }
    }
    types$4.ZodAny = ZodAny;
    ZodAny.create = (params) => {
      return new ZodAny({
        typeName: ZodFirstPartyTypeKind.ZodAny,
        ...processCreateParams(params)
      });
    };
    class ZodUnknown extends ZodType {
      constructor() {
        super(...arguments);
        this._unknown = true;
      }
      _parse(input) {
        return (0, parseUtil_1.OK)(input.data);
      }
    }
    types$4.ZodUnknown = ZodUnknown;
    ZodUnknown.create = (params) => {
      return new ZodUnknown({
        typeName: ZodFirstPartyTypeKind.ZodUnknown,
        ...processCreateParams(params)
      });
    };
    class ZodNever extends ZodType {
      _parse(input) {
        const ctx = this._getOrReturnCtx(input);
        (0, parseUtil_1.addIssueToContext)(ctx, {
          code: ZodError_1.ZodIssueCode.invalid_type,
          expected: util_1.ZodParsedType.never,
          received: ctx.parsedType
        });
        return parseUtil_1.INVALID;
      }
    }
    types$4.ZodNever = ZodNever;
    ZodNever.create = (params) => {
      return new ZodNever({
        typeName: ZodFirstPartyTypeKind.ZodNever,
        ...processCreateParams(params)
      });
    };
    class ZodVoid extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.undefined) {
          const ctx = this._getOrReturnCtx(input);
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.void,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
      }
    }
    types$4.ZodVoid = ZodVoid;
    ZodVoid.create = (params) => {
      return new ZodVoid({
        typeName: ZodFirstPartyTypeKind.ZodVoid,
        ...processCreateParams(params)
      });
    };
    class ZodArray extends ZodType {
      _parse(input) {
        const { ctx, status } = this._processInputParams(input);
        const def = this._def;
        if (ctx.parsedType !== util_1.ZodParsedType.array) {
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.array,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        if (def.exactLength !== null) {
          const tooBig = ctx.data.length > def.exactLength.value;
          const tooSmall = ctx.data.length < def.exactLength.value;
          if (tooBig || tooSmall) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: tooBig ? ZodError_1.ZodIssueCode.too_big : ZodError_1.ZodIssueCode.too_small,
              minimum: tooSmall ? def.exactLength.value : void 0,
              maximum: tooBig ? def.exactLength.value : void 0,
              type: "array",
              inclusive: true,
              exact: true,
              message: def.exactLength.message
            });
            status.dirty();
          }
        }
        if (def.minLength !== null) {
          if (ctx.data.length < def.minLength.value) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.too_small,
              minimum: def.minLength.value,
              type: "array",
              inclusive: true,
              exact: false,
              message: def.minLength.message
            });
            status.dirty();
          }
        }
        if (def.maxLength !== null) {
          if (ctx.data.length > def.maxLength.value) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.too_big,
              maximum: def.maxLength.value,
              type: "array",
              inclusive: true,
              exact: false,
              message: def.maxLength.message
            });
            status.dirty();
          }
        }
        if (ctx.common.async) {
          return Promise.all([...ctx.data].map((item, i) => {
            return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
          })).then((result2) => {
            return parseUtil_1.ParseStatus.mergeArray(status, result2);
          });
        }
        const result = [...ctx.data].map((item, i) => {
          return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
        });
        return parseUtil_1.ParseStatus.mergeArray(status, result);
      }
      get element() {
        return this._def.type;
      }
      min(minLength, message2) {
        return new ZodArray({
          ...this._def,
          minLength: { value: minLength, message: errorUtil_1.errorUtil.toString(message2) }
        });
      }
      max(maxLength, message2) {
        return new ZodArray({
          ...this._def,
          maxLength: { value: maxLength, message: errorUtil_1.errorUtil.toString(message2) }
        });
      }
      length(len, message2) {
        return new ZodArray({
          ...this._def,
          exactLength: { value: len, message: errorUtil_1.errorUtil.toString(message2) }
        });
      }
      nonempty(message2) {
        return this.min(1, message2);
      }
    }
    types$4.ZodArray = ZodArray;
    ZodArray.create = (schema2, params) => {
      return new ZodArray({
        type: schema2,
        minLength: null,
        maxLength: null,
        exactLength: null,
        typeName: ZodFirstPartyTypeKind.ZodArray,
        ...processCreateParams(params)
      });
    };
    function deepPartialify(schema2) {
      if (schema2 instanceof ZodObject) {
        const newShape = {};
        for (const key in schema2.shape) {
          const fieldSchema = schema2.shape[key];
          newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
        }
        return new ZodObject({
          ...schema2._def,
          shape: () => newShape
        });
      } else if (schema2 instanceof ZodArray) {
        return new ZodArray({
          ...schema2._def,
          type: deepPartialify(schema2.element)
        });
      } else if (schema2 instanceof ZodOptional) {
        return ZodOptional.create(deepPartialify(schema2.unwrap()));
      } else if (schema2 instanceof ZodNullable) {
        return ZodNullable.create(deepPartialify(schema2.unwrap()));
      } else if (schema2 instanceof ZodTuple) {
        return ZodTuple.create(schema2.items.map((item) => deepPartialify(item)));
      } else {
        return schema2;
      }
    }
    class ZodObject extends ZodType {
      constructor() {
        super(...arguments);
        this._cached = null;
        this.nonstrict = this.passthrough;
        this.augment = this.extend;
      }
      _getCached() {
        if (this._cached !== null)
          return this._cached;
        const shape = this._def.shape();
        const keys = util_1.util.objectKeys(shape);
        return this._cached = { shape, keys };
      }
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.object) {
          const ctx2 = this._getOrReturnCtx(input);
          (0, parseUtil_1.addIssueToContext)(ctx2, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.object,
            received: ctx2.parsedType
          });
          return parseUtil_1.INVALID;
        }
        const { status, ctx } = this._processInputParams(input);
        const { shape, keys: shapeKeys } = this._getCached();
        const extraKeys = [];
        if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
          for (const key in ctx.data) {
            if (!shapeKeys.includes(key)) {
              extraKeys.push(key);
            }
          }
        }
        const pairs = [];
        for (const key of shapeKeys) {
          const keyValidator = shape[key];
          const value = ctx.data[key];
          pairs.push({
            key: { status: "valid", value: key },
            value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
            alwaysSet: key in ctx.data
          });
        }
        if (this._def.catchall instanceof ZodNever) {
          const unknownKeys = this._def.unknownKeys;
          if (unknownKeys === "passthrough") {
            for (const key of extraKeys) {
              pairs.push({
                key: { status: "valid", value: key },
                value: { status: "valid", value: ctx.data[key] }
              });
            }
          } else if (unknownKeys === "strict") {
            if (extraKeys.length > 0) {
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.unrecognized_keys,
                keys: extraKeys
              });
              status.dirty();
            }
          } else if (unknownKeys === "strip") ;
          else {
            throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
          }
        } else {
          const catchall = this._def.catchall;
          for (const key of extraKeys) {
            const value = ctx.data[key];
            pairs.push({
              key: { status: "valid", value: key },
              value: catchall._parse(
                new ParseInputLazyPath(ctx, value, ctx.path, key)
                //, ctx.child(key), value, getParsedType(value)
              ),
              alwaysSet: key in ctx.data
            });
          }
        }
        if (ctx.common.async) {
          return Promise.resolve().then(async () => {
            const syncPairs = [];
            for (const pair of pairs) {
              const key = await pair.key;
              const value = await pair.value;
              syncPairs.push({
                key,
                value,
                alwaysSet: pair.alwaysSet
              });
            }
            return syncPairs;
          }).then((syncPairs) => {
            return parseUtil_1.ParseStatus.mergeObjectSync(status, syncPairs);
          });
        } else {
          return parseUtil_1.ParseStatus.mergeObjectSync(status, pairs);
        }
      }
      get shape() {
        return this._def.shape();
      }
      strict(message2) {
        errorUtil_1.errorUtil.errToObj;
        return new ZodObject({
          ...this._def,
          unknownKeys: "strict",
          ...message2 !== void 0 ? {
            errorMap: (issue, ctx) => {
              var _a, _b, _c, _d;
              const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
              if (issue.code === "unrecognized_keys")
                return {
                  message: (_d = errorUtil_1.errorUtil.errToObj(message2).message) !== null && _d !== void 0 ? _d : defaultError
                };
              return {
                message: defaultError
              };
            }
          } : {}
        });
      }
      strip() {
        return new ZodObject({
          ...this._def,
          unknownKeys: "strip"
        });
      }
      passthrough() {
        return new ZodObject({
          ...this._def,
          unknownKeys: "passthrough"
        });
      }
      // const AugmentFactory =
      //   <Def extends ZodObjectDef>(def: Def) =>
      //   <Augmentation extends ZodRawShape>(
      //     augmentation: Augmentation
      //   ): ZodObject<
      //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
      //     Def["unknownKeys"],
      //     Def["catchall"]
      //   > => {
      //     return new ZodObject({
      //       ...def,
      //       shape: () => ({
      //         ...def.shape(),
      //         ...augmentation,
      //       }),
      //     }) as any;
      //   };
      extend(augmentation) {
        return new ZodObject({
          ...this._def,
          shape: () => ({
            ...this._def.shape(),
            ...augmentation
          })
        });
      }
      /**
       * Prior to zod@1.0.12 there was a bug in the
       * inferred type of merged objects. Please
       * upgrade if you are experiencing issues.
       */
      merge(merging) {
        const merged = new ZodObject({
          unknownKeys: merging._def.unknownKeys,
          catchall: merging._def.catchall,
          shape: () => ({
            ...this._def.shape(),
            ...merging._def.shape()
          }),
          typeName: ZodFirstPartyTypeKind.ZodObject
        });
        return merged;
      }
      // merge<
      //   Incoming extends AnyZodObject,
      //   Augmentation extends Incoming["shape"],
      //   NewOutput extends {
      //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
      //       ? Augmentation[k]["_output"]
      //       : k extends keyof Output
      //       ? Output[k]
      //       : never;
      //   },
      //   NewInput extends {
      //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
      //       ? Augmentation[k]["_input"]
      //       : k extends keyof Input
      //       ? Input[k]
      //       : never;
      //   }
      // >(
      //   merging: Incoming
      // ): ZodObject<
      //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
      //   Incoming["_def"]["unknownKeys"],
      //   Incoming["_def"]["catchall"],
      //   NewOutput,
      //   NewInput
      // > {
      //   const merged: any = new ZodObject({
      //     unknownKeys: merging._def.unknownKeys,
      //     catchall: merging._def.catchall,
      //     shape: () =>
      //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
      //     typeName: ZodFirstPartyTypeKind.ZodObject,
      //   }) as any;
      //   return merged;
      // }
      setKey(key, schema2) {
        return this.augment({ [key]: schema2 });
      }
      // merge<Incoming extends AnyZodObject>(
      //   merging: Incoming
      // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
      // ZodObject<
      //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
      //   Incoming["_def"]["unknownKeys"],
      //   Incoming["_def"]["catchall"]
      // > {
      //   // const mergedShape = objectUtil.mergeShapes(
      //   //   this._def.shape(),
      //   //   merging._def.shape()
      //   // );
      //   const merged: any = new ZodObject({
      //     unknownKeys: merging._def.unknownKeys,
      //     catchall: merging._def.catchall,
      //     shape: () =>
      //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
      //     typeName: ZodFirstPartyTypeKind.ZodObject,
      //   }) as any;
      //   return merged;
      // }
      catchall(index) {
        return new ZodObject({
          ...this._def,
          catchall: index
        });
      }
      pick(mask) {
        const shape = {};
        util_1.util.objectKeys(mask).forEach((key) => {
          if (mask[key] && this.shape[key]) {
            shape[key] = this.shape[key];
          }
        });
        return new ZodObject({
          ...this._def,
          shape: () => shape
        });
      }
      omit(mask) {
        const shape = {};
        util_1.util.objectKeys(this.shape).forEach((key) => {
          if (!mask[key]) {
            shape[key] = this.shape[key];
          }
        });
        return new ZodObject({
          ...this._def,
          shape: () => shape
        });
      }
      /**
       * @deprecated
       */
      deepPartial() {
        return deepPartialify(this);
      }
      partial(mask) {
        const newShape = {};
        util_1.util.objectKeys(this.shape).forEach((key) => {
          const fieldSchema = this.shape[key];
          if (mask && !mask[key]) {
            newShape[key] = fieldSchema;
          } else {
            newShape[key] = fieldSchema.optional();
          }
        });
        return new ZodObject({
          ...this._def,
          shape: () => newShape
        });
      }
      required(mask) {
        const newShape = {};
        util_1.util.objectKeys(this.shape).forEach((key) => {
          if (mask && !mask[key]) {
            newShape[key] = this.shape[key];
          } else {
            const fieldSchema = this.shape[key];
            let newField = fieldSchema;
            while (newField instanceof ZodOptional) {
              newField = newField._def.innerType;
            }
            newShape[key] = newField;
          }
        });
        return new ZodObject({
          ...this._def,
          shape: () => newShape
        });
      }
      keyof() {
        return createZodEnum(util_1.util.objectKeys(this.shape));
      }
    }
    types$4.ZodObject = ZodObject;
    ZodObject.create = (shape, params) => {
      return new ZodObject({
        shape: () => shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params)
      });
    };
    ZodObject.strictCreate = (shape, params) => {
      return new ZodObject({
        shape: () => shape,
        unknownKeys: "strict",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params)
      });
    };
    ZodObject.lazycreate = (shape, params) => {
      return new ZodObject({
        shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params)
      });
    };
    class ZodUnion extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const options = this._def.options;
        function handleResults(results) {
          for (const result of results) {
            if (result.result.status === "valid") {
              return result.result;
            }
          }
          for (const result of results) {
            if (result.result.status === "dirty") {
              ctx.common.issues.push(...result.ctx.common.issues);
              return result.result;
            }
          }
          const unionErrors = results.map((result) => new ZodError_1.ZodError(result.ctx.common.issues));
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_union,
            unionErrors
          });
          return parseUtil_1.INVALID;
        }
        if (ctx.common.async) {
          return Promise.all(options.map(async (option) => {
            const childCtx = {
              ...ctx,
              common: {
                ...ctx.common,
                issues: []
              },
              parent: null
            };
            return {
              result: await option._parseAsync({
                data: ctx.data,
                path: ctx.path,
                parent: childCtx
              }),
              ctx: childCtx
            };
          })).then(handleResults);
        } else {
          let dirty = void 0;
          const issues = [];
          for (const option of options) {
            const childCtx = {
              ...ctx,
              common: {
                ...ctx.common,
                issues: []
              },
              parent: null
            };
            const result = option._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: childCtx
            });
            if (result.status === "valid") {
              return result;
            } else if (result.status === "dirty" && !dirty) {
              dirty = { result, ctx: childCtx };
            }
            if (childCtx.common.issues.length) {
              issues.push(childCtx.common.issues);
            }
          }
          if (dirty) {
            ctx.common.issues.push(...dirty.ctx.common.issues);
            return dirty.result;
          }
          const unionErrors = issues.map((issues2) => new ZodError_1.ZodError(issues2));
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_union,
            unionErrors
          });
          return parseUtil_1.INVALID;
        }
      }
      get options() {
        return this._def.options;
      }
    }
    types$4.ZodUnion = ZodUnion;
    ZodUnion.create = (types2, params) => {
      return new ZodUnion({
        options: types2,
        typeName: ZodFirstPartyTypeKind.ZodUnion,
        ...processCreateParams(params)
      });
    };
    const getDiscriminator = (type) => {
      if (type instanceof ZodLazy) {
        return getDiscriminator(type.schema);
      } else if (type instanceof ZodEffects) {
        return getDiscriminator(type.innerType());
      } else if (type instanceof ZodLiteral) {
        return [type.value];
      } else if (type instanceof ZodEnum) {
        return type.options;
      } else if (type instanceof ZodNativeEnum) {
        return util_1.util.objectValues(type.enum);
      } else if (type instanceof ZodDefault) {
        return getDiscriminator(type._def.innerType);
      } else if (type instanceof ZodUndefined) {
        return [void 0];
      } else if (type instanceof ZodNull) {
        return [null];
      } else if (type instanceof ZodOptional) {
        return [void 0, ...getDiscriminator(type.unwrap())];
      } else if (type instanceof ZodNullable) {
        return [null, ...getDiscriminator(type.unwrap())];
      } else if (type instanceof ZodBranded) {
        return getDiscriminator(type.unwrap());
      } else if (type instanceof ZodReadonly) {
        return getDiscriminator(type.unwrap());
      } else if (type instanceof ZodCatch) {
        return getDiscriminator(type._def.innerType);
      } else {
        return [];
      }
    };
    class ZodDiscriminatedUnion extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1.ZodParsedType.object) {
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.object,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        const discriminator = this.discriminator;
        const discriminatorValue = ctx.data[discriminator];
        const option = this.optionsMap.get(discriminatorValue);
        if (!option) {
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_union_discriminator,
            options: Array.from(this.optionsMap.keys()),
            path: [discriminator]
          });
          return parseUtil_1.INVALID;
        }
        if (ctx.common.async) {
          return option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
        } else {
          return option._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
        }
      }
      get discriminator() {
        return this._def.discriminator;
      }
      get options() {
        return this._def.options;
      }
      get optionsMap() {
        return this._def.optionsMap;
      }
      /**
       * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
       * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
       * have a different value for each object in the union.
       * @param discriminator the name of the discriminator property
       * @param types an array of object schemas
       * @param params
       */
      static create(discriminator, options, params) {
        const optionsMap = /* @__PURE__ */ new Map();
        for (const type of options) {
          const discriminatorValues = getDiscriminator(type.shape[discriminator]);
          if (!discriminatorValues.length) {
            throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
          }
          for (const value of discriminatorValues) {
            if (optionsMap.has(value)) {
              throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
            }
            optionsMap.set(value, type);
          }
        }
        return new ZodDiscriminatedUnion({
          typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
          discriminator,
          options,
          optionsMap,
          ...processCreateParams(params)
        });
      }
    }
    types$4.ZodDiscriminatedUnion = ZodDiscriminatedUnion;
    function mergeValues(a, b) {
      const aType = (0, util_1.getParsedType)(a);
      const bType = (0, util_1.getParsedType)(b);
      if (a === b) {
        return { valid: true, data: a };
      } else if (aType === util_1.ZodParsedType.object && bType === util_1.ZodParsedType.object) {
        const bKeys = util_1.util.objectKeys(b);
        const sharedKeys = util_1.util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
        const newObj = { ...a, ...b };
        for (const key of sharedKeys) {
          const sharedValue = mergeValues(a[key], b[key]);
          if (!sharedValue.valid) {
            return { valid: false };
          }
          newObj[key] = sharedValue.data;
        }
        return { valid: true, data: newObj };
      } else if (aType === util_1.ZodParsedType.array && bType === util_1.ZodParsedType.array) {
        if (a.length !== b.length) {
          return { valid: false };
        }
        const newArray = [];
        for (let index = 0; index < a.length; index++) {
          const itemA = a[index];
          const itemB = b[index];
          const sharedValue = mergeValues(itemA, itemB);
          if (!sharedValue.valid) {
            return { valid: false };
          }
          newArray.push(sharedValue.data);
        }
        return { valid: true, data: newArray };
      } else if (aType === util_1.ZodParsedType.date && bType === util_1.ZodParsedType.date && +a === +b) {
        return { valid: true, data: a };
      } else {
        return { valid: false };
      }
    }
    class ZodIntersection extends ZodType {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const handleParsed = (parsedLeft, parsedRight) => {
          if ((0, parseUtil_1.isAborted)(parsedLeft) || (0, parseUtil_1.isAborted)(parsedRight)) {
            return parseUtil_1.INVALID;
          }
          const merged = mergeValues(parsedLeft.value, parsedRight.value);
          if (!merged.valid) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.invalid_intersection_types
            });
            return parseUtil_1.INVALID;
          }
          if ((0, parseUtil_1.isDirty)(parsedLeft) || (0, parseUtil_1.isDirty)(parsedRight)) {
            status.dirty();
          }
          return { status: status.value, value: merged.data };
        };
        if (ctx.common.async) {
          return Promise.all([
            this._def.left._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            }),
            this._def.right._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            })
          ]).then(([left, right]) => handleParsed(left, right));
        } else {
          return handleParsed(this._def.left._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }), this._def.right._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }));
        }
      }
    }
    types$4.ZodIntersection = ZodIntersection;
    ZodIntersection.create = (left, right, params) => {
      return new ZodIntersection({
        left,
        right,
        typeName: ZodFirstPartyTypeKind.ZodIntersection,
        ...processCreateParams(params)
      });
    };
    class ZodTuple extends ZodType {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1.ZodParsedType.array) {
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.array,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        if (ctx.data.length < this._def.items.length) {
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.too_small,
            minimum: this._def.items.length,
            inclusive: true,
            exact: false,
            type: "array"
          });
          return parseUtil_1.INVALID;
        }
        const rest = this._def.rest;
        if (!rest && ctx.data.length > this._def.items.length) {
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.too_big,
            maximum: this._def.items.length,
            inclusive: true,
            exact: false,
            type: "array"
          });
          status.dirty();
        }
        const items = [...ctx.data].map((item, itemIndex) => {
          const schema2 = this._def.items[itemIndex] || this._def.rest;
          if (!schema2)
            return null;
          return schema2._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
        }).filter((x) => !!x);
        if (ctx.common.async) {
          return Promise.all(items).then((results) => {
            return parseUtil_1.ParseStatus.mergeArray(status, results);
          });
        } else {
          return parseUtil_1.ParseStatus.mergeArray(status, items);
        }
      }
      get items() {
        return this._def.items;
      }
      rest(rest) {
        return new ZodTuple({
          ...this._def,
          rest
        });
      }
    }
    types$4.ZodTuple = ZodTuple;
    ZodTuple.create = (schemas, params) => {
      if (!Array.isArray(schemas)) {
        throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
      }
      return new ZodTuple({
        items: schemas,
        typeName: ZodFirstPartyTypeKind.ZodTuple,
        rest: null,
        ...processCreateParams(params)
      });
    };
    class ZodRecord extends ZodType {
      get keySchema() {
        return this._def.keyType;
      }
      get valueSchema() {
        return this._def.valueType;
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1.ZodParsedType.object) {
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.object,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        const pairs = [];
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        for (const key in ctx.data) {
          pairs.push({
            key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
            value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
            alwaysSet: key in ctx.data
          });
        }
        if (ctx.common.async) {
          return parseUtil_1.ParseStatus.mergeObjectAsync(status, pairs);
        } else {
          return parseUtil_1.ParseStatus.mergeObjectSync(status, pairs);
        }
      }
      get element() {
        return this._def.valueType;
      }
      static create(first, second, third) {
        if (second instanceof ZodType) {
          return new ZodRecord({
            keyType: first,
            valueType: second,
            typeName: ZodFirstPartyTypeKind.ZodRecord,
            ...processCreateParams(third)
          });
        }
        return new ZodRecord({
          keyType: ZodString.create(),
          valueType: first,
          typeName: ZodFirstPartyTypeKind.ZodRecord,
          ...processCreateParams(second)
        });
      }
    }
    types$4.ZodRecord = ZodRecord;
    class ZodMap extends ZodType {
      get keySchema() {
        return this._def.keyType;
      }
      get valueSchema() {
        return this._def.valueType;
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1.ZodParsedType.map) {
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.map,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        const pairs = [...ctx.data.entries()].map(([key, value], index) => {
          return {
            key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
            value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
          };
        });
        if (ctx.common.async) {
          const finalMap = /* @__PURE__ */ new Map();
          return Promise.resolve().then(async () => {
            for (const pair of pairs) {
              const key = await pair.key;
              const value = await pair.value;
              if (key.status === "aborted" || value.status === "aborted") {
                return parseUtil_1.INVALID;
              }
              if (key.status === "dirty" || value.status === "dirty") {
                status.dirty();
              }
              finalMap.set(key.value, value.value);
            }
            return { status: status.value, value: finalMap };
          });
        } else {
          const finalMap = /* @__PURE__ */ new Map();
          for (const pair of pairs) {
            const key = pair.key;
            const value = pair.value;
            if (key.status === "aborted" || value.status === "aborted") {
              return parseUtil_1.INVALID;
            }
            if (key.status === "dirty" || value.status === "dirty") {
              status.dirty();
            }
            finalMap.set(key.value, value.value);
          }
          return { status: status.value, value: finalMap };
        }
      }
    }
    types$4.ZodMap = ZodMap;
    ZodMap.create = (keyType, valueType, params) => {
      return new ZodMap({
        valueType,
        keyType,
        typeName: ZodFirstPartyTypeKind.ZodMap,
        ...processCreateParams(params)
      });
    };
    class ZodSet extends ZodType {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1.ZodParsedType.set) {
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.set,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        const def = this._def;
        if (def.minSize !== null) {
          if (ctx.data.size < def.minSize.value) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.too_small,
              minimum: def.minSize.value,
              type: "set",
              inclusive: true,
              exact: false,
              message: def.minSize.message
            });
            status.dirty();
          }
        }
        if (def.maxSize !== null) {
          if (ctx.data.size > def.maxSize.value) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.too_big,
              maximum: def.maxSize.value,
              type: "set",
              inclusive: true,
              exact: false,
              message: def.maxSize.message
            });
            status.dirty();
          }
        }
        const valueType = this._def.valueType;
        function finalizeSet(elements2) {
          const parsedSet = /* @__PURE__ */ new Set();
          for (const element of elements2) {
            if (element.status === "aborted")
              return parseUtil_1.INVALID;
            if (element.status === "dirty")
              status.dirty();
            parsedSet.add(element.value);
          }
          return { status: status.value, value: parsedSet };
        }
        const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
        if (ctx.common.async) {
          return Promise.all(elements).then((elements2) => finalizeSet(elements2));
        } else {
          return finalizeSet(elements);
        }
      }
      min(minSize, message2) {
        return new ZodSet({
          ...this._def,
          minSize: { value: minSize, message: errorUtil_1.errorUtil.toString(message2) }
        });
      }
      max(maxSize, message2) {
        return new ZodSet({
          ...this._def,
          maxSize: { value: maxSize, message: errorUtil_1.errorUtil.toString(message2) }
        });
      }
      size(size, message2) {
        return this.min(size, message2).max(size, message2);
      }
      nonempty(message2) {
        return this.min(1, message2);
      }
    }
    types$4.ZodSet = ZodSet;
    ZodSet.create = (valueType, params) => {
      return new ZodSet({
        valueType,
        minSize: null,
        maxSize: null,
        typeName: ZodFirstPartyTypeKind.ZodSet,
        ...processCreateParams(params)
      });
    };
    class ZodFunction extends ZodType {
      constructor() {
        super(...arguments);
        this.validate = this.implement;
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1.ZodParsedType.function) {
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.function,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        function makeArgsIssue(args, error) {
          return (0, parseUtil_1.makeIssue)({
            data: args,
            path: ctx.path,
            errorMaps: [
              ctx.common.contextualErrorMap,
              ctx.schemaErrorMap,
              (0, errors_1.getErrorMap)(),
              errors_1.defaultErrorMap
            ].filter((x) => !!x),
            issueData: {
              code: ZodError_1.ZodIssueCode.invalid_arguments,
              argumentsError: error
            }
          });
        }
        function makeReturnsIssue(returns, error) {
          return (0, parseUtil_1.makeIssue)({
            data: returns,
            path: ctx.path,
            errorMaps: [
              ctx.common.contextualErrorMap,
              ctx.schemaErrorMap,
              (0, errors_1.getErrorMap)(),
              errors_1.defaultErrorMap
            ].filter((x) => !!x),
            issueData: {
              code: ZodError_1.ZodIssueCode.invalid_return_type,
              returnTypeError: error
            }
          });
        }
        const params = { errorMap: ctx.common.contextualErrorMap };
        const fn = ctx.data;
        if (this._def.returns instanceof ZodPromise) {
          const me = this;
          return (0, parseUtil_1.OK)(async function(...args) {
            const error = new ZodError_1.ZodError([]);
            const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
              error.addIssue(makeArgsIssue(args, e));
              throw error;
            });
            const result = await Reflect.apply(fn, this, parsedArgs);
            const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
              error.addIssue(makeReturnsIssue(result, e));
              throw error;
            });
            return parsedReturns;
          });
        } else {
          const me = this;
          return (0, parseUtil_1.OK)(function(...args) {
            const parsedArgs = me._def.args.safeParse(args, params);
            if (!parsedArgs.success) {
              throw new ZodError_1.ZodError([makeArgsIssue(args, parsedArgs.error)]);
            }
            const result = Reflect.apply(fn, this, parsedArgs.data);
            const parsedReturns = me._def.returns.safeParse(result, params);
            if (!parsedReturns.success) {
              throw new ZodError_1.ZodError([makeReturnsIssue(result, parsedReturns.error)]);
            }
            return parsedReturns.data;
          });
        }
      }
      parameters() {
        return this._def.args;
      }
      returnType() {
        return this._def.returns;
      }
      args(...items) {
        return new ZodFunction({
          ...this._def,
          args: ZodTuple.create(items).rest(ZodUnknown.create())
        });
      }
      returns(returnType) {
        return new ZodFunction({
          ...this._def,
          returns: returnType
        });
      }
      implement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
      }
      strictImplement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
      }
      static create(args, returns, params) {
        return new ZodFunction({
          args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
          returns: returns || ZodUnknown.create(),
          typeName: ZodFirstPartyTypeKind.ZodFunction,
          ...processCreateParams(params)
        });
      }
    }
    types$4.ZodFunction = ZodFunction;
    class ZodLazy extends ZodType {
      get schema() {
        return this._def.getter();
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const lazySchema = this._def.getter();
        return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
      }
    }
    types$4.ZodLazy = ZodLazy;
    ZodLazy.create = (getter, params) => {
      return new ZodLazy({
        getter,
        typeName: ZodFirstPartyTypeKind.ZodLazy,
        ...processCreateParams(params)
      });
    };
    class ZodLiteral extends ZodType {
      _parse(input) {
        if (input.data !== this._def.value) {
          const ctx = this._getOrReturnCtx(input);
          (0, parseUtil_1.addIssueToContext)(ctx, {
            received: ctx.data,
            code: ZodError_1.ZodIssueCode.invalid_literal,
            expected: this._def.value
          });
          return parseUtil_1.INVALID;
        }
        return { status: "valid", value: input.data };
      }
      get value() {
        return this._def.value;
      }
    }
    types$4.ZodLiteral = ZodLiteral;
    ZodLiteral.create = (value, params) => {
      return new ZodLiteral({
        value,
        typeName: ZodFirstPartyTypeKind.ZodLiteral,
        ...processCreateParams(params)
      });
    };
    function createZodEnum(values, params) {
      return new ZodEnum({
        values,
        typeName: ZodFirstPartyTypeKind.ZodEnum,
        ...processCreateParams(params)
      });
    }
    class ZodEnum extends ZodType {
      constructor() {
        super(...arguments);
        _ZodEnum_cache.set(this, void 0);
      }
      _parse(input) {
        if (typeof input.data !== "string") {
          const ctx = this._getOrReturnCtx(input);
          const expectedValues = this._def.values;
          (0, parseUtil_1.addIssueToContext)(ctx, {
            expected: util_1.util.joinValues(expectedValues),
            received: ctx.parsedType,
            code: ZodError_1.ZodIssueCode.invalid_type
          });
          return parseUtil_1.INVALID;
        }
        if (!__classPrivateFieldGet(this, _ZodEnum_cache, "f")) {
          __classPrivateFieldSet(this, _ZodEnum_cache, new Set(this._def.values), "f");
        }
        if (!__classPrivateFieldGet(this, _ZodEnum_cache, "f").has(input.data)) {
          const ctx = this._getOrReturnCtx(input);
          const expectedValues = this._def.values;
          (0, parseUtil_1.addIssueToContext)(ctx, {
            received: ctx.data,
            code: ZodError_1.ZodIssueCode.invalid_enum_value,
            options: expectedValues
          });
          return parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
      }
      get options() {
        return this._def.values;
      }
      get enum() {
        const enumValues = {};
        for (const val of this._def.values) {
          enumValues[val] = val;
        }
        return enumValues;
      }
      get Values() {
        const enumValues = {};
        for (const val of this._def.values) {
          enumValues[val] = val;
        }
        return enumValues;
      }
      get Enum() {
        const enumValues = {};
        for (const val of this._def.values) {
          enumValues[val] = val;
        }
        return enumValues;
      }
      extract(values, newDef = this._def) {
        return ZodEnum.create(values, {
          ...this._def,
          ...newDef
        });
      }
      exclude(values, newDef = this._def) {
        return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
          ...this._def,
          ...newDef
        });
      }
    }
    types$4.ZodEnum = ZodEnum;
    _ZodEnum_cache = /* @__PURE__ */ new WeakMap();
    ZodEnum.create = createZodEnum;
    class ZodNativeEnum extends ZodType {
      constructor() {
        super(...arguments);
        _ZodNativeEnum_cache.set(this, void 0);
      }
      _parse(input) {
        const nativeEnumValues = util_1.util.getValidEnumValues(this._def.values);
        const ctx = this._getOrReturnCtx(input);
        if (ctx.parsedType !== util_1.ZodParsedType.string && ctx.parsedType !== util_1.ZodParsedType.number) {
          const expectedValues = util_1.util.objectValues(nativeEnumValues);
          (0, parseUtil_1.addIssueToContext)(ctx, {
            expected: util_1.util.joinValues(expectedValues),
            received: ctx.parsedType,
            code: ZodError_1.ZodIssueCode.invalid_type
          });
          return parseUtil_1.INVALID;
        }
        if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, "f")) {
          __classPrivateFieldSet(this, _ZodNativeEnum_cache, new Set(util_1.util.getValidEnumValues(this._def.values)), "f");
        }
        if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, "f").has(input.data)) {
          const expectedValues = util_1.util.objectValues(nativeEnumValues);
          (0, parseUtil_1.addIssueToContext)(ctx, {
            received: ctx.data,
            code: ZodError_1.ZodIssueCode.invalid_enum_value,
            options: expectedValues
          });
          return parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
      }
      get enum() {
        return this._def.values;
      }
    }
    types$4.ZodNativeEnum = ZodNativeEnum;
    _ZodNativeEnum_cache = /* @__PURE__ */ new WeakMap();
    ZodNativeEnum.create = (values, params) => {
      return new ZodNativeEnum({
        values,
        typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
        ...processCreateParams(params)
      });
    };
    class ZodPromise extends ZodType {
      unwrap() {
        return this._def.type;
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1.ZodParsedType.promise && ctx.common.async === false) {
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.promise,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        const promisified = ctx.parsedType === util_1.ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
        return (0, parseUtil_1.OK)(promisified.then((data) => {
          return this._def.type.parseAsync(data, {
            path: ctx.path,
            errorMap: ctx.common.contextualErrorMap
          });
        }));
      }
    }
    types$4.ZodPromise = ZodPromise;
    ZodPromise.create = (schema2, params) => {
      return new ZodPromise({
        type: schema2,
        typeName: ZodFirstPartyTypeKind.ZodPromise,
        ...processCreateParams(params)
      });
    };
    class ZodEffects extends ZodType {
      innerType() {
        return this._def.schema;
      }
      sourceType() {
        return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const effect = this._def.effect || null;
        const checkCtx = {
          addIssue: (arg) => {
            (0, parseUtil_1.addIssueToContext)(ctx, arg);
            if (arg.fatal) {
              status.abort();
            } else {
              status.dirty();
            }
          },
          get path() {
            return ctx.path;
          }
        };
        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
        if (effect.type === "preprocess") {
          const processed = effect.transform(ctx.data, checkCtx);
          if (ctx.common.async) {
            return Promise.resolve(processed).then(async (processed2) => {
              if (status.value === "aborted")
                return parseUtil_1.INVALID;
              const result = await this._def.schema._parseAsync({
                data: processed2,
                path: ctx.path,
                parent: ctx
              });
              if (result.status === "aborted")
                return parseUtil_1.INVALID;
              if (result.status === "dirty")
                return (0, parseUtil_1.DIRTY)(result.value);
              if (status.value === "dirty")
                return (0, parseUtil_1.DIRTY)(result.value);
              return result;
            });
          } else {
            if (status.value === "aborted")
              return parseUtil_1.INVALID;
            const result = this._def.schema._parseSync({
              data: processed,
              path: ctx.path,
              parent: ctx
            });
            if (result.status === "aborted")
              return parseUtil_1.INVALID;
            if (result.status === "dirty")
              return (0, parseUtil_1.DIRTY)(result.value);
            if (status.value === "dirty")
              return (0, parseUtil_1.DIRTY)(result.value);
            return result;
          }
        }
        if (effect.type === "refinement") {
          const executeRefinement = (acc) => {
            const result = effect.refinement(acc, checkCtx);
            if (ctx.common.async) {
              return Promise.resolve(result);
            }
            if (result instanceof Promise) {
              throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
            }
            return acc;
          };
          if (ctx.common.async === false) {
            const inner = this._def.schema._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (inner.status === "aborted")
              return parseUtil_1.INVALID;
            if (inner.status === "dirty")
              status.dirty();
            executeRefinement(inner.value);
            return { status: status.value, value: inner.value };
          } else {
            return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
              if (inner.status === "aborted")
                return parseUtil_1.INVALID;
              if (inner.status === "dirty")
                status.dirty();
              return executeRefinement(inner.value).then(() => {
                return { status: status.value, value: inner.value };
              });
            });
          }
        }
        if (effect.type === "transform") {
          if (ctx.common.async === false) {
            const base3 = this._def.schema._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (!(0, parseUtil_1.isValid)(base3))
              return base3;
            const result = effect.transform(base3.value, checkCtx);
            if (result instanceof Promise) {
              throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
            }
            return { status: status.value, value: result };
          } else {
            return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base3) => {
              if (!(0, parseUtil_1.isValid)(base3))
                return base3;
              return Promise.resolve(effect.transform(base3.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
            });
          }
        }
        util_1.util.assertNever(effect);
      }
    }
    types$4.ZodEffects = ZodEffects;
    types$4.ZodTransformer = ZodEffects;
    ZodEffects.create = (schema2, effect, params) => {
      return new ZodEffects({
        schema: schema2,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect,
        ...processCreateParams(params)
      });
    };
    ZodEffects.createWithPreprocess = (preprocess, schema2, params) => {
      return new ZodEffects({
        schema: schema2,
        effect: { type: "preprocess", transform: preprocess },
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        ...processCreateParams(params)
      });
    };
    class ZodOptional extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === util_1.ZodParsedType.undefined) {
          return (0, parseUtil_1.OK)(void 0);
        }
        return this._def.innerType._parse(input);
      }
      unwrap() {
        return this._def.innerType;
      }
    }
    types$4.ZodOptional = ZodOptional;
    ZodOptional.create = (type, params) => {
      return new ZodOptional({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodOptional,
        ...processCreateParams(params)
      });
    };
    class ZodNullable extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === util_1.ZodParsedType.null) {
          return (0, parseUtil_1.OK)(null);
        }
        return this._def.innerType._parse(input);
      }
      unwrap() {
        return this._def.innerType;
      }
    }
    types$4.ZodNullable = ZodNullable;
    ZodNullable.create = (type, params) => {
      return new ZodNullable({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodNullable,
        ...processCreateParams(params)
      });
    };
    class ZodDefault extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        let data = ctx.data;
        if (ctx.parsedType === util_1.ZodParsedType.undefined) {
          data = this._def.defaultValue();
        }
        return this._def.innerType._parse({
          data,
          path: ctx.path,
          parent: ctx
        });
      }
      removeDefault() {
        return this._def.innerType;
      }
    }
    types$4.ZodDefault = ZodDefault;
    ZodDefault.create = (type, params) => {
      return new ZodDefault({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodDefault,
        defaultValue: typeof params.default === "function" ? params.default : () => params.default,
        ...processCreateParams(params)
      });
    };
    class ZodCatch extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const newCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          }
        };
        const result = this._def.innerType._parse({
          data: newCtx.data,
          path: newCtx.path,
          parent: {
            ...newCtx
          }
        });
        if ((0, parseUtil_1.isAsync)(result)) {
          return result.then((result2) => {
            return {
              status: "valid",
              value: result2.status === "valid" ? result2.value : this._def.catchValue({
                get error() {
                  return new ZodError_1.ZodError(newCtx.common.issues);
                },
                input: newCtx.data
              })
            };
          });
        } else {
          return {
            status: "valid",
            value: result.status === "valid" ? result.value : this._def.catchValue({
              get error() {
                return new ZodError_1.ZodError(newCtx.common.issues);
              },
              input: newCtx.data
            })
          };
        }
      }
      removeCatch() {
        return this._def.innerType;
      }
    }
    types$4.ZodCatch = ZodCatch;
    ZodCatch.create = (type, params) => {
      return new ZodCatch({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodCatch,
        catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
        ...processCreateParams(params)
      });
    };
    class ZodNaN extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.nan) {
          const ctx = this._getOrReturnCtx(input);
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.nan,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        return { status: "valid", value: input.data };
      }
    }
    types$4.ZodNaN = ZodNaN;
    ZodNaN.create = (params) => {
      return new ZodNaN({
        typeName: ZodFirstPartyTypeKind.ZodNaN,
        ...processCreateParams(params)
      });
    };
    types$4.BRAND = Symbol("zod_brand");
    class ZodBranded extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const data = ctx.data;
        return this._def.type._parse({
          data,
          path: ctx.path,
          parent: ctx
        });
      }
      unwrap() {
        return this._def.type;
      }
    }
    types$4.ZodBranded = ZodBranded;
    class ZodPipeline extends ZodType {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.common.async) {
          const handleAsync = async () => {
            const inResult = await this._def.in._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (inResult.status === "aborted")
              return parseUtil_1.INVALID;
            if (inResult.status === "dirty") {
              status.dirty();
              return (0, parseUtil_1.DIRTY)(inResult.value);
            } else {
              return this._def.out._parseAsync({
                data: inResult.value,
                path: ctx.path,
                parent: ctx
              });
            }
          };
          return handleAsync();
        } else {
          const inResult = this._def.in._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inResult.status === "aborted")
            return parseUtil_1.INVALID;
          if (inResult.status === "dirty") {
            status.dirty();
            return {
              status: "dirty",
              value: inResult.value
            };
          } else {
            return this._def.out._parseSync({
              data: inResult.value,
              path: ctx.path,
              parent: ctx
            });
          }
        }
      }
      static create(a, b) {
        return new ZodPipeline({
          in: a,
          out: b,
          typeName: ZodFirstPartyTypeKind.ZodPipeline
        });
      }
    }
    types$4.ZodPipeline = ZodPipeline;
    class ZodReadonly extends ZodType {
      _parse(input) {
        const result = this._def.innerType._parse(input);
        const freeze = (data) => {
          if ((0, parseUtil_1.isValid)(data)) {
            data.value = Object.freeze(data.value);
          }
          return data;
        };
        return (0, parseUtil_1.isAsync)(result) ? result.then((data) => freeze(data)) : freeze(result);
      }
      unwrap() {
        return this._def.innerType;
      }
    }
    types$4.ZodReadonly = ZodReadonly;
    ZodReadonly.create = (type, params) => {
      return new ZodReadonly({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodReadonly,
        ...processCreateParams(params)
      });
    };
    function cleanParams(params, data) {
      const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
      const p2 = typeof p === "string" ? { message: p } : p;
      return p2;
    }
    function custom(check2, _params = {}, fatal) {
      if (check2)
        return ZodAny.create().superRefine((data, ctx) => {
          var _a, _b;
          const r = check2(data);
          if (r instanceof Promise) {
            return r.then((r2) => {
              var _a2, _b2;
              if (!r2) {
                const params = cleanParams(_params, data);
                const _fatal = (_b2 = (_a2 = params.fatal) !== null && _a2 !== void 0 ? _a2 : fatal) !== null && _b2 !== void 0 ? _b2 : true;
                ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
              }
            });
          }
          if (!r) {
            const params = cleanParams(_params, data);
            const _fatal = (_b = (_a = params.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;
            ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
          }
          return;
        });
      return ZodAny.create();
    }
    types$4.custom = custom;
    types$4.late = {
      object: ZodObject.lazycreate
    };
    var ZodFirstPartyTypeKind;
    (function(ZodFirstPartyTypeKind2) {
      ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
      ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
      ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
      ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
      ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
      ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
      ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
      ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
      ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
      ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
      ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
      ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
      ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
      ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
      ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
      ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
      ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
      ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
      ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
      ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
      ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
      ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
      ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
      ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
      ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
      ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
      ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
      ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
      ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
      ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
      ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
      ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
      ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
      ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
      ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
      ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
    })(ZodFirstPartyTypeKind || (types$4.ZodFirstPartyTypeKind = ZodFirstPartyTypeKind = {}));
    const instanceOfType = (cls, params = {
      message: `Input not instance of ${cls.name}`
    }) => custom((data) => data instanceof cls, params);
    types$4.instanceof = instanceOfType;
    const stringType = ZodString.create;
    types$4.string = stringType;
    const numberType = ZodNumber.create;
    types$4.number = numberType;
    const nanType = ZodNaN.create;
    types$4.nan = nanType;
    const bigIntType = ZodBigInt.create;
    types$4.bigint = bigIntType;
    const booleanType = ZodBoolean.create;
    types$4.boolean = booleanType;
    const dateType = ZodDate.create;
    types$4.date = dateType;
    const symbolType = ZodSymbol.create;
    types$4.symbol = symbolType;
    const undefinedType = ZodUndefined.create;
    types$4.undefined = undefinedType;
    const nullType = ZodNull.create;
    types$4.null = nullType;
    const anyType = ZodAny.create;
    types$4.any = anyType;
    const unknownType = ZodUnknown.create;
    types$4.unknown = unknownType;
    const neverType = ZodNever.create;
    types$4.never = neverType;
    const voidType = ZodVoid.create;
    types$4.void = voidType;
    const arrayType = ZodArray.create;
    types$4.array = arrayType;
    const objectType = ZodObject.create;
    types$4.object = objectType;
    const strictObjectType = ZodObject.strictCreate;
    types$4.strictObject = strictObjectType;
    const unionType = ZodUnion.create;
    types$4.union = unionType;
    const discriminatedUnionType = ZodDiscriminatedUnion.create;
    types$4.discriminatedUnion = discriminatedUnionType;
    const intersectionType = ZodIntersection.create;
    types$4.intersection = intersectionType;
    const tupleType = ZodTuple.create;
    types$4.tuple = tupleType;
    const recordType = ZodRecord.create;
    types$4.record = recordType;
    const mapType = ZodMap.create;
    types$4.map = mapType;
    const setType = ZodSet.create;
    types$4.set = setType;
    const functionType = ZodFunction.create;
    types$4.function = functionType;
    const lazyType = ZodLazy.create;
    types$4.lazy = lazyType;
    const literalType = ZodLiteral.create;
    types$4.literal = literalType;
    const enumType = ZodEnum.create;
    types$4.enum = enumType;
    const nativeEnumType = ZodNativeEnum.create;
    types$4.nativeEnum = nativeEnumType;
    const promiseType = ZodPromise.create;
    types$4.promise = promiseType;
    const effectsType = ZodEffects.create;
    types$4.effect = effectsType;
    types$4.transformer = effectsType;
    const optionalType = ZodOptional.create;
    types$4.optional = optionalType;
    const nullableType = ZodNullable.create;
    types$4.nullable = nullableType;
    const preprocessType = ZodEffects.createWithPreprocess;
    types$4.preprocess = preprocessType;
    const pipelineType = ZodPipeline.create;
    types$4.pipeline = pipelineType;
    const ostring = () => stringType().optional();
    types$4.ostring = ostring;
    const onumber = () => numberType().optional();
    types$4.onumber = onumber;
    const oboolean = () => booleanType().optional();
    types$4.oboolean = oboolean;
    types$4.coerce = {
      string: (arg) => ZodString.create({ ...arg, coerce: true }),
      number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
      boolean: (arg) => ZodBoolean.create({
        ...arg,
        coerce: true
      }),
      bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
      date: (arg) => ZodDate.create({ ...arg, coerce: true })
    };
    types$4.NEVER = parseUtil_1.INVALID;
    return types$4;
  }
  var hasRequiredExternal$1;
  function requireExternal$1() {
    if (hasRequiredExternal$1) return external$1;
    hasRequiredExternal$1 = 1;
    (function(exports) {
      var __createBinding = external$1 && external$1.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      });
      var __exportStar = external$1 && external$1.__exportStar || function(m, exports2) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      __exportStar(/* @__PURE__ */ requireErrors(), exports);
      __exportStar(/* @__PURE__ */ requireParseUtil(), exports);
      __exportStar(/* @__PURE__ */ requireTypeAliases(), exports);
      __exportStar(/* @__PURE__ */ requireUtil$8(), exports);
      __exportStar(/* @__PURE__ */ requireTypes$5(), exports);
      __exportStar(/* @__PURE__ */ requireZodError(), exports);
    })(external$1);
    return external$1;
  }
  var hasRequiredLib$1;
  function requireLib$1() {
    if (hasRequiredLib$1) return lib$1;
    hasRequiredLib$1 = 1;
    (function(exports) {
      var __createBinding = lib$1 && lib$1.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = lib$1 && lib$1.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = lib$1 && lib$1.__importStar || function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      var __exportStar = lib$1 && lib$1.__exportStar || function(m, exports2) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.z = void 0;
      const z = __importStar(/* @__PURE__ */ requireExternal$1());
      exports.z = z;
      __exportStar(/* @__PURE__ */ requireExternal$1(), exports);
      exports.default = z;
    })(lib$1);
    return lib$1;
  }
  var dist$3 = {};
  var handle = {};
  var hasRequiredHandle;
  function requireHandle() {
    if (hasRequiredHandle) return handle;
    hasRequiredHandle = 1;
    (function(exports) {
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DisallowedDomainError = exports.UnsupportedDomainError = exports.ReservedHandleError = exports.InvalidHandleError = exports.isValidTld = exports.isValidHandle = exports.normalizeAndEnsureValidHandle = exports.normalizeHandle = exports.ensureValidHandleRegex = exports.ensureValidHandle = exports.DISALLOWED_TLDS = exports.INVALID_HANDLE = void 0;
      exports.INVALID_HANDLE = "handle.invalid";
      exports.DISALLOWED_TLDS = [
        ".local",
        ".arpa",
        ".invalid",
        ".localhost",
        ".internal",
        ".example",
        ".alt",
        // policy could concievably change on ".onion" some day
        ".onion"
        // NOTE: .test is allowed in testing and devopment. In practical terms
        // "should" "never" actually resolve and get registered in production
      ];
      const ensureValidHandle = (handle2) => {
        if (!/^[a-zA-Z0-9.-]*$/.test(handle2)) {
          throw new InvalidHandleError("Disallowed characters in handle (ASCII letters, digits, dashes, periods only)");
        }
        if (handle2.length > 253) {
          throw new InvalidHandleError("Handle is too long (253 chars max)");
        }
        const labels2 = handle2.split(".");
        if (labels2.length < 2) {
          throw new InvalidHandleError("Handle domain needs at least two parts");
        }
        for (let i = 0; i < labels2.length; i++) {
          const l = labels2[i];
          if (l.length < 1) {
            throw new InvalidHandleError("Handle parts can not be empty");
          }
          if (l.length > 63) {
            throw new InvalidHandleError("Handle part too long (max 63 chars)");
          }
          if (l.endsWith("-") || l.startsWith("-")) {
            throw new InvalidHandleError("Handle parts can not start or end with hyphens");
          }
          if (i + 1 === labels2.length && !/^[a-zA-Z]/.test(l)) {
            throw new InvalidHandleError("Handle final component (TLD) must start with ASCII letter");
          }
        }
      };
      exports.ensureValidHandle = ensureValidHandle;
      const ensureValidHandleRegex = (handle2) => {
        if (!/^([a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?$/.test(handle2)) {
          throw new InvalidHandleError("Handle didn't validate via regex");
        }
        if (handle2.length > 253) {
          throw new InvalidHandleError("Handle is too long (253 chars max)");
        }
      };
      exports.ensureValidHandleRegex = ensureValidHandleRegex;
      const normalizeHandle = (handle2) => {
        return handle2.toLowerCase();
      };
      exports.normalizeHandle = normalizeHandle;
      const normalizeAndEnsureValidHandle = (handle2) => {
        const normalized = (0, exports.normalizeHandle)(handle2);
        (0, exports.ensureValidHandle)(normalized);
        return normalized;
      };
      exports.normalizeAndEnsureValidHandle = normalizeAndEnsureValidHandle;
      const isValidHandle = (handle2) => {
        try {
          (0, exports.ensureValidHandle)(handle2);
        } catch (err) {
          if (err instanceof InvalidHandleError) {
            return false;
          }
          throw err;
        }
        return true;
      };
      exports.isValidHandle = isValidHandle;
      const isValidTld = (handle2) => {
        return !exports.DISALLOWED_TLDS.some((domain) => handle2.endsWith(domain));
      };
      exports.isValidTld = isValidTld;
      class InvalidHandleError extends Error {
      }
      exports.InvalidHandleError = InvalidHandleError;
      class ReservedHandleError extends Error {
      }
      exports.ReservedHandleError = ReservedHandleError;
      class UnsupportedDomainError extends Error {
      }
      exports.UnsupportedDomainError = UnsupportedDomainError;
      class DisallowedDomainError extends Error {
      }
      exports.DisallowedDomainError = DisallowedDomainError;
    })(handle);
    return handle;
  }
  var did = {};
  var hasRequiredDid;
  function requireDid() {
    if (hasRequiredDid) return did;
    hasRequiredDid = 1;
    Object.defineProperty(did, "__esModule", { value: true });
    did.InvalidDidError = did.ensureValidDidRegex = did.ensureValidDid = void 0;
    const ensureValidDid = (did2) => {
      if (!did2.startsWith("did:")) {
        throw new InvalidDidError('DID requires "did:" prefix');
      }
      if (!/^[a-zA-Z0-9._:%-]*$/.test(did2)) {
        throw new InvalidDidError("Disallowed characters in DID (ASCII letters, digits, and a couple other characters only)");
      }
      const { length: length2, 1: method } = did2.split(":");
      if (length2 < 3) {
        throw new InvalidDidError("DID requires prefix, method, and method-specific content");
      }
      if (!/^[a-z]+$/.test(method)) {
        throw new InvalidDidError("DID method must be lower-case letters");
      }
      if (did2.endsWith(":") || did2.endsWith("%")) {
        throw new InvalidDidError('DID can not end with ":" or "%"');
      }
      if (did2.length > 2 * 1024) {
        throw new InvalidDidError("DID is too long (2048 chars max)");
      }
    };
    did.ensureValidDid = ensureValidDid;
    const ensureValidDidRegex = (did2) => {
      if (!/^did:[a-z]+:[a-zA-Z0-9._:%-]*[a-zA-Z0-9._-]$/.test(did2)) {
        throw new InvalidDidError("DID didn't validate via regex");
      }
      if (did2.length > 2 * 1024) {
        throw new InvalidDidError("DID is too long (2048 chars max)");
      }
    };
    did.ensureValidDidRegex = ensureValidDidRegex;
    class InvalidDidError extends Error {
    }
    did.InvalidDidError = InvalidDidError;
    return did;
  }
  var nsid = {};
  var hasRequiredNsid;
  function requireNsid() {
    if (hasRequiredNsid) return nsid;
    hasRequiredNsid = 1;
    (function(exports) {
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.InvalidNsidError = exports.ensureValidNsidRegex = exports.ensureValidNsid = exports.NSID = void 0;
      class NSID {
        static parse(nsid2) {
          return new NSID(nsid2);
        }
        static create(authority, name) {
          const segments = [...authority.split(".").reverse(), name].join(".");
          return new NSID(segments);
        }
        static isValid(nsid2) {
          try {
            NSID.parse(nsid2);
            return true;
          } catch (e) {
            return false;
          }
        }
        constructor(nsid2) {
          Object.defineProperty(this, "segments", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
          });
          (0, exports.ensureValidNsid)(nsid2);
          this.segments = nsid2.split(".");
        }
        get authority() {
          return this.segments.slice(0, this.segments.length - 1).reverse().join(".");
        }
        get name() {
          return this.segments.at(this.segments.length - 1);
        }
        toString() {
          return this.segments.join(".");
        }
      }
      exports.NSID = NSID;
      const ensureValidNsid = (nsid2) => {
        const toCheck = nsid2;
        if (!/^[a-zA-Z0-9.-]*$/.test(toCheck)) {
          throw new InvalidNsidError("Disallowed characters in NSID (ASCII letters, digits, dashes, periods only)");
        }
        if (toCheck.length > 253 + 1 + 63) {
          throw new InvalidNsidError("NSID is too long (317 chars max)");
        }
        const labels2 = toCheck.split(".");
        if (labels2.length < 3) {
          throw new InvalidNsidError("NSID needs at least three parts");
        }
        for (let i = 0; i < labels2.length; i++) {
          const l = labels2[i];
          if (l.length < 1) {
            throw new InvalidNsidError("NSID parts can not be empty");
          }
          if (l.length > 63) {
            throw new InvalidNsidError("NSID part too long (max 63 chars)");
          }
          if (l.endsWith("-") || l.startsWith("-")) {
            throw new InvalidNsidError("NSID parts can not start or end with hyphen");
          }
          if (/^[0-9]/.test(l) && i === 0) {
            throw new InvalidNsidError("NSID first part may not start with a digit");
          }
          if (!/^[a-zA-Z]+$/.test(l) && i + 1 === labels2.length) {
            throw new InvalidNsidError("NSID name part must be only letters");
          }
        }
      };
      exports.ensureValidNsid = ensureValidNsid;
      const ensureValidNsidRegex = (nsid2) => {
        if (!/^[a-zA-Z]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(\.[a-zA-Z]([a-zA-Z]{0,61}[a-zA-Z])?)$/.test(nsid2)) {
          throw new InvalidNsidError("NSID didn't validate via regex");
        }
        if (nsid2.length > 253 + 1 + 63) {
          throw new InvalidNsidError("NSID is too long (317 chars max)");
        }
      };
      exports.ensureValidNsidRegex = ensureValidNsidRegex;
      class InvalidNsidError extends Error {
      }
      exports.InvalidNsidError = InvalidNsidError;
    })(nsid);
    return nsid;
  }
  var aturi = {};
  var aturi_validation = {};
  var hasRequiredAturi_validation;
  function requireAturi_validation() {
    if (hasRequiredAturi_validation) return aturi_validation;
    hasRequiredAturi_validation = 1;
    Object.defineProperty(aturi_validation, "__esModule", { value: true });
    aturi_validation.ensureValidAtUriRegex = aturi_validation.ensureValidAtUri = void 0;
    const did_1 = requireDid();
    const handle_1 = requireHandle();
    const nsid_1 = requireNsid();
    const ensureValidAtUri = (uri) => {
      const uriParts = uri.split("#");
      if (uriParts.length > 2) {
        throw new Error('ATURI can have at most one "#", separating fragment out');
      }
      const fragmentPart = uriParts[1] || null;
      uri = uriParts[0];
      if (!/^[a-zA-Z0-9._~:@!$&')(*+,;=%/-]*$/.test(uri)) {
        throw new Error("Disallowed characters in ATURI (ASCII)");
      }
      const parts = uri.split("/");
      if (parts.length >= 3 && (parts[0] !== "at:" || parts[1].length !== 0)) {
        throw new Error('ATURI must start with "at://"');
      }
      if (parts.length < 3) {
        throw new Error("ATURI requires at least method and authority sections");
      }
      try {
        if (parts[2].startsWith("did:")) {
          (0, did_1.ensureValidDid)(parts[2]);
        } else {
          (0, handle_1.ensureValidHandle)(parts[2]);
        }
      } catch {
        throw new Error("ATURI authority must be a valid handle or DID");
      }
      if (parts.length >= 4) {
        if (parts[3].length === 0) {
          throw new Error("ATURI can not have a slash after authority without a path segment");
        }
        try {
          (0, nsid_1.ensureValidNsid)(parts[3]);
        } catch {
          throw new Error("ATURI requires first path segment (if supplied) to be valid NSID");
        }
      }
      if (parts.length >= 5) {
        if (parts[4].length === 0) {
          throw new Error("ATURI can not have a slash after collection, unless record key is provided");
        }
      }
      if (parts.length >= 6) {
        throw new Error("ATURI path can have at most two parts, and no trailing slash");
      }
      if (uriParts.length >= 2 && fragmentPart == null) {
        throw new Error("ATURI fragment must be non-empty and start with slash");
      }
      if (fragmentPart != null) {
        if (fragmentPart.length === 0 || fragmentPart[0] !== "/") {
          throw new Error("ATURI fragment must be non-empty and start with slash");
        }
        if (!/^\/[a-zA-Z0-9._~:@!$&')(*+,;=%[\]/-]*$/.test(fragmentPart)) {
          throw new Error("Disallowed characters in ATURI fragment (ASCII)");
        }
      }
      if (uri.length > 8 * 1024) {
        throw new Error("ATURI is far too long");
      }
    };
    aturi_validation.ensureValidAtUri = ensureValidAtUri;
    const ensureValidAtUriRegex = (uri) => {
      const aturiRegex = /^at:\/\/(?<authority>[a-zA-Z0-9._:%-]+)(\/(?<collection>[a-zA-Z0-9-.]+)(\/(?<rkey>[a-zA-Z0-9._~:@!$&%')(*+,;=-]+))?)?(#(?<fragment>\/[a-zA-Z0-9._~:@!$&%')(*+,;=\-[\]/\\]*))?$/;
      const rm = uri.match(aturiRegex);
      if (!rm || !rm.groups) {
        throw new Error("ATURI didn't validate via regex");
      }
      const groups = rm.groups;
      try {
        (0, handle_1.ensureValidHandleRegex)(groups.authority);
      } catch {
        try {
          (0, did_1.ensureValidDidRegex)(groups.authority);
        } catch {
          throw new Error("ATURI authority must be a valid handle or DID");
        }
      }
      if (groups.collection) {
        try {
          (0, nsid_1.ensureValidNsidRegex)(groups.collection);
        } catch {
          throw new Error("ATURI collection path segment must be a valid NSID");
        }
      }
      if (uri.length > 8 * 1024) {
        throw new Error("ATURI is far too long");
      }
    };
    aturi_validation.ensureValidAtUriRegex = ensureValidAtUriRegex;
    return aturi_validation;
  }
  var hasRequiredAturi;
  function requireAturi() {
    if (hasRequiredAturi) return aturi;
    hasRequiredAturi = 1;
    (function(exports) {
      var __createBinding = aturi && aturi.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      });
      var __exportStar = aturi && aturi.__exportStar || function(m, exports2) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.AtUri = exports.ATP_URI_REGEX = void 0;
      __exportStar(requireAturi_validation(), exports);
      exports.ATP_URI_REGEX = // proto-    --did--------------   --name----------------   --path----   --query--   --hash--
      /^(at:\/\/)?((?:did:[a-z0-9:%-]+)|(?:[a-z0-9][a-z0-9.:-]*))(\/[^?#\s]*)?(\?[^#\s]+)?(#[^\s]+)?$/i;
      const RELATIVE_REGEX = /^(\/[^?#\s]*)?(\?[^#\s]+)?(#[^\s]+)?$/i;
      class AtUri {
        constructor(uri, base3) {
          Object.defineProperty(this, "hash", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "host", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "pathname", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "searchParams", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          let parsed;
          if (base3) {
            parsed = parse(base3);
            if (!parsed) {
              throw new Error(`Invalid at uri: ${base3}`);
            }
            const relativep = parseRelative(uri);
            if (!relativep) {
              throw new Error(`Invalid path: ${uri}`);
            }
            Object.assign(parsed, relativep);
          } else {
            parsed = parse(uri);
            if (!parsed) {
              throw new Error(`Invalid at uri: ${uri}`);
            }
          }
          this.hash = parsed.hash;
          this.host = parsed.host;
          this.pathname = parsed.pathname;
          this.searchParams = parsed.searchParams;
        }
        static make(handleOrDid, collection, rkey) {
          let str = handleOrDid;
          if (collection)
            str += "/" + collection;
          if (rkey)
            str += "/" + rkey;
          return new AtUri(str);
        }
        get protocol() {
          return "at:";
        }
        get origin() {
          return `at://${this.host}`;
        }
        get hostname() {
          return this.host;
        }
        set hostname(v) {
          this.host = v;
        }
        get search() {
          return this.searchParams.toString();
        }
        set search(v) {
          this.searchParams = new URLSearchParams(v);
        }
        get collection() {
          return this.pathname.split("/").filter(Boolean)[0] || "";
        }
        set collection(v) {
          const parts = this.pathname.split("/").filter(Boolean);
          parts[0] = v;
          this.pathname = parts.join("/");
        }
        get rkey() {
          return this.pathname.split("/").filter(Boolean)[1] || "";
        }
        set rkey(v) {
          const parts = this.pathname.split("/").filter(Boolean);
          if (!parts[0])
            parts[0] = "undefined";
          parts[1] = v;
          this.pathname = parts.join("/");
        }
        get href() {
          return this.toString();
        }
        toString() {
          let path = this.pathname || "/";
          if (!path.startsWith("/")) {
            path = `/${path}`;
          }
          let qs = this.searchParams.toString();
          if (qs && !qs.startsWith("?")) {
            qs = `?${qs}`;
          }
          let hash = this.hash;
          if (hash && !hash.startsWith("#")) {
            hash = `#${hash}`;
          }
          return `at://${this.host}${path}${qs}${hash}`;
        }
      }
      exports.AtUri = AtUri;
      function parse(str) {
        const match2 = exports.ATP_URI_REGEX.exec(str);
        if (match2) {
          return {
            hash: match2[5] || "",
            host: match2[2] || "",
            pathname: match2[3] || "",
            searchParams: new URLSearchParams(match2[4] || "")
          };
        }
        return void 0;
      }
      function parseRelative(str) {
        const match2 = RELATIVE_REGEX.exec(str);
        if (match2) {
          return {
            hash: match2[3] || "",
            pathname: match2[1] || "",
            searchParams: new URLSearchParams(match2[2] || "")
          };
        }
        return void 0;
      }
    })(aturi);
    return aturi;
  }
  var tid$1 = {};
  var hasRequiredTid$1;
  function requireTid$1() {
    if (hasRequiredTid$1) return tid$1;
    hasRequiredTid$1 = 1;
    Object.defineProperty(tid$1, "__esModule", { value: true });
    tid$1.InvalidTidError = tid$1.isValidTid = tid$1.ensureValidTid = void 0;
    const TID_LENGTH = 13;
    const TID_REGEX = /^[234567abcdefghij][234567abcdefghijklmnopqrstuvwxyz]{12}$/;
    const ensureValidTid = (tid2) => {
      if (tid2.length !== TID_LENGTH) {
        throw new InvalidTidError(`TID must be ${TID_LENGTH} characters`);
      }
      if (!TID_REGEX.test(tid2)) {
        throw new InvalidTidError("TID syntax not valid (regex)");
      }
    };
    tid$1.ensureValidTid = ensureValidTid;
    const isValidTid = (tid2) => {
      return tid2.length === TID_LENGTH && TID_REGEX.test(tid2);
    };
    tid$1.isValidTid = isValidTid;
    class InvalidTidError extends Error {
    }
    tid$1.InvalidTidError = InvalidTidError;
    return tid$1;
  }
  var recordkey = {};
  var hasRequiredRecordkey;
  function requireRecordkey() {
    if (hasRequiredRecordkey) return recordkey;
    hasRequiredRecordkey = 1;
    (function(exports) {
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.InvalidRecordKeyError = exports.isValidRecordKey = exports.ensureValidRecordKey = void 0;
      const ensureValidRecordKey = (rkey) => {
        if (rkey.length > 512 || rkey.length < 1) {
          throw new InvalidRecordKeyError("record key must be 1 to 512 characters");
        }
        if (!/^[a-zA-Z0-9_~.:-]{1,512}$/.test(rkey)) {
          throw new InvalidRecordKeyError("record key syntax not valid (regex)");
        }
        if (rkey === "." || rkey === "..")
          throw new InvalidRecordKeyError('record key can not be "." or ".."');
      };
      exports.ensureValidRecordKey = ensureValidRecordKey;
      const isValidRecordKey = (rkey) => {
        try {
          (0, exports.ensureValidRecordKey)(rkey);
        } catch (err) {
          if (err instanceof InvalidRecordKeyError) {
            return false;
          }
          throw err;
        }
        return true;
      };
      exports.isValidRecordKey = isValidRecordKey;
      class InvalidRecordKeyError extends Error {
      }
      exports.InvalidRecordKeyError = InvalidRecordKeyError;
    })(recordkey);
    return recordkey;
  }
  var datetime = {};
  var hasRequiredDatetime;
  function requireDatetime() {
    if (hasRequiredDatetime) return datetime;
    hasRequiredDatetime = 1;
    (function(exports) {
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.InvalidDatetimeError = exports.normalizeDatetimeAlways = exports.normalizeDatetime = exports.isValidDatetime = exports.ensureValidDatetime = void 0;
      const ensureValidDatetime = (dtStr) => {
        const date = new Date(dtStr);
        if (isNaN(date.getTime())) {
          throw new InvalidDatetimeError("datetime did not parse as ISO 8601");
        }
        if (date.toISOString().startsWith("-")) {
          throw new InvalidDatetimeError("datetime normalized to a negative time");
        }
        if (!/^[0-9]{4}-[01][0-9]-[0-3][0-9]T[0-2][0-9]:[0-6][0-9]:[0-6][0-9](.[0-9]{1,20})?(Z|([+-][0-2][0-9]:[0-5][0-9]))$/.test(dtStr)) {
          throw new InvalidDatetimeError("datetime didn't validate via regex");
        }
        if (dtStr.length > 64) {
          throw new InvalidDatetimeError("datetime is too long (64 chars max)");
        }
        if (dtStr.endsWith("-00:00")) {
          throw new InvalidDatetimeError('datetime can not use "-00:00" for UTC timezone');
        }
        if (dtStr.startsWith("000")) {
          throw new InvalidDatetimeError("datetime so close to year zero not allowed");
        }
      };
      exports.ensureValidDatetime = ensureValidDatetime;
      const isValidDatetime = (dtStr) => {
        try {
          (0, exports.ensureValidDatetime)(dtStr);
        } catch (err) {
          if (err instanceof InvalidDatetimeError) {
            return false;
          }
          throw err;
        }
        return true;
      };
      exports.isValidDatetime = isValidDatetime;
      const normalizeDatetime = (dtStr) => {
        if ((0, exports.isValidDatetime)(dtStr)) {
          const outStr = new Date(dtStr).toISOString();
          if ((0, exports.isValidDatetime)(outStr)) {
            return outStr;
          }
        }
        if (!/.*(([+-]\d\d:?\d\d)|[a-zA-Z])$/.test(dtStr)) {
          const date2 = /* @__PURE__ */ new Date(dtStr + "Z");
          if (!isNaN(date2.getTime())) {
            const tzStr = date2.toISOString();
            if ((0, exports.isValidDatetime)(tzStr)) {
              return tzStr;
            }
          }
        }
        const date = new Date(dtStr);
        if (isNaN(date.getTime())) {
          throw new InvalidDatetimeError("datetime did not parse as any timestamp format");
        }
        const isoStr = date.toISOString();
        if ((0, exports.isValidDatetime)(isoStr)) {
          return isoStr;
        } else {
          throw new InvalidDatetimeError("datetime normalized to invalid timestamp string");
        }
      };
      exports.normalizeDatetime = normalizeDatetime;
      const normalizeDatetimeAlways = (dtStr) => {
        try {
          return (0, exports.normalizeDatetime)(dtStr);
        } catch (err) {
          if (err instanceof InvalidDatetimeError) {
            return (/* @__PURE__ */ new Date(0)).toISOString();
          }
          throw err;
        }
      };
      exports.normalizeDatetimeAlways = normalizeDatetimeAlways;
      class InvalidDatetimeError extends Error {
      }
      exports.InvalidDatetimeError = InvalidDatetimeError;
    })(datetime);
    return datetime;
  }
  var hasRequiredDist$5;
  function requireDist$5() {
    if (hasRequiredDist$5) return dist$3;
    hasRequiredDist$5 = 1;
    (function(exports) {
      var __createBinding = dist$3 && dist$3.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      });
      var __exportStar = dist$3 && dist$3.__exportStar || function(m, exports2) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      __exportStar(requireHandle(), exports);
      __exportStar(requireDid(), exports);
      __exportStar(requireNsid(), exports);
      __exportStar(requireAturi(), exports);
      __exportStar(requireTid$1(), exports);
      __exportStar(requireRecordkey(), exports);
      __exportStar(requireDatetime(), exports);
    })(dist$3);
    return dist$3;
  }
  var util$7 = {};
  var hasRequiredUtil$7;
  function requireUtil$7() {
    if (hasRequiredUtil$7) return util$7;
    hasRequiredUtil$7 = 1;
    Object.defineProperty(util$7, "__esModule", { value: true });
    util$7.toLexUri = toLexUri;
    util$7.requiredPropertiesRefinement = requiredPropertiesRefinement;
    const zod_1 = /* @__PURE__ */ requireLib$1();
    function toLexUri(str, baseUri) {
      if (str.split("#").length > 2) {
        throw new Error("Uri can only have one hash segment");
      }
      if (str.startsWith("lex:")) {
        return str;
      }
      if (str.startsWith("#")) {
        if (!baseUri) {
          throw new Error(`Unable to resolve uri without anchor: ${str}`);
        }
        return `${baseUri}${str}`;
      }
      return `lex:${str}`;
    }
    function requiredPropertiesRefinement(object, ctx) {
      if (object.required === void 0) {
        return;
      }
      if (!Array.isArray(object.required)) {
        ctx.addIssue({
          code: zod_1.z.ZodIssueCode.invalid_type,
          received: typeof object.required,
          expected: "array"
        });
        return;
      }
      if (object.properties === void 0) {
        if (object.required.length > 0) {
          ctx.addIssue({
            code: zod_1.z.ZodIssueCode.custom,
            message: `Required fields defined but no properties defined`
          });
        }
        return;
      }
      for (const field of object.required) {
        if (object.properties[field] === void 0) {
          ctx.addIssue({
            code: zod_1.z.ZodIssueCode.custom,
            message: `Required field "${field}" not defined`
          });
        }
      }
    }
    return util$7;
  }
  var hasRequiredTypes$4;
  function requireTypes$4() {
    if (hasRequiredTypes$4) return types$5;
    hasRequiredTypes$4 = 1;
    (function(exports) {
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.LexiconDefNotFoundError = exports.InvalidLexiconError = exports.ValidationError = exports.lexiconDoc = exports.lexUserType = exports.lexRecord = exports.lexXrpcSubscription = exports.lexXrpcProcedure = exports.lexXrpcQuery = exports.lexXrpcError = exports.lexXrpcSubscriptionMessage = exports.lexXrpcBody = exports.lexXrpcParameters = exports.lexObject = exports.lexToken = exports.lexPrimitiveArray = exports.lexArray = exports.lexBlob = exports.lexRefVariant = exports.lexRefUnion = exports.lexRef = exports.lexIpldType = exports.lexCidLink = exports.lexBytes = exports.lexPrimitive = exports.lexUnknown = exports.lexString = exports.lexStringFormat = exports.lexInteger = exports.lexBoolean = void 0;
      exports.isValidLexiconDoc = isValidLexiconDoc;
      exports.isObj = isObj;
      exports.isDiscriminatedObject = isDiscriminatedObject;
      exports.parseLexiconDoc = parseLexiconDoc;
      const zod_1 = /* @__PURE__ */ requireLib$1();
      const syntax_1 = requireDist$5();
      const util_1 = requireUtil$7();
      exports.lexBoolean = zod_1.z.object({
        type: zod_1.z.literal("boolean"),
        description: zod_1.z.string().optional(),
        default: zod_1.z.boolean().optional(),
        const: zod_1.z.boolean().optional()
      }).strict();
      exports.lexInteger = zod_1.z.object({
        type: zod_1.z.literal("integer"),
        description: zod_1.z.string().optional(),
        default: zod_1.z.number().int().optional(),
        minimum: zod_1.z.number().int().optional(),
        maximum: zod_1.z.number().int().optional(),
        enum: zod_1.z.number().int().array().optional(),
        const: zod_1.z.number().int().optional()
      }).strict();
      exports.lexStringFormat = zod_1.z.enum([
        "datetime",
        "uri",
        "at-uri",
        "did",
        "handle",
        "at-identifier",
        "nsid",
        "cid",
        "language",
        "tid",
        "record-key"
      ]);
      exports.lexString = zod_1.z.object({
        type: zod_1.z.literal("string"),
        format: exports.lexStringFormat.optional(),
        description: zod_1.z.string().optional(),
        default: zod_1.z.string().optional(),
        minLength: zod_1.z.number().int().optional(),
        maxLength: zod_1.z.number().int().optional(),
        minGraphemes: zod_1.z.number().int().optional(),
        maxGraphemes: zod_1.z.number().int().optional(),
        enum: zod_1.z.string().array().optional(),
        const: zod_1.z.string().optional(),
        knownValues: zod_1.z.string().array().optional()
      }).strict();
      exports.lexUnknown = zod_1.z.object({
        type: zod_1.z.literal("unknown"),
        description: zod_1.z.string().optional()
      }).strict();
      exports.lexPrimitive = zod_1.z.discriminatedUnion("type", [
        exports.lexBoolean,
        exports.lexInteger,
        exports.lexString,
        exports.lexUnknown
      ]);
      exports.lexBytes = zod_1.z.object({
        type: zod_1.z.literal("bytes"),
        description: zod_1.z.string().optional(),
        maxLength: zod_1.z.number().optional(),
        minLength: zod_1.z.number().optional()
      }).strict();
      exports.lexCidLink = zod_1.z.object({
        type: zod_1.z.literal("cid-link"),
        description: zod_1.z.string().optional()
      }).strict();
      exports.lexIpldType = zod_1.z.discriminatedUnion("type", [exports.lexBytes, exports.lexCidLink]);
      exports.lexRef = zod_1.z.object({
        type: zod_1.z.literal("ref"),
        description: zod_1.z.string().optional(),
        ref: zod_1.z.string()
      }).strict();
      exports.lexRefUnion = zod_1.z.object({
        type: zod_1.z.literal("union"),
        description: zod_1.z.string().optional(),
        refs: zod_1.z.string().array(),
        closed: zod_1.z.boolean().optional()
      }).strict();
      exports.lexRefVariant = zod_1.z.discriminatedUnion("type", [exports.lexRef, exports.lexRefUnion]);
      exports.lexBlob = zod_1.z.object({
        type: zod_1.z.literal("blob"),
        description: zod_1.z.string().optional(),
        accept: zod_1.z.string().array().optional(),
        maxSize: zod_1.z.number().optional()
      }).strict();
      exports.lexArray = zod_1.z.object({
        type: zod_1.z.literal("array"),
        description: zod_1.z.string().optional(),
        items: zod_1.z.discriminatedUnion("type", [
          // lexPrimitive
          exports.lexBoolean,
          exports.lexInteger,
          exports.lexString,
          exports.lexUnknown,
          // lexIpldType
          exports.lexBytes,
          exports.lexCidLink,
          // lexRefVariant
          exports.lexRef,
          exports.lexRefUnion,
          // other
          exports.lexBlob
        ]),
        minLength: zod_1.z.number().int().optional(),
        maxLength: zod_1.z.number().int().optional()
      }).strict();
      exports.lexPrimitiveArray = exports.lexArray.merge(zod_1.z.object({
        items: exports.lexPrimitive
      }).strict());
      exports.lexToken = zod_1.z.object({
        type: zod_1.z.literal("token"),
        description: zod_1.z.string().optional()
      }).strict();
      exports.lexObject = zod_1.z.object({
        type: zod_1.z.literal("object"),
        description: zod_1.z.string().optional(),
        required: zod_1.z.string().array().optional(),
        nullable: zod_1.z.string().array().optional(),
        properties: zod_1.z.record(zod_1.z.discriminatedUnion("type", [
          exports.lexArray,
          // lexPrimitive
          exports.lexBoolean,
          exports.lexInteger,
          exports.lexString,
          exports.lexUnknown,
          // lexIpldType
          exports.lexBytes,
          exports.lexCidLink,
          // lexRefVariant
          exports.lexRef,
          exports.lexRefUnion,
          // other
          exports.lexBlob
        ]))
      }).strict().superRefine(util_1.requiredPropertiesRefinement);
      exports.lexXrpcParameters = zod_1.z.object({
        type: zod_1.z.literal("params"),
        description: zod_1.z.string().optional(),
        required: zod_1.z.string().array().optional(),
        properties: zod_1.z.record(zod_1.z.discriminatedUnion("type", [
          exports.lexPrimitiveArray,
          // lexPrimitive
          exports.lexBoolean,
          exports.lexInteger,
          exports.lexString,
          exports.lexUnknown
        ]))
      }).strict().superRefine(util_1.requiredPropertiesRefinement);
      exports.lexXrpcBody = zod_1.z.object({
        description: zod_1.z.string().optional(),
        encoding: zod_1.z.string(),
        // @NOTE using discriminatedUnion with a refined schema requires zod >= 4
        schema: zod_1.z.union([exports.lexRefVariant, exports.lexObject]).optional()
      }).strict();
      exports.lexXrpcSubscriptionMessage = zod_1.z.object({
        description: zod_1.z.string().optional(),
        // @NOTE using discriminatedUnion with a refined schema requires zod >= 4
        schema: zod_1.z.union([exports.lexRefVariant, exports.lexObject]).optional()
      }).strict();
      exports.lexXrpcError = zod_1.z.object({
        name: zod_1.z.string(),
        description: zod_1.z.string().optional()
      }).strict();
      exports.lexXrpcQuery = zod_1.z.object({
        type: zod_1.z.literal("query"),
        description: zod_1.z.string().optional(),
        parameters: exports.lexXrpcParameters.optional(),
        output: exports.lexXrpcBody.optional(),
        errors: exports.lexXrpcError.array().optional()
      }).strict();
      exports.lexXrpcProcedure = zod_1.z.object({
        type: zod_1.z.literal("procedure"),
        description: zod_1.z.string().optional(),
        parameters: exports.lexXrpcParameters.optional(),
        input: exports.lexXrpcBody.optional(),
        output: exports.lexXrpcBody.optional(),
        errors: exports.lexXrpcError.array().optional()
      }).strict();
      exports.lexXrpcSubscription = zod_1.z.object({
        type: zod_1.z.literal("subscription"),
        description: zod_1.z.string().optional(),
        parameters: exports.lexXrpcParameters.optional(),
        message: exports.lexXrpcSubscriptionMessage.optional(),
        errors: exports.lexXrpcError.array().optional()
      }).strict();
      exports.lexRecord = zod_1.z.object({
        type: zod_1.z.literal("record"),
        description: zod_1.z.string().optional(),
        key: zod_1.z.string().optional(),
        record: exports.lexObject
      }).strict();
      exports.lexUserType = zod_1.z.custom((val) => {
        if (!val || typeof val !== "object") {
          return;
        }
        if (val["type"] === void 0) {
          return;
        }
        switch (val["type"]) {
          case "record":
            return exports.lexRecord.parse(val);
          case "query":
            return exports.lexXrpcQuery.parse(val);
          case "procedure":
            return exports.lexXrpcProcedure.parse(val);
          case "subscription":
            return exports.lexXrpcSubscription.parse(val);
          case "blob":
            return exports.lexBlob.parse(val);
          case "array":
            return exports.lexArray.parse(val);
          case "token":
            return exports.lexToken.parse(val);
          case "object":
            return exports.lexObject.parse(val);
          case "boolean":
            return exports.lexBoolean.parse(val);
          case "integer":
            return exports.lexInteger.parse(val);
          case "string":
            return exports.lexString.parse(val);
          case "bytes":
            return exports.lexBytes.parse(val);
          case "cid-link":
            return exports.lexCidLink.parse(val);
          case "unknown":
            return exports.lexUnknown.parse(val);
        }
      }, (val) => {
        if (!val || typeof val !== "object") {
          return {
            message: "Must be an object",
            fatal: true
          };
        }
        if (val["type"] === void 0) {
          return {
            message: "Must have a type",
            fatal: true
          };
        }
        if (typeof val["type"] !== "string") {
          return {
            message: "Type property must be a string",
            fatal: true
          };
        }
        return {
          message: `Invalid type: ${val["type"]} must be one of: record, query, procedure, subscription, blob, array, token, object, boolean, integer, string, bytes, cid-link, unknown`,
          fatal: true
        };
      });
      exports.lexiconDoc = zod_1.z.object({
        lexicon: zod_1.z.literal(1),
        id: zod_1.z.string().refine((v) => syntax_1.NSID.isValid(v), {
          message: "Must be a valid NSID"
        }),
        revision: zod_1.z.number().optional(),
        description: zod_1.z.string().optional(),
        defs: zod_1.z.record(exports.lexUserType)
      }).strict().superRefine((doc, ctx) => {
        for (const defId in doc.defs) {
          const def = doc.defs[defId];
          if (defId !== "main" && (def.type === "record" || def.type === "procedure" || def.type === "query" || def.type === "subscription")) {
            ctx.addIssue({
              code: zod_1.z.ZodIssueCode.custom,
              message: `Records, procedures, queries, and subscriptions must be the main definition.`
            });
          }
        }
      });
      function isValidLexiconDoc(v) {
        return exports.lexiconDoc.safeParse(v).success;
      }
      function isObj(v) {
        return v != null && typeof v === "object";
      }
      function isDiscriminatedObject(v) {
        return isObj(v) && "$type" in v && typeof v.$type === "string";
      }
      function parseLexiconDoc(v) {
        exports.lexiconDoc.parse(v);
        return v;
      }
      class ValidationError extends Error {
      }
      exports.ValidationError = ValidationError;
      class InvalidLexiconError extends Error {
      }
      exports.InvalidLexiconError = InvalidLexiconError;
      class LexiconDefNotFoundError extends Error {
      }
      exports.LexiconDefNotFoundError = LexiconDefNotFoundError;
    })(types$5);
    return types$5;
  }
  var lexicons$1 = {};
  var validation = {};
  var complex = {};
  var blob = {};
  var blobRefs = {};
  var encode_1 = encode$2;
  var MSB = 128, MSBALL = -128, INT = Math.pow(2, 31);
  function encode$2(num, out, offset) {
    out = out || [];
    offset = offset || 0;
    var oldOffset = offset;
    while (num >= INT) {
      out[offset++] = num & 255 | MSB;
      num /= 128;
    }
    while (num & MSBALL) {
      out[offset++] = num & 255 | MSB;
      num >>>= 7;
    }
    out[offset] = num | 0;
    encode$2.bytes = offset - oldOffset + 1;
    return out;
  }
  var decode$4 = read;
  var MSB$1 = 128, REST$1 = 127;
  function read(buf, offset) {
    var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;
    do {
      if (counter >= l) {
        read.bytes = 0;
        throw new RangeError("Could not decode varint");
      }
      b = buf[counter++];
      res += shift < 28 ? (b & REST$1) << shift : (b & REST$1) * Math.pow(2, shift);
      shift += 7;
    } while (b >= MSB$1);
    read.bytes = counter - offset;
    return res;
  }
  var N1 = Math.pow(2, 7);
  var N2 = Math.pow(2, 14);
  var N3 = Math.pow(2, 21);
  var N4 = Math.pow(2, 28);
  var N5 = Math.pow(2, 35);
  var N6 = Math.pow(2, 42);
  var N7 = Math.pow(2, 49);
  var N8 = Math.pow(2, 56);
  var N9 = Math.pow(2, 63);
  var length = function(value) {
    return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
  };
  var varint = {
    encode: encode_1,
    decode: decode$4,
    encodingLength: length
  };
  var _brrp_varint = varint;
  const decode$3 = (data, offset = 0) => {
    const code = _brrp_varint.decode(data, offset);
    return [
      code,
      _brrp_varint.decode.bytes
    ];
  };
  const encodeTo = (int, target2, offset = 0) => {
    _brrp_varint.encode(int, target2, offset);
    return target2;
  };
  const encodingLength = (int) => {
    return _brrp_varint.encodingLength(int);
  };
  const equals$2 = (aa, bb) => {
    if (aa === bb)
      return true;
    if (aa.byteLength !== bb.byteLength) {
      return false;
    }
    for (let ii = 0; ii < aa.byteLength; ii++) {
      if (aa[ii] !== bb[ii]) {
        return false;
      }
    }
    return true;
  };
  const coerce = (o) => {
    if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
      return o;
    if (o instanceof ArrayBuffer)
      return new Uint8Array(o);
    if (ArrayBuffer.isView(o)) {
      return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
    }
    throw new Error("Unknown type, must be binary type");
  };
  const fromString$1 = (str) => new TextEncoder().encode(str);
  const toString$1 = (b) => new TextDecoder().decode(b);
  const create = (code, digest) => {
    const size = digest.byteLength;
    const sizeOffset = encodingLength(code);
    const digestOffset = sizeOffset + encodingLength(size);
    const bytes = new Uint8Array(digestOffset + size);
    encodeTo(code, bytes, 0);
    encodeTo(size, bytes, sizeOffset);
    bytes.set(digest, digestOffset);
    return new Digest(code, size, digest, bytes);
  };
  const decode$2 = (multihash) => {
    const bytes = coerce(multihash);
    const [code, sizeOffset] = decode$3(bytes);
    const [size, digestOffset] = decode$3(bytes.subarray(sizeOffset));
    const digest = bytes.subarray(sizeOffset + digestOffset);
    if (digest.byteLength !== size) {
      throw new Error("Incorrect length");
    }
    return new Digest(code, size, digest, bytes);
  };
  const equals$1 = (a, b) => {
    if (a === b) {
      return true;
    } else {
      return a.code === b.code && a.size === b.size && equals$2(a.bytes, b.bytes);
    }
  };
  class Digest {
    constructor(code, size, digest, bytes) {
      this.code = code;
      this.size = size;
      this.digest = digest;
      this.bytes = bytes;
    }
  }
  function base$2(ALPHABET, name) {
    if (ALPHABET.length >= 255) {
      throw new TypeError("Alphabet too long");
    }
    var BASE_MAP = new Uint8Array(256);
    for (var j = 0; j < BASE_MAP.length; j++) {
      BASE_MAP[j] = 255;
    }
    for (var i = 0; i < ALPHABET.length; i++) {
      var x = ALPHABET.charAt(i);
      var xc = x.charCodeAt(0);
      if (BASE_MAP[xc] !== 255) {
        throw new TypeError(x + " is ambiguous");
      }
      BASE_MAP[xc] = i;
    }
    var BASE = ALPHABET.length;
    var LEADER = ALPHABET.charAt(0);
    var FACTOR = Math.log(BASE) / Math.log(256);
    var iFACTOR = Math.log(256) / Math.log(BASE);
    function encode2(source) {
      if (source instanceof Uint8Array) ;
      else if (ArrayBuffer.isView(source)) {
        source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
      } else if (Array.isArray(source)) {
        source = Uint8Array.from(source);
      }
      if (!(source instanceof Uint8Array)) {
        throw new TypeError("Expected Uint8Array");
      }
      if (source.length === 0) {
        return "";
      }
      var zeroes = 0;
      var length2 = 0;
      var pbegin = 0;
      var pend = source.length;
      while (pbegin !== pend && source[pbegin] === 0) {
        pbegin++;
        zeroes++;
      }
      var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
      var b58 = new Uint8Array(size);
      while (pbegin !== pend) {
        var carry = source[pbegin];
        var i2 = 0;
        for (var it1 = size - 1; (carry !== 0 || i2 < length2) && it1 !== -1; it1--, i2++) {
          carry += 256 * b58[it1] >>> 0;
          b58[it1] = carry % BASE >>> 0;
          carry = carry / BASE >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length2 = i2;
        pbegin++;
      }
      var it2 = size - length2;
      while (it2 !== size && b58[it2] === 0) {
        it2++;
      }
      var str = LEADER.repeat(zeroes);
      for (; it2 < size; ++it2) {
        str += ALPHABET.charAt(b58[it2]);
      }
      return str;
    }
    function decodeUnsafe(source) {
      if (typeof source !== "string") {
        throw new TypeError("Expected String");
      }
      if (source.length === 0) {
        return new Uint8Array();
      }
      var psz = 0;
      if (source[psz] === " ") {
        return;
      }
      var zeroes = 0;
      var length2 = 0;
      while (source[psz] === LEADER) {
        zeroes++;
        psz++;
      }
      var size = (source.length - psz) * FACTOR + 1 >>> 0;
      var b256 = new Uint8Array(size);
      while (source[psz]) {
        var carry = BASE_MAP[source.charCodeAt(psz)];
        if (carry === 255) {
          return;
        }
        var i2 = 0;
        for (var it3 = size - 1; (carry !== 0 || i2 < length2) && it3 !== -1; it3--, i2++) {
          carry += BASE * b256[it3] >>> 0;
          b256[it3] = carry % 256 >>> 0;
          carry = carry / 256 >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length2 = i2;
        psz++;
      }
      if (source[psz] === " ") {
        return;
      }
      var it4 = size - length2;
      while (it4 !== size && b256[it4] === 0) {
        it4++;
      }
      var vch = new Uint8Array(zeroes + (size - it4));
      var j2 = zeroes;
      while (it4 !== size) {
        vch[j2++] = b256[it4++];
      }
      return vch;
    }
    function decode2(string2) {
      var buffer = decodeUnsafe(string2);
      if (buffer) {
        return buffer;
      }
      throw new Error(`Non-${name} character`);
    }
    return {
      encode: encode2,
      decodeUnsafe,
      decode: decode2
    };
  }
  var src$1 = base$2;
  var _brrp__multiformats_scope_baseX = src$1;
  class Encoder {
    constructor(name, prefix, baseEncode) {
      this.name = name;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
    }
    encode(bytes) {
      if (bytes instanceof Uint8Array) {
        return `${this.prefix}${this.baseEncode(bytes)}`;
      } else {
        throw Error("Unknown type, must be binary type");
      }
    }
  }
  class Decoder {
    constructor(name, prefix, baseDecode) {
      this.name = name;
      this.prefix = prefix;
      if (prefix.codePointAt(0) === void 0) {
        throw new Error("Invalid prefix character");
      }
      this.prefixCodePoint = prefix.codePointAt(0);
      this.baseDecode = baseDecode;
    }
    decode(text) {
      if (typeof text === "string") {
        if (text.codePointAt(0) !== this.prefixCodePoint) {
          throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
        }
        return this.baseDecode(text.slice(this.prefix.length));
      } else {
        throw Error("Can only multibase decode strings");
      }
    }
    or(decoder) {
      return or(this, decoder);
    }
  }
  class ComposedDecoder {
    constructor(decoders) {
      this.decoders = decoders;
    }
    or(decoder) {
      return or(this, decoder);
    }
    decode(input) {
      const prefix = input[0];
      const decoder = this.decoders[prefix];
      if (decoder) {
        return decoder.decode(input);
      } else {
        throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
      }
    }
  }
  const or = (left, right) => new ComposedDecoder({
    ...left.decoders || { [left.prefix]: left },
    ...right.decoders || { [right.prefix]: right }
  });
  class Codec {
    constructor(name, prefix, baseEncode, baseDecode) {
      this.name = name;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
      this.baseDecode = baseDecode;
      this.encoder = new Encoder(name, prefix, baseEncode);
      this.decoder = new Decoder(name, prefix, baseDecode);
    }
    encode(input) {
      return this.encoder.encode(input);
    }
    decode(input) {
      return this.decoder.decode(input);
    }
  }
  const from = ({ name, prefix, encode: encode2, decode: decode2 }) => new Codec(name, prefix, encode2, decode2);
  const baseX = ({ prefix, name, alphabet: alphabet2 }) => {
    const { encode: encode2, decode: decode2 } = _brrp__multiformats_scope_baseX(alphabet2, name);
    return from({
      prefix,
      name,
      encode: encode2,
      decode: (text) => coerce(decode2(text))
    });
  };
  const decode$1 = (string2, alphabet2, bitsPerChar, name) => {
    const codes = {};
    for (let i = 0; i < alphabet2.length; ++i) {
      codes[alphabet2[i]] = i;
    }
    let end = string2.length;
    while (string2[end - 1] === "=") {
      --end;
    }
    const out = new Uint8Array(end * bitsPerChar / 8 | 0);
    let bits = 0;
    let buffer = 0;
    let written = 0;
    for (let i = 0; i < end; ++i) {
      const value = codes[string2[i]];
      if (value === void 0) {
        throw new SyntaxError(`Non-${name} character`);
      }
      buffer = buffer << bitsPerChar | value;
      bits += bitsPerChar;
      if (bits >= 8) {
        bits -= 8;
        out[written++] = 255 & buffer >> bits;
      }
    }
    if (bits >= bitsPerChar || 255 & buffer << 8 - bits) {
      throw new SyntaxError("Unexpected end of data");
    }
    return out;
  };
  const encode$1 = (data, alphabet2, bitsPerChar) => {
    const pad = alphabet2[alphabet2.length - 1] === "=";
    const mask = (1 << bitsPerChar) - 1;
    let out = "";
    let bits = 0;
    let buffer = 0;
    for (let i = 0; i < data.length; ++i) {
      buffer = buffer << 8 | data[i];
      bits += 8;
      while (bits > bitsPerChar) {
        bits -= bitsPerChar;
        out += alphabet2[mask & buffer >> bits];
      }
    }
    if (bits) {
      out += alphabet2[mask & buffer << bitsPerChar - bits];
    }
    if (pad) {
      while (out.length * bitsPerChar & 7) {
        out += "=";
      }
    }
    return out;
  };
  const rfc4648 = ({ name, prefix, bitsPerChar, alphabet: alphabet2 }) => {
    return from({
      prefix,
      name,
      encode(input) {
        return encode$1(input, alphabet2, bitsPerChar);
      },
      decode(input) {
        return decode$1(input, alphabet2, bitsPerChar, name);
      }
    });
  };
  const base58btc = baseX({
    name: "base58btc",
    prefix: "z",
    alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
  });
  const base58flickr = baseX({
    name: "base58flickr",
    prefix: "Z",
    alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
  });
  const base58 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    base58btc,
    base58flickr
  }, Symbol.toStringTag, { value: "Module" }));
  const base32 = rfc4648({
    prefix: "b",
    name: "base32",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567",
    bitsPerChar: 5
  });
  const base32upper = rfc4648({
    prefix: "B",
    name: "base32upper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
    bitsPerChar: 5
  });
  const base32pad = rfc4648({
    prefix: "c",
    name: "base32pad",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
    bitsPerChar: 5
  });
  const base32padupper = rfc4648({
    prefix: "C",
    name: "base32padupper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
    bitsPerChar: 5
  });
  const base32hex = rfc4648({
    prefix: "v",
    name: "base32hex",
    alphabet: "0123456789abcdefghijklmnopqrstuv",
    bitsPerChar: 5
  });
  const base32hexupper = rfc4648({
    prefix: "V",
    name: "base32hexupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
    bitsPerChar: 5
  });
  const base32hexpad = rfc4648({
    prefix: "t",
    name: "base32hexpad",
    alphabet: "0123456789abcdefghijklmnopqrstuv=",
    bitsPerChar: 5
  });
  const base32hexpadupper = rfc4648({
    prefix: "T",
    name: "base32hexpadupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
    bitsPerChar: 5
  });
  const base32z = rfc4648({
    prefix: "h",
    name: "base32z",
    alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
    bitsPerChar: 5
  });
  const base32$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    base32,
    base32hex,
    base32hexpad,
    base32hexpadupper,
    base32hexupper,
    base32pad,
    base32padupper,
    base32upper,
    base32z
  }, Symbol.toStringTag, { value: "Module" }));
  class CID {
    constructor(version2, code, multihash, bytes) {
      this.code = code;
      this.version = version2;
      this.multihash = multihash;
      this.bytes = bytes;
      this.byteOffset = bytes.byteOffset;
      this.byteLength = bytes.byteLength;
      this.asCID = this;
      this._baseCache = /* @__PURE__ */ new Map();
      Object.defineProperties(this, {
        byteOffset: hidden,
        byteLength: hidden,
        code: readonly,
        version: readonly,
        multihash: readonly,
        bytes: readonly,
        _baseCache: hidden,
        asCID: hidden
      });
    }
    toV0() {
      switch (this.version) {
        case 0: {
          return this;
        }
        default: {
          const { code, multihash } = this;
          if (code !== DAG_PB_CODE) {
            throw new Error("Cannot convert a non dag-pb CID to CIDv0");
          }
          if (multihash.code !== SHA_256_CODE) {
            throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
          }
          return CID.createV0(multihash);
        }
      }
    }
    toV1() {
      switch (this.version) {
        case 0: {
          const { code, digest } = this.multihash;
          const multihash = create(code, digest);
          return CID.createV1(this.code, multihash);
        }
        case 1: {
          return this;
        }
        default: {
          throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
        }
      }
    }
    equals(other) {
      return other && this.code === other.code && this.version === other.version && equals$1(this.multihash, other.multihash);
    }
    toString(base3) {
      const { bytes, version: version2, _baseCache } = this;
      switch (version2) {
        case 0:
          return toStringV0(bytes, _baseCache, base3 || base58btc.encoder);
        default:
          return toStringV1(bytes, _baseCache, base3 || base32.encoder);
      }
    }
    toJSON() {
      return {
        code: this.code,
        version: this.version,
        hash: this.multihash.bytes
      };
    }
    get [Symbol.toStringTag]() {
      return "CID";
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
      return "CID(" + this.toString() + ")";
    }
    static isCID(value) {
      deprecate(/^0\.0/, IS_CID_DEPRECATION);
      return !!(value && (value[cidSymbol] || value.asCID === value));
    }
    get toBaseEncodedString() {
      throw new Error("Deprecated, use .toString()");
    }
    get codec() {
      throw new Error('"codec" property is deprecated, use integer "code" property instead');
    }
    get buffer() {
      throw new Error("Deprecated .buffer property, use .bytes to get Uint8Array instead");
    }
    get multibaseName() {
      throw new Error('"multibaseName" property is deprecated');
    }
    get prefix() {
      throw new Error('"prefix" property is deprecated');
    }
    static asCID(value) {
      if (value instanceof CID) {
        return value;
      } else if (value != null && value.asCID === value) {
        const { version: version2, code, multihash, bytes } = value;
        return new CID(version2, code, multihash, bytes || encodeCID(version2, code, multihash.bytes));
      } else if (value != null && value[cidSymbol] === true) {
        const { version: version2, multihash, code } = value;
        const digest = decode$2(multihash);
        return CID.create(version2, code, digest);
      } else {
        return null;
      }
    }
    static create(version2, code, digest) {
      if (typeof code !== "number") {
        throw new Error("String codecs are no longer supported");
      }
      switch (version2) {
        case 0: {
          if (code !== DAG_PB_CODE) {
            throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`);
          } else {
            return new CID(version2, code, digest, digest.bytes);
          }
        }
        case 1: {
          const bytes = encodeCID(version2, code, digest.bytes);
          return new CID(version2, code, digest, bytes);
        }
        default: {
          throw new Error("Invalid version");
        }
      }
    }
    static createV0(digest) {
      return CID.create(0, DAG_PB_CODE, digest);
    }
    static createV1(code, digest) {
      return CID.create(1, code, digest);
    }
    static decode(bytes) {
      const [cid2, remainder] = CID.decodeFirst(bytes);
      if (remainder.length) {
        throw new Error("Incorrect length");
      }
      return cid2;
    }
    static decodeFirst(bytes) {
      const specs = CID.inspectBytes(bytes);
      const prefixSize = specs.size - specs.multihashSize;
      const multihashBytes = coerce(bytes.subarray(prefixSize, prefixSize + specs.multihashSize));
      if (multihashBytes.byteLength !== specs.multihashSize) {
        throw new Error("Incorrect length");
      }
      const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
      const digest = new Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
      const cid2 = specs.version === 0 ? CID.createV0(digest) : CID.createV1(specs.codec, digest);
      return [
        cid2,
        bytes.subarray(specs.size)
      ];
    }
    static inspectBytes(initialBytes) {
      let offset = 0;
      const next = () => {
        const [i, length2] = decode$3(initialBytes.subarray(offset));
        offset += length2;
        return i;
      };
      let version2 = next();
      let codec = DAG_PB_CODE;
      if (version2 === 18) {
        version2 = 0;
        offset = 0;
      } else if (version2 === 1) {
        codec = next();
      }
      if (version2 !== 0 && version2 !== 1) {
        throw new RangeError(`Invalid CID version ${version2}`);
      }
      const prefixSize = offset;
      const multihashCode = next();
      const digestSize = next();
      const size = offset + digestSize;
      const multihashSize = size - prefixSize;
      return {
        version: version2,
        codec,
        multihashCode,
        digestSize,
        multihashSize,
        size
      };
    }
    static parse(source, base3) {
      const [prefix, bytes] = parseCIDtoBytes(source, base3);
      const cid2 = CID.decode(bytes);
      cid2._baseCache.set(prefix, source);
      return cid2;
    }
  }
  const parseCIDtoBytes = (source, base3) => {
    switch (source[0]) {
      case "Q": {
        const decoder = base3 || base58btc;
        return [
          base58btc.prefix,
          decoder.decode(`${base58btc.prefix}${source}`)
        ];
      }
      case base58btc.prefix: {
        const decoder = base3 || base58btc;
        return [
          base58btc.prefix,
          decoder.decode(source)
        ];
      }
      case base32.prefix: {
        const decoder = base3 || base32;
        return [
          base32.prefix,
          decoder.decode(source)
        ];
      }
      default: {
        if (base3 == null) {
          throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
        }
        return [
          source[0],
          base3.decode(source)
        ];
      }
    }
  };
  const toStringV0 = (bytes, cache, base3) => {
    const { prefix } = base3;
    if (prefix !== base58btc.prefix) {
      throw Error(`Cannot string encode V0 in ${base3.name} encoding`);
    }
    const cid2 = cache.get(prefix);
    if (cid2 == null) {
      const cid3 = base3.encode(bytes).slice(1);
      cache.set(prefix, cid3);
      return cid3;
    } else {
      return cid2;
    }
  };
  const toStringV1 = (bytes, cache, base3) => {
    const { prefix } = base3;
    const cid2 = cache.get(prefix);
    if (cid2 == null) {
      const cid3 = base3.encode(bytes);
      cache.set(prefix, cid3);
      return cid3;
    } else {
      return cid2;
    }
  };
  const DAG_PB_CODE = 112;
  const SHA_256_CODE = 18;
  const encodeCID = (version2, code, multihash) => {
    const codeOffset = encodingLength(version2);
    const hashOffset = codeOffset + encodingLength(code);
    const bytes = new Uint8Array(hashOffset + multihash.byteLength);
    encodeTo(version2, bytes, 0);
    encodeTo(code, bytes, codeOffset);
    bytes.set(multihash, hashOffset);
    return bytes;
  };
  const cidSymbol = Symbol.for("@ipld/js-cid/CID");
  const readonly = {
    writable: false,
    configurable: false,
    enumerable: true
  };
  const hidden = {
    writable: false,
    enumerable: false,
    configurable: false
  };
  const version = "0.0.0-dev";
  const deprecate = (range, message2) => {
    if (range.test(version)) {
      console.warn(message2);
    } else {
      throw new Error(message2);
    }
  };
  const IS_CID_DEPRECATION = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`;
  const cid = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    CID
  }, Symbol.toStringTag, { value: "Module" }));
  const require$$0$1 = /* @__PURE__ */ getAugmentedNamespace(cid);
  var dist$2 = {};
  var check = {};
  var hasRequiredCheck;
  function requireCheck() {
    if (hasRequiredCheck) return check;
    hasRequiredCheck = 1;
    Object.defineProperty(check, "__esModule", { value: true });
    check.isObject = check.assure = check.create = check.is = void 0;
    const is = (obj, def) => {
      return def.safeParse(obj).success;
    };
    check.is = is;
    const create2 = (def) => (v) => def.safeParse(v).success;
    check.create = create2;
    const assure = (def, obj) => {
      return def.parse(obj);
    };
    check.assure = assure;
    const isObject = (obj) => {
      return typeof obj === "object" && obj !== null;
    };
    check.isObject = isObject;
    return check;
  }
  var util$6 = {};
  var hasRequiredUtil$6;
  function requireUtil$6() {
    if (hasRequiredUtil$6) return util$6;
    hasRequiredUtil$6 = 1;
    (function(exports) {
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.parseIntWithFallback = exports.dedupeStrs = exports.range = exports.chunkArray = exports.errHasMsg = exports.isErrnoException = exports.asyncFilter = exports.s32decode = exports.s32encode = exports.streamToBuffer = exports.flattenUint8Arrays = exports.bailableWait = exports.wait = exports.jitter = exports.noUndefinedVals = void 0;
      exports.omit = omit;
      const noUndefinedVals = (obj) => {
        Object.keys(obj).forEach((k) => {
          if (obj[k] === void 0) {
            delete obj[k];
          }
        });
        return obj;
      };
      exports.noUndefinedVals = noUndefinedVals;
      function omit(src2, rejectedKeys) {
        if (!src2)
          return src2;
        const dst = {};
        const srcKeys = Object.keys(src2);
        for (let i = 0; i < srcKeys.length; i++) {
          const key = srcKeys[i];
          if (!rejectedKeys.includes(key)) {
            dst[key] = src2[key];
          }
        }
        return dst;
      }
      const jitter = (maxMs) => {
        return Math.round((Math.random() - 0.5) * maxMs * 2);
      };
      exports.jitter = jitter;
      const wait = (ms) => {
        return new Promise((res) => setTimeout(res, ms));
      };
      exports.wait = wait;
      const bailableWait = (ms) => {
        let bail;
        const waitPromise = new Promise((res) => {
          const timeout = setTimeout(res, ms);
          bail = () => {
            clearTimeout(timeout);
            res();
          };
        });
        return { bail, wait: () => waitPromise };
      };
      exports.bailableWait = bailableWait;
      const flattenUint8Arrays = (arrs) => {
        const length2 = arrs.reduce((acc, cur) => {
          return acc + cur.length;
        }, 0);
        const flattened = new Uint8Array(length2);
        let offset = 0;
        arrs.forEach((arr) => {
          flattened.set(arr, offset);
          offset += arr.length;
        });
        return flattened;
      };
      exports.flattenUint8Arrays = flattenUint8Arrays;
      const streamToBuffer = async (stream) => {
        const arrays2 = [];
        for await (const chunk of stream) {
          arrays2.push(chunk);
        }
        return (0, exports.flattenUint8Arrays)(arrays2);
      };
      exports.streamToBuffer = streamToBuffer;
      const S32_CHAR = "234567abcdefghijklmnopqrstuvwxyz";
      const s32encode = (i) => {
        let s = "";
        while (i) {
          const c = i % 32;
          i = Math.floor(i / 32);
          s = S32_CHAR.charAt(c) + s;
        }
        return s;
      };
      exports.s32encode = s32encode;
      const s32decode = (s) => {
        let i = 0;
        for (const c of s) {
          i = i * 32 + S32_CHAR.indexOf(c);
        }
        return i;
      };
      exports.s32decode = s32decode;
      const asyncFilter = async (arr, fn) => {
        const results = await Promise.all(arr.map((t) => fn(t)));
        return arr.filter((_, i) => results[i]);
      };
      exports.asyncFilter = asyncFilter;
      const isErrnoException = (err) => {
        return !!err && err["code"];
      };
      exports.isErrnoException = isErrnoException;
      const errHasMsg = (err, msg) => {
        return !!err && typeof err === "object" && err["message"] === msg;
      };
      exports.errHasMsg = errHasMsg;
      const chunkArray = (arr, chunkSize) => {
        return arr.reduce((acc, cur, i) => {
          const chunkI = Math.floor(i / chunkSize);
          if (!acc[chunkI]) {
            acc[chunkI] = [];
          }
          acc[chunkI].push(cur);
          return acc;
        }, []);
      };
      exports.chunkArray = chunkArray;
      const range = (num) => {
        const nums = [];
        for (let i = 0; i < num; i++) {
          nums.push(i);
        }
        return nums;
      };
      exports.range = range;
      const dedupeStrs = (strs) => {
        return [...new Set(strs)];
      };
      exports.dedupeStrs = dedupeStrs;
      const parseIntWithFallback = (value, fallback) => {
        const parsed = parseInt(value || "", 10);
        return isNaN(parsed) ? fallback : parsed;
      };
      exports.parseIntWithFallback = parseIntWithFallback;
    })(util$6);
    return util$6;
  }
  var arrays = {};
  var hasRequiredArrays;
  function requireArrays() {
    if (hasRequiredArrays) return arrays;
    hasRequiredArrays = 1;
    Object.defineProperty(arrays, "__esModule", { value: true });
    arrays.mapDefined = void 0;
    arrays.keyBy = keyBy;
    function keyBy(arr, key) {
      return arr.reduce((acc, cur) => {
        acc.set(cur[key], cur);
        return acc;
      }, /* @__PURE__ */ new Map());
    }
    const mapDefined = (arr, fn) => {
      const output = [];
      for (const item of arr) {
        const val = fn(item);
        if (val !== void 0) {
          output.push(val);
        }
      }
      return output;
    };
    arrays.mapDefined = mapDefined;
    return arrays;
  }
  var async = {};
  var hasRequiredAsync;
  function requireAsync() {
    if (hasRequiredAsync) return async;
    hasRequiredAsync = 1;
    (function(exports) {
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.AsyncBufferFullError = exports.AsyncBuffer = exports.allComplete = exports.createDeferrables = exports.createDeferrable = exports.readFromGenerator = void 0;
      exports.allFulfilled = allFulfilled;
      exports.handleAllSettledErrors = handleAllSettledErrors;
      exports.isRejectedResult = isRejectedResult;
      exports.isFulfilledResult = isFulfilledResult;
      const util_1 = requireUtil$6();
      const readFromGenerator = async (gen, isDone, waitFor = Promise.resolve(), maxLength = Number.MAX_SAFE_INTEGER) => {
        const evts = [];
        let bail;
        let hasBroke = false;
        const awaitDone = async () => {
          if (await isDone(evts.at(-1))) {
            return true;
          }
          const bailable = (0, util_1.bailableWait)(20);
          await bailable.wait();
          bail = bailable.bail;
          if (hasBroke)
            return false;
          return await awaitDone();
        };
        const breakOn = new Promise((resolve) => {
          waitFor.then(() => {
            awaitDone().then(() => resolve());
          });
        });
        try {
          while (evts.length < maxLength) {
            const maybeEvt = await Promise.race([gen.next(), breakOn]);
            if (!maybeEvt)
              break;
            const evt = maybeEvt;
            if (evt.done)
              break;
            evts.push(evt.value);
          }
        } finally {
          hasBroke = true;
          bail && bail();
        }
        return evts;
      };
      exports.readFromGenerator = readFromGenerator;
      const createDeferrable = () => {
        let resolve;
        const promise = new Promise((res) => {
          resolve = () => res();
        });
        return { resolve, complete: promise };
      };
      exports.createDeferrable = createDeferrable;
      const createDeferrables = (count) => {
        const list2 = [];
        for (let i = 0; i < count; i++) {
          list2.push((0, exports.createDeferrable)());
        }
        return list2;
      };
      exports.createDeferrables = createDeferrables;
      const allComplete = async (deferrables) => {
        await Promise.all(deferrables.map((d) => d.complete));
      };
      exports.allComplete = allComplete;
      class AsyncBuffer {
        constructor(maxSize) {
          Object.defineProperty(this, "maxSize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: maxSize
          });
          Object.defineProperty(this, "buffer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
          });
          Object.defineProperty(this, "promise", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "resolve", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "closed", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
          });
          Object.defineProperty(this, "toThrow", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          this.promise = Promise.resolve();
          this.resolve = () => null;
          this.resetPromise();
        }
        get curr() {
          return this.buffer;
        }
        get size() {
          return this.buffer.length;
        }
        get isClosed() {
          return this.closed;
        }
        resetPromise() {
          this.promise = new Promise((r) => this.resolve = r);
        }
        push(item) {
          this.buffer.push(item);
          this.resolve();
        }
        pushMany(items) {
          items.forEach((i) => this.buffer.push(i));
          this.resolve();
        }
        async *events() {
          while (true) {
            if (this.closed && this.buffer.length === 0) {
              if (this.toThrow) {
                throw this.toThrow;
              } else {
                return;
              }
            }
            await this.promise;
            if (this.toThrow) {
              throw this.toThrow;
            }
            if (this.maxSize && this.size > this.maxSize) {
              throw new AsyncBufferFullError(this.maxSize);
            }
            const [first, ...rest] = this.buffer;
            if (first) {
              this.buffer = rest;
              yield first;
            } else {
              this.resetPromise();
            }
          }
        }
        throw(err) {
          this.toThrow = err;
          this.closed = true;
          this.resolve();
        }
        close() {
          this.closed = true;
          this.resolve();
        }
      }
      exports.AsyncBuffer = AsyncBuffer;
      class AsyncBufferFullError extends Error {
        constructor(maxSize) {
          super(`ReachedMaxBufferSize: ${maxSize}`);
        }
      }
      exports.AsyncBufferFullError = AsyncBufferFullError;
      function allFulfilled(promises) {
        return Promise.allSettled(promises).then(handleAllSettledErrors);
      }
      function handleAllSettledErrors(results) {
        const errors2 = results.filter(isRejectedResult).map(extractReason);
        if (errors2.length === 0) {
          return results.map(extractValue);
        }
        if (errors2.length === 1) {
          throw errors2[0];
        }
        throw new AggregateError(errors2, `Multiple errors: ${errors2.map(stringifyReason).join("\n")}`);
      }
      function isRejectedResult(result) {
        return result.status === "rejected";
      }
      function extractReason(result) {
        return result.reason;
      }
      function isFulfilledResult(result) {
        return result.status === "fulfilled";
      }
      function extractValue(result) {
        return result.value;
      }
      function stringifyReason(reason) {
        if (reason instanceof Error) {
          return reason.message;
        }
        return String(reason);
      }
    })(async);
    return async;
  }
  var tid = {};
  var hasRequiredTid;
  function requireTid() {
    if (hasRequiredTid) return tid;
    hasRequiredTid = 1;
    Object.defineProperty(tid, "__esModule", { value: true });
    tid.TID = void 0;
    const util_1 = requireUtil$6();
    const TID_LEN = 13;
    let lastTimestamp = 0;
    let timestampCount = 0;
    let clockid = null;
    function dedash(str) {
      return str.replaceAll("-", "");
    }
    class TID {
      constructor(str) {
        Object.defineProperty(this, "str", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        const noDashes = dedash(str);
        if (noDashes.length !== TID_LEN) {
          throw new Error(`Poorly formatted TID: ${noDashes.length} length`);
        }
        this.str = noDashes;
      }
      static next(prev) {
        const time = Math.max(Date.now(), lastTimestamp);
        if (time === lastTimestamp) {
          timestampCount++;
        }
        lastTimestamp = time;
        const timestamp = time * 1e3 + timestampCount;
        if (clockid === null) {
          clockid = Math.floor(Math.random() * 32);
        }
        const tid2 = TID.fromTime(timestamp, clockid);
        if (!prev || tid2.newerThan(prev)) {
          return tid2;
        }
        return TID.fromTime(prev.timestamp() + 1, clockid);
      }
      static nextStr(prev) {
        return TID.next(prev ? new TID(prev) : void 0).toString();
      }
      static fromTime(timestamp, clockid2) {
        const str = `${(0, util_1.s32encode)(timestamp)}${(0, util_1.s32encode)(clockid2).padStart(2, "2")}`;
        return new TID(str);
      }
      static fromStr(str) {
        return new TID(str);
      }
      static oldestFirst(a, b) {
        return a.compareTo(b);
      }
      static newestFirst(a, b) {
        return b.compareTo(a);
      }
      static is(str) {
        return dedash(str).length === TID_LEN;
      }
      timestamp() {
        return (0, util_1.s32decode)(this.str.slice(0, 11));
      }
      clockid() {
        return (0, util_1.s32decode)(this.str.slice(11, 13));
      }
      formatted() {
        const str = this.toString();
        return `${str.slice(0, 4)}-${str.slice(4, 7)}-${str.slice(7, 11)}-${str.slice(11, 13)}`;
      }
      toString() {
        return this.str;
      }
      // newer > older
      compareTo(other) {
        if (this.str > other.str)
          return 1;
        if (this.str < other.str)
          return -1;
        return 0;
      }
      equals(other) {
        return this.str === other.str;
      }
      newerThan(other) {
        return this.compareTo(other) > 0;
      }
      olderThan(other) {
        return this.compareTo(other) < 0;
      }
    }
    tid.TID = TID;
    return tid;
  }
  var ipld = {};
  function compare(a, b) {
    for (let i = 0; i < a.byteLength; i++) {
      if (a[i] < b[i]) {
        return -1;
      }
      if (a[i] > b[i]) {
        return 1;
      }
    }
    if (a.byteLength > b.byteLength) {
      return 1;
    }
    if (a.byteLength < b.byteLength) {
      return -1;
    }
    return 0;
  }
  function concat(arrays2, length2) {
    if (!length2) {
      length2 = arrays2.reduce((acc, curr) => acc + curr.length, 0);
    }
    const output = new Uint8Array(length2);
    let offset = 0;
    for (const arr of arrays2) {
      output.set(arr, offset);
      offset += arr.length;
    }
    return output;
  }
  function equals(a, b) {
    if (a === b) {
      return true;
    }
    if (a.byteLength !== b.byteLength) {
      return false;
    }
    for (let i = 0; i < a.byteLength; i++) {
      if (a[i] !== b[i]) {
        return false;
      }
    }
    return true;
  }
  const identity = from({
    prefix: "\0",
    name: "identity",
    encode: (buf) => toString$1(buf),
    decode: (str) => fromString$1(str)
  });
  const identityBase = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    identity
  }, Symbol.toStringTag, { value: "Module" }));
  const base2 = rfc4648({
    prefix: "0",
    name: "base2",
    alphabet: "01",
    bitsPerChar: 1
  });
  const base2$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    base2
  }, Symbol.toStringTag, { value: "Module" }));
  const base8 = rfc4648({
    prefix: "7",
    name: "base8",
    alphabet: "01234567",
    bitsPerChar: 3
  });
  const base8$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    base8
  }, Symbol.toStringTag, { value: "Module" }));
  const base10 = baseX({
    prefix: "9",
    name: "base10",
    alphabet: "0123456789"
  });
  const base10$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    base10
  }, Symbol.toStringTag, { value: "Module" }));
  const base16 = rfc4648({
    prefix: "f",
    name: "base16",
    alphabet: "0123456789abcdef",
    bitsPerChar: 4
  });
  const base16upper = rfc4648({
    prefix: "F",
    name: "base16upper",
    alphabet: "0123456789ABCDEF",
    bitsPerChar: 4
  });
  const base16$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    base16,
    base16upper
  }, Symbol.toStringTag, { value: "Module" }));
  const base36 = baseX({
    prefix: "k",
    name: "base36",
    alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
  });
  const base36upper = baseX({
    prefix: "K",
    name: "base36upper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
  });
  const base36$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    base36,
    base36upper
  }, Symbol.toStringTag, { value: "Module" }));
  const base64$1 = rfc4648({
    prefix: "m",
    name: "base64",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
    bitsPerChar: 6
  });
  const base64pad = rfc4648({
    prefix: "M",
    name: "base64pad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
    bitsPerChar: 6
  });
  const base64url = rfc4648({
    prefix: "u",
    name: "base64url",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
    bitsPerChar: 6
  });
  const base64urlpad = rfc4648({
    prefix: "U",
    name: "base64urlpad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
    bitsPerChar: 6
  });
  const base64$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    base64: base64$1,
    base64pad,
    base64url,
    base64urlpad
  }, Symbol.toStringTag, { value: "Module" }));
  const alphabet = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
  const alphabetBytesToChars = alphabet.reduce((p, c, i) => {
    p[i] = c;
    return p;
  }, []);
  const alphabetCharsToBytes = alphabet.reduce((p, c, i) => {
    p[c.codePointAt(0)] = i;
    return p;
  }, []);
  function encode(data) {
    return data.reduce((p, c) => {
      p += alphabetBytesToChars[c];
      return p;
    }, "");
  }
  function decode(str) {
    const byts = [];
    for (const char of str) {
      const byt = alphabetCharsToBytes[char.codePointAt(0)];
      if (byt === void 0) {
        throw new Error(`Non-base256emoji character: ${char}`);
      }
      byts.push(byt);
    }
    return new Uint8Array(byts);
  }
  const base256emoji = from({
    prefix: "\u{1F680}",
    name: "base256emoji",
    encode,
    decode
  });
  const base256emoji$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    base256emoji
  }, Symbol.toStringTag, { value: "Module" }));
  new TextEncoder();
  new TextDecoder();
  const bases = {
    ...identityBase,
    ...base2$1,
    ...base8$1,
    ...base10$1,
    ...base16$1,
    ...base32$1,
    ...base36$1,
    ...base58,
    ...base64$2,
    ...base256emoji$1
  };
  function createCodec(name, prefix, encode2, decode2) {
    return {
      name,
      prefix,
      encoder: {
        name,
        prefix,
        encode: encode2
      },
      decoder: { decode: decode2 }
    };
  }
  const string = createCodec("utf8", "u", (buf) => {
    const decoder = new TextDecoder("utf8");
    return "u" + decoder.decode(buf);
  }, (str) => {
    const encoder = new TextEncoder();
    return encoder.encode(str.substring(1));
  });
  const ascii = createCodec("ascii", "a", (buf) => {
    let string2 = "a";
    for (let i = 0; i < buf.length; i++) {
      string2 += String.fromCharCode(buf[i]);
    }
    return string2;
  }, (str) => {
    str = str.substring(1);
    const buf = new Uint8Array(str.length);
    for (let i = 0; i < str.length; i++) {
      buf[i] = str.charCodeAt(i);
    }
    return buf;
  });
  const BASES = {
    utf8: string,
    "utf-8": string,
    hex: bases.base16,
    latin1: ascii,
    ascii,
    binary: ascii,
    ...bases
  };
  function fromString(string2, encoding = "utf8") {
    const base3 = BASES[encoding];
    if (!base3) {
      throw new Error(`Unsupported encoding "${encoding}"`);
    }
    return base3.decoder.decode(`${base3.prefix}${string2}`);
  }
  function toString(array, encoding = "utf8") {
    const base3 = BASES[encoding];
    if (!base3) {
      throw new Error(`Unsupported encoding "${encoding}"`);
    }
    return base3.encoder.encode(array).substring(1);
  }
  function xor(a, b) {
    if (a.length !== b.length) {
      throw new Error("Inputs should have the same length");
    }
    const result = new Uint8Array(a.length);
    for (let i = 0; i < a.length; i++) {
      result[i] = a[i] ^ b[i];
    }
    return result;
  }
  const src = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    compare,
    concat,
    equals,
    fromString,
    toString,
    xor
  }, Symbol.toStringTag, { value: "Module" }));
  const require$$1 = /* @__PURE__ */ getAugmentedNamespace(src);
  var hasRequiredIpld;
  function requireIpld() {
    if (hasRequiredIpld) return ipld;
    hasRequiredIpld = 1;
    (function(exports) {
      var __createBinding = ipld && ipld.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = ipld && ipld.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = ipld && ipld.__importStar || function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ipldEquals = exports.ipldToJson = exports.jsonToIpld = void 0;
      const cid_1 = require$$0$1;
      const ui8 = __importStar(require$$1);
      const jsonToIpld = (val) => {
        if (Array.isArray(val)) {
          return val.map((item) => (0, exports.jsonToIpld)(item));
        }
        if (val && typeof val === "object") {
          if (typeof val["$link"] === "string" && Object.keys(val).length === 1) {
            return cid_1.CID.parse(val["$link"]);
          }
          if (typeof val["$bytes"] === "string" && Object.keys(val).length === 1) {
            return ui8.fromString(val["$bytes"], "base64");
          }
          const toReturn = {};
          for (const key of Object.keys(val)) {
            toReturn[key] = (0, exports.jsonToIpld)(val[key]);
          }
          return toReturn;
        }
        return val;
      };
      exports.jsonToIpld = jsonToIpld;
      const ipldToJson = (val) => {
        if (Array.isArray(val)) {
          return val.map((item) => (0, exports.ipldToJson)(item));
        }
        if (val && typeof val === "object") {
          if (val instanceof Uint8Array) {
            return {
              $bytes: ui8.toString(val, "base64")
            };
          }
          if (cid_1.CID.asCID(val)) {
            return {
              $link: val.toString()
            };
          }
          const toReturn = {};
          for (const key of Object.keys(val)) {
            toReturn[key] = (0, exports.ipldToJson)(val[key]);
          }
          return toReturn;
        }
        return val;
      };
      exports.ipldToJson = ipldToJson;
      const ipldEquals = (a, b) => {
        if (Array.isArray(a) && Array.isArray(b)) {
          if (a.length !== b.length)
            return false;
          for (let i = 0; i < a.length; i++) {
            if (!(0, exports.ipldEquals)(a[i], b[i]))
              return false;
          }
          return true;
        }
        if (a && b && typeof a === "object" && typeof b === "object") {
          if (a instanceof Uint8Array && b instanceof Uint8Array) {
            return ui8.equals(a, b);
          }
          if (cid_1.CID.asCID(a) && cid_1.CID.asCID(b)) {
            return cid_1.CID.asCID(a)?.equals(cid_1.CID.asCID(b));
          }
          if (Object.keys(a).length !== Object.keys(b).length)
            return false;
          for (const key of Object.keys(a)) {
            if (!(0, exports.ipldEquals)(a[key], b[key]))
              return false;
          }
          return true;
        }
        return a === b;
      };
      exports.ipldEquals = ipldEquals;
    })(ipld);
    return ipld;
  }
  var retry = {};
  var hasRequiredRetry;
  function requireRetry() {
    if (hasRequiredRetry) return retry;
    hasRequiredRetry = 1;
    Object.defineProperty(retry, "__esModule", { value: true });
    retry.retry = retry$1;
    retry.createRetryable = createRetryable;
    retry.backoffMs = backoffMs;
    const util_1 = requireUtil$6();
    async function retry$1(fn, opts = {}) {
      const { maxRetries = 3, retryable = () => true, getWaitMs = backoffMs } = opts;
      let retries = 0;
      let doneError;
      while (!doneError) {
        try {
          return await fn();
        } catch (err) {
          const waitMs = getWaitMs(retries);
          const willRetry = retries < maxRetries && waitMs !== null && retryable(err);
          if (willRetry) {
            retries += 1;
            if (waitMs !== 0) {
              await (0, util_1.wait)(waitMs);
            }
          } else {
            doneError = err;
          }
        }
      }
      throw doneError;
    }
    function createRetryable(retryable) {
      return async (fn, opts) => retry$1(fn, { ...opts, retryable });
    }
    function backoffMs(n, multiplier = 100, max = 1e3) {
      const exponentialMs = Math.pow(2, n) * multiplier;
      const ms = Math.min(exponentialMs, max);
      return jitter(ms);
    }
    function jitter(value) {
      const delta = value * 0.15;
      return value + randomRange(-delta, delta);
    }
    function randomRange(from2, to) {
      const rand = Math.random() * (to - from2);
      return rand + from2;
    }
    return retry;
  }
  var types$3 = {};
  var hasRequiredTypes$3;
  function requireTypes$3() {
    if (hasRequiredTypes$3) return types$3;
    hasRequiredTypes$3 = 1;
    (function(exports) {
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.def = exports.schema = void 0;
      const cid_1 = require$$0$1;
      const zod_1 = /* @__PURE__ */ requireLib$1();
      const cidSchema = zod_1.z.any().refine((obj) => cid_1.CID.asCID(obj) !== null, {
        message: "Not a CID"
      }).transform((obj) => cid_1.CID.asCID(obj));
      exports.schema = {
        cid: cidSchema,
        bytes: zod_1.z.instanceof(Uint8Array),
        string: zod_1.z.string(),
        array: zod_1.z.array(zod_1.z.unknown()),
        map: zod_1.z.record(zod_1.z.string(), zod_1.z.unknown()),
        unknown: zod_1.z.unknown()
      };
      exports.def = {
        cid: {
          name: "cid",
          schema: exports.schema.cid
        },
        bytes: {
          name: "bytes",
          schema: exports.schema.bytes
        },
        string: {
          name: "string",
          schema: exports.schema.string
        },
        map: {
          name: "map",
          schema: exports.schema.map
        },
        unknown: {
          name: "unknown",
          schema: exports.schema.unknown
        }
      };
    })(types$3);
    return types$3;
  }
  var times = {};
  var hasRequiredTimes;
  function requireTimes() {
    if (hasRequiredTimes) return times;
    hasRequiredTimes = 1;
    (function(exports) {
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.addHoursToDate = exports.lessThanAgoMs = exports.DAY = exports.HOUR = exports.MINUTE = exports.SECOND = void 0;
      exports.SECOND = 1e3;
      exports.MINUTE = exports.SECOND * 60;
      exports.HOUR = exports.MINUTE * 60;
      exports.DAY = exports.HOUR * 24;
      const lessThanAgoMs = (time, range) => {
        return Date.now() < time.getTime() + range;
      };
      exports.lessThanAgoMs = lessThanAgoMs;
      const addHoursToDate = (hours, startingDate) => {
        const currentDate = startingDate ? new Date(startingDate) : /* @__PURE__ */ new Date();
        currentDate.setHours(currentDate.getHours() + hours);
        return currentDate;
      };
      exports.addHoursToDate = addHoursToDate;
    })(times);
    return times;
  }
  var strings = {};
  var lib = {};
  var Graphemer = {};
  var boundaries = {};
  var hasRequiredBoundaries;
  function requireBoundaries() {
    if (hasRequiredBoundaries) return boundaries;
    hasRequiredBoundaries = 1;
    (function(exports) {
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.EXTENDED_PICTOGRAPHIC = exports.CLUSTER_BREAK = void 0;
      (function(CLUSTER_BREAK) {
        CLUSTER_BREAK[CLUSTER_BREAK["CR"] = 0] = "CR";
        CLUSTER_BREAK[CLUSTER_BREAK["LF"] = 1] = "LF";
        CLUSTER_BREAK[CLUSTER_BREAK["CONTROL"] = 2] = "CONTROL";
        CLUSTER_BREAK[CLUSTER_BREAK["EXTEND"] = 3] = "EXTEND";
        CLUSTER_BREAK[CLUSTER_BREAK["REGIONAL_INDICATOR"] = 4] = "REGIONAL_INDICATOR";
        CLUSTER_BREAK[CLUSTER_BREAK["SPACINGMARK"] = 5] = "SPACINGMARK";
        CLUSTER_BREAK[CLUSTER_BREAK["L"] = 6] = "L";
        CLUSTER_BREAK[CLUSTER_BREAK["V"] = 7] = "V";
        CLUSTER_BREAK[CLUSTER_BREAK["T"] = 8] = "T";
        CLUSTER_BREAK[CLUSTER_BREAK["LV"] = 9] = "LV";
        CLUSTER_BREAK[CLUSTER_BREAK["LVT"] = 10] = "LVT";
        CLUSTER_BREAK[CLUSTER_BREAK["OTHER"] = 11] = "OTHER";
        CLUSTER_BREAK[CLUSTER_BREAK["PREPEND"] = 12] = "PREPEND";
        CLUSTER_BREAK[CLUSTER_BREAK["E_BASE"] = 13] = "E_BASE";
        CLUSTER_BREAK[CLUSTER_BREAK["E_MODIFIER"] = 14] = "E_MODIFIER";
        CLUSTER_BREAK[CLUSTER_BREAK["ZWJ"] = 15] = "ZWJ";
        CLUSTER_BREAK[CLUSTER_BREAK["GLUE_AFTER_ZWJ"] = 16] = "GLUE_AFTER_ZWJ";
        CLUSTER_BREAK[CLUSTER_BREAK["E_BASE_GAZ"] = 17] = "E_BASE_GAZ";
      })(exports.CLUSTER_BREAK || (exports.CLUSTER_BREAK = {}));
      exports.EXTENDED_PICTOGRAPHIC = 101;
    })(boundaries);
    return boundaries;
  }
  var GraphemerHelper = {};
  var hasRequiredGraphemerHelper;
  function requireGraphemerHelper() {
    if (hasRequiredGraphemerHelper) return GraphemerHelper;
    hasRequiredGraphemerHelper = 1;
    Object.defineProperty(GraphemerHelper, "__esModule", { value: true });
    const boundaries_1 = requireBoundaries();
    const NotBreak = 0;
    const BreakStart = 1;
    const Break = 2;
    const BreakLastRegional = 3;
    const BreakPenultimateRegional = 4;
    let GraphemerHelper$1 = class GraphemerHelper {
      /**
       * Check if the the character at the position {pos} of the string is surrogate
       * @param str {string}
       * @param pos {number}
       * @returns {boolean}
       */
      static isSurrogate(str, pos) {
        return 55296 <= str.charCodeAt(pos) && str.charCodeAt(pos) <= 56319 && 56320 <= str.charCodeAt(pos + 1) && str.charCodeAt(pos + 1) <= 57343;
      }
      /**
       * The String.prototype.codePointAt polyfill
       * Private function, gets a Unicode code point from a JavaScript UTF-16 string
       * handling surrogate pairs appropriately
       * @param str {string}
       * @param idx {number}
       * @returns {number}
       */
      static codePointAt(str, idx) {
        if (idx === void 0) {
          idx = 0;
        }
        const code = str.charCodeAt(idx);
        if (55296 <= code && code <= 56319 && idx < str.length - 1) {
          const hi = code;
          const low = str.charCodeAt(idx + 1);
          if (56320 <= low && low <= 57343) {
            return (hi - 55296) * 1024 + (low - 56320) + 65536;
          }
          return hi;
        }
        if (56320 <= code && code <= 57343 && idx >= 1) {
          const hi = str.charCodeAt(idx - 1);
          const low = code;
          if (55296 <= hi && hi <= 56319) {
            return (hi - 55296) * 1024 + (low - 56320) + 65536;
          }
          return low;
        }
        return code;
      }
      //
      /**
       * Private function, returns whether a break is allowed between the two given grapheme breaking classes
       * Implemented the UAX #29 3.1.1 Grapheme Cluster Boundary Rules on extended grapheme clusters
       * @param start {number}
       * @param mid {Array<number>}
       * @param end {number}
       * @param startEmoji {number}
       * @param midEmoji {Array<number>}
       * @param endEmoji {number}
       * @returns {number}
       */
      static shouldBreak(start, mid, end, startEmoji, midEmoji, endEmoji) {
        const all = [start].concat(mid).concat([end]);
        const allEmoji = [startEmoji].concat(midEmoji).concat([endEmoji]);
        const previous = all[all.length - 2];
        const next = end;
        const nextEmoji = endEmoji;
        const rIIndex = all.lastIndexOf(boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR);
        if (rIIndex > 0 && all.slice(1, rIIndex).every(function(c) {
          return c === boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR;
        }) && [boundaries_1.CLUSTER_BREAK.PREPEND, boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR].indexOf(previous) === -1) {
          if (all.filter(function(c) {
            return c === boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR;
          }).length % 2 === 1) {
            return BreakLastRegional;
          } else {
            return BreakPenultimateRegional;
          }
        }
        if (previous === boundaries_1.CLUSTER_BREAK.CR && next === boundaries_1.CLUSTER_BREAK.LF) {
          return NotBreak;
        } else if (previous === boundaries_1.CLUSTER_BREAK.CONTROL || previous === boundaries_1.CLUSTER_BREAK.CR || previous === boundaries_1.CLUSTER_BREAK.LF) {
          return BreakStart;
        } else if (next === boundaries_1.CLUSTER_BREAK.CONTROL || next === boundaries_1.CLUSTER_BREAK.CR || next === boundaries_1.CLUSTER_BREAK.LF) {
          return BreakStart;
        } else if (previous === boundaries_1.CLUSTER_BREAK.L && (next === boundaries_1.CLUSTER_BREAK.L || next === boundaries_1.CLUSTER_BREAK.V || next === boundaries_1.CLUSTER_BREAK.LV || next === boundaries_1.CLUSTER_BREAK.LVT)) {
          return NotBreak;
        } else if ((previous === boundaries_1.CLUSTER_BREAK.LV || previous === boundaries_1.CLUSTER_BREAK.V) && (next === boundaries_1.CLUSTER_BREAK.V || next === boundaries_1.CLUSTER_BREAK.T)) {
          return NotBreak;
        } else if ((previous === boundaries_1.CLUSTER_BREAK.LVT || previous === boundaries_1.CLUSTER_BREAK.T) && next === boundaries_1.CLUSTER_BREAK.T) {
          return NotBreak;
        } else if (next === boundaries_1.CLUSTER_BREAK.EXTEND || next === boundaries_1.CLUSTER_BREAK.ZWJ) {
          return NotBreak;
        } else if (next === boundaries_1.CLUSTER_BREAK.SPACINGMARK) {
          return NotBreak;
        } else if (previous === boundaries_1.CLUSTER_BREAK.PREPEND) {
          return NotBreak;
        }
        const previousNonExtendIndex = allEmoji.slice(0, -1).lastIndexOf(boundaries_1.EXTENDED_PICTOGRAPHIC);
        if (previousNonExtendIndex !== -1 && allEmoji[previousNonExtendIndex] === boundaries_1.EXTENDED_PICTOGRAPHIC && all.slice(previousNonExtendIndex + 1, -2).every(function(c) {
          return c === boundaries_1.CLUSTER_BREAK.EXTEND;
        }) && previous === boundaries_1.CLUSTER_BREAK.ZWJ && nextEmoji === boundaries_1.EXTENDED_PICTOGRAPHIC) {
          return NotBreak;
        }
        if (mid.indexOf(boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR) !== -1) {
          return Break;
        }
        if (previous === boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR && next === boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR) {
          return NotBreak;
        }
        return BreakStart;
      }
    };
    GraphemerHelper.default = GraphemerHelper$1;
    return GraphemerHelper;
  }
  var GraphemerIterator = {};
  var hasRequiredGraphemerIterator;
  function requireGraphemerIterator() {
    if (hasRequiredGraphemerIterator) return GraphemerIterator;
    hasRequiredGraphemerIterator = 1;
    Object.defineProperty(GraphemerIterator, "__esModule", { value: true });
    let GraphemerIterator$1 = class GraphemerIterator {
      constructor(str, nextBreak) {
        this._index = 0;
        this._str = str;
        this._nextBreak = nextBreak;
      }
      [Symbol.iterator]() {
        return this;
      }
      next() {
        let brk;
        if ((brk = this._nextBreak(this._str, this._index)) < this._str.length) {
          const value = this._str.slice(this._index, brk);
          this._index = brk;
          return { value, done: false };
        }
        if (this._index < this._str.length) {
          const value = this._str.slice(this._index);
          this._index = this._str.length;
          return { value, done: false };
        }
        return { value: void 0, done: true };
      }
    };
    GraphemerIterator.default = GraphemerIterator$1;
    return GraphemerIterator;
  }
  var hasRequiredGraphemer;
  function requireGraphemer() {
    if (hasRequiredGraphemer) return Graphemer;
    hasRequiredGraphemer = 1;
    var __importDefault = Graphemer && Graphemer.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(Graphemer, "__esModule", { value: true });
    const boundaries_1 = requireBoundaries();
    const GraphemerHelper_1 = __importDefault(requireGraphemerHelper());
    const GraphemerIterator_1 = __importDefault(requireGraphemerIterator());
    let Graphemer$1 = class Graphemer2 {
      /**
       * Returns the next grapheme break in the string after the given index
       * @param string {string}
       * @param index {number}
       * @returns {number}
       */
      static nextBreak(string2, index) {
        if (index === void 0) {
          index = 0;
        }
        if (index < 0) {
          return 0;
        }
        if (index >= string2.length - 1) {
          return string2.length;
        }
        const prevCP = GraphemerHelper_1.default.codePointAt(string2, index);
        const prev = Graphemer2.getGraphemeBreakProperty(prevCP);
        const prevEmoji = Graphemer2.getEmojiProperty(prevCP);
        const mid = [];
        const midEmoji = [];
        for (let i = index + 1; i < string2.length; i++) {
          if (GraphemerHelper_1.default.isSurrogate(string2, i - 1)) {
            continue;
          }
          const nextCP = GraphemerHelper_1.default.codePointAt(string2, i);
          const next = Graphemer2.getGraphemeBreakProperty(nextCP);
          const nextEmoji = Graphemer2.getEmojiProperty(nextCP);
          if (GraphemerHelper_1.default.shouldBreak(prev, mid, next, prevEmoji, midEmoji, nextEmoji)) {
            return i;
          }
          mid.push(next);
          midEmoji.push(nextEmoji);
        }
        return string2.length;
      }
      /**
       * Breaks the given string into an array of grapheme clusters
       * @param str {string}
       * @returns {string[]}
       */
      splitGraphemes(str) {
        const res = [];
        let index = 0;
        let brk;
        while ((brk = Graphemer2.nextBreak(str, index)) < str.length) {
          res.push(str.slice(index, brk));
          index = brk;
        }
        if (index < str.length) {
          res.push(str.slice(index));
        }
        return res;
      }
      /**
       * Returns an iterator of grapheme clusters in the given string
       * @param str {string}
       * @returns {GraphemerIterator}
       */
      iterateGraphemes(str) {
        return new GraphemerIterator_1.default(str, Graphemer2.nextBreak);
      }
      /**
       * Returns the number of grapheme clusters in the given string
       * @param str {string}
       * @returns {number}
       */
      countGraphemes(str) {
        let count = 0;
        let index = 0;
        let brk;
        while ((brk = Graphemer2.nextBreak(str, index)) < str.length) {
          index = brk;
          count++;
        }
        if (index < str.length) {
          count++;
        }
        return count;
      }
      /**
       * Given a Unicode code point, determines this symbol's grapheme break property
       * @param code {number} Unicode code point
       * @returns {number}
       */
      static getGraphemeBreakProperty(code) {
        if (code < 48905) {
          if (code < 44116) {
            if (code < 4141) {
              if (code < 2818) {
                if (code < 2363) {
                  if (code < 1759) {
                    if (code < 1471) {
                      if (code < 127) {
                        if (code < 11) {
                          if (code < 10) {
                            if (0 <= code && code <= 9) {
                              return boundaries_1.CLUSTER_BREAK.CONTROL;
                            }
                          } else {
                            if (10 === code) {
                              return boundaries_1.CLUSTER_BREAK.LF;
                            }
                          }
                        } else {
                          if (code < 13) {
                            if (11 <= code && code <= 12) {
                              return boundaries_1.CLUSTER_BREAK.CONTROL;
                            }
                          } else {
                            if (code < 14) {
                              if (13 === code) {
                                return boundaries_1.CLUSTER_BREAK.CR;
                              }
                            } else {
                              if (14 <= code && code <= 31) {
                                return boundaries_1.CLUSTER_BREAK.CONTROL;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 768) {
                          if (code < 173) {
                            if (127 <= code && code <= 159) {
                              return boundaries_1.CLUSTER_BREAK.CONTROL;
                            }
                          } else {
                            if (173 === code) {
                              return boundaries_1.CLUSTER_BREAK.CONTROL;
                            }
                          }
                        } else {
                          if (code < 1155) {
                            if (768 <= code && code <= 879) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 1425) {
                              if (1155 <= code && code <= 1161) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (1425 <= code && code <= 1469) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 1552) {
                        if (code < 1476) {
                          if (code < 1473) {
                            if (1471 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (1473 <= code && code <= 1474) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 1479) {
                            if (1476 <= code && code <= 1477) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 1536) {
                              if (1479 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (1536 <= code && code <= 1541) {
                                return boundaries_1.CLUSTER_BREAK.PREPEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 1648) {
                          if (code < 1564) {
                            if (1552 <= code && code <= 1562) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 1611) {
                              if (1564 === code) {
                                return boundaries_1.CLUSTER_BREAK.CONTROL;
                              }
                            } else {
                              if (1611 <= code && code <= 1631) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        } else {
                          if (code < 1750) {
                            if (1648 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 1757) {
                              if (1750 <= code && code <= 1756) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (1757 === code) {
                                return boundaries_1.CLUSTER_BREAK.PREPEND;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code < 2075) {
                      if (code < 1840) {
                        if (code < 1770) {
                          if (code < 1767) {
                            if (1759 <= code && code <= 1764) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (1767 <= code && code <= 1768) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 1807) {
                            if (1770 <= code && code <= 1773) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (1807 === code) {
                              return boundaries_1.CLUSTER_BREAK.PREPEND;
                            }
                            if (1809 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        }
                      } else {
                        if (code < 2027) {
                          if (code < 1958) {
                            if (1840 <= code && code <= 1866) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (1958 <= code && code <= 1968) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 2045) {
                            if (2027 <= code && code <= 2035) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 2070) {
                              if (2045 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (2070 <= code && code <= 2073) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 2200) {
                        if (code < 2089) {
                          if (code < 2085) {
                            if (2075 <= code && code <= 2083) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (2085 <= code && code <= 2087) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 2137) {
                            if (2089 <= code && code <= 2093) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 2192) {
                              if (2137 <= code && code <= 2139) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (2192 <= code && code <= 2193) {
                                return boundaries_1.CLUSTER_BREAK.PREPEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 2275) {
                          if (code < 2250) {
                            if (2200 <= code && code <= 2207) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 2274) {
                              if (2250 <= code && code <= 2273) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (2274 === code) {
                                return boundaries_1.CLUSTER_BREAK.PREPEND;
                              }
                            }
                          }
                        } else {
                          if (code < 2307) {
                            if (2275 <= code && code <= 2306) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (2307 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                            if (2362 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  if (code < 2561) {
                    if (code < 2434) {
                      if (code < 2381) {
                        if (code < 2366) {
                          if (2363 === code) {
                            return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                          }
                          if (2364 === code) {
                            return boundaries_1.CLUSTER_BREAK.EXTEND;
                          }
                        } else {
                          if (code < 2369) {
                            if (2366 <= code && code <= 2368) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code < 2377) {
                              if (2369 <= code && code <= 2376) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (2377 <= code && code <= 2380) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 2385) {
                          if (code < 2382) {
                            if (2381 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (2382 <= code && code <= 2383) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          }
                        } else {
                          if (code < 2402) {
                            if (2385 <= code && code <= 2391) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 2433) {
                              if (2402 <= code && code <= 2403) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (2433 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 2503) {
                        if (code < 2494) {
                          if (code < 2492) {
                            if (2434 <= code && code <= 2435) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (2492 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 2495) {
                            if (2494 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 2497) {
                              if (2495 <= code && code <= 2496) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (2497 <= code && code <= 2500) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 2519) {
                          if (code < 2507) {
                            if (2503 <= code && code <= 2504) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code < 2509) {
                              if (2507 <= code && code <= 2508) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (2509 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        } else {
                          if (code < 2530) {
                            if (2519 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 2558) {
                              if (2530 <= code && code <= 2531) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (2558 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code < 2691) {
                      if (code < 2631) {
                        if (code < 2620) {
                          if (code < 2563) {
                            if (2561 <= code && code <= 2562) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (2563 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          }
                        } else {
                          if (code < 2622) {
                            if (2620 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 2625) {
                              if (2622 <= code && code <= 2624) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (2625 <= code && code <= 2626) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 2672) {
                          if (code < 2635) {
                            if (2631 <= code && code <= 2632) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 2641) {
                              if (2635 <= code && code <= 2637) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (2641 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        } else {
                          if (code < 2677) {
                            if (2672 <= code && code <= 2673) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 2689) {
                              if (2677 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (2689 <= code && code <= 2690) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 2761) {
                        if (code < 2750) {
                          if (2691 === code) {
                            return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                          }
                          if (2748 === code) {
                            return boundaries_1.CLUSTER_BREAK.EXTEND;
                          }
                        } else {
                          if (code < 2753) {
                            if (2750 <= code && code <= 2752) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code < 2759) {
                              if (2753 <= code && code <= 2757) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (2759 <= code && code <= 2760) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 2786) {
                          if (code < 2763) {
                            if (2761 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code < 2765) {
                              if (2763 <= code && code <= 2764) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (2765 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        } else {
                          if (code < 2810) {
                            if (2786 <= code && code <= 2787) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 2817) {
                              if (2810 <= code && code <= 2815) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (2817 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              } else {
                if (code < 3315) {
                  if (code < 3076) {
                    if (code < 2946) {
                      if (code < 2887) {
                        if (code < 2878) {
                          if (code < 2876) {
                            if (2818 <= code && code <= 2819) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (2876 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 2880) {
                            if (2878 <= code && code <= 2879) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 2881) {
                              if (2880 === code) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (2881 <= code && code <= 2884) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 2893) {
                          if (code < 2891) {
                            if (2887 <= code && code <= 2888) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (2891 <= code && code <= 2892) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          }
                        } else {
                          if (code < 2901) {
                            if (2893 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 2914) {
                              if (2901 <= code && code <= 2903) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (2914 <= code && code <= 2915) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 3014) {
                        if (code < 3007) {
                          if (2946 === code) {
                            return boundaries_1.CLUSTER_BREAK.EXTEND;
                          }
                          if (3006 === code) {
                            return boundaries_1.CLUSTER_BREAK.EXTEND;
                          }
                        } else {
                          if (code < 3008) {
                            if (3007 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code < 3009) {
                              if (3008 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (3009 <= code && code <= 3010) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 3031) {
                          if (code < 3018) {
                            if (3014 <= code && code <= 3016) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code < 3021) {
                              if (3018 <= code && code <= 3020) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (3021 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        } else {
                          if (code < 3072) {
                            if (3031 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 3073) {
                              if (3072 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (3073 <= code && code <= 3075) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code < 3262) {
                      if (code < 3146) {
                        if (code < 3134) {
                          if (3076 === code) {
                            return boundaries_1.CLUSTER_BREAK.EXTEND;
                          }
                          if (3132 === code) {
                            return boundaries_1.CLUSTER_BREAK.EXTEND;
                          }
                        } else {
                          if (code < 3137) {
                            if (3134 <= code && code <= 3136) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 3142) {
                              if (3137 <= code && code <= 3140) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (3142 <= code && code <= 3144) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 3201) {
                          if (code < 3157) {
                            if (3146 <= code && code <= 3149) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 3170) {
                              if (3157 <= code && code <= 3158) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (3170 <= code && code <= 3171) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        } else {
                          if (code < 3202) {
                            if (3201 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 3260) {
                              if (3202 <= code && code <= 3203) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (3260 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 3270) {
                        if (code < 3264) {
                          if (3262 === code) {
                            return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                          }
                          if (3263 === code) {
                            return boundaries_1.CLUSTER_BREAK.EXTEND;
                          }
                        } else {
                          if (code < 3266) {
                            if (3264 <= code && code <= 3265) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code < 3267) {
                              if (3266 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (3267 <= code && code <= 3268) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 3276) {
                          if (code < 3271) {
                            if (3270 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 3274) {
                              if (3271 <= code && code <= 3272) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (3274 <= code && code <= 3275) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        } else {
                          if (code < 3285) {
                            if (3276 <= code && code <= 3277) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 3298) {
                              if (3285 <= code && code <= 3286) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (3298 <= code && code <= 3299) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  if (code < 3551) {
                    if (code < 3406) {
                      if (code < 3391) {
                        if (code < 3330) {
                          if (code < 3328) {
                            if (3315 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (3328 <= code && code <= 3329) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 3387) {
                            if (3330 <= code && code <= 3331) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code < 3390) {
                              if (3387 <= code && code <= 3388) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (3390 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 3398) {
                          if (code < 3393) {
                            if (3391 <= code && code <= 3392) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (3393 <= code && code <= 3396) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 3402) {
                            if (3398 <= code && code <= 3400) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code < 3405) {
                              if (3402 <= code && code <= 3404) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (3405 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 3530) {
                        if (code < 3426) {
                          if (3406 === code) {
                            return boundaries_1.CLUSTER_BREAK.PREPEND;
                          }
                          if (3415 === code) {
                            return boundaries_1.CLUSTER_BREAK.EXTEND;
                          }
                        } else {
                          if (code < 3457) {
                            if (3426 <= code && code <= 3427) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 3458) {
                              if (3457 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (3458 <= code && code <= 3459) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 3538) {
                          if (code < 3535) {
                            if (3530 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 3536) {
                              if (3535 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (3536 <= code && code <= 3537) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        } else {
                          if (code < 3542) {
                            if (3538 <= code && code <= 3540) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 3544) {
                              if (3542 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (3544 <= code && code <= 3550) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code < 3893) {
                      if (code < 3655) {
                        if (code < 3633) {
                          if (code < 3570) {
                            if (3551 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (3570 <= code && code <= 3571) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          }
                        } else {
                          if (code < 3635) {
                            if (3633 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 3636) {
                              if (3635 === code) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (3636 <= code && code <= 3642) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 3764) {
                          if (code < 3761) {
                            if (3655 <= code && code <= 3662) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (3761 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                            if (3763 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          }
                        } else {
                          if (code < 3784) {
                            if (3764 <= code && code <= 3772) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 3864) {
                              if (3784 <= code && code <= 3790) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (3864 <= code && code <= 3865) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 3967) {
                        if (code < 3897) {
                          if (3893 === code) {
                            return boundaries_1.CLUSTER_BREAK.EXTEND;
                          }
                          if (3895 === code) {
                            return boundaries_1.CLUSTER_BREAK.EXTEND;
                          }
                        } else {
                          if (code < 3902) {
                            if (3897 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 3953) {
                              if (3902 <= code && code <= 3903) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (3953 <= code && code <= 3966) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 3981) {
                          if (code < 3968) {
                            if (3967 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code < 3974) {
                              if (3968 <= code && code <= 3972) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (3974 <= code && code <= 3975) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        } else {
                          if (code < 3993) {
                            if (3981 <= code && code <= 3991) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 4038) {
                              if (3993 <= code && code <= 4028) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (4038 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            } else {
              if (code < 7204) {
                if (code < 6448) {
                  if (code < 5938) {
                    if (code < 4226) {
                      if (code < 4157) {
                        if (code < 4146) {
                          if (code < 4145) {
                            if (4141 <= code && code <= 4144) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (4145 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          }
                        } else {
                          if (code < 4153) {
                            if (4146 <= code && code <= 4151) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 4155) {
                              if (4153 <= code && code <= 4154) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (4155 <= code && code <= 4156) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 4184) {
                          if (code < 4182) {
                            if (4157 <= code && code <= 4158) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (4182 <= code && code <= 4183) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          }
                        } else {
                          if (code < 4190) {
                            if (4184 <= code && code <= 4185) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 4209) {
                              if (4190 <= code && code <= 4192) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (4209 <= code && code <= 4212) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 4352) {
                        if (code < 4229) {
                          if (4226 === code) {
                            return boundaries_1.CLUSTER_BREAK.EXTEND;
                          }
                          if (4228 === code) {
                            return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                          }
                        } else {
                          if (code < 4237) {
                            if (4229 <= code && code <= 4230) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (4237 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                            if (4253 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        }
                      } else {
                        if (code < 4957) {
                          if (code < 4448) {
                            if (4352 <= code && code <= 4447) {
                              return boundaries_1.CLUSTER_BREAK.L;
                            }
                          } else {
                            if (code < 4520) {
                              if (4448 <= code && code <= 4519) {
                                return boundaries_1.CLUSTER_BREAK.V;
                              }
                            } else {
                              if (4520 <= code && code <= 4607) {
                                return boundaries_1.CLUSTER_BREAK.T;
                              }
                            }
                          }
                        } else {
                          if (code < 5906) {
                            if (4957 <= code && code <= 4959) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 5909) {
                              if (5906 <= code && code <= 5908) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (5909 === code) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code < 6089) {
                      if (code < 6070) {
                        if (code < 5970) {
                          if (code < 5940) {
                            if (5938 <= code && code <= 5939) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (5940 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          }
                        } else {
                          if (code < 6002) {
                            if (5970 <= code && code <= 5971) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 6068) {
                              if (6002 <= code && code <= 6003) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (6068 <= code && code <= 6069) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 6078) {
                          if (code < 6071) {
                            if (6070 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (6071 <= code && code <= 6077) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 6086) {
                            if (6078 <= code && code <= 6085) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code < 6087) {
                              if (6086 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (6087 <= code && code <= 6088) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 6277) {
                        if (code < 6155) {
                          if (code < 6109) {
                            if (6089 <= code && code <= 6099) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (6109 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 6158) {
                            if (6155 <= code && code <= 6157) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (6158 === code) {
                              return boundaries_1.CLUSTER_BREAK.CONTROL;
                            }
                            if (6159 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        }
                      } else {
                        if (code < 6435) {
                          if (code < 6313) {
                            if (6277 <= code && code <= 6278) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 6432) {
                              if (6313 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (6432 <= code && code <= 6434) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        } else {
                          if (code < 6439) {
                            if (6435 <= code && code <= 6438) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code < 6441) {
                              if (6439 <= code && code <= 6440) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (6441 <= code && code <= 6443) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  if (code < 6971) {
                    if (code < 6744) {
                      if (code < 6681) {
                        if (code < 6451) {
                          if (code < 6450) {
                            if (6448 <= code && code <= 6449) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (6450 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 6457) {
                            if (6451 <= code && code <= 6456) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code < 6679) {
                              if (6457 <= code && code <= 6459) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (6679 <= code && code <= 6680) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 6741) {
                          if (code < 6683) {
                            if (6681 <= code && code <= 6682) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (6683 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 6742) {
                            if (6741 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (6742 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                            if (6743 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 6771) {
                        if (code < 6754) {
                          if (code < 6752) {
                            if (6744 <= code && code <= 6750) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (6752 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 6757) {
                            if (6754 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 6765) {
                              if (6757 <= code && code <= 6764) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (6765 <= code && code <= 6770) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 6912) {
                          if (code < 6783) {
                            if (6771 <= code && code <= 6780) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 6832) {
                              if (6783 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (6832 <= code && code <= 6862) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        } else {
                          if (code < 6916) {
                            if (6912 <= code && code <= 6915) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 6964) {
                              if (6916 === code) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (6964 <= code && code <= 6970) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code < 7080) {
                      if (code < 7019) {
                        if (code < 6973) {
                          if (6971 === code) {
                            return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                          }
                          if (6972 === code) {
                            return boundaries_1.CLUSTER_BREAK.EXTEND;
                          }
                        } else {
                          if (code < 6978) {
                            if (6973 <= code && code <= 6977) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code < 6979) {
                              if (6978 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (6979 <= code && code <= 6980) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 7073) {
                          if (code < 7040) {
                            if (7019 <= code && code <= 7027) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 7042) {
                              if (7040 <= code && code <= 7041) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (7042 === code) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        } else {
                          if (code < 7074) {
                            if (7073 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code < 7078) {
                              if (7074 <= code && code <= 7077) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (7078 <= code && code <= 7079) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 7144) {
                        if (code < 7083) {
                          if (code < 7082) {
                            if (7080 <= code && code <= 7081) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (7082 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          }
                        } else {
                          if (code < 7142) {
                            if (7083 <= code && code <= 7085) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (7142 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                            if (7143 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          }
                        }
                      } else {
                        if (code < 7150) {
                          if (code < 7146) {
                            if (7144 <= code && code <= 7145) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 7149) {
                              if (7146 <= code && code <= 7148) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (7149 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        } else {
                          if (code < 7151) {
                            if (7150 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code < 7154) {
                              if (7151 <= code && code <= 7153) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (7154 <= code && code <= 7155) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              } else {
                if (code < 43346) {
                  if (code < 11647) {
                    if (code < 7415) {
                      if (code < 7380) {
                        if (code < 7220) {
                          if (code < 7212) {
                            if (7204 <= code && code <= 7211) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (7212 <= code && code <= 7219) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 7222) {
                            if (7220 <= code && code <= 7221) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code < 7376) {
                              if (7222 <= code && code <= 7223) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (7376 <= code && code <= 7378) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 7394) {
                          if (code < 7393) {
                            if (7380 <= code && code <= 7392) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (7393 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          }
                        } else {
                          if (code < 7405) {
                            if (7394 <= code && code <= 7400) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (7405 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                            if (7412 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 8205) {
                        if (code < 7616) {
                          if (code < 7416) {
                            if (7415 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (7416 <= code && code <= 7417) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 8203) {
                            if (7616 <= code && code <= 7679) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (8203 === code) {
                              return boundaries_1.CLUSTER_BREAK.CONTROL;
                            }
                            if (8204 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        }
                      } else {
                        if (code < 8288) {
                          if (code < 8206) {
                            if (8205 === code) {
                              return boundaries_1.CLUSTER_BREAK.ZWJ;
                            }
                          } else {
                            if (code < 8232) {
                              if (8206 <= code && code <= 8207) {
                                return boundaries_1.CLUSTER_BREAK.CONTROL;
                              }
                            } else {
                              if (8232 <= code && code <= 8238) {
                                return boundaries_1.CLUSTER_BREAK.CONTROL;
                              }
                            }
                          }
                        } else {
                          if (code < 8400) {
                            if (8288 <= code && code <= 8303) {
                              return boundaries_1.CLUSTER_BREAK.CONTROL;
                            }
                          } else {
                            if (code < 11503) {
                              if (8400 <= code && code <= 8432) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (11503 <= code && code <= 11505) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code < 43043) {
                      if (code < 42612) {
                        if (code < 12330) {
                          if (code < 11744) {
                            if (11647 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (11744 <= code && code <= 11775) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 12441) {
                            if (12330 <= code && code <= 12335) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 42607) {
                              if (12441 <= code && code <= 12442) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (42607 <= code && code <= 42610) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 43010) {
                          if (code < 42654) {
                            if (42612 <= code && code <= 42621) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 42736) {
                              if (42654 <= code && code <= 42655) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (42736 <= code && code <= 42737) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        } else {
                          if (code < 43014) {
                            if (43010 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (43014 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                            if (43019 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 43188) {
                        if (code < 43047) {
                          if (code < 43045) {
                            if (43043 <= code && code <= 43044) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (43045 <= code && code <= 43046) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 43052) {
                            if (43047 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code < 43136) {
                              if (43052 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (43136 <= code && code <= 43137) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 43263) {
                          if (code < 43204) {
                            if (43188 <= code && code <= 43203) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code < 43232) {
                              if (43204 <= code && code <= 43205) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (43232 <= code && code <= 43249) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        } else {
                          if (code < 43302) {
                            if (43263 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 43335) {
                              if (43302 <= code && code <= 43309) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (43335 <= code && code <= 43345) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  if (code < 43698) {
                    if (code < 43493) {
                      if (code < 43444) {
                        if (code < 43392) {
                          if (code < 43360) {
                            if (43346 <= code && code <= 43347) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (43360 <= code && code <= 43388) {
                              return boundaries_1.CLUSTER_BREAK.L;
                            }
                          }
                        } else {
                          if (code < 43395) {
                            if (43392 <= code && code <= 43394) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (43395 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                            if (43443 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        }
                      } else {
                        if (code < 43450) {
                          if (code < 43446) {
                            if (43444 <= code && code <= 43445) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (43446 <= code && code <= 43449) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 43452) {
                            if (43450 <= code && code <= 43451) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code < 43454) {
                              if (43452 <= code && code <= 43453) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (43454 <= code && code <= 43456) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 43573) {
                        if (code < 43567) {
                          if (code < 43561) {
                            if (43493 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (43561 <= code && code <= 43566) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 43569) {
                            if (43567 <= code && code <= 43568) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code < 43571) {
                              if (43569 <= code && code <= 43570) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (43571 <= code && code <= 43572) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 43597) {
                          if (code < 43587) {
                            if (43573 <= code && code <= 43574) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (43587 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                            if (43596 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 43644) {
                            if (43597 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (43644 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                            if (43696 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code < 44006) {
                      if (code < 43756) {
                        if (code < 43710) {
                          if (code < 43703) {
                            if (43698 <= code && code <= 43700) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (43703 <= code && code <= 43704) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 43713) {
                            if (43710 <= code && code <= 43711) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (43713 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                            if (43755 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          }
                        }
                      } else {
                        if (code < 43766) {
                          if (code < 43758) {
                            if (43756 <= code && code <= 43757) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 43765) {
                              if (43758 <= code && code <= 43759) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (43765 === code) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        } else {
                          if (code < 44003) {
                            if (43766 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 44005) {
                              if (44003 <= code && code <= 44004) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (44005 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 44032) {
                        if (code < 44009) {
                          if (code < 44008) {
                            if (44006 <= code && code <= 44007) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (44008 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 44012) {
                            if (44009 <= code && code <= 44010) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (44012 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                            if (44013 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        }
                      } else {
                        if (code < 44061) {
                          if (code < 44033) {
                            if (44032 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 44060) {
                              if (44033 <= code && code <= 44059) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (44060 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code < 44088) {
                            if (44061 <= code && code <= 44087) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 44089) {
                              if (44088 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (44089 <= code && code <= 44115) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          } else {
            if (code < 46497) {
              if (code < 45293) {
                if (code < 44704) {
                  if (code < 44397) {
                    if (code < 44256) {
                      if (code < 44173) {
                        if (code < 44144) {
                          if (code < 44117) {
                            if (44116 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (44117 <= code && code <= 44143) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 44145) {
                            if (44144 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 44172) {
                              if (44145 <= code && code <= 44171) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (44172 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 44201) {
                          if (code < 44200) {
                            if (44173 <= code && code <= 44199) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (44200 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 44228) {
                            if (44201 <= code && code <= 44227) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 44229) {
                              if (44228 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (44229 <= code && code <= 44255) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 44313) {
                        if (code < 44284) {
                          if (code < 44257) {
                            if (44256 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (44257 <= code && code <= 44283) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 44285) {
                            if (44284 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 44312) {
                              if (44285 <= code && code <= 44311) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (44312 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 44368) {
                          if (code < 44340) {
                            if (44313 <= code && code <= 44339) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 44341) {
                              if (44340 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (44341 <= code && code <= 44367) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code < 44369) {
                            if (44368 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 44396) {
                              if (44369 <= code && code <= 44395) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (44396 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code < 44537) {
                      if (code < 44480) {
                        if (code < 44425) {
                          if (code < 44424) {
                            if (44397 <= code && code <= 44423) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (44424 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 44452) {
                            if (44425 <= code && code <= 44451) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 44453) {
                              if (44452 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (44453 <= code && code <= 44479) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 44508) {
                          if (code < 44481) {
                            if (44480 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (44481 <= code && code <= 44507) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 44509) {
                            if (44508 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 44536) {
                              if (44509 <= code && code <= 44535) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (44536 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 44620) {
                        if (code < 44565) {
                          if (code < 44564) {
                            if (44537 <= code && code <= 44563) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (44564 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 44592) {
                            if (44565 <= code && code <= 44591) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 44593) {
                              if (44592 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (44593 <= code && code <= 44619) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 44649) {
                          if (code < 44621) {
                            if (44620 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 44648) {
                              if (44621 <= code && code <= 44647) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (44648 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code < 44676) {
                            if (44649 <= code && code <= 44675) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 44677) {
                              if (44676 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (44677 <= code && code <= 44703) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  if (code < 44985) {
                    if (code < 44844) {
                      if (code < 44761) {
                        if (code < 44732) {
                          if (code < 44705) {
                            if (44704 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (44705 <= code && code <= 44731) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 44733) {
                            if (44732 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 44760) {
                              if (44733 <= code && code <= 44759) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (44760 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 44789) {
                          if (code < 44788) {
                            if (44761 <= code && code <= 44787) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (44788 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 44816) {
                            if (44789 <= code && code <= 44815) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 44817) {
                              if (44816 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (44817 <= code && code <= 44843) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 44901) {
                        if (code < 44872) {
                          if (code < 44845) {
                            if (44844 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (44845 <= code && code <= 44871) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 44873) {
                            if (44872 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 44900) {
                              if (44873 <= code && code <= 44899) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (44900 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 44956) {
                          if (code < 44928) {
                            if (44901 <= code && code <= 44927) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 44929) {
                              if (44928 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (44929 <= code && code <= 44955) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code < 44957) {
                            if (44956 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 44984) {
                              if (44957 <= code && code <= 44983) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (44984 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code < 45152) {
                      if (code < 45068) {
                        if (code < 45013) {
                          if (code < 45012) {
                            if (44985 <= code && code <= 45011) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (45012 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 45040) {
                            if (45013 <= code && code <= 45039) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 45041) {
                              if (45040 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (45041 <= code && code <= 45067) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 45097) {
                          if (code < 45069) {
                            if (45068 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 45096) {
                              if (45069 <= code && code <= 45095) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (45096 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code < 45124) {
                            if (45097 <= code && code <= 45123) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 45125) {
                              if (45124 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (45125 <= code && code <= 45151) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 45209) {
                        if (code < 45180) {
                          if (code < 45153) {
                            if (45152 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (45153 <= code && code <= 45179) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 45181) {
                            if (45180 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 45208) {
                              if (45181 <= code && code <= 45207) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (45208 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 45264) {
                          if (code < 45236) {
                            if (45209 <= code && code <= 45235) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 45237) {
                              if (45236 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (45237 <= code && code <= 45263) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code < 45265) {
                            if (45264 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 45292) {
                              if (45265 <= code && code <= 45291) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (45292 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              } else {
                if (code < 45908) {
                  if (code < 45600) {
                    if (code < 45433) {
                      if (code < 45376) {
                        if (code < 45321) {
                          if (code < 45320) {
                            if (45293 <= code && code <= 45319) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (45320 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 45348) {
                            if (45321 <= code && code <= 45347) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 45349) {
                              if (45348 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (45349 <= code && code <= 45375) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 45404) {
                          if (code < 45377) {
                            if (45376 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (45377 <= code && code <= 45403) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 45405) {
                            if (45404 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 45432) {
                              if (45405 <= code && code <= 45431) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (45432 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 45516) {
                        if (code < 45461) {
                          if (code < 45460) {
                            if (45433 <= code && code <= 45459) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (45460 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 45488) {
                            if (45461 <= code && code <= 45487) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 45489) {
                              if (45488 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (45489 <= code && code <= 45515) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 45545) {
                          if (code < 45517) {
                            if (45516 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 45544) {
                              if (45517 <= code && code <= 45543) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (45544 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code < 45572) {
                            if (45545 <= code && code <= 45571) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 45573) {
                              if (45572 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (45573 <= code && code <= 45599) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code < 45741) {
                      if (code < 45657) {
                        if (code < 45628) {
                          if (code < 45601) {
                            if (45600 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (45601 <= code && code <= 45627) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 45629) {
                            if (45628 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 45656) {
                              if (45629 <= code && code <= 45655) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (45656 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 45712) {
                          if (code < 45684) {
                            if (45657 <= code && code <= 45683) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 45685) {
                              if (45684 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (45685 <= code && code <= 45711) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code < 45713) {
                            if (45712 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 45740) {
                              if (45713 <= code && code <= 45739) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (45740 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 45824) {
                        if (code < 45769) {
                          if (code < 45768) {
                            if (45741 <= code && code <= 45767) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (45768 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 45796) {
                            if (45769 <= code && code <= 45795) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 45797) {
                              if (45796 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (45797 <= code && code <= 45823) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 45853) {
                          if (code < 45825) {
                            if (45824 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 45852) {
                              if (45825 <= code && code <= 45851) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (45852 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code < 45880) {
                            if (45853 <= code && code <= 45879) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 45881) {
                              if (45880 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (45881 <= code && code <= 45907) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  if (code < 46189) {
                    if (code < 46048) {
                      if (code < 45965) {
                        if (code < 45936) {
                          if (code < 45909) {
                            if (45908 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (45909 <= code && code <= 45935) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 45937) {
                            if (45936 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 45964) {
                              if (45937 <= code && code <= 45963) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (45964 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 45993) {
                          if (code < 45992) {
                            if (45965 <= code && code <= 45991) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (45992 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 46020) {
                            if (45993 <= code && code <= 46019) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 46021) {
                              if (46020 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (46021 <= code && code <= 46047) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 46105) {
                        if (code < 46076) {
                          if (code < 46049) {
                            if (46048 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (46049 <= code && code <= 46075) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 46077) {
                            if (46076 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 46104) {
                              if (46077 <= code && code <= 46103) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (46104 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 46160) {
                          if (code < 46132) {
                            if (46105 <= code && code <= 46131) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 46133) {
                              if (46132 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (46133 <= code && code <= 46159) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code < 46161) {
                            if (46160 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 46188) {
                              if (46161 <= code && code <= 46187) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (46188 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code < 46356) {
                      if (code < 46272) {
                        if (code < 46217) {
                          if (code < 46216) {
                            if (46189 <= code && code <= 46215) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (46216 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 46244) {
                            if (46217 <= code && code <= 46243) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 46245) {
                              if (46244 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (46245 <= code && code <= 46271) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 46301) {
                          if (code < 46273) {
                            if (46272 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 46300) {
                              if (46273 <= code && code <= 46299) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (46300 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code < 46328) {
                            if (46301 <= code && code <= 46327) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 46329) {
                              if (46328 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (46329 <= code && code <= 46355) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 46413) {
                        if (code < 46384) {
                          if (code < 46357) {
                            if (46356 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (46357 <= code && code <= 46383) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 46385) {
                            if (46384 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 46412) {
                              if (46385 <= code && code <= 46411) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (46412 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 46468) {
                          if (code < 46440) {
                            if (46413 <= code && code <= 46439) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 46441) {
                              if (46440 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (46441 <= code && code <= 46467) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code < 46469) {
                            if (46468 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 46496) {
                              if (46469 <= code && code <= 46495) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (46496 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            } else {
              if (code < 47701) {
                if (code < 47112) {
                  if (code < 46804) {
                    if (code < 46637) {
                      if (code < 46580) {
                        if (code < 46525) {
                          if (code < 46524) {
                            if (46497 <= code && code <= 46523) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (46524 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 46552) {
                            if (46525 <= code && code <= 46551) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 46553) {
                              if (46552 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (46553 <= code && code <= 46579) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 46608) {
                          if (code < 46581) {
                            if (46580 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (46581 <= code && code <= 46607) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 46609) {
                            if (46608 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 46636) {
                              if (46609 <= code && code <= 46635) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (46636 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 46720) {
                        if (code < 46665) {
                          if (code < 46664) {
                            if (46637 <= code && code <= 46663) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (46664 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 46692) {
                            if (46665 <= code && code <= 46691) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 46693) {
                              if (46692 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (46693 <= code && code <= 46719) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 46749) {
                          if (code < 46721) {
                            if (46720 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 46748) {
                              if (46721 <= code && code <= 46747) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (46748 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code < 46776) {
                            if (46749 <= code && code <= 46775) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 46777) {
                              if (46776 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (46777 <= code && code <= 46803) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code < 46945) {
                      if (code < 46861) {
                        if (code < 46832) {
                          if (code < 46805) {
                            if (46804 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (46805 <= code && code <= 46831) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 46833) {
                            if (46832 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 46860) {
                              if (46833 <= code && code <= 46859) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (46860 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 46916) {
                          if (code < 46888) {
                            if (46861 <= code && code <= 46887) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 46889) {
                              if (46888 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (46889 <= code && code <= 46915) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code < 46917) {
                            if (46916 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 46944) {
                              if (46917 <= code && code <= 46943) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (46944 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 47028) {
                        if (code < 46973) {
                          if (code < 46972) {
                            if (46945 <= code && code <= 46971) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (46972 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 47e3) {
                            if (46973 <= code && code <= 46999) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 47001) {
                              if (47e3 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (47001 <= code && code <= 47027) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 47057) {
                          if (code < 47029) {
                            if (47028 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 47056) {
                              if (47029 <= code && code <= 47055) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (47056 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code < 47084) {
                            if (47057 <= code && code <= 47083) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 47085) {
                              if (47084 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (47085 <= code && code <= 47111) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  if (code < 47393) {
                    if (code < 47252) {
                      if (code < 47169) {
                        if (code < 47140) {
                          if (code < 47113) {
                            if (47112 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (47113 <= code && code <= 47139) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 47141) {
                            if (47140 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 47168) {
                              if (47141 <= code && code <= 47167) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (47168 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 47197) {
                          if (code < 47196) {
                            if (47169 <= code && code <= 47195) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (47196 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 47224) {
                            if (47197 <= code && code <= 47223) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 47225) {
                              if (47224 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (47225 <= code && code <= 47251) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 47309) {
                        if (code < 47280) {
                          if (code < 47253) {
                            if (47252 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (47253 <= code && code <= 47279) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 47281) {
                            if (47280 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 47308) {
                              if (47281 <= code && code <= 47307) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (47308 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 47364) {
                          if (code < 47336) {
                            if (47309 <= code && code <= 47335) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 47337) {
                              if (47336 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (47337 <= code && code <= 47363) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code < 47365) {
                            if (47364 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 47392) {
                              if (47365 <= code && code <= 47391) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (47392 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code < 47560) {
                      if (code < 47476) {
                        if (code < 47421) {
                          if (code < 47420) {
                            if (47393 <= code && code <= 47419) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (47420 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 47448) {
                            if (47421 <= code && code <= 47447) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 47449) {
                              if (47448 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (47449 <= code && code <= 47475) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 47505) {
                          if (code < 47477) {
                            if (47476 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 47504) {
                              if (47477 <= code && code <= 47503) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (47504 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code < 47532) {
                            if (47505 <= code && code <= 47531) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 47533) {
                              if (47532 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (47533 <= code && code <= 47559) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 47617) {
                        if (code < 47588) {
                          if (code < 47561) {
                            if (47560 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (47561 <= code && code <= 47587) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 47589) {
                            if (47588 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 47616) {
                              if (47589 <= code && code <= 47615) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (47616 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 47672) {
                          if (code < 47644) {
                            if (47617 <= code && code <= 47643) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 47645) {
                              if (47644 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (47645 <= code && code <= 47671) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code < 47673) {
                            if (47672 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 47700) {
                              if (47673 <= code && code <= 47699) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (47700 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              } else {
                if (code < 48316) {
                  if (code < 48008) {
                    if (code < 47841) {
                      if (code < 47784) {
                        if (code < 47729) {
                          if (code < 47728) {
                            if (47701 <= code && code <= 47727) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (47728 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 47756) {
                            if (47729 <= code && code <= 47755) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 47757) {
                              if (47756 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (47757 <= code && code <= 47783) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 47812) {
                          if (code < 47785) {
                            if (47784 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (47785 <= code && code <= 47811) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 47813) {
                            if (47812 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 47840) {
                              if (47813 <= code && code <= 47839) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (47840 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 47924) {
                        if (code < 47869) {
                          if (code < 47868) {
                            if (47841 <= code && code <= 47867) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (47868 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 47896) {
                            if (47869 <= code && code <= 47895) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 47897) {
                              if (47896 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (47897 <= code && code <= 47923) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 47953) {
                          if (code < 47925) {
                            if (47924 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 47952) {
                              if (47925 <= code && code <= 47951) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (47952 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code < 47980) {
                            if (47953 <= code && code <= 47979) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 47981) {
                              if (47980 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (47981 <= code && code <= 48007) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code < 48149) {
                      if (code < 48065) {
                        if (code < 48036) {
                          if (code < 48009) {
                            if (48008 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (48009 <= code && code <= 48035) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 48037) {
                            if (48036 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 48064) {
                              if (48037 <= code && code <= 48063) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (48064 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 48120) {
                          if (code < 48092) {
                            if (48065 <= code && code <= 48091) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 48093) {
                              if (48092 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (48093 <= code && code <= 48119) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code < 48121) {
                            if (48120 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 48148) {
                              if (48121 <= code && code <= 48147) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (48148 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 48232) {
                        if (code < 48177) {
                          if (code < 48176) {
                            if (48149 <= code && code <= 48175) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (48176 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 48204) {
                            if (48177 <= code && code <= 48203) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 48205) {
                              if (48204 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (48205 <= code && code <= 48231) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 48261) {
                          if (code < 48233) {
                            if (48232 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 48260) {
                              if (48233 <= code && code <= 48259) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (48260 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code < 48288) {
                            if (48261 <= code && code <= 48287) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 48289) {
                              if (48288 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (48289 <= code && code <= 48315) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  if (code < 48597) {
                    if (code < 48456) {
                      if (code < 48373) {
                        if (code < 48344) {
                          if (code < 48317) {
                            if (48316 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (48317 <= code && code <= 48343) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 48345) {
                            if (48344 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 48372) {
                              if (48345 <= code && code <= 48371) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (48372 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 48401) {
                          if (code < 48400) {
                            if (48373 <= code && code <= 48399) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (48400 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 48428) {
                            if (48401 <= code && code <= 48427) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 48429) {
                              if (48428 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (48429 <= code && code <= 48455) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 48513) {
                        if (code < 48484) {
                          if (code < 48457) {
                            if (48456 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (48457 <= code && code <= 48483) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 48485) {
                            if (48484 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 48512) {
                              if (48485 <= code && code <= 48511) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (48512 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 48568) {
                          if (code < 48540) {
                            if (48513 <= code && code <= 48539) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 48541) {
                              if (48540 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (48541 <= code && code <= 48567) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code < 48569) {
                            if (48568 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 48596) {
                              if (48569 <= code && code <= 48595) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (48596 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code < 48764) {
                      if (code < 48680) {
                        if (code < 48625) {
                          if (code < 48624) {
                            if (48597 <= code && code <= 48623) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (48624 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 48652) {
                            if (48625 <= code && code <= 48651) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 48653) {
                              if (48652 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (48653 <= code && code <= 48679) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 48709) {
                          if (code < 48681) {
                            if (48680 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 48708) {
                              if (48681 <= code && code <= 48707) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (48708 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code < 48736) {
                            if (48709 <= code && code <= 48735) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 48737) {
                              if (48736 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (48737 <= code && code <= 48763) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 48821) {
                        if (code < 48792) {
                          if (code < 48765) {
                            if (48764 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (48765 <= code && code <= 48791) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 48793) {
                            if (48792 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 48820) {
                              if (48793 <= code && code <= 48819) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (48820 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 48876) {
                          if (code < 48848) {
                            if (48821 <= code && code <= 48847) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 48849) {
                              if (48848 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (48849 <= code && code <= 48875) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code < 48877) {
                            if (48876 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 48904) {
                              if (48877 <= code && code <= 48903) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (48904 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        } else {
          if (code < 53720) {
            if (code < 51312) {
              if (code < 50108) {
                if (code < 49493) {
                  if (code < 49212) {
                    if (code < 49045) {
                      if (code < 48988) {
                        if (code < 48933) {
                          if (code < 48932) {
                            if (48905 <= code && code <= 48931) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (48932 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 48960) {
                            if (48933 <= code && code <= 48959) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 48961) {
                              if (48960 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (48961 <= code && code <= 48987) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 49016) {
                          if (code < 48989) {
                            if (48988 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (48989 <= code && code <= 49015) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 49017) {
                            if (49016 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 49044) {
                              if (49017 <= code && code <= 49043) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (49044 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 49128) {
                        if (code < 49073) {
                          if (code < 49072) {
                            if (49045 <= code && code <= 49071) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (49072 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 49100) {
                            if (49073 <= code && code <= 49099) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 49101) {
                              if (49100 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (49101 <= code && code <= 49127) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 49157) {
                          if (code < 49129) {
                            if (49128 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 49156) {
                              if (49129 <= code && code <= 49155) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (49156 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code < 49184) {
                            if (49157 <= code && code <= 49183) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 49185) {
                              if (49184 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (49185 <= code && code <= 49211) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code < 49352) {
                      if (code < 49269) {
                        if (code < 49240) {
                          if (code < 49213) {
                            if (49212 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (49213 <= code && code <= 49239) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 49241) {
                            if (49240 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 49268) {
                              if (49241 <= code && code <= 49267) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (49268 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 49297) {
                          if (code < 49296) {
                            if (49269 <= code && code <= 49295) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (49296 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 49324) {
                            if (49297 <= code && code <= 49323) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 49325) {
                              if (49324 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (49325 <= code && code <= 49351) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 49409) {
                        if (code < 49380) {
                          if (code < 49353) {
                            if (49352 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (49353 <= code && code <= 49379) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 49381) {
                            if (49380 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 49408) {
                              if (49381 <= code && code <= 49407) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (49408 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 49464) {
                          if (code < 49436) {
                            if (49409 <= code && code <= 49435) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 49437) {
                              if (49436 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (49437 <= code && code <= 49463) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code < 49465) {
                            if (49464 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 49492) {
                              if (49465 <= code && code <= 49491) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (49492 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  if (code < 49800) {
                    if (code < 49633) {
                      if (code < 49576) {
                        if (code < 49521) {
                          if (code < 49520) {
                            if (49493 <= code && code <= 49519) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (49520 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 49548) {
                            if (49521 <= code && code <= 49547) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 49549) {
                              if (49548 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (49549 <= code && code <= 49575) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 49604) {
                          if (code < 49577) {
                            if (49576 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (49577 <= code && code <= 49603) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 49605) {
                            if (49604 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 49632) {
                              if (49605 <= code && code <= 49631) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (49632 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 49716) {
                        if (code < 49661) {
                          if (code < 49660) {
                            if (49633 <= code && code <= 49659) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (49660 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 49688) {
                            if (49661 <= code && code <= 49687) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 49689) {
                              if (49688 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (49689 <= code && code <= 49715) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 49745) {
                          if (code < 49717) {
                            if (49716 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 49744) {
                              if (49717 <= code && code <= 49743) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (49744 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code < 49772) {
                            if (49745 <= code && code <= 49771) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 49773) {
                              if (49772 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (49773 <= code && code <= 49799) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code < 49941) {
                      if (code < 49857) {
                        if (code < 49828) {
                          if (code < 49801) {
                            if (49800 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (49801 <= code && code <= 49827) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 49829) {
                            if (49828 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 49856) {
                              if (49829 <= code && code <= 49855) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (49856 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 49912) {
                          if (code < 49884) {
                            if (49857 <= code && code <= 49883) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 49885) {
                              if (49884 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (49885 <= code && code <= 49911) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code < 49913) {
                            if (49912 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 49940) {
                              if (49913 <= code && code <= 49939) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (49940 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 50024) {
                        if (code < 49969) {
                          if (code < 49968) {
                            if (49941 <= code && code <= 49967) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (49968 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 49996) {
                            if (49969 <= code && code <= 49995) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 49997) {
                              if (49996 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (49997 <= code && code <= 50023) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 50053) {
                          if (code < 50025) {
                            if (50024 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 50052) {
                              if (50025 <= code && code <= 50051) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (50052 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code < 50080) {
                            if (50053 <= code && code <= 50079) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 50081) {
                              if (50080 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (50081 <= code && code <= 50107) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              } else {
                if (code < 50697) {
                  if (code < 50389) {
                    if (code < 50248) {
                      if (code < 50165) {
                        if (code < 50136) {
                          if (code < 50109) {
                            if (50108 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (50109 <= code && code <= 50135) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 50137) {
                            if (50136 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 50164) {
                              if (50137 <= code && code <= 50163) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (50164 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 50193) {
                          if (code < 50192) {
                            if (50165 <= code && code <= 50191) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (50192 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 50220) {
                            if (50193 <= code && code <= 50219) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 50221) {
                              if (50220 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (50221 <= code && code <= 50247) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 50305) {
                        if (code < 50276) {
                          if (code < 50249) {
                            if (50248 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (50249 <= code && code <= 50275) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 50277) {
                            if (50276 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 50304) {
                              if (50277 <= code && code <= 50303) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (50304 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 50360) {
                          if (code < 50332) {
                            if (50305 <= code && code <= 50331) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 50333) {
                              if (50332 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (50333 <= code && code <= 50359) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code < 50361) {
                            if (50360 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 50388) {
                              if (50361 <= code && code <= 50387) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (50388 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code < 50556) {
                      if (code < 50472) {
                        if (code < 50417) {
                          if (code < 50416) {
                            if (50389 <= code && code <= 50415) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (50416 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 50444) {
                            if (50417 <= code && code <= 50443) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 50445) {
                              if (50444 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (50445 <= code && code <= 50471) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 50501) {
                          if (code < 50473) {
                            if (50472 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 50500) {
                              if (50473 <= code && code <= 50499) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (50500 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code < 50528) {
                            if (50501 <= code && code <= 50527) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 50529) {
                              if (50528 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (50529 <= code && code <= 50555) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 50613) {
                        if (code < 50584) {
                          if (code < 50557) {
                            if (50556 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (50557 <= code && code <= 50583) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 50585) {
                            if (50584 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 50612) {
                              if (50585 <= code && code <= 50611) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (50612 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 50668) {
                          if (code < 50640) {
                            if (50613 <= code && code <= 50639) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 50641) {
                              if (50640 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (50641 <= code && code <= 50667) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code < 50669) {
                            if (50668 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 50696) {
                              if (50669 <= code && code <= 50695) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (50696 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  if (code < 51004) {
                    if (code < 50837) {
                      if (code < 50780) {
                        if (code < 50725) {
                          if (code < 50724) {
                            if (50697 <= code && code <= 50723) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (50724 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 50752) {
                            if (50725 <= code && code <= 50751) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 50753) {
                              if (50752 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (50753 <= code && code <= 50779) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 50808) {
                          if (code < 50781) {
                            if (50780 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (50781 <= code && code <= 50807) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 50809) {
                            if (50808 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 50836) {
                              if (50809 <= code && code <= 50835) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (50836 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 50920) {
                        if (code < 50865) {
                          if (code < 50864) {
                            if (50837 <= code && code <= 50863) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (50864 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 50892) {
                            if (50865 <= code && code <= 50891) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 50893) {
                              if (50892 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (50893 <= code && code <= 50919) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 50949) {
                          if (code < 50921) {
                            if (50920 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 50948) {
                              if (50921 <= code && code <= 50947) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (50948 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code < 50976) {
                            if (50949 <= code && code <= 50975) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 50977) {
                              if (50976 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (50977 <= code && code <= 51003) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code < 51145) {
                      if (code < 51061) {
                        if (code < 51032) {
                          if (code < 51005) {
                            if (51004 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (51005 <= code && code <= 51031) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 51033) {
                            if (51032 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 51060) {
                              if (51033 <= code && code <= 51059) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (51060 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 51116) {
                          if (code < 51088) {
                            if (51061 <= code && code <= 51087) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 51089) {
                              if (51088 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (51089 <= code && code <= 51115) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code < 51117) {
                            if (51116 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 51144) {
                              if (51117 <= code && code <= 51143) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (51144 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 51228) {
                        if (code < 51173) {
                          if (code < 51172) {
                            if (51145 <= code && code <= 51171) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (51172 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 51200) {
                            if (51173 <= code && code <= 51199) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 51201) {
                              if (51200 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (51201 <= code && code <= 51227) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 51257) {
                          if (code < 51229) {
                            if (51228 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 51256) {
                              if (51229 <= code && code <= 51255) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (51256 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code < 51284) {
                            if (51257 <= code && code <= 51283) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 51285) {
                              if (51284 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (51285 <= code && code <= 51311) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            } else {
              if (code < 52516) {
                if (code < 51901) {
                  if (code < 51593) {
                    if (code < 51452) {
                      if (code < 51369) {
                        if (code < 51340) {
                          if (code < 51313) {
                            if (51312 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (51313 <= code && code <= 51339) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 51341) {
                            if (51340 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 51368) {
                              if (51341 <= code && code <= 51367) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (51368 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 51397) {
                          if (code < 51396) {
                            if (51369 <= code && code <= 51395) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (51396 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 51424) {
                            if (51397 <= code && code <= 51423) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 51425) {
                              if (51424 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (51425 <= code && code <= 51451) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 51509) {
                        if (code < 51480) {
                          if (code < 51453) {
                            if (51452 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (51453 <= code && code <= 51479) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 51481) {
                            if (51480 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 51508) {
                              if (51481 <= code && code <= 51507) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (51508 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 51564) {
                          if (code < 51536) {
                            if (51509 <= code && code <= 51535) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 51537) {
                              if (51536 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (51537 <= code && code <= 51563) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code < 51565) {
                            if (51564 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 51592) {
                              if (51565 <= code && code <= 51591) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (51592 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code < 51760) {
                      if (code < 51676) {
                        if (code < 51621) {
                          if (code < 51620) {
                            if (51593 <= code && code <= 51619) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (51620 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 51648) {
                            if (51621 <= code && code <= 51647) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 51649) {
                              if (51648 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (51649 <= code && code <= 51675) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 51705) {
                          if (code < 51677) {
                            if (51676 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 51704) {
                              if (51677 <= code && code <= 51703) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (51704 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code < 51732) {
                            if (51705 <= code && code <= 51731) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 51733) {
                              if (51732 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (51733 <= code && code <= 51759) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 51817) {
                        if (code < 51788) {
                          if (code < 51761) {
                            if (51760 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (51761 <= code && code <= 51787) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 51789) {
                            if (51788 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 51816) {
                              if (51789 <= code && code <= 51815) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (51816 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 51872) {
                          if (code < 51844) {
                            if (51817 <= code && code <= 51843) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 51845) {
                              if (51844 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (51845 <= code && code <= 51871) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code < 51873) {
                            if (51872 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 51900) {
                              if (51873 <= code && code <= 51899) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (51900 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  if (code < 52208) {
                    if (code < 52041) {
                      if (code < 51984) {
                        if (code < 51929) {
                          if (code < 51928) {
                            if (51901 <= code && code <= 51927) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (51928 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 51956) {
                            if (51929 <= code && code <= 51955) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 51957) {
                              if (51956 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (51957 <= code && code <= 51983) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 52012) {
                          if (code < 51985) {
                            if (51984 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (51985 <= code && code <= 52011) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 52013) {
                            if (52012 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 52040) {
                              if (52013 <= code && code <= 52039) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (52040 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 52124) {
                        if (code < 52069) {
                          if (code < 52068) {
                            if (52041 <= code && code <= 52067) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (52068 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 52096) {
                            if (52069 <= code && code <= 52095) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 52097) {
                              if (52096 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (52097 <= code && code <= 52123) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 52153) {
                          if (code < 52125) {
                            if (52124 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 52152) {
                              if (52125 <= code && code <= 52151) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (52152 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code < 52180) {
                            if (52153 <= code && code <= 52179) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 52181) {
                              if (52180 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (52181 <= code && code <= 52207) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code < 52349) {
                      if (code < 52265) {
                        if (code < 52236) {
                          if (code < 52209) {
                            if (52208 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (52209 <= code && code <= 52235) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 52237) {
                            if (52236 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 52264) {
                              if (52237 <= code && code <= 52263) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (52264 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 52320) {
                          if (code < 52292) {
                            if (52265 <= code && code <= 52291) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 52293) {
                              if (52292 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (52293 <= code && code <= 52319) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code < 52321) {
                            if (52320 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 52348) {
                              if (52321 <= code && code <= 52347) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (52348 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 52432) {
                        if (code < 52377) {
                          if (code < 52376) {
                            if (52349 <= code && code <= 52375) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (52376 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 52404) {
                            if (52377 <= code && code <= 52403) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 52405) {
                              if (52404 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (52405 <= code && code <= 52431) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 52461) {
                          if (code < 52433) {
                            if (52432 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 52460) {
                              if (52433 <= code && code <= 52459) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (52460 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code < 52488) {
                            if (52461 <= code && code <= 52487) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 52489) {
                              if (52488 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (52489 <= code && code <= 52515) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              } else {
                if (code < 53105) {
                  if (code < 52797) {
                    if (code < 52656) {
                      if (code < 52573) {
                        if (code < 52544) {
                          if (code < 52517) {
                            if (52516 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (52517 <= code && code <= 52543) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 52545) {
                            if (52544 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 52572) {
                              if (52545 <= code && code <= 52571) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (52572 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 52601) {
                          if (code < 52600) {
                            if (52573 <= code && code <= 52599) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (52600 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 52628) {
                            if (52601 <= code && code <= 52627) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 52629) {
                              if (52628 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (52629 <= code && code <= 52655) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 52713) {
                        if (code < 52684) {
                          if (code < 52657) {
                            if (52656 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (52657 <= code && code <= 52683) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 52685) {
                            if (52684 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 52712) {
                              if (52685 <= code && code <= 52711) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (52712 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 52768) {
                          if (code < 52740) {
                            if (52713 <= code && code <= 52739) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 52741) {
                              if (52740 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (52741 <= code && code <= 52767) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code < 52769) {
                            if (52768 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 52796) {
                              if (52769 <= code && code <= 52795) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (52796 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code < 52964) {
                      if (code < 52880) {
                        if (code < 52825) {
                          if (code < 52824) {
                            if (52797 <= code && code <= 52823) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (52824 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 52852) {
                            if (52825 <= code && code <= 52851) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 52853) {
                              if (52852 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (52853 <= code && code <= 52879) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 52909) {
                          if (code < 52881) {
                            if (52880 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 52908) {
                              if (52881 <= code && code <= 52907) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (52908 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code < 52936) {
                            if (52909 <= code && code <= 52935) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 52937) {
                              if (52936 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (52937 <= code && code <= 52963) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 53021) {
                        if (code < 52992) {
                          if (code < 52965) {
                            if (52964 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (52965 <= code && code <= 52991) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 52993) {
                            if (52992 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 53020) {
                              if (52993 <= code && code <= 53019) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (53020 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 53076) {
                          if (code < 53048) {
                            if (53021 <= code && code <= 53047) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 53049) {
                              if (53048 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (53049 <= code && code <= 53075) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code < 53077) {
                            if (53076 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 53104) {
                              if (53077 <= code && code <= 53103) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (53104 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  if (code < 53412) {
                    if (code < 53245) {
                      if (code < 53188) {
                        if (code < 53133) {
                          if (code < 53132) {
                            if (53105 <= code && code <= 53131) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (53132 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 53160) {
                            if (53133 <= code && code <= 53159) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 53161) {
                              if (53160 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (53161 <= code && code <= 53187) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 53216) {
                          if (code < 53189) {
                            if (53188 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (53189 <= code && code <= 53215) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 53217) {
                            if (53216 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 53244) {
                              if (53217 <= code && code <= 53243) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (53244 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 53328) {
                        if (code < 53273) {
                          if (code < 53272) {
                            if (53245 <= code && code <= 53271) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (53272 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 53300) {
                            if (53273 <= code && code <= 53299) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 53301) {
                              if (53300 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (53301 <= code && code <= 53327) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 53357) {
                          if (code < 53329) {
                            if (53328 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 53356) {
                              if (53329 <= code && code <= 53355) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (53356 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code < 53384) {
                            if (53357 <= code && code <= 53383) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 53385) {
                              if (53384 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (53385 <= code && code <= 53411) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code < 53553) {
                      if (code < 53469) {
                        if (code < 53440) {
                          if (code < 53413) {
                            if (53412 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (53413 <= code && code <= 53439) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 53441) {
                            if (53440 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 53468) {
                              if (53441 <= code && code <= 53467) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (53468 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 53524) {
                          if (code < 53496) {
                            if (53469 <= code && code <= 53495) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 53497) {
                              if (53496 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (53497 <= code && code <= 53523) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code < 53525) {
                            if (53524 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 53552) {
                              if (53525 <= code && code <= 53551) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (53552 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 53636) {
                        if (code < 53581) {
                          if (code < 53580) {
                            if (53553 <= code && code <= 53579) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (53580 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 53608) {
                            if (53581 <= code && code <= 53607) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 53609) {
                              if (53608 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (53609 <= code && code <= 53635) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 53665) {
                          if (code < 53637) {
                            if (53636 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 53664) {
                              if (53637 <= code && code <= 53663) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (53664 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code < 53692) {
                            if (53665 <= code && code <= 53691) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 53693) {
                              if (53692 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (53693 <= code && code <= 53719) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          } else {
            if (code < 70459) {
              if (code < 54897) {
                if (code < 54308) {
                  if (code < 54001) {
                    if (code < 53860) {
                      if (code < 53777) {
                        if (code < 53748) {
                          if (code < 53721) {
                            if (53720 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (53721 <= code && code <= 53747) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 53749) {
                            if (53748 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 53776) {
                              if (53749 <= code && code <= 53775) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (53776 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 53805) {
                          if (code < 53804) {
                            if (53777 <= code && code <= 53803) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (53804 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 53832) {
                            if (53805 <= code && code <= 53831) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 53833) {
                              if (53832 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (53833 <= code && code <= 53859) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 53917) {
                        if (code < 53888) {
                          if (code < 53861) {
                            if (53860 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (53861 <= code && code <= 53887) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 53889) {
                            if (53888 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 53916) {
                              if (53889 <= code && code <= 53915) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (53916 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 53972) {
                          if (code < 53944) {
                            if (53917 <= code && code <= 53943) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 53945) {
                              if (53944 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (53945 <= code && code <= 53971) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code < 53973) {
                            if (53972 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 54e3) {
                              if (53973 <= code && code <= 53999) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (54e3 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code < 54141) {
                      if (code < 54084) {
                        if (code < 54029) {
                          if (code < 54028) {
                            if (54001 <= code && code <= 54027) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (54028 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 54056) {
                            if (54029 <= code && code <= 54055) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 54057) {
                              if (54056 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (54057 <= code && code <= 54083) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 54112) {
                          if (code < 54085) {
                            if (54084 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (54085 <= code && code <= 54111) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 54113) {
                            if (54112 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 54140) {
                              if (54113 <= code && code <= 54139) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (54140 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 54224) {
                        if (code < 54169) {
                          if (code < 54168) {
                            if (54141 <= code && code <= 54167) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (54168 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 54196) {
                            if (54169 <= code && code <= 54195) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 54197) {
                              if (54196 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (54197 <= code && code <= 54223) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 54253) {
                          if (code < 54225) {
                            if (54224 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 54252) {
                              if (54225 <= code && code <= 54251) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (54252 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code < 54280) {
                            if (54253 <= code && code <= 54279) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 54281) {
                              if (54280 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (54281 <= code && code <= 54307) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  if (code < 54589) {
                    if (code < 54448) {
                      if (code < 54365) {
                        if (code < 54336) {
                          if (code < 54309) {
                            if (54308 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (54309 <= code && code <= 54335) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 54337) {
                            if (54336 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 54364) {
                              if (54337 <= code && code <= 54363) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (54364 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 54393) {
                          if (code < 54392) {
                            if (54365 <= code && code <= 54391) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (54392 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 54420) {
                            if (54393 <= code && code <= 54419) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 54421) {
                              if (54420 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (54421 <= code && code <= 54447) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 54505) {
                        if (code < 54476) {
                          if (code < 54449) {
                            if (54448 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (54449 <= code && code <= 54475) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 54477) {
                            if (54476 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 54504) {
                              if (54477 <= code && code <= 54503) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (54504 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 54560) {
                          if (code < 54532) {
                            if (54505 <= code && code <= 54531) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 54533) {
                              if (54532 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (54533 <= code && code <= 54559) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code < 54561) {
                            if (54560 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 54588) {
                              if (54561 <= code && code <= 54587) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (54588 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code < 54756) {
                      if (code < 54672) {
                        if (code < 54617) {
                          if (code < 54616) {
                            if (54589 <= code && code <= 54615) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (54616 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 54644) {
                            if (54617 <= code && code <= 54643) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 54645) {
                              if (54644 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (54645 <= code && code <= 54671) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 54701) {
                          if (code < 54673) {
                            if (54672 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 54700) {
                              if (54673 <= code && code <= 54699) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (54700 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code < 54728) {
                            if (54701 <= code && code <= 54727) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 54729) {
                              if (54728 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (54729 <= code && code <= 54755) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 54813) {
                        if (code < 54784) {
                          if (code < 54757) {
                            if (54756 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (54757 <= code && code <= 54783) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 54785) {
                            if (54784 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 54812) {
                              if (54785 <= code && code <= 54811) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (54812 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 54868) {
                          if (code < 54840) {
                            if (54813 <= code && code <= 54839) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 54841) {
                              if (54840 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (54841 <= code && code <= 54867) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code < 54869) {
                            if (54868 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 54896) {
                              if (54869 <= code && code <= 54895) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (54896 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              } else {
                if (code < 69632) {
                  if (code < 55216) {
                    if (code < 55037) {
                      if (code < 54980) {
                        if (code < 54925) {
                          if (code < 54924) {
                            if (54897 <= code && code <= 54923) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (54924 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 54952) {
                            if (54925 <= code && code <= 54951) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 54953) {
                              if (54952 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (54953 <= code && code <= 54979) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 55008) {
                          if (code < 54981) {
                            if (54980 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (54981 <= code && code <= 55007) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 55009) {
                            if (55008 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 55036) {
                              if (55009 <= code && code <= 55035) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (55036 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 55120) {
                        if (code < 55065) {
                          if (code < 55064) {
                            if (55037 <= code && code <= 55063) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (55064 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 55092) {
                            if (55065 <= code && code <= 55091) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 55093) {
                              if (55092 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (55093 <= code && code <= 55119) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 55149) {
                          if (code < 55121) {
                            if (55120 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 55148) {
                              if (55121 <= code && code <= 55147) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (55148 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code < 55176) {
                            if (55149 <= code && code <= 55175) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 55177) {
                              if (55176 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (55177 <= code && code <= 55203) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code < 68097) {
                      if (code < 65279) {
                        if (code < 64286) {
                          if (code < 55243) {
                            if (55216 <= code && code <= 55238) {
                              return boundaries_1.CLUSTER_BREAK.V;
                            }
                          } else {
                            if (55243 <= code && code <= 55291) {
                              return boundaries_1.CLUSTER_BREAK.T;
                            }
                          }
                        } else {
                          if (code < 65024) {
                            if (64286 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 65056) {
                              if (65024 <= code && code <= 65039) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (65056 <= code && code <= 65071) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 66045) {
                          if (code < 65438) {
                            if (65279 === code) {
                              return boundaries_1.CLUSTER_BREAK.CONTROL;
                            }
                          } else {
                            if (code < 65520) {
                              if (65438 <= code && code <= 65439) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (65520 <= code && code <= 65531) {
                                return boundaries_1.CLUSTER_BREAK.CONTROL;
                              }
                            }
                          }
                        } else {
                          if (code < 66272) {
                            if (66045 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 66422) {
                              if (66272 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (66422 <= code && code <= 66426) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 68325) {
                        if (code < 68108) {
                          if (code < 68101) {
                            if (68097 <= code && code <= 68099) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (68101 <= code && code <= 68102) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 68152) {
                            if (68108 <= code && code <= 68111) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 68159) {
                              if (68152 <= code && code <= 68154) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (68159 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 69373) {
                          if (code < 68900) {
                            if (68325 <= code && code <= 68326) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 69291) {
                              if (68900 <= code && code <= 68903) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (69291 <= code && code <= 69292) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        } else {
                          if (code < 69446) {
                            if (69373 <= code && code <= 69375) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 69506) {
                              if (69446 <= code && code <= 69456) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (69506 <= code && code <= 69509) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  if (code < 70016) {
                    if (code < 69815) {
                      if (code < 69747) {
                        if (code < 69634) {
                          if (69632 === code) {
                            return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                          }
                          if (69633 === code) {
                            return boundaries_1.CLUSTER_BREAK.EXTEND;
                          }
                        } else {
                          if (code < 69688) {
                            if (69634 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code < 69744) {
                              if (69688 <= code && code <= 69702) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (69744 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 69762) {
                          if (code < 69759) {
                            if (69747 <= code && code <= 69748) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (69759 <= code && code <= 69761) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 69808) {
                            if (69762 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code < 69811) {
                              if (69808 <= code && code <= 69810) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (69811 <= code && code <= 69814) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 69888) {
                        if (code < 69821) {
                          if (code < 69817) {
                            if (69815 <= code && code <= 69816) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (69817 <= code && code <= 69818) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 69826) {
                            if (69821 === code) {
                              return boundaries_1.CLUSTER_BREAK.PREPEND;
                            }
                          } else {
                            if (69826 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                            if (69837 === code) {
                              return boundaries_1.CLUSTER_BREAK.PREPEND;
                            }
                          }
                        }
                      } else {
                        if (code < 69933) {
                          if (code < 69927) {
                            if (69888 <= code && code <= 69890) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 69932) {
                              if (69927 <= code && code <= 69931) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (69932 === code) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        } else {
                          if (code < 69957) {
                            if (69933 <= code && code <= 69940) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 70003) {
                              if (69957 <= code && code <= 69958) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (70003 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code < 70194) {
                      if (code < 70082) {
                        if (code < 70067) {
                          if (code < 70018) {
                            if (70016 <= code && code <= 70017) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (70018 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          }
                        } else {
                          if (code < 70070) {
                            if (70067 <= code && code <= 70069) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code < 70079) {
                              if (70070 <= code && code <= 70078) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (70079 <= code && code <= 70080) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 70095) {
                          if (code < 70089) {
                            if (70082 <= code && code <= 70083) {
                              return boundaries_1.CLUSTER_BREAK.PREPEND;
                            }
                          } else {
                            if (code < 70094) {
                              if (70089 <= code && code <= 70092) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (70094 === code) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        } else {
                          if (code < 70188) {
                            if (70095 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 70191) {
                              if (70188 <= code && code <= 70190) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (70191 <= code && code <= 70193) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 70209) {
                        if (code < 70197) {
                          if (code < 70196) {
                            if (70194 <= code && code <= 70195) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (70196 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 70198) {
                            if (70197 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code < 70206) {
                              if (70198 <= code && code <= 70199) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (70206 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 70371) {
                          if (code < 70367) {
                            if (70209 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 70368) {
                              if (70367 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (70368 <= code && code <= 70370) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        } else {
                          if (code < 70400) {
                            if (70371 <= code && code <= 70378) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 70402) {
                              if (70400 <= code && code <= 70401) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (70402 <= code && code <= 70403) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            } else {
              if (code < 72343) {
                if (code < 71339) {
                  if (code < 70841) {
                    if (code < 70512) {
                      if (code < 70471) {
                        if (code < 70463) {
                          if (code < 70462) {
                            if (70459 <= code && code <= 70460) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (70462 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 70464) {
                            if (70463 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code < 70465) {
                              if (70464 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (70465 <= code && code <= 70468) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 70487) {
                          if (code < 70475) {
                            if (70471 <= code && code <= 70472) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (70475 <= code && code <= 70477) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          }
                        } else {
                          if (code < 70498) {
                            if (70487 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 70502) {
                              if (70498 <= code && code <= 70499) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (70502 <= code && code <= 70508) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 70725) {
                        if (code < 70712) {
                          if (code < 70709) {
                            if (70512 <= code && code <= 70516) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (70709 <= code && code <= 70711) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          }
                        } else {
                          if (code < 70720) {
                            if (70712 <= code && code <= 70719) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 70722) {
                              if (70720 <= code && code <= 70721) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (70722 <= code && code <= 70724) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 70832) {
                          if (code < 70726) {
                            if (70725 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (70726 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                            if (70750 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 70833) {
                            if (70832 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 70835) {
                              if (70833 <= code && code <= 70834) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (70835 <= code && code <= 70840) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code < 71096) {
                      if (code < 70847) {
                        if (code < 70843) {
                          if (70841 === code) {
                            return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                          }
                          if (70842 === code) {
                            return boundaries_1.CLUSTER_BREAK.EXTEND;
                          }
                        } else {
                          if (code < 70845) {
                            if (70843 <= code && code <= 70844) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (70845 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                            if (70846 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          }
                        }
                      } else {
                        if (code < 71087) {
                          if (code < 70849) {
                            if (70847 <= code && code <= 70848) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 70850) {
                              if (70849 === code) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (70850 <= code && code <= 70851) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        } else {
                          if (code < 71088) {
                            if (71087 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 71090) {
                              if (71088 <= code && code <= 71089) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (71090 <= code && code <= 71093) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 71216) {
                        if (code < 71102) {
                          if (code < 71100) {
                            if (71096 <= code && code <= 71099) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (71100 <= code && code <= 71101) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 71103) {
                            if (71102 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code < 71132) {
                              if (71103 <= code && code <= 71104) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (71132 <= code && code <= 71133) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 71229) {
                          if (code < 71219) {
                            if (71216 <= code && code <= 71218) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code < 71227) {
                              if (71219 <= code && code <= 71226) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (71227 <= code && code <= 71228) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        } else {
                          if (code < 71230) {
                            if (71229 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 71231) {
                              if (71230 === code) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (71231 <= code && code <= 71232) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  if (code < 71999) {
                    if (code < 71463) {
                      if (code < 71350) {
                        if (code < 71341) {
                          if (71339 === code) {
                            return boundaries_1.CLUSTER_BREAK.EXTEND;
                          }
                          if (71340 === code) {
                            return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                          }
                        } else {
                          if (code < 71342) {
                            if (71341 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 71344) {
                              if (71342 <= code && code <= 71343) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (71344 <= code && code <= 71349) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 71453) {
                          if (71350 === code) {
                            return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                          }
                          if (71351 === code) {
                            return boundaries_1.CLUSTER_BREAK.EXTEND;
                          }
                        } else {
                          if (code < 71458) {
                            if (71453 <= code && code <= 71455) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 71462) {
                              if (71458 <= code && code <= 71461) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (71462 === code) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 71984) {
                        if (code < 71727) {
                          if (code < 71724) {
                            if (71463 <= code && code <= 71467) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (71724 <= code && code <= 71726) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          }
                        } else {
                          if (code < 71736) {
                            if (71727 <= code && code <= 71735) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 71737) {
                              if (71736 === code) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (71737 <= code && code <= 71738) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 71995) {
                          if (code < 71985) {
                            if (71984 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 71991) {
                              if (71985 <= code && code <= 71989) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (71991 <= code && code <= 71992) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        } else {
                          if (code < 71997) {
                            if (71995 <= code && code <= 71996) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (71997 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                            if (71998 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code < 72193) {
                      if (code < 72145) {
                        if (code < 72001) {
                          if (71999 === code) {
                            return boundaries_1.CLUSTER_BREAK.PREPEND;
                          }
                          if (72e3 === code) {
                            return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                          }
                        } else {
                          if (code < 72002) {
                            if (72001 === code) {
                              return boundaries_1.CLUSTER_BREAK.PREPEND;
                            }
                          } else {
                            if (72002 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                            if (72003 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        }
                      } else {
                        if (code < 72156) {
                          if (code < 72148) {
                            if (72145 <= code && code <= 72147) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code < 72154) {
                              if (72148 <= code && code <= 72151) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (72154 <= code && code <= 72155) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        } else {
                          if (code < 72160) {
                            if (72156 <= code && code <= 72159) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (72160 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                            if (72164 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 72263) {
                        if (code < 72249) {
                          if (code < 72243) {
                            if (72193 <= code && code <= 72202) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (72243 <= code && code <= 72248) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 72250) {
                            if (72249 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code < 72251) {
                              if (72250 === code) {
                                return boundaries_1.CLUSTER_BREAK.PREPEND;
                              }
                            } else {
                              if (72251 <= code && code <= 72254) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 72281) {
                          if (code < 72273) {
                            if (72263 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 72279) {
                              if (72273 <= code && code <= 72278) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (72279 <= code && code <= 72280) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        } else {
                          if (code < 72324) {
                            if (72281 <= code && code <= 72283) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 72330) {
                              if (72324 <= code && code <= 72329) {
                                return boundaries_1.CLUSTER_BREAK.PREPEND;
                              }
                            } else {
                              if (72330 <= code && code <= 72342) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              } else {
                if (code < 94033) {
                  if (code < 73104) {
                    if (code < 72881) {
                      if (code < 72766) {
                        if (code < 72751) {
                          if (code < 72344) {
                            if (72343 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (72344 <= code && code <= 72345) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 72752) {
                            if (72751 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code < 72760) {
                              if (72752 <= code && code <= 72758) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (72760 <= code && code <= 72765) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 72850) {
                          if (72766 === code) {
                            return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                          }
                          if (72767 === code) {
                            return boundaries_1.CLUSTER_BREAK.EXTEND;
                          }
                        } else {
                          if (code < 72873) {
                            if (72850 <= code && code <= 72871) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 72874) {
                              if (72873 === code) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (72874 <= code && code <= 72880) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 73018) {
                        if (code < 72884) {
                          if (code < 72882) {
                            if (72881 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (72882 <= code && code <= 72883) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 72885) {
                            if (72884 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code < 73009) {
                              if (72885 <= code && code <= 72886) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (73009 <= code && code <= 73014) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 73030) {
                          if (code < 73020) {
                            if (73018 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 73023) {
                              if (73020 <= code && code <= 73021) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (73023 <= code && code <= 73029) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        } else {
                          if (code < 73031) {
                            if (73030 === code) {
                              return boundaries_1.CLUSTER_BREAK.PREPEND;
                            }
                          } else {
                            if (code < 73098) {
                              if (73031 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (73098 <= code && code <= 73102) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code < 73526) {
                      if (code < 73459) {
                        if (code < 73109) {
                          if (code < 73107) {
                            if (73104 <= code && code <= 73105) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (73107 <= code && code <= 73108) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          }
                        } else {
                          if (code < 73110) {
                            if (73109 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (73110 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                            if (73111 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        }
                      } else {
                        if (code < 73474) {
                          if (code < 73461) {
                            if (73459 <= code && code <= 73460) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 73472) {
                              if (73461 <= code && code <= 73462) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (73472 <= code && code <= 73473) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        } else {
                          if (code < 73475) {
                            if (73474 === code) {
                              return boundaries_1.CLUSTER_BREAK.PREPEND;
                            }
                          } else {
                            if (code < 73524) {
                              if (73475 === code) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (73524 <= code && code <= 73525) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 78896) {
                        if (code < 73536) {
                          if (code < 73534) {
                            if (73526 <= code && code <= 73530) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (73534 <= code && code <= 73535) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          }
                        } else {
                          if (code < 73537) {
                            if (73536 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (73537 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                            if (73538 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        }
                      } else {
                        if (code < 92912) {
                          if (code < 78912) {
                            if (78896 <= code && code <= 78911) {
                              return boundaries_1.CLUSTER_BREAK.CONTROL;
                            }
                          } else {
                            if (code < 78919) {
                              if (78912 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (78919 <= code && code <= 78933) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        } else {
                          if (code < 92976) {
                            if (92912 <= code && code <= 92916) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 94031) {
                              if (92976 <= code && code <= 92982) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (94031 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  if (code < 121476) {
                    if (code < 119143) {
                      if (code < 113824) {
                        if (code < 94180) {
                          if (code < 94095) {
                            if (94033 <= code && code <= 94087) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (94095 <= code && code <= 94098) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 94192) {
                            if (94180 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 113821) {
                              if (94192 <= code && code <= 94193) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (113821 <= code && code <= 113822) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 118576) {
                          if (code < 118528) {
                            if (113824 <= code && code <= 113827) {
                              return boundaries_1.CLUSTER_BREAK.CONTROL;
                            }
                          } else {
                            if (118528 <= code && code <= 118573) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 119141) {
                            if (118576 <= code && code <= 118598) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (119141 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                            if (119142 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 119173) {
                        if (code < 119150) {
                          if (code < 119149) {
                            if (119143 <= code && code <= 119145) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (119149 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          }
                        } else {
                          if (code < 119155) {
                            if (119150 <= code && code <= 119154) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 119163) {
                              if (119155 <= code && code <= 119162) {
                                return boundaries_1.CLUSTER_BREAK.CONTROL;
                              }
                            } else {
                              if (119163 <= code && code <= 119170) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 121344) {
                          if (code < 119210) {
                            if (119173 <= code && code <= 119179) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 119362) {
                              if (119210 <= code && code <= 119213) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (119362 <= code && code <= 119364) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        } else {
                          if (code < 121403) {
                            if (121344 <= code && code <= 121398) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 121461) {
                              if (121403 <= code && code <= 121452) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (121461 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code < 123628) {
                      if (code < 122907) {
                        if (code < 121505) {
                          if (code < 121499) {
                            if (121476 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (121499 <= code && code <= 121503) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 122880) {
                            if (121505 <= code && code <= 121519) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 122888) {
                              if (122880 <= code && code <= 122886) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (122888 <= code && code <= 122904) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 123023) {
                          if (code < 122915) {
                            if (122907 <= code && code <= 122913) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 122918) {
                              if (122915 <= code && code <= 122916) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (122918 <= code && code <= 122922) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        } else {
                          if (code < 123184) {
                            if (123023 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 123566) {
                              if (123184 <= code && code <= 123190) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (123566 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 127995) {
                        if (code < 125136) {
                          if (code < 124140) {
                            if (123628 <= code && code <= 123631) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (124140 <= code && code <= 124143) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 125252) {
                            if (125136 <= code && code <= 125142) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 127462) {
                              if (125252 <= code && code <= 125258) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (127462 <= code && code <= 127487) {
                                return boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 917632) {
                          if (code < 917504) {
                            if (127995 <= code && code <= 127999) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 917536) {
                              if (917504 <= code && code <= 917535) {
                                return boundaries_1.CLUSTER_BREAK.CONTROL;
                              }
                            } else {
                              if (917536 <= code && code <= 917631) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        } else {
                          if (code < 917760) {
                            if (917632 <= code && code <= 917759) {
                              return boundaries_1.CLUSTER_BREAK.CONTROL;
                            }
                          } else {
                            if (code < 918e3) {
                              if (917760 <= code && code <= 917999) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (918e3 <= code && code <= 921599) {
                                return boundaries_1.CLUSTER_BREAK.CONTROL;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        return boundaries_1.CLUSTER_BREAK.OTHER;
      }
      /**
       * Given a Unicode code point, returns if symbol is an extended pictographic or some other break
       * @param code {number} Unicode code point
       * @returns {number}
       */
      static getEmojiProperty(code) {
        if (code < 10160) {
          if (code < 9728) {
            if (code < 9e3) {
              if (code < 8482) {
                if (code < 8252) {
                  if (169 === code) {
                    return boundaries_1.EXTENDED_PICTOGRAPHIC;
                  }
                  if (174 === code) {
                    return boundaries_1.EXTENDED_PICTOGRAPHIC;
                  }
                } else {
                  if (8252 === code) {
                    return boundaries_1.EXTENDED_PICTOGRAPHIC;
                  }
                  if (8265 === code) {
                    return boundaries_1.EXTENDED_PICTOGRAPHIC;
                  }
                }
              } else {
                if (code < 8596) {
                  if (8482 === code) {
                    return boundaries_1.EXTENDED_PICTOGRAPHIC;
                  }
                  if (8505 === code) {
                    return boundaries_1.EXTENDED_PICTOGRAPHIC;
                  }
                } else {
                  if (code < 8617) {
                    if (8596 <= code && code <= 8601) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (code < 8986) {
                      if (8617 <= code && code <= 8618) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    } else {
                      if (8986 <= code && code <= 8987) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    }
                  }
                }
              }
            } else {
              if (code < 9410) {
                if (code < 9167) {
                  if (9e3 === code) {
                    return boundaries_1.EXTENDED_PICTOGRAPHIC;
                  }
                  if (9096 === code) {
                    return boundaries_1.EXTENDED_PICTOGRAPHIC;
                  }
                } else {
                  if (code < 9193) {
                    if (9167 === code) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (code < 9208) {
                      if (9193 <= code && code <= 9203) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    } else {
                      if (9208 <= code && code <= 9210) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    }
                  }
                }
              } else {
                if (code < 9654) {
                  if (code < 9642) {
                    if (9410 === code) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (9642 <= code && code <= 9643) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  }
                } else {
                  if (code < 9664) {
                    if (9654 === code) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (code < 9723) {
                      if (9664 === code) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    } else {
                      if (9723 <= code && code <= 9726) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    }
                  }
                }
              }
            }
          } else {
            if (code < 10035) {
              if (code < 10004) {
                if (code < 9748) {
                  if (code < 9735) {
                    if (9728 <= code && code <= 9733) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (9735 <= code && code <= 9746) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  }
                } else {
                  if (code < 9872) {
                    if (9748 <= code && code <= 9861) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (code < 9992) {
                      if (9872 <= code && code <= 9989) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    } else {
                      if (9992 <= code && code <= 10002) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    }
                  }
                }
              } else {
                if (code < 10013) {
                  if (10004 === code) {
                    return boundaries_1.EXTENDED_PICTOGRAPHIC;
                  }
                  if (10006 === code) {
                    return boundaries_1.EXTENDED_PICTOGRAPHIC;
                  }
                } else {
                  if (code < 10017) {
                    if (10013 === code) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (10017 === code) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                    if (10024 === code) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  }
                }
              }
            } else {
              if (code < 10067) {
                if (code < 10055) {
                  if (code < 10052) {
                    if (10035 <= code && code <= 10036) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (10052 === code) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  }
                } else {
                  if (code < 10060) {
                    if (10055 === code) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (10060 === code) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                    if (10062 === code) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  }
                }
              } else {
                if (code < 10083) {
                  if (code < 10071) {
                    if (10067 <= code && code <= 10069) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (10071 === code) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  }
                } else {
                  if (code < 10133) {
                    if (10083 <= code && code <= 10087) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (code < 10145) {
                      if (10133 <= code && code <= 10135) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    } else {
                      if (10145 === code) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    }
                  }
                }
              }
            }
          }
        } else {
          if (code < 127489) {
            if (code < 12951) {
              if (code < 11035) {
                if (code < 10548) {
                  if (10160 === code) {
                    return boundaries_1.EXTENDED_PICTOGRAPHIC;
                  }
                  if (10175 === code) {
                    return boundaries_1.EXTENDED_PICTOGRAPHIC;
                  }
                } else {
                  if (code < 11013) {
                    if (10548 <= code && code <= 10549) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (11013 <= code && code <= 11015) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  }
                }
              } else {
                if (code < 11093) {
                  if (code < 11088) {
                    if (11035 <= code && code <= 11036) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (11088 === code) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  }
                } else {
                  if (code < 12336) {
                    if (11093 === code) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (12336 === code) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                    if (12349 === code) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  }
                }
              }
            } else {
              if (code < 127340) {
                if (code < 126976) {
                  if (12951 === code) {
                    return boundaries_1.EXTENDED_PICTOGRAPHIC;
                  }
                  if (12953 === code) {
                    return boundaries_1.EXTENDED_PICTOGRAPHIC;
                  }
                } else {
                  if (code < 127245) {
                    if (126976 <= code && code <= 127231) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (code < 127279) {
                      if (127245 <= code && code <= 127247) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    } else {
                      if (127279 === code) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    }
                  }
                }
              } else {
                if (code < 127374) {
                  if (code < 127358) {
                    if (127340 <= code && code <= 127345) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (127358 <= code && code <= 127359) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  }
                } else {
                  if (code < 127377) {
                    if (127374 === code) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (code < 127405) {
                      if (127377 <= code && code <= 127386) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    } else {
                      if (127405 <= code && code <= 127461) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    }
                  }
                }
              }
            }
          } else {
            if (code < 128981) {
              if (code < 127561) {
                if (code < 127535) {
                  if (code < 127514) {
                    if (127489 <= code && code <= 127503) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (127514 === code) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  }
                } else {
                  if (code < 127538) {
                    if (127535 === code) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (code < 127548) {
                      if (127538 <= code && code <= 127546) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    } else {
                      if (127548 <= code && code <= 127551) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    }
                  }
                }
              } else {
                if (code < 128326) {
                  if (code < 128e3) {
                    if (127561 <= code && code <= 127994) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (128e3 <= code && code <= 128317) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  }
                } else {
                  if (code < 128640) {
                    if (128326 <= code && code <= 128591) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (code < 128884) {
                      if (128640 <= code && code <= 128767) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    } else {
                      if (128884 <= code && code <= 128895) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    }
                  }
                }
              }
            } else {
              if (code < 129198) {
                if (code < 129096) {
                  if (code < 129036) {
                    if (128981 <= code && code <= 129023) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (129036 <= code && code <= 129039) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  }
                } else {
                  if (code < 129114) {
                    if (129096 <= code && code <= 129103) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (code < 129160) {
                      if (129114 <= code && code <= 129119) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    } else {
                      if (129160 <= code && code <= 129167) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    }
                  }
                }
              } else {
                if (code < 129340) {
                  if (code < 129292) {
                    if (129198 <= code && code <= 129279) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (129292 <= code && code <= 129338) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  }
                } else {
                  if (code < 129351) {
                    if (129340 <= code && code <= 129349) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (code < 130048) {
                      if (129351 <= code && code <= 129791) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    } else {
                      if (130048 <= code && code <= 131069) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    }
                  }
                }
              }
            }
          }
        }
        return boundaries_1.CLUSTER_BREAK.OTHER;
      }
    };
    Graphemer.default = Graphemer$1;
    return Graphemer;
  }
  var hasRequiredLib;
  function requireLib() {
    if (hasRequiredLib) return lib;
    hasRequiredLib = 1;
    var __importDefault = lib && lib.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(lib, "__esModule", { value: true });
    const Graphemer_1 = __importDefault(requireGraphemer());
    lib.default = Graphemer_1.default;
    return lib;
  }
  var hasRequiredStrings;
  function requireStrings() {
    if (hasRequiredStrings) return strings;
    hasRequiredStrings = 1;
    var __createBinding = strings && strings.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = strings && strings.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = strings && strings.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = strings && strings.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(strings, "__esModule", { value: true });
    strings.validateLanguage = strings.parseLanguage = strings.b64UrlToUtf8 = strings.utf8ToB64Url = strings.graphemeLen = strings.utf8Len = void 0;
    const graphemer_1 = __importDefault(requireLib());
    const ui8 = __importStar(require$$1);
    const utf8Len = (str) => {
      return new TextEncoder().encode(str).byteLength;
    };
    strings.utf8Len = utf8Len;
    const graphemeLen = (str) => {
      const splitter = new graphemer_1.default();
      return splitter.countGraphemes(str);
    };
    strings.graphemeLen = graphemeLen;
    const utf8ToB64Url = (utf8) => {
      return ui8.toString(ui8.fromString(utf8, "utf8"), "base64url");
    };
    strings.utf8ToB64Url = utf8ToB64Url;
    const b64UrlToUtf8 = (b64) => {
      return ui8.toString(ui8.fromString(b64, "base64url"), "utf8");
    };
    strings.b64UrlToUtf8 = b64UrlToUtf8;
    const parseLanguage = (langTag) => {
      const parsed = langTag.match(bcp47Regexp);
      if (!parsed?.groups)
        return null;
      const parts = parsed.groups;
      return {
        grandfathered: parts.grandfathered,
        language: parts.language,
        extlang: parts.extlang,
        script: parts.script,
        region: parts.region,
        variant: parts.variant,
        extension: parts.extension,
        privateUse: parts.privateUseA || parts.privateUseB
      };
    };
    strings.parseLanguage = parseLanguage;
    const validateLanguage = (langTag) => {
      return bcp47Regexp.test(langTag);
    };
    strings.validateLanguage = validateLanguage;
    const bcp47Regexp = /^((?<grandfathered>(en-GB-oed|i-ami|i-bnn|i-default|i-enochian|i-hak|i-klingon|i-lux|i-mingo|i-navajo|i-pwn|i-tao|i-tay|i-tsu|sgn-BE-FR|sgn-BE-NL|sgn-CH-DE)|(art-lojban|cel-gaulish|no-bok|no-nyn|zh-guoyu|zh-hakka|zh-min|zh-min-nan|zh-xiang))|((?<language>([A-Za-z]{2,3}(-(?<extlang>[A-Za-z]{3}(-[A-Za-z]{3}){0,2}))?)|[A-Za-z]{4}|[A-Za-z]{5,8})(-(?<script>[A-Za-z]{4}))?(-(?<region>[A-Za-z]{2}|[0-9]{3}))?(-(?<variant>[A-Za-z0-9]{5,8}|[0-9][A-Za-z0-9]{3}))*(-(?<extension>[0-9A-WY-Za-wy-z](-[A-Za-z0-9]{2,8})+))*(-(?<privateUseA>x(-[A-Za-z0-9]{1,8})+))?)|(?<privateUseB>x(-[A-Za-z0-9]{1,8})+))$/;
    return strings;
  }
  var didDoc = {};
  var hasRequiredDidDoc;
  function requireDidDoc() {
    if (hasRequiredDidDoc) return didDoc;
    hasRequiredDidDoc = 1;
    (function(exports) {
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.didDocument = exports.getServiceEndpoint = exports.getNotifEndpoint = exports.getFeedGenEndpoint = exports.getPdsEndpoint = exports.getSigningDidKey = exports.getVerificationMaterial = exports.getSigningKey = exports.getHandle = exports.getDid = exports.isValidDidDoc = void 0;
      const zod_1 = /* @__PURE__ */ requireLib$1();
      const isValidDidDoc = (doc) => {
        return exports.didDocument.safeParse(doc).success;
      };
      exports.isValidDidDoc = isValidDidDoc;
      const getDid = (doc) => {
        const id = doc.id;
        if (typeof id !== "string") {
          throw new Error("No `id` on document");
        }
        return id;
      };
      exports.getDid = getDid;
      const getHandle = (doc) => {
        const aka = doc.alsoKnownAs;
        if (aka) {
          for (let i = 0; i < aka.length; i++) {
            const alias = aka[i];
            if (alias.startsWith("at://")) {
              return alias.slice(5);
            }
          }
        }
        return void 0;
      };
      exports.getHandle = getHandle;
      const getSigningKey = (doc) => {
        return (0, exports.getVerificationMaterial)(doc, "atproto");
      };
      exports.getSigningKey = getSigningKey;
      const getVerificationMaterial = (doc, keyId) => {
        const key = findItemById(doc, "verificationMethod", `#${keyId}`);
        if (!key) {
          return void 0;
        }
        if (!key.publicKeyMultibase) {
          return void 0;
        }
        return {
          type: key.type,
          publicKeyMultibase: key.publicKeyMultibase
        };
      };
      exports.getVerificationMaterial = getVerificationMaterial;
      const getSigningDidKey = (doc) => {
        const parsed = (0, exports.getSigningKey)(doc);
        if (!parsed)
          return;
        return `did:key:${parsed.publicKeyMultibase}`;
      };
      exports.getSigningDidKey = getSigningDidKey;
      const getPdsEndpoint = (doc) => {
        return (0, exports.getServiceEndpoint)(doc, {
          id: "#atproto_pds",
          type: "AtprotoPersonalDataServer"
        });
      };
      exports.getPdsEndpoint = getPdsEndpoint;
      const getFeedGenEndpoint = (doc) => {
        return (0, exports.getServiceEndpoint)(doc, {
          id: "#bsky_fg",
          type: "BskyFeedGenerator"
        });
      };
      exports.getFeedGenEndpoint = getFeedGenEndpoint;
      const getNotifEndpoint = (doc) => {
        return (0, exports.getServiceEndpoint)(doc, {
          id: "#bsky_notif",
          type: "BskyNotificationService"
        });
      };
      exports.getNotifEndpoint = getNotifEndpoint;
      const getServiceEndpoint = (doc, opts) => {
        const service3 = findItemById(doc, "service", opts.id);
        if (!service3) {
          return void 0;
        }
        if (opts.type && service3.type !== opts.type) {
          return void 0;
        }
        if (typeof service3.serviceEndpoint !== "string") {
          return void 0;
        }
        return validateUrl(service3.serviceEndpoint);
      };
      exports.getServiceEndpoint = getServiceEndpoint;
      function findItemById(doc, type, id) {
        const items = doc[type];
        if (items) {
          for (let i = 0; i < items.length; i++) {
            const item = items[i];
            const itemId = item.id;
            if (itemId[0] === "#" ? itemId === id : (
              // Optimized version of: itemId === `${doc.id}${id}`
              itemId.length === doc.id.length + id.length && itemId[doc.id.length] === "#" && itemId.endsWith(id) && itemId.startsWith(doc.id)
            )) {
              return item;
            }
          }
        }
        return void 0;
      }
      const validateUrl = (urlStr) => {
        if (!urlStr.startsWith("http://") && !urlStr.startsWith("https://")) {
          return void 0;
        }
        if (!canParseUrl(urlStr)) {
          return void 0;
        }
        return urlStr;
      };
      const canParseUrl = URL.canParse ?? // URL.canParse is not available in Node.js < 18.17.0
      ((urlStr) => {
        try {
          new URL(urlStr);
          return true;
        } catch {
          return false;
        }
      });
      const verificationMethod = zod_1.z.object({
        id: zod_1.z.string(),
        type: zod_1.z.string(),
        controller: zod_1.z.string(),
        publicKeyMultibase: zod_1.z.string().optional()
      });
      const service2 = zod_1.z.object({
        id: zod_1.z.string(),
        type: zod_1.z.string(),
        serviceEndpoint: zod_1.z.union([zod_1.z.string(), zod_1.z.record(zod_1.z.unknown())])
      });
      exports.didDocument = zod_1.z.object({
        id: zod_1.z.string(),
        alsoKnownAs: zod_1.z.array(zod_1.z.string()).optional(),
        verificationMethod: zod_1.z.array(verificationMethod).optional(),
        service: zod_1.z.array(service2).optional()
      });
    })(didDoc);
    return didDoc;
  }
  var hasRequiredDist$4;
  function requireDist$4() {
    if (hasRequiredDist$4) return dist$2;
    hasRequiredDist$4 = 1;
    (function(exports) {
      var __createBinding = dist$2 && dist$2.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = dist$2 && dist$2.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = dist$2 && dist$2.__importStar || function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      var __exportStar = dist$2 && dist$2.__exportStar || function(m, exports2) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.util = exports.check = void 0;
      exports.check = __importStar(requireCheck());
      exports.util = __importStar(requireUtil$6());
      __exportStar(requireArrays(), exports);
      __exportStar(requireAsync(), exports);
      __exportStar(requireUtil$6(), exports);
      __exportStar(requireTid(), exports);
      __exportStar(requireIpld(), exports);
      __exportStar(requireRetry(), exports);
      __exportStar(requireTypes$3(), exports);
      __exportStar(requireTimes(), exports);
      __exportStar(requireStrings(), exports);
      __exportStar(requireDidDoc(), exports);
    })(dist$2);
    return dist$2;
  }
  var hasRequiredBlobRefs;
  function requireBlobRefs() {
    if (hasRequiredBlobRefs) return blobRefs;
    hasRequiredBlobRefs = 1;
    (function(exports) {
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.BlobRef = exports.jsonBlobRef = exports.untypedJsonBlobRef = exports.typedJsonBlobRef = void 0;
      const cid_1 = require$$0$1;
      const zod_1 = /* @__PURE__ */ requireLib$1();
      const common_web_1 = requireDist$4();
      exports.typedJsonBlobRef = zod_1.z.object({
        $type: zod_1.z.literal("blob"),
        ref: common_web_1.schema.cid,
        mimeType: zod_1.z.string(),
        size: zod_1.z.number()
      }).strict();
      exports.untypedJsonBlobRef = zod_1.z.object({
        cid: zod_1.z.string(),
        mimeType: zod_1.z.string()
      }).strict();
      exports.jsonBlobRef = zod_1.z.union([exports.typedJsonBlobRef, exports.untypedJsonBlobRef]);
      class BlobRef {
        constructor(ref, mimeType, size, original) {
          Object.defineProperty(this, "ref", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: ref
          });
          Object.defineProperty(this, "mimeType", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: mimeType
          });
          Object.defineProperty(this, "size", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: size
          });
          Object.defineProperty(this, "original", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          this.original = original ?? {
            $type: "blob",
            ref,
            mimeType,
            size
          };
        }
        static asBlobRef(obj) {
          if (common_web_1.check.is(obj, exports.jsonBlobRef)) {
            return BlobRef.fromJsonRef(obj);
          }
          return null;
        }
        static fromJsonRef(json) {
          if (common_web_1.check.is(json, exports.typedJsonBlobRef)) {
            return new BlobRef(json.ref, json.mimeType, json.size);
          } else {
            return new BlobRef(cid_1.CID.parse(json.cid), json.mimeType, -1, json);
          }
        }
        ipld() {
          return {
            $type: "blob",
            ref: this.ref,
            mimeType: this.mimeType,
            size: this.size
          };
        }
        toJSON() {
          return (0, common_web_1.ipldToJson)(this.ipld());
        }
      }
      exports.BlobRef = BlobRef;
    })(blobRefs);
    return blobRefs;
  }
  var hasRequiredBlob;
  function requireBlob() {
    if (hasRequiredBlob) return blob;
    hasRequiredBlob = 1;
    Object.defineProperty(blob, "__esModule", { value: true });
    blob.blob = blob$1;
    const blob_refs_1 = requireBlobRefs();
    const types_1 = requireTypes$4();
    function blob$1(lexicons2, path, def, value) {
      if (!value || !(value instanceof blob_refs_1.BlobRef)) {
        return {
          success: false,
          error: new types_1.ValidationError(`${path} should be a blob ref`)
        };
      }
      return { success: true, value };
    }
    return blob;
  }
  var primitives = {};
  var formats = {};
  var dist$1 = {};
  var hasRequiredDist$3;
  function requireDist$3() {
    if (hasRequiredDist$3) return dist$1;
    hasRequiredDist$3 = 1;
    (function(exports) {
      (() => {
        var e = { d: (t2, r2) => {
          for (var n2 in r2) e.o(r2, n2) && !e.o(t2, n2) && Object.defineProperty(t2, n2, { enumerable: true, get: r2[n2] });
        }, o: (e2, t2) => Object.prototype.hasOwnProperty.call(e2, t2), r: (e2) => {
          "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e2, "__esModule", { value: true });
        } }, t = {};
        function r(e2, t2) {
          return void 0 === t2 && (t2 = "-"), new RegExp("^(?!0{4}" + t2 + "0{2}" + t2 + "0{2})((?=[0-9]{4}" + t2 + "(((0[^2])|1[0-2])|02(?=" + t2 + "(([0-1][0-9])|2[0-8])))" + t2 + "[0-9]{2})|(?=((([13579][26])|([2468][048])|(0[48]))0{2})|([0-9]{2}((((0|[2468])[48])|[2468][048])|([13579][26])))" + t2 + "02" + t2 + "29))([0-9]{4})" + t2 + "(?!((0[469])|11)" + t2 + "31)((0[1,3-9]|1[0-2])|(02(?!" + t2 + "3)))" + t2 + "(0[1-9]|[1-2][0-9]|3[0-1])$").test(e2);
        }
        function n(e2) {
          var t2 = /\D/.exec(e2);
          return t2 ? t2[0] : "";
        }
        function i(e2, t2, r2) {
          void 0 === t2 && (t2 = ":"), void 0 === r2 && (r2 = false);
          var i2 = new RegExp("^([0-1]|2(?=([0-3])|4" + t2 + "00))[0-9]" + t2 + "[0-5][0-9](" + t2 + "([0-5]|6(?=0))[0-9])?(.[0-9]{1,9})?$");
          if (!r2 || !/[Z+\-]/.test(e2)) return i2.test(e2);
          if (/Z$/.test(e2)) return i2.test(e2.replace("Z", ""));
          var o2 = e2.includes("+"), a2 = e2.split(/[+-]/), u2 = a2[0], d2 = a2[1];
          return i2.test(u2) && function(e3, t3, r3) {
            return void 0 === r3 && (r3 = ":"), new RegExp(t3 ? "^(0(?!(2" + r3 + "4)|0" + r3 + "3)|1(?=([0-1]|2(?=" + r3 + "[04])|[34](?=" + r3 + "0))))([03469](?=" + r3 + "[03])|[17](?=" + r3 + "0)|2(?=" + r3 + "[04])|5(?=" + r3 + "[034])|8(?=" + r3 + "[04]))" + r3 + "([03](?=0)|4(?=5))[05]$" : "^(0(?=[^0])|1(?=[0-2]))([39](?=" + r3 + "[03])|[0-24-8](?=" + r3 + "00))" + r3 + "[03]0$").test(e3);
          }(d2, o2, n(d2));
        }
        function o(e2) {
          var t2 = e2.split("T"), o2 = t2[0], a2 = t2[1], u2 = r(o2, n(o2));
          if (!a2) return false;
          var d2, s = (d2 = a2.match(/([^Z+\-\d])(?=\d+\1)/), Array.isArray(d2) ? d2[0] : "");
          return u2 && i(a2, s, true);
        }
        function a(e2, t2) {
          return void 0 === t2 && (t2 = "-"), new RegExp("^[0-9]{4}" + t2 + "(0(?=[^0])|1(?=[0-2]))[0-9]$").test(e2);
        }
        e.r(t), e.d(t, { isValidDate: () => r, isValidISODateString: () => o, isValidTime: () => i, isValidYearMonth: () => a });
        var u = exports;
        for (var d in t) u[d] = t[d];
        t.__esModule && Object.defineProperty(u, "__esModule", { value: true });
      })();
    })(dist$1);
    return dist$1;
  }
  var hasRequiredFormats;
  function requireFormats() {
    if (hasRequiredFormats) return formats;
    hasRequiredFormats = 1;
    Object.defineProperty(formats, "__esModule", { value: true });
    formats.datetime = datetime2;
    formats.uri = uri;
    formats.atUri = atUri;
    formats.did = did2;
    formats.handle = handle2;
    formats.atIdentifier = atIdentifier;
    formats.nsid = nsid2;
    formats.cid = cid2;
    formats.language = language;
    formats.tid = tid2;
    formats.recordKey = recordKey;
    const iso_datestring_validator_1 = requireDist$3();
    const cid_1 = require$$0$1;
    const common_web_1 = requireDist$4();
    const syntax_1 = requireDist$5();
    const types_1 = requireTypes$4();
    function datetime2(path, value) {
      try {
        if (!(0, iso_datestring_validator_1.isValidISODateString)(value)) {
          throw new Error();
        }
      } catch {
        return {
          success: false,
          error: new types_1.ValidationError(`${path} must be an valid atproto datetime (both RFC-3339 and ISO-8601)`)
        };
      }
      return { success: true, value };
    }
    function uri(path, value) {
      const isUri = value.match(/^\w+:(?:\/\/)?[^\s/][^\s]*$/) !== null;
      if (!isUri) {
        return {
          success: false,
          error: new types_1.ValidationError(`${path} must be a uri`)
        };
      }
      return { success: true, value };
    }
    function atUri(path, value) {
      try {
        (0, syntax_1.ensureValidAtUri)(value);
      } catch {
        return {
          success: false,
          error: new types_1.ValidationError(`${path} must be a valid at-uri`)
        };
      }
      return { success: true, value };
    }
    function did2(path, value) {
      try {
        (0, syntax_1.ensureValidDid)(value);
      } catch {
        return {
          success: false,
          error: new types_1.ValidationError(`${path} must be a valid did`)
        };
      }
      return { success: true, value };
    }
    function handle2(path, value) {
      try {
        (0, syntax_1.ensureValidHandle)(value);
      } catch {
        return {
          success: false,
          error: new types_1.ValidationError(`${path} must be a valid handle`)
        };
      }
      return { success: true, value };
    }
    function atIdentifier(path, value) {
      if (value.startsWith("did:")) {
        const didResult = did2(path, value);
        if (didResult.success)
          return didResult;
      } else {
        const handleResult = handle2(path, value);
        if (handleResult.success)
          return handleResult;
      }
      return {
        success: false,
        error: new types_1.ValidationError(`${path} must be a valid did or a handle`)
      };
    }
    function nsid2(path, value) {
      try {
        (0, syntax_1.ensureValidNsid)(value);
      } catch {
        return {
          success: false,
          error: new types_1.ValidationError(`${path} must be a valid nsid`)
        };
      }
      return { success: true, value };
    }
    function cid2(path, value) {
      try {
        cid_1.CID.parse(value);
      } catch {
        return {
          success: false,
          error: new types_1.ValidationError(`${path} must be a cid string`)
        };
      }
      return { success: true, value };
    }
    function language(path, value) {
      if ((0, common_web_1.validateLanguage)(value)) {
        return { success: true, value };
      }
      return {
        success: false,
        error: new types_1.ValidationError(`${path} must be a well-formed BCP 47 language tag`)
      };
    }
    function tid2(path, value) {
      if ((0, syntax_1.isValidTid)(value)) {
        return { success: true, value };
      }
      return {
        success: false,
        error: new types_1.ValidationError(`${path} must be a valid TID`)
      };
    }
    function recordKey(path, value) {
      try {
        (0, syntax_1.ensureValidRecordKey)(value);
      } catch {
        return {
          success: false,
          error: new types_1.ValidationError(`${path} must be a valid Record Key`)
        };
      }
      return { success: true, value };
    }
    return formats;
  }
  var hasRequiredPrimitives;
  function requirePrimitives() {
    if (hasRequiredPrimitives) return primitives;
    hasRequiredPrimitives = 1;
    var __createBinding = primitives && primitives.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = primitives && primitives.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = primitives && primitives.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(primitives, "__esModule", { value: true });
    primitives.validate = validate;
    const cid_1 = require$$0$1;
    const common_web_1 = requireDist$4();
    const types_1 = requireTypes$4();
    const formats2 = __importStar(requireFormats());
    function validate(lexicons2, path, def, value) {
      switch (def.type) {
        case "boolean":
          return boolean(lexicons2, path, def, value);
        case "integer":
          return integer(lexicons2, path, def, value);
        case "string":
          return string2(lexicons2, path, def, value);
        case "bytes":
          return bytes(lexicons2, path, def, value);
        case "cid-link":
          return cidLink(lexicons2, path, def, value);
        case "unknown":
          return unknown(lexicons2, path, def, value);
        default:
          return {
            success: false,
            error: new types_1.ValidationError(`Unexpected lexicon type: ${def.type}`)
          };
      }
    }
    function boolean(lexicons2, path, def, value) {
      def = def;
      const type = typeof value;
      if (type === "undefined") {
        if (typeof def.default === "boolean") {
          return { success: true, value: def.default };
        }
        return {
          success: false,
          error: new types_1.ValidationError(`${path} must be a boolean`)
        };
      } else if (type !== "boolean") {
        return {
          success: false,
          error: new types_1.ValidationError(`${path} must be a boolean`)
        };
      }
      if (typeof def.const === "boolean") {
        if (value !== def.const) {
          return {
            success: false,
            error: new types_1.ValidationError(`${path} must be ${def.const}`)
          };
        }
      }
      return { success: true, value };
    }
    function integer(lexicons2, path, def, value) {
      def = def;
      const type = typeof value;
      if (type === "undefined") {
        if (typeof def.default === "number") {
          return { success: true, value: def.default };
        }
        return {
          success: false,
          error: new types_1.ValidationError(`${path} must be an integer`)
        };
      } else if (!Number.isInteger(value)) {
        return {
          success: false,
          error: new types_1.ValidationError(`${path} must be an integer`)
        };
      }
      if (typeof def.const === "number") {
        if (value !== def.const) {
          return {
            success: false,
            error: new types_1.ValidationError(`${path} must be ${def.const}`)
          };
        }
      }
      if (Array.isArray(def.enum)) {
        if (!def.enum.includes(value)) {
          return {
            success: false,
            error: new types_1.ValidationError(`${path} must be one of (${def.enum.join("|")})`)
          };
        }
      }
      if (typeof def.maximum === "number") {
        if (value > def.maximum) {
          return {
            success: false,
            error: new types_1.ValidationError(`${path} can not be greater than ${def.maximum}`)
          };
        }
      }
      if (typeof def.minimum === "number") {
        if (value < def.minimum) {
          return {
            success: false,
            error: new types_1.ValidationError(`${path} can not be less than ${def.minimum}`)
          };
        }
      }
      return { success: true, value };
    }
    function string2(lexicons2, path, def, value) {
      def = def;
      if (typeof value === "undefined") {
        if (typeof def.default === "string") {
          return { success: true, value: def.default };
        }
        return {
          success: false,
          error: new types_1.ValidationError(`${path} must be a string`)
        };
      } else if (typeof value !== "string") {
        return {
          success: false,
          error: new types_1.ValidationError(`${path} must be a string`)
        };
      }
      if (typeof def.const === "string") {
        if (value !== def.const) {
          return {
            success: false,
            error: new types_1.ValidationError(`${path} must be ${def.const}`)
          };
        }
      }
      if (Array.isArray(def.enum)) {
        if (!def.enum.includes(value)) {
          return {
            success: false,
            error: new types_1.ValidationError(`${path} must be one of (${def.enum.join("|")})`)
          };
        }
      }
      if (typeof def.minLength === "number" || typeof def.maxLength === "number") {
        if (typeof def.minLength === "number" && value.length * 3 < def.minLength) {
          return {
            success: false,
            error: new types_1.ValidationError(`${path} must not be shorter than ${def.minLength} characters`)
          };
        }
        let canSkipUtf8LenChecks = false;
        if (typeof def.minLength === "undefined" && typeof def.maxLength === "number" && value.length * 3 <= def.maxLength) {
          canSkipUtf8LenChecks = true;
        }
        if (!canSkipUtf8LenChecks) {
          const len = (0, common_web_1.utf8Len)(value);
          if (typeof def.maxLength === "number") {
            if (len > def.maxLength) {
              return {
                success: false,
                error: new types_1.ValidationError(`${path} must not be longer than ${def.maxLength} characters`)
              };
            }
          }
          if (typeof def.minLength === "number") {
            if (len < def.minLength) {
              return {
                success: false,
                error: new types_1.ValidationError(`${path} must not be shorter than ${def.minLength} characters`)
              };
            }
          }
        }
      }
      if (typeof def.maxGraphemes === "number" || typeof def.minGraphemes === "number") {
        let needsMaxGraphemesCheck = false;
        let needsMinGraphemesCheck = false;
        if (typeof def.maxGraphemes === "number") {
          if (value.length <= def.maxGraphemes) {
            needsMaxGraphemesCheck = false;
          } else {
            needsMaxGraphemesCheck = true;
          }
        }
        if (typeof def.minGraphemes === "number") {
          if (value.length < def.minGraphemes) {
            return {
              success: false,
              error: new types_1.ValidationError(`${path} must not be shorter than ${def.minGraphemes} graphemes`)
            };
          } else {
            needsMinGraphemesCheck = true;
          }
        }
        if (needsMaxGraphemesCheck || needsMinGraphemesCheck) {
          const len = (0, common_web_1.graphemeLen)(value);
          if (typeof def.maxGraphemes === "number") {
            if (len > def.maxGraphemes) {
              return {
                success: false,
                error: new types_1.ValidationError(`${path} must not be longer than ${def.maxGraphemes} graphemes`)
              };
            }
          }
          if (typeof def.minGraphemes === "number") {
            if (len < def.minGraphemes) {
              return {
                success: false,
                error: new types_1.ValidationError(`${path} must not be shorter than ${def.minGraphemes} graphemes`)
              };
            }
          }
        }
      }
      if (typeof def.format === "string") {
        switch (def.format) {
          case "datetime":
            return formats2.datetime(path, value);
          case "uri":
            return formats2.uri(path, value);
          case "at-uri":
            return formats2.atUri(path, value);
          case "did":
            return formats2.did(path, value);
          case "handle":
            return formats2.handle(path, value);
          case "at-identifier":
            return formats2.atIdentifier(path, value);
          case "nsid":
            return formats2.nsid(path, value);
          case "cid":
            return formats2.cid(path, value);
          case "language":
            return formats2.language(path, value);
          case "tid":
            return formats2.tid(path, value);
          case "record-key":
            return formats2.recordKey(path, value);
        }
      }
      return { success: true, value };
    }
    function bytes(lexicons2, path, def, value) {
      def = def;
      if (!value || !(value instanceof Uint8Array)) {
        return {
          success: false,
          error: new types_1.ValidationError(`${path} must be a byte array`)
        };
      }
      if (typeof def.maxLength === "number") {
        if (value.byteLength > def.maxLength) {
          return {
            success: false,
            error: new types_1.ValidationError(`${path} must not be larger than ${def.maxLength} bytes`)
          };
        }
      }
      if (typeof def.minLength === "number") {
        if (value.byteLength < def.minLength) {
          return {
            success: false,
            error: new types_1.ValidationError(`${path} must not be smaller than ${def.minLength} bytes`)
          };
        }
      }
      return { success: true, value };
    }
    function cidLink(lexicons2, path, def, value) {
      if (cid_1.CID.asCID(value) === null) {
        return {
          success: false,
          error: new types_1.ValidationError(`${path} must be a CID`)
        };
      }
      return { success: true, value };
    }
    function unknown(lexicons2, path, def, value) {
      if (!value || typeof value !== "object") {
        return {
          success: false,
          error: new types_1.ValidationError(`${path} must be an object`)
        };
      }
      return { success: true, value };
    }
    return primitives;
  }
  var hasRequiredComplex;
  function requireComplex() {
    if (hasRequiredComplex) return complex;
    hasRequiredComplex = 1;
    Object.defineProperty(complex, "__esModule", { value: true });
    complex.validate = validate;
    complex.array = array;
    complex.object = object;
    complex.validateOneOf = validateOneOf;
    const types_1 = requireTypes$4();
    const util_1 = requireUtil$7();
    const blob_1 = requireBlob();
    const primitives_1 = requirePrimitives();
    function validate(lexicons2, path, def, value) {
      switch (def.type) {
        case "object":
          return object(lexicons2, path, def, value);
        case "array":
          return array(lexicons2, path, def, value);
        case "blob":
          return (0, blob_1.blob)(lexicons2, path, def, value);
        default:
          return (0, primitives_1.validate)(lexicons2, path, def, value);
      }
    }
    function array(lexicons2, path, def, value) {
      if (!Array.isArray(value)) {
        return {
          success: false,
          error: new types_1.ValidationError(`${path} must be an array`)
        };
      }
      if (typeof def.maxLength === "number") {
        if (value.length > def.maxLength) {
          return {
            success: false,
            error: new types_1.ValidationError(`${path} must not have more than ${def.maxLength} elements`)
          };
        }
      }
      if (typeof def.minLength === "number") {
        if (value.length < def.minLength) {
          return {
            success: false,
            error: new types_1.ValidationError(`${path} must not have fewer than ${def.minLength} elements`)
          };
        }
      }
      const itemsDef = def.items;
      for (let i = 0; i < value.length; i++) {
        const itemValue = value[i];
        const itemPath = `${path}/${i}`;
        const res = validateOneOf(lexicons2, itemPath, itemsDef, itemValue);
        if (!res.success) {
          return res;
        }
      }
      return { success: true, value };
    }
    function object(lexicons2, path, def, value) {
      if (!(0, types_1.isObj)(value)) {
        return {
          success: false,
          error: new types_1.ValidationError(`${path} must be an object`)
        };
      }
      let resultValue = value;
      if ("properties" in def && def.properties != null) {
        for (const key in def.properties) {
          const keyValue = value[key];
          if (keyValue === null && def.nullable?.includes(key)) {
            continue;
          }
          const propDef = def.properties[key];
          if (keyValue === void 0 && !def.required?.includes(key)) {
            if (propDef.type === "integer" || propDef.type === "boolean" || propDef.type === "string") {
              if (propDef.default === void 0) {
                continue;
              }
            } else {
              continue;
            }
          }
          const propPath = `${path}/${key}`;
          const validated = validateOneOf(lexicons2, propPath, propDef, keyValue);
          const propValue = validated.success ? validated.value : keyValue;
          if (propValue === void 0) {
            if (def.required?.includes(key)) {
              return {
                success: false,
                error: new types_1.ValidationError(`${path} must have the property "${key}"`)
              };
            }
          } else {
            if (!validated.success) {
              return validated;
            }
          }
          if (propValue !== keyValue) {
            if (resultValue === value) {
              resultValue = { ...value };
            }
            resultValue[key] = propValue;
          }
        }
      }
      return { success: true, value: resultValue };
    }
    function validateOneOf(lexicons2, path, def, value, mustBeObj = false) {
      let concreteDef;
      if (def.type === "union") {
        if (!(0, types_1.isDiscriminatedObject)(value)) {
          return {
            success: false,
            error: new types_1.ValidationError(`${path} must be an object which includes the "$type" property`)
          };
        }
        if (!refsContainType(def.refs, value.$type)) {
          if (def.closed) {
            return {
              success: false,
              error: new types_1.ValidationError(`${path} $type must be one of ${def.refs.join(", ")}`)
            };
          }
          return { success: true, value };
        } else {
          concreteDef = lexicons2.getDefOrThrow(value.$type);
        }
      } else if (def.type === "ref") {
        concreteDef = lexicons2.getDefOrThrow(def.ref);
      } else {
        concreteDef = def;
      }
      return mustBeObj ? object(lexicons2, path, concreteDef, value) : validate(lexicons2, path, concreteDef, value);
    }
    const refsContainType = (refs, type) => {
      const lexUri = (0, util_1.toLexUri)(type);
      if (refs.includes(lexUri)) {
        return true;
      }
      if (lexUri.endsWith("#main")) {
        return refs.includes(lexUri.slice(0, -5));
      } else {
        return !lexUri.includes("#") && refs.includes(`${lexUri}#main`);
      }
    };
    return complex;
  }
  var xrpc = {};
  var hasRequiredXrpc;
  function requireXrpc() {
    if (hasRequiredXrpc) return xrpc;
    hasRequiredXrpc = 1;
    var __createBinding = xrpc && xrpc.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = xrpc && xrpc.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = xrpc && xrpc.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(xrpc, "__esModule", { value: true });
    xrpc.params = params;
    const types_1 = requireTypes$4();
    const complex_1 = requireComplex();
    const PrimitiveValidators = __importStar(requirePrimitives());
    function params(lexicons2, path, def, val) {
      const value = val && typeof val === "object" ? val : {};
      const requiredProps = new Set(def.required ?? []);
      let resultValue = value;
      if (typeof def.properties === "object") {
        for (const key in def.properties) {
          const propDef = def.properties[key];
          const validated = propDef.type === "array" ? (0, complex_1.array)(lexicons2, key, propDef, value[key]) : PrimitiveValidators.validate(lexicons2, key, propDef, value[key]);
          const propValue = validated.success ? validated.value : value[key];
          const propIsUndefined = typeof propValue === "undefined";
          if (propIsUndefined && requiredProps.has(key)) {
            return {
              success: false,
              error: new types_1.ValidationError(`${path} must have the property "${key}"`)
            };
          } else if (!propIsUndefined && !validated.success) {
            return validated;
          }
          if (propValue !== value[key]) {
            if (resultValue === value) {
              resultValue = { ...value };
            }
            resultValue[key] = propValue;
          }
        }
      }
      return { success: true, value: resultValue };
    }
    return xrpc;
  }
  var hasRequiredValidation;
  function requireValidation() {
    if (hasRequiredValidation) return validation;
    hasRequiredValidation = 1;
    Object.defineProperty(validation, "__esModule", { value: true });
    validation.assertValidRecord = assertValidRecord;
    validation.assertValidXrpcParams = assertValidXrpcParams;
    validation.assertValidXrpcInput = assertValidXrpcInput;
    validation.assertValidXrpcOutput = assertValidXrpcOutput;
    validation.assertValidXrpcMessage = assertValidXrpcMessage;
    const complex_1 = requireComplex();
    const xrpc_1 = requireXrpc();
    function assertValidRecord(lexicons2, def, value) {
      const res = (0, complex_1.object)(lexicons2, "Record", def.record, value);
      if (!res.success)
        throw res.error;
      return res.value;
    }
    function assertValidXrpcParams(lexicons2, def, value) {
      if (def.parameters) {
        const res = (0, xrpc_1.params)(lexicons2, "Params", def.parameters, value);
        if (!res.success)
          throw res.error;
        return res.value;
      }
    }
    function assertValidXrpcInput(lexicons2, def, value) {
      if (def.input?.schema) {
        return assertValidOneOf(lexicons2, "Input", def.input.schema, value, true);
      }
    }
    function assertValidXrpcOutput(lexicons2, def, value) {
      if (def.output?.schema) {
        return assertValidOneOf(lexicons2, "Output", def.output.schema, value, true);
      }
    }
    function assertValidXrpcMessage(lexicons2, def, value) {
      if (def.message?.schema) {
        return assertValidOneOf(lexicons2, "Message", def.message.schema, value, true);
      }
    }
    function assertValidOneOf(lexicons2, path, def, value, mustBeObj = false) {
      const res = (0, complex_1.validateOneOf)(lexicons2, path, def, value, mustBeObj);
      if (!res.success)
        throw res.error;
      return res.value;
    }
    return validation;
  }
  var hasRequiredLexicons$1;
  function requireLexicons$1() {
    if (hasRequiredLexicons$1) return lexicons$1;
    hasRequiredLexicons$1 = 1;
    Object.defineProperty(lexicons$1, "__esModule", { value: true });
    lexicons$1.Lexicons = void 0;
    const types_1 = requireTypes$4();
    const util_1 = requireUtil$7();
    const validation_1 = requireValidation();
    const complex_1 = requireComplex();
    class Lexicons {
      constructor(docs) {
        Object.defineProperty(this, "docs", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: /* @__PURE__ */ new Map()
        });
        Object.defineProperty(this, "defs", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: /* @__PURE__ */ new Map()
        });
        if (docs) {
          for (const doc of docs) {
            this.add(doc);
          }
        }
      }
      /**
       * @example clone a lexicon:
       * ```ts
       * const clone = new Lexicons(originalLexicon)
       * ```
       *
       * @example get docs array:
       * ```ts
       * const docs = Array.from(lexicons)
       * ```
       */
      [Symbol.iterator]() {
        return this.docs.values();
      }
      /**
       * Add a lexicon doc.
       */
      add(doc) {
        const uri = (0, util_1.toLexUri)(doc.id);
        if (this.docs.has(uri)) {
          throw new Error(`${uri} has already been registered`);
        }
        resolveRefUris(doc, uri);
        this.docs.set(uri, doc);
        for (const [defUri, def] of iterDefs(doc)) {
          this.defs.set(defUri, def);
        }
      }
      /**
       * Remove a lexicon doc.
       */
      remove(uri) {
        uri = (0, util_1.toLexUri)(uri);
        const doc = this.docs.get(uri);
        if (!doc) {
          throw new Error(`Unable to remove "${uri}": does not exist`);
        }
        for (const [defUri, _def] of iterDefs(doc)) {
          this.defs.delete(defUri);
        }
        this.docs.delete(uri);
      }
      /**
       * Get a lexicon doc.
       */
      get(uri) {
        uri = (0, util_1.toLexUri)(uri);
        return this.docs.get(uri);
      }
      /**
       * Get a definition.
       */
      getDef(uri) {
        uri = (0, util_1.toLexUri)(uri);
        return this.defs.get(uri);
      }
      getDefOrThrow(uri, types2) {
        const def = this.getDef(uri);
        if (!def) {
          throw new types_1.LexiconDefNotFoundError(`Lexicon not found: ${uri}`);
        }
        if (types2 && !types2.includes(def.type)) {
          throw new types_1.InvalidLexiconError(`Not a ${types2.join(" or ")} lexicon: ${uri}`);
        }
        return def;
      }
      /**
       * Validate a record or object.
       */
      validate(lexUri, value) {
        if (!(0, types_1.isObj)(value)) {
          throw new types_1.ValidationError(`Value must be an object`);
        }
        const lexUriNormalized = (0, util_1.toLexUri)(lexUri);
        const def = this.getDefOrThrow(lexUriNormalized, ["record", "object"]);
        if (def.type === "record") {
          return (0, complex_1.object)(this, "Record", def.record, value);
        } else if (def.type === "object") {
          return (0, complex_1.object)(this, "Object", def, value);
        } else {
          throw new types_1.InvalidLexiconError("Definition must be a record or object");
        }
      }
      /**
       * Validate a record and throw on any error.
       */
      assertValidRecord(lexUri, value) {
        if (!(0, types_1.isObj)(value)) {
          throw new types_1.ValidationError(`Record must be an object`);
        }
        if (!("$type" in value)) {
          throw new types_1.ValidationError(`Record/$type must be a string`);
        }
        const { $type } = value;
        if (typeof $type !== "string") {
          throw new types_1.ValidationError(`Record/$type must be a string`);
        }
        const lexUriNormalized = (0, util_1.toLexUri)(lexUri);
        if ((0, util_1.toLexUri)($type) !== lexUriNormalized) {
          throw new types_1.ValidationError(`Invalid $type: must be ${lexUriNormalized}, got ${$type}`);
        }
        const def = this.getDefOrThrow(lexUriNormalized, ["record"]);
        return (0, validation_1.assertValidRecord)(this, def, value);
      }
      /**
       * Validate xrpc query params and throw on any error.
       */
      assertValidXrpcParams(lexUri, value) {
        lexUri = (0, util_1.toLexUri)(lexUri);
        const def = this.getDefOrThrow(lexUri, [
          "query",
          "procedure",
          "subscription"
        ]);
        return (0, validation_1.assertValidXrpcParams)(this, def, value);
      }
      /**
       * Validate xrpc input body and throw on any error.
       */
      assertValidXrpcInput(lexUri, value) {
        lexUri = (0, util_1.toLexUri)(lexUri);
        const def = this.getDefOrThrow(lexUri, ["procedure"]);
        return (0, validation_1.assertValidXrpcInput)(this, def, value);
      }
      /**
       * Validate xrpc output body and throw on any error.
       */
      assertValidXrpcOutput(lexUri, value) {
        lexUri = (0, util_1.toLexUri)(lexUri);
        const def = this.getDefOrThrow(lexUri, ["query", "procedure"]);
        return (0, validation_1.assertValidXrpcOutput)(this, def, value);
      }
      /**
       * Validate xrpc subscription message and throw on any error.
       */
      assertValidXrpcMessage(lexUri, value) {
        lexUri = (0, util_1.toLexUri)(lexUri);
        const def = this.getDefOrThrow(lexUri, ["subscription"]);
        return (0, validation_1.assertValidXrpcMessage)(this, def, value);
      }
      /**
       * Resolve a lex uri given a ref
       */
      resolveLexUri(lexUri, ref) {
        lexUri = (0, util_1.toLexUri)(lexUri);
        return (0, util_1.toLexUri)(ref, lexUri);
      }
    }
    lexicons$1.Lexicons = Lexicons;
    function* iterDefs(doc) {
      for (const defId in doc.defs) {
        yield [`lex:${doc.id}#${defId}`, doc.defs[defId]];
        if (defId === "main") {
          yield [`lex:${doc.id}`, doc.defs[defId]];
        }
      }
    }
    function resolveRefUris(obj, baseUri) {
      for (const k in obj) {
        if (obj.type === "ref") {
          obj.ref = (0, util_1.toLexUri)(obj.ref, baseUri);
        } else if (obj.type === "union") {
          obj.refs = obj.refs.map((ref) => (0, util_1.toLexUri)(ref, baseUri));
        } else if (Array.isArray(obj[k])) {
          obj[k] = obj[k].map((item) => {
            if (typeof item === "string") {
              return item.startsWith("#") ? (0, util_1.toLexUri)(item, baseUri) : item;
            } else if (item && typeof item === "object") {
              return resolveRefUris(item, baseUri);
            }
            return item;
          });
        } else if (obj[k] && typeof obj[k] === "object") {
          obj[k] = resolveRefUris(obj[k], baseUri);
        }
      }
      return obj;
    }
    return lexicons$1;
  }
  var serialize = {};
  var hasRequiredSerialize;
  function requireSerialize() {
    if (hasRequiredSerialize) return serialize;
    hasRequiredSerialize = 1;
    (function(exports) {
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.jsonStringToLex = exports.jsonToLex = exports.stringifyLex = exports.lexToJson = exports.ipldToLex = exports.lexToIpld = void 0;
      const cid_1 = require$$0$1;
      const common_web_1 = requireDist$4();
      const blob_refs_1 = requireBlobRefs();
      const lexToIpld = (val) => {
        if (Array.isArray(val)) {
          return val.map((item) => (0, exports.lexToIpld)(item));
        }
        if (val && typeof val === "object") {
          if (val instanceof blob_refs_1.BlobRef) {
            return val.original;
          }
          if (cid_1.CID.asCID(val) || val instanceof Uint8Array) {
            return val;
          }
          const toReturn = {};
          for (const key of Object.keys(val)) {
            toReturn[key] = (0, exports.lexToIpld)(val[key]);
          }
          return toReturn;
        }
        return val;
      };
      exports.lexToIpld = lexToIpld;
      const ipldToLex = (val) => {
        if (Array.isArray(val)) {
          return val.map((item) => (0, exports.ipldToLex)(item));
        }
        if (val && typeof val === "object") {
          if ((val["$type"] === "blob" || typeof val["cid"] === "string" && typeof val["mimeType"] === "string") && common_web_1.check.is(val, blob_refs_1.jsonBlobRef)) {
            return blob_refs_1.BlobRef.fromJsonRef(val);
          }
          if (cid_1.CID.asCID(val) || val instanceof Uint8Array) {
            return val;
          }
          const toReturn = {};
          for (const key of Object.keys(val)) {
            toReturn[key] = (0, exports.ipldToLex)(val[key]);
          }
          return toReturn;
        }
        return val;
      };
      exports.ipldToLex = ipldToLex;
      const lexToJson = (val) => {
        return (0, common_web_1.ipldToJson)((0, exports.lexToIpld)(val));
      };
      exports.lexToJson = lexToJson;
      const stringifyLex = (val) => {
        return JSON.stringify((0, exports.lexToJson)(val));
      };
      exports.stringifyLex = stringifyLex;
      const jsonToLex = (val) => {
        return (0, exports.ipldToLex)((0, common_web_1.jsonToIpld)(val));
      };
      exports.jsonToLex = jsonToLex;
      const jsonStringToLex = (val) => {
        return (0, exports.jsonToLex)(JSON.parse(val));
      };
      exports.jsonStringToLex = jsonStringToLex;
    })(serialize);
    return serialize;
  }
  var hasRequiredDist$2;
  function requireDist$2() {
    if (hasRequiredDist$2) return dist$4;
    hasRequiredDist$2 = 1;
    (function(exports) {
      var __createBinding = dist$4 && dist$4.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      });
      var __exportStar = dist$4 && dist$4.__exportStar || function(m, exports2) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      __exportStar(requireTypes$4(), exports);
      __exportStar(requireLexicons$1(), exports);
      __exportStar(requireBlobRefs(), exports);
      __exportStar(requireSerialize(), exports);
    })(dist$4);
    return dist$4;
  }
  var lexicons = {};
  var util$5 = {};
  var hasRequiredUtil$5;
  function requireUtil$5() {
    if (hasRequiredUtil$5) return util$5;
    hasRequiredUtil$5 = 1;
    Object.defineProperty(util$5, "__esModule", { value: true });
    util$5.is$typed = is$typed;
    util$5.maybe$typed = maybe$typed;
    util$5.asPredicate = asPredicate;
    function isObject(v) {
      return v != null && typeof v === "object";
    }
    function is$type($type, id, hash) {
      return hash === "main" ? $type === id : (
        // $type === `${id}#${hash}`
        typeof $type === "string" && $type.length === id.length + 1 + hash.length && $type.charCodeAt(id.length) === 35 && $type.startsWith(id) && $type.endsWith(hash)
      );
    }
    function is$typed(v, id, hash) {
      return isObject(v) && "$type" in v && is$type(v.$type, id, hash);
    }
    function maybe$typed(v, id, hash) {
      return isObject(v) && ("$type" in v ? v.$type === void 0 || is$type(v.$type, id, hash) : true);
    }
    function asPredicate(validate) {
      return function(v) {
        return validate(v).success;
      };
    }
    return util$5;
  }
  var hasRequiredLexicons;
  function requireLexicons() {
    if (hasRequiredLexicons) return lexicons;
    hasRequiredLexicons = 1;
    (function(exports) {
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ids = exports.lexicons = exports.schemas = exports.schemaDict = void 0;
      exports.validate = validate;
      const lexicon_1 = requireDist$2();
      const util_js_1 = requireUtil$5();
      exports.schemaDict = {
        ComAtprotoAdminDefs: {
          lexicon: 1,
          id: "com.atproto.admin.defs",
          defs: {
            statusAttr: {
              type: "object",
              required: ["applied"],
              properties: {
                applied: {
                  type: "boolean"
                },
                ref: {
                  type: "string"
                }
              }
            },
            accountView: {
              type: "object",
              required: ["did", "handle", "indexedAt"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                },
                handle: {
                  type: "string",
                  format: "handle"
                },
                email: {
                  type: "string"
                },
                relatedRecords: {
                  type: "array",
                  items: {
                    type: "unknown"
                  }
                },
                indexedAt: {
                  type: "string",
                  format: "datetime"
                },
                invitedBy: {
                  type: "ref",
                  ref: "lex:com.atproto.server.defs#inviteCode"
                },
                invites: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.server.defs#inviteCode"
                  }
                },
                invitesDisabled: {
                  type: "boolean"
                },
                emailConfirmedAt: {
                  type: "string",
                  format: "datetime"
                },
                inviteNote: {
                  type: "string"
                },
                deactivatedAt: {
                  type: "string",
                  format: "datetime"
                },
                threatSignatures: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.admin.defs#threatSignature"
                  }
                }
              }
            },
            repoRef: {
              type: "object",
              required: ["did"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                }
              }
            },
            repoBlobRef: {
              type: "object",
              required: ["did", "cid"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                },
                cid: {
                  type: "string",
                  format: "cid"
                },
                recordUri: {
                  type: "string",
                  format: "at-uri"
                }
              }
            },
            threatSignature: {
              type: "object",
              required: ["property", "value"],
              properties: {
                property: {
                  type: "string"
                },
                value: {
                  type: "string"
                }
              }
            }
          }
        },
        ComAtprotoAdminDeleteAccount: {
          lexicon: 1,
          id: "com.atproto.admin.deleteAccount",
          defs: {
            main: {
              type: "procedure",
              description: "Delete a user account as an administrator.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["did"],
                  properties: {
                    did: {
                      type: "string",
                      format: "did"
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoAdminDisableAccountInvites: {
          lexicon: 1,
          id: "com.atproto.admin.disableAccountInvites",
          defs: {
            main: {
              type: "procedure",
              description: "Disable an account from receiving new invite codes, but does not invalidate existing codes.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["account"],
                  properties: {
                    account: {
                      type: "string",
                      format: "did"
                    },
                    note: {
                      type: "string",
                      description: "Optional reason for disabled invites."
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoAdminDisableInviteCodes: {
          lexicon: 1,
          id: "com.atproto.admin.disableInviteCodes",
          defs: {
            main: {
              type: "procedure",
              description: "Disable some set of codes and/or all codes associated with a set of users.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  properties: {
                    codes: {
                      type: "array",
                      items: {
                        type: "string"
                      }
                    },
                    accounts: {
                      type: "array",
                      items: {
                        type: "string"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoAdminEnableAccountInvites: {
          lexicon: 1,
          id: "com.atproto.admin.enableAccountInvites",
          defs: {
            main: {
              type: "procedure",
              description: "Re-enable an account's ability to receive invite codes.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["account"],
                  properties: {
                    account: {
                      type: "string",
                      format: "did"
                    },
                    note: {
                      type: "string",
                      description: "Optional reason for enabled invites."
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoAdminGetAccountInfo: {
          lexicon: 1,
          id: "com.atproto.admin.getAccountInfo",
          defs: {
            main: {
              type: "query",
              description: "Get details about an account.",
              parameters: {
                type: "params",
                required: ["did"],
                properties: {
                  did: {
                    type: "string",
                    format: "did"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "ref",
                  ref: "lex:com.atproto.admin.defs#accountView"
                }
              }
            }
          }
        },
        ComAtprotoAdminGetAccountInfos: {
          lexicon: 1,
          id: "com.atproto.admin.getAccountInfos",
          defs: {
            main: {
              type: "query",
              description: "Get details about some accounts.",
              parameters: {
                type: "params",
                required: ["dids"],
                properties: {
                  dids: {
                    type: "array",
                    items: {
                      type: "string",
                      format: "did"
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["infos"],
                  properties: {
                    infos: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:com.atproto.admin.defs#accountView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoAdminGetInviteCodes: {
          lexicon: 1,
          id: "com.atproto.admin.getInviteCodes",
          defs: {
            main: {
              type: "query",
              description: "Get an admin view of invite codes.",
              parameters: {
                type: "params",
                properties: {
                  sort: {
                    type: "string",
                    knownValues: ["recent", "usage"],
                    default: "recent"
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 500,
                    default: 100
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["codes"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    codes: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:com.atproto.server.defs#inviteCode"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoAdminGetSubjectStatus: {
          lexicon: 1,
          id: "com.atproto.admin.getSubjectStatus",
          defs: {
            main: {
              type: "query",
              description: "Get the service-specific admin status of a subject (account, record, or blob).",
              parameters: {
                type: "params",
                properties: {
                  did: {
                    type: "string",
                    format: "did"
                  },
                  uri: {
                    type: "string",
                    format: "at-uri"
                  },
                  blob: {
                    type: "string",
                    format: "cid"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["subject"],
                  properties: {
                    subject: {
                      type: "union",
                      refs: [
                        "lex:com.atproto.admin.defs#repoRef",
                        "lex:com.atproto.repo.strongRef",
                        "lex:com.atproto.admin.defs#repoBlobRef"
                      ]
                    },
                    takedown: {
                      type: "ref",
                      ref: "lex:com.atproto.admin.defs#statusAttr"
                    },
                    deactivated: {
                      type: "ref",
                      ref: "lex:com.atproto.admin.defs#statusAttr"
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoAdminSearchAccounts: {
          lexicon: 1,
          id: "com.atproto.admin.searchAccounts",
          defs: {
            main: {
              type: "query",
              description: "Get list of accounts that matches your search query.",
              parameters: {
                type: "params",
                properties: {
                  email: {
                    type: "string"
                  },
                  cursor: {
                    type: "string"
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["accounts"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    accounts: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:com.atproto.admin.defs#accountView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoAdminSendEmail: {
          lexicon: 1,
          id: "com.atproto.admin.sendEmail",
          defs: {
            main: {
              type: "procedure",
              description: "Send email to a user's account email address.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["recipientDid", "content", "senderDid"],
                  properties: {
                    recipientDid: {
                      type: "string",
                      format: "did"
                    },
                    content: {
                      type: "string"
                    },
                    subject: {
                      type: "string"
                    },
                    senderDid: {
                      type: "string",
                      format: "did"
                    },
                    comment: {
                      type: "string",
                      description: "Additional comment by the sender that won't be used in the email itself but helpful to provide more context for moderators/reviewers"
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["sent"],
                  properties: {
                    sent: {
                      type: "boolean"
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoAdminUpdateAccountEmail: {
          lexicon: 1,
          id: "com.atproto.admin.updateAccountEmail",
          defs: {
            main: {
              type: "procedure",
              description: "Administrative action to update an account's email.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["account", "email"],
                  properties: {
                    account: {
                      type: "string",
                      format: "at-identifier",
                      description: "The handle or DID of the repo."
                    },
                    email: {
                      type: "string"
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoAdminUpdateAccountHandle: {
          lexicon: 1,
          id: "com.atproto.admin.updateAccountHandle",
          defs: {
            main: {
              type: "procedure",
              description: "Administrative action to update an account's handle.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["did", "handle"],
                  properties: {
                    did: {
                      type: "string",
                      format: "did"
                    },
                    handle: {
                      type: "string",
                      format: "handle"
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoAdminUpdateAccountPassword: {
          lexicon: 1,
          id: "com.atproto.admin.updateAccountPassword",
          defs: {
            main: {
              type: "procedure",
              description: "Update the password for a user account as an administrator.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["did", "password"],
                  properties: {
                    did: {
                      type: "string",
                      format: "did"
                    },
                    password: {
                      type: "string"
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoAdminUpdateSubjectStatus: {
          lexicon: 1,
          id: "com.atproto.admin.updateSubjectStatus",
          defs: {
            main: {
              type: "procedure",
              description: "Update the service-specific admin status of a subject (account, record, or blob).",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["subject"],
                  properties: {
                    subject: {
                      type: "union",
                      refs: [
                        "lex:com.atproto.admin.defs#repoRef",
                        "lex:com.atproto.repo.strongRef",
                        "lex:com.atproto.admin.defs#repoBlobRef"
                      ]
                    },
                    takedown: {
                      type: "ref",
                      ref: "lex:com.atproto.admin.defs#statusAttr"
                    },
                    deactivated: {
                      type: "ref",
                      ref: "lex:com.atproto.admin.defs#statusAttr"
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["subject"],
                  properties: {
                    subject: {
                      type: "union",
                      refs: [
                        "lex:com.atproto.admin.defs#repoRef",
                        "lex:com.atproto.repo.strongRef",
                        "lex:com.atproto.admin.defs#repoBlobRef"
                      ]
                    },
                    takedown: {
                      type: "ref",
                      ref: "lex:com.atproto.admin.defs#statusAttr"
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoIdentityGetRecommendedDidCredentials: {
          lexicon: 1,
          id: "com.atproto.identity.getRecommendedDidCredentials",
          defs: {
            main: {
              type: "query",
              description: "Describe the credentials that should be included in the DID doc of an account that is migrating to this service.",
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  properties: {
                    rotationKeys: {
                      description: "Recommended rotation keys for PLC dids. Should be undefined (or ignored) for did:webs.",
                      type: "array",
                      items: {
                        type: "string"
                      }
                    },
                    alsoKnownAs: {
                      type: "array",
                      items: {
                        type: "string"
                      }
                    },
                    verificationMethods: {
                      type: "unknown"
                    },
                    services: {
                      type: "unknown"
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoIdentityRequestPlcOperationSignature: {
          lexicon: 1,
          id: "com.atproto.identity.requestPlcOperationSignature",
          defs: {
            main: {
              type: "procedure",
              description: "Request an email with a code to in order to request a signed PLC operation. Requires Auth."
            }
          }
        },
        ComAtprotoIdentityResolveHandle: {
          lexicon: 1,
          id: "com.atproto.identity.resolveHandle",
          defs: {
            main: {
              type: "query",
              description: "Resolves a handle (domain name) to a DID.",
              parameters: {
                type: "params",
                required: ["handle"],
                properties: {
                  handle: {
                    type: "string",
                    format: "handle",
                    description: "The handle to resolve."
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["did"],
                  properties: {
                    did: {
                      type: "string",
                      format: "did"
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoIdentitySignPlcOperation: {
          lexicon: 1,
          id: "com.atproto.identity.signPlcOperation",
          defs: {
            main: {
              type: "procedure",
              description: "Signs a PLC operation to update some value(s) in the requesting DID's document.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  properties: {
                    token: {
                      description: "A token received through com.atproto.identity.requestPlcOperationSignature",
                      type: "string"
                    },
                    rotationKeys: {
                      type: "array",
                      items: {
                        type: "string"
                      }
                    },
                    alsoKnownAs: {
                      type: "array",
                      items: {
                        type: "string"
                      }
                    },
                    verificationMethods: {
                      type: "unknown"
                    },
                    services: {
                      type: "unknown"
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["operation"],
                  properties: {
                    operation: {
                      type: "unknown",
                      description: "A signed DID PLC operation."
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoIdentitySubmitPlcOperation: {
          lexicon: 1,
          id: "com.atproto.identity.submitPlcOperation",
          defs: {
            main: {
              type: "procedure",
              description: "Validates a PLC operation to ensure that it doesn't violate a service's constraints or get the identity into a bad state, then submits it to the PLC registry",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["operation"],
                  properties: {
                    operation: {
                      type: "unknown"
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoIdentityUpdateHandle: {
          lexicon: 1,
          id: "com.atproto.identity.updateHandle",
          defs: {
            main: {
              type: "procedure",
              description: "Updates the current account's handle. Verifies handle validity, and updates did:plc document if necessary. Implemented by PDS, and requires auth.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["handle"],
                  properties: {
                    handle: {
                      type: "string",
                      format: "handle",
                      description: "The new handle."
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoLabelDefs: {
          lexicon: 1,
          id: "com.atproto.label.defs",
          defs: {
            label: {
              type: "object",
              description: "Metadata tag on an atproto resource (eg, repo or record).",
              required: ["src", "uri", "val", "cts"],
              properties: {
                ver: {
                  type: "integer",
                  description: "The AT Protocol version of the label object."
                },
                src: {
                  type: "string",
                  format: "did",
                  description: "DID of the actor who created this label."
                },
                uri: {
                  type: "string",
                  format: "uri",
                  description: "AT URI of the record, repository (account), or other resource that this label applies to."
                },
                cid: {
                  type: "string",
                  format: "cid",
                  description: "Optionally, CID specifying the specific version of 'uri' resource this label applies to."
                },
                val: {
                  type: "string",
                  maxLength: 128,
                  description: "The short string name of the value or type of this label."
                },
                neg: {
                  type: "boolean",
                  description: "If true, this is a negation label, overwriting a previous label."
                },
                cts: {
                  type: "string",
                  format: "datetime",
                  description: "Timestamp when this label was created."
                },
                exp: {
                  type: "string",
                  format: "datetime",
                  description: "Timestamp at which this label expires (no longer applies)."
                },
                sig: {
                  type: "bytes",
                  description: "Signature of dag-cbor encoded label."
                }
              }
            },
            selfLabels: {
              type: "object",
              description: "Metadata tags on an atproto record, published by the author within the record.",
              required: ["values"],
              properties: {
                values: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.label.defs#selfLabel"
                  },
                  maxLength: 10
                }
              }
            },
            selfLabel: {
              type: "object",
              description: "Metadata tag on an atproto record, published by the author within the record. Note that schemas should use #selfLabels, not #selfLabel.",
              required: ["val"],
              properties: {
                val: {
                  type: "string",
                  maxLength: 128,
                  description: "The short string name of the value or type of this label."
                }
              }
            },
            labelValueDefinition: {
              type: "object",
              description: "Declares a label value and its expected interpretations and behaviors.",
              required: ["identifier", "severity", "blurs", "locales"],
              properties: {
                identifier: {
                  type: "string",
                  description: "The value of the label being defined. Must only include lowercase ascii and the '-' character ([a-z-]+).",
                  maxLength: 100,
                  maxGraphemes: 100
                },
                severity: {
                  type: "string",
                  description: "How should a client visually convey this label? 'inform' means neutral and informational; 'alert' means negative and warning; 'none' means show nothing.",
                  knownValues: ["inform", "alert", "none"]
                },
                blurs: {
                  type: "string",
                  description: "What should this label hide in the UI, if applied? 'content' hides all of the target; 'media' hides the images/video/audio; 'none' hides nothing.",
                  knownValues: ["content", "media", "none"]
                },
                defaultSetting: {
                  type: "string",
                  description: "The default setting for this label.",
                  knownValues: ["ignore", "warn", "hide"],
                  default: "warn"
                },
                adultOnly: {
                  type: "boolean",
                  description: "Does the user need to have adult content enabled in order to configure this label?"
                },
                locales: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.label.defs#labelValueDefinitionStrings"
                  }
                }
              }
            },
            labelValueDefinitionStrings: {
              type: "object",
              description: "Strings which describe the label in the UI, localized into a specific language.",
              required: ["lang", "name", "description"],
              properties: {
                lang: {
                  type: "string",
                  description: "The code of the language these strings are written in.",
                  format: "language"
                },
                name: {
                  type: "string",
                  description: "A short human-readable name for the label.",
                  maxGraphemes: 64,
                  maxLength: 640
                },
                description: {
                  type: "string",
                  description: "A longer description of what the label means and why it might be applied.",
                  maxGraphemes: 1e4,
                  maxLength: 1e5
                }
              }
            },
            labelValue: {
              type: "string",
              knownValues: [
                "!hide",
                "!no-promote",
                "!warn",
                "!no-unauthenticated",
                "dmca-violation",
                "doxxing",
                "porn",
                "sexual",
                "nudity",
                "nsfl",
                "gore"
              ]
            }
          }
        },
        ComAtprotoLabelQueryLabels: {
          lexicon: 1,
          id: "com.atproto.label.queryLabels",
          defs: {
            main: {
              type: "query",
              description: "Find labels relevant to the provided AT-URI patterns. Public endpoint for moderation services, though may return different or additional results with auth.",
              parameters: {
                type: "params",
                required: ["uriPatterns"],
                properties: {
                  uriPatterns: {
                    type: "array",
                    items: {
                      type: "string"
                    },
                    description: "List of AT URI patterns to match (boolean 'OR'). Each may be a prefix (ending with '*'; will match inclusive of the string leading to '*'), or a full URI."
                  },
                  sources: {
                    type: "array",
                    items: {
                      type: "string",
                      format: "did"
                    },
                    description: "Optional list of label sources (DIDs) to filter on."
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 250,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["labels"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    labels: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:com.atproto.label.defs#label"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoLabelSubscribeLabels: {
          lexicon: 1,
          id: "com.atproto.label.subscribeLabels",
          defs: {
            main: {
              type: "subscription",
              description: "Subscribe to stream of labels (and negations). Public endpoint implemented by mod services. Uses same sequencing scheme as repo event stream.",
              parameters: {
                type: "params",
                properties: {
                  cursor: {
                    type: "integer",
                    description: "The last known event seq number to backfill from."
                  }
                }
              },
              message: {
                schema: {
                  type: "union",
                  refs: [
                    "lex:com.atproto.label.subscribeLabels#labels",
                    "lex:com.atproto.label.subscribeLabels#info"
                  ]
                }
              },
              errors: [
                {
                  name: "FutureCursor"
                }
              ]
            },
            labels: {
              type: "object",
              required: ["seq", "labels"],
              properties: {
                seq: {
                  type: "integer"
                },
                labels: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.label.defs#label"
                  }
                }
              }
            },
            info: {
              type: "object",
              required: ["name"],
              properties: {
                name: {
                  type: "string",
                  knownValues: ["OutdatedCursor"]
                },
                message: {
                  type: "string"
                }
              }
            }
          }
        },
        ComAtprotoLexiconSchema: {
          lexicon: 1,
          id: "com.atproto.lexicon.schema",
          defs: {
            main: {
              type: "record",
              description: "Representation of Lexicon schemas themselves, when published as atproto records. Note that the schema language is not defined in Lexicon; this meta schema currently only includes a single version field ('lexicon'). See the atproto specifications for description of the other expected top-level fields ('id', 'defs', etc).",
              key: "nsid",
              record: {
                type: "object",
                required: ["lexicon"],
                properties: {
                  lexicon: {
                    type: "integer",
                    description: "Indicates the 'version' of the Lexicon language. Must be '1' for the current atproto/Lexicon schema system."
                  }
                }
              }
            }
          }
        },
        ComAtprotoModerationCreateReport: {
          lexicon: 1,
          id: "com.atproto.moderation.createReport",
          defs: {
            main: {
              type: "procedure",
              description: "Submit a moderation report regarding an atproto account or record. Implemented by moderation services (with PDS proxying), and requires auth.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["reasonType", "subject"],
                  properties: {
                    reasonType: {
                      type: "ref",
                      description: "Indicates the broad category of violation the report is for.",
                      ref: "lex:com.atproto.moderation.defs#reasonType"
                    },
                    reason: {
                      type: "string",
                      maxGraphemes: 2e3,
                      maxLength: 2e4,
                      description: "Additional context about the content and violation."
                    },
                    subject: {
                      type: "union",
                      refs: [
                        "lex:com.atproto.admin.defs#repoRef",
                        "lex:com.atproto.repo.strongRef"
                      ]
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: [
                    "id",
                    "reasonType",
                    "subject",
                    "reportedBy",
                    "createdAt"
                  ],
                  properties: {
                    id: {
                      type: "integer"
                    },
                    reasonType: {
                      type: "ref",
                      ref: "lex:com.atproto.moderation.defs#reasonType"
                    },
                    reason: {
                      type: "string",
                      maxGraphemes: 2e3,
                      maxLength: 2e4
                    },
                    subject: {
                      type: "union",
                      refs: [
                        "lex:com.atproto.admin.defs#repoRef",
                        "lex:com.atproto.repo.strongRef"
                      ]
                    },
                    reportedBy: {
                      type: "string",
                      format: "did"
                    },
                    createdAt: {
                      type: "string",
                      format: "datetime"
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoModerationDefs: {
          lexicon: 1,
          id: "com.atproto.moderation.defs",
          defs: {
            reasonType: {
              type: "string",
              knownValues: [
                "com.atproto.moderation.defs#reasonSpam",
                "com.atproto.moderation.defs#reasonViolation",
                "com.atproto.moderation.defs#reasonMisleading",
                "com.atproto.moderation.defs#reasonSexual",
                "com.atproto.moderation.defs#reasonRude",
                "com.atproto.moderation.defs#reasonOther",
                "com.atproto.moderation.defs#reasonAppeal"
              ]
            },
            reasonSpam: {
              type: "token",
              description: "Spam: frequent unwanted promotion, replies, mentions"
            },
            reasonViolation: {
              type: "token",
              description: "Direct violation of server rules, laws, terms of service"
            },
            reasonMisleading: {
              type: "token",
              description: "Misleading identity, affiliation, or content"
            },
            reasonSexual: {
              type: "token",
              description: "Unwanted or mislabeled sexual content"
            },
            reasonRude: {
              type: "token",
              description: "Rude, harassing, explicit, or otherwise unwelcoming behavior"
            },
            reasonOther: {
              type: "token",
              description: "Other: reports not falling under another report category"
            },
            reasonAppeal: {
              type: "token",
              description: "Appeal: appeal a previously taken moderation action"
            }
          }
        },
        ComAtprotoRepoApplyWrites: {
          lexicon: 1,
          id: "com.atproto.repo.applyWrites",
          defs: {
            main: {
              type: "procedure",
              description: "Apply a batch transaction of repository creates, updates, and deletes. Requires auth, implemented by PDS.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["repo", "writes"],
                  properties: {
                    repo: {
                      type: "string",
                      format: "at-identifier",
                      description: "The handle or DID of the repo (aka, current account)."
                    },
                    validate: {
                      type: "boolean",
                      description: "Can be set to 'false' to skip Lexicon schema validation of record data across all operations, 'true' to require it, or leave unset to validate only for known Lexicons."
                    },
                    writes: {
                      type: "array",
                      items: {
                        type: "union",
                        refs: [
                          "lex:com.atproto.repo.applyWrites#create",
                          "lex:com.atproto.repo.applyWrites#update",
                          "lex:com.atproto.repo.applyWrites#delete"
                        ],
                        closed: true
                      }
                    },
                    swapCommit: {
                      type: "string",
                      description: "If provided, the entire operation will fail if the current repo commit CID does not match this value. Used to prevent conflicting repo mutations.",
                      format: "cid"
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: [],
                  properties: {
                    commit: {
                      type: "ref",
                      ref: "lex:com.atproto.repo.defs#commitMeta"
                    },
                    results: {
                      type: "array",
                      items: {
                        type: "union",
                        refs: [
                          "lex:com.atproto.repo.applyWrites#createResult",
                          "lex:com.atproto.repo.applyWrites#updateResult",
                          "lex:com.atproto.repo.applyWrites#deleteResult"
                        ],
                        closed: true
                      }
                    }
                  }
                }
              },
              errors: [
                {
                  name: "InvalidSwap",
                  description: "Indicates that the 'swapCommit' parameter did not match current commit."
                }
              ]
            },
            create: {
              type: "object",
              description: "Operation which creates a new record.",
              required: ["collection", "value"],
              properties: {
                collection: {
                  type: "string",
                  format: "nsid"
                },
                rkey: {
                  type: "string",
                  maxLength: 512
                },
                value: {
                  type: "unknown"
                }
              }
            },
            update: {
              type: "object",
              description: "Operation which updates an existing record.",
              required: ["collection", "rkey", "value"],
              properties: {
                collection: {
                  type: "string",
                  format: "nsid"
                },
                rkey: {
                  type: "string"
                },
                value: {
                  type: "unknown"
                }
              }
            },
            delete: {
              type: "object",
              description: "Operation which deletes an existing record.",
              required: ["collection", "rkey"],
              properties: {
                collection: {
                  type: "string",
                  format: "nsid"
                },
                rkey: {
                  type: "string"
                }
              }
            },
            createResult: {
              type: "object",
              required: ["uri", "cid"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                cid: {
                  type: "string",
                  format: "cid"
                },
                validationStatus: {
                  type: "string",
                  knownValues: ["valid", "unknown"]
                }
              }
            },
            updateResult: {
              type: "object",
              required: ["uri", "cid"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                cid: {
                  type: "string",
                  format: "cid"
                },
                validationStatus: {
                  type: "string",
                  knownValues: ["valid", "unknown"]
                }
              }
            },
            deleteResult: {
              type: "object",
              required: [],
              properties: {}
            }
          }
        },
        ComAtprotoRepoCreateRecord: {
          lexicon: 1,
          id: "com.atproto.repo.createRecord",
          defs: {
            main: {
              type: "procedure",
              description: "Create a single new repository record. Requires auth, implemented by PDS.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["repo", "collection", "record"],
                  properties: {
                    repo: {
                      type: "string",
                      format: "at-identifier",
                      description: "The handle or DID of the repo (aka, current account)."
                    },
                    collection: {
                      type: "string",
                      format: "nsid",
                      description: "The NSID of the record collection."
                    },
                    rkey: {
                      type: "string",
                      description: "The Record Key.",
                      maxLength: 512
                    },
                    validate: {
                      type: "boolean",
                      description: "Can be set to 'false' to skip Lexicon schema validation of record data, 'true' to require it, or leave unset to validate only for known Lexicons."
                    },
                    record: {
                      type: "unknown",
                      description: "The record itself. Must contain a $type field."
                    },
                    swapCommit: {
                      type: "string",
                      format: "cid",
                      description: "Compare and swap with the previous commit by CID."
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["uri", "cid"],
                  properties: {
                    uri: {
                      type: "string",
                      format: "at-uri"
                    },
                    cid: {
                      type: "string",
                      format: "cid"
                    },
                    commit: {
                      type: "ref",
                      ref: "lex:com.atproto.repo.defs#commitMeta"
                    },
                    validationStatus: {
                      type: "string",
                      knownValues: ["valid", "unknown"]
                    }
                  }
                }
              },
              errors: [
                {
                  name: "InvalidSwap",
                  description: "Indicates that 'swapCommit' didn't match current repo commit."
                }
              ]
            }
          }
        },
        ComAtprotoRepoDefs: {
          lexicon: 1,
          id: "com.atproto.repo.defs",
          defs: {
            commitMeta: {
              type: "object",
              required: ["cid", "rev"],
              properties: {
                cid: {
                  type: "string",
                  format: "cid"
                },
                rev: {
                  type: "string"
                }
              }
            }
          }
        },
        ComAtprotoRepoDeleteRecord: {
          lexicon: 1,
          id: "com.atproto.repo.deleteRecord",
          defs: {
            main: {
              type: "procedure",
              description: "Delete a repository record, or ensure it doesn't exist. Requires auth, implemented by PDS.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["repo", "collection", "rkey"],
                  properties: {
                    repo: {
                      type: "string",
                      format: "at-identifier",
                      description: "The handle or DID of the repo (aka, current account)."
                    },
                    collection: {
                      type: "string",
                      format: "nsid",
                      description: "The NSID of the record collection."
                    },
                    rkey: {
                      type: "string",
                      description: "The Record Key."
                    },
                    swapRecord: {
                      type: "string",
                      format: "cid",
                      description: "Compare and swap with the previous record by CID."
                    },
                    swapCommit: {
                      type: "string",
                      format: "cid",
                      description: "Compare and swap with the previous commit by CID."
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  properties: {
                    commit: {
                      type: "ref",
                      ref: "lex:com.atproto.repo.defs#commitMeta"
                    }
                  }
                }
              },
              errors: [
                {
                  name: "InvalidSwap"
                }
              ]
            }
          }
        },
        ComAtprotoRepoDescribeRepo: {
          lexicon: 1,
          id: "com.atproto.repo.describeRepo",
          defs: {
            main: {
              type: "query",
              description: "Get information about an account and repository, including the list of collections. Does not require auth.",
              parameters: {
                type: "params",
                required: ["repo"],
                properties: {
                  repo: {
                    type: "string",
                    format: "at-identifier",
                    description: "The handle or DID of the repo."
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: [
                    "handle",
                    "did",
                    "didDoc",
                    "collections",
                    "handleIsCorrect"
                  ],
                  properties: {
                    handle: {
                      type: "string",
                      format: "handle"
                    },
                    did: {
                      type: "string",
                      format: "did"
                    },
                    didDoc: {
                      type: "unknown",
                      description: "The complete DID document for this account."
                    },
                    collections: {
                      type: "array",
                      description: "List of all the collections (NSIDs) for which this repo contains at least one record.",
                      items: {
                        type: "string",
                        format: "nsid"
                      }
                    },
                    handleIsCorrect: {
                      type: "boolean",
                      description: "Indicates if handle is currently valid (resolves bi-directionally)"
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoRepoGetRecord: {
          lexicon: 1,
          id: "com.atproto.repo.getRecord",
          defs: {
            main: {
              type: "query",
              description: "Get a single record from a repository. Does not require auth.",
              parameters: {
                type: "params",
                required: ["repo", "collection", "rkey"],
                properties: {
                  repo: {
                    type: "string",
                    format: "at-identifier",
                    description: "The handle or DID of the repo."
                  },
                  collection: {
                    type: "string",
                    format: "nsid",
                    description: "The NSID of the record collection."
                  },
                  rkey: {
                    type: "string",
                    description: "The Record Key."
                  },
                  cid: {
                    type: "string",
                    format: "cid",
                    description: "The CID of the version of the record. If not specified, then return the most recent version."
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["uri", "value"],
                  properties: {
                    uri: {
                      type: "string",
                      format: "at-uri"
                    },
                    cid: {
                      type: "string",
                      format: "cid"
                    },
                    value: {
                      type: "unknown"
                    }
                  }
                }
              },
              errors: [
                {
                  name: "RecordNotFound"
                }
              ]
            }
          }
        },
        ComAtprotoRepoImportRepo: {
          lexicon: 1,
          id: "com.atproto.repo.importRepo",
          defs: {
            main: {
              type: "procedure",
              description: "Import a repo in the form of a CAR file. Requires Content-Length HTTP header to be set.",
              input: {
                encoding: "application/vnd.ipld.car"
              }
            }
          }
        },
        ComAtprotoRepoListMissingBlobs: {
          lexicon: 1,
          id: "com.atproto.repo.listMissingBlobs",
          defs: {
            main: {
              type: "query",
              description: "Returns a list of missing blobs for the requesting account. Intended to be used in the account migration flow.",
              parameters: {
                type: "params",
                properties: {
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 1e3,
                    default: 500
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["blobs"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    blobs: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:com.atproto.repo.listMissingBlobs#recordBlob"
                      }
                    }
                  }
                }
              }
            },
            recordBlob: {
              type: "object",
              required: ["cid", "recordUri"],
              properties: {
                cid: {
                  type: "string",
                  format: "cid"
                },
                recordUri: {
                  type: "string",
                  format: "at-uri"
                }
              }
            }
          }
        },
        ComAtprotoRepoListRecords: {
          lexicon: 1,
          id: "com.atproto.repo.listRecords",
          defs: {
            main: {
              type: "query",
              description: "List a range of records in a repository, matching a specific collection. Does not require auth.",
              parameters: {
                type: "params",
                required: ["repo", "collection"],
                properties: {
                  repo: {
                    type: "string",
                    format: "at-identifier",
                    description: "The handle or DID of the repo."
                  },
                  collection: {
                    type: "string",
                    format: "nsid",
                    description: "The NSID of the record type."
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50,
                    description: "The number of records to return."
                  },
                  cursor: {
                    type: "string"
                  },
                  rkeyStart: {
                    type: "string",
                    description: "DEPRECATED: The lowest sort-ordered rkey to start from (exclusive)"
                  },
                  rkeyEnd: {
                    type: "string",
                    description: "DEPRECATED: The highest sort-ordered rkey to stop at (exclusive)"
                  },
                  reverse: {
                    type: "boolean",
                    description: "Flag to reverse the order of the returned records."
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["records"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    records: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:com.atproto.repo.listRecords#record"
                      }
                    }
                  }
                }
              }
            },
            record: {
              type: "object",
              required: ["uri", "cid", "value"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                cid: {
                  type: "string",
                  format: "cid"
                },
                value: {
                  type: "unknown"
                }
              }
            }
          }
        },
        ComAtprotoRepoPutRecord: {
          lexicon: 1,
          id: "com.atproto.repo.putRecord",
          defs: {
            main: {
              type: "procedure",
              description: "Write a repository record, creating or updating it as needed. Requires auth, implemented by PDS.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["repo", "collection", "rkey", "record"],
                  nullable: ["swapRecord"],
                  properties: {
                    repo: {
                      type: "string",
                      format: "at-identifier",
                      description: "The handle or DID of the repo (aka, current account)."
                    },
                    collection: {
                      type: "string",
                      format: "nsid",
                      description: "The NSID of the record collection."
                    },
                    rkey: {
                      type: "string",
                      description: "The Record Key.",
                      maxLength: 512
                    },
                    validate: {
                      type: "boolean",
                      description: "Can be set to 'false' to skip Lexicon schema validation of record data, 'true' to require it, or leave unset to validate only for known Lexicons."
                    },
                    record: {
                      type: "unknown",
                      description: "The record to write."
                    },
                    swapRecord: {
                      type: "string",
                      format: "cid",
                      description: "Compare and swap with the previous record by CID. WARNING: nullable and optional field; may cause problems with golang implementation"
                    },
                    swapCommit: {
                      type: "string",
                      format: "cid",
                      description: "Compare and swap with the previous commit by CID."
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["uri", "cid"],
                  properties: {
                    uri: {
                      type: "string",
                      format: "at-uri"
                    },
                    cid: {
                      type: "string",
                      format: "cid"
                    },
                    commit: {
                      type: "ref",
                      ref: "lex:com.atproto.repo.defs#commitMeta"
                    },
                    validationStatus: {
                      type: "string",
                      knownValues: ["valid", "unknown"]
                    }
                  }
                }
              },
              errors: [
                {
                  name: "InvalidSwap"
                }
              ]
            }
          }
        },
        ComAtprotoRepoStrongRef: {
          lexicon: 1,
          id: "com.atproto.repo.strongRef",
          description: "A URI with a content-hash fingerprint.",
          defs: {
            main: {
              type: "object",
              required: ["uri", "cid"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                cid: {
                  type: "string",
                  format: "cid"
                }
              }
            }
          }
        },
        ComAtprotoRepoUploadBlob: {
          lexicon: 1,
          id: "com.atproto.repo.uploadBlob",
          defs: {
            main: {
              type: "procedure",
              description: "Upload a new blob, to be referenced from a repository record. The blob will be deleted if it is not referenced within a time window (eg, minutes). Blob restrictions (mimetype, size, etc) are enforced when the reference is created. Requires auth, implemented by PDS.",
              input: {
                encoding: "*/*"
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["blob"],
                  properties: {
                    blob: {
                      type: "blob"
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoServerActivateAccount: {
          lexicon: 1,
          id: "com.atproto.server.activateAccount",
          defs: {
            main: {
              type: "procedure",
              description: "Activates a currently deactivated account. Used to finalize account migration after the account's repo is imported and identity is setup."
            }
          }
        },
        ComAtprotoServerCheckAccountStatus: {
          lexicon: 1,
          id: "com.atproto.server.checkAccountStatus",
          defs: {
            main: {
              type: "query",
              description: "Returns the status of an account, especially as pertaining to import or recovery. Can be called many times over the course of an account migration. Requires auth and can only be called pertaining to oneself.",
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: [
                    "activated",
                    "validDid",
                    "repoCommit",
                    "repoRev",
                    "repoBlocks",
                    "indexedRecords",
                    "privateStateValues",
                    "expectedBlobs",
                    "importedBlobs"
                  ],
                  properties: {
                    activated: {
                      type: "boolean"
                    },
                    validDid: {
                      type: "boolean"
                    },
                    repoCommit: {
                      type: "string",
                      format: "cid"
                    },
                    repoRev: {
                      type: "string"
                    },
                    repoBlocks: {
                      type: "integer"
                    },
                    indexedRecords: {
                      type: "integer"
                    },
                    privateStateValues: {
                      type: "integer"
                    },
                    expectedBlobs: {
                      type: "integer"
                    },
                    importedBlobs: {
                      type: "integer"
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoServerConfirmEmail: {
          lexicon: 1,
          id: "com.atproto.server.confirmEmail",
          defs: {
            main: {
              type: "procedure",
              description: "Confirm an email using a token from com.atproto.server.requestEmailConfirmation.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["email", "token"],
                  properties: {
                    email: {
                      type: "string"
                    },
                    token: {
                      type: "string"
                    }
                  }
                }
              },
              errors: [
                {
                  name: "AccountNotFound"
                },
                {
                  name: "ExpiredToken"
                },
                {
                  name: "InvalidToken"
                },
                {
                  name: "InvalidEmail"
                }
              ]
            }
          }
        },
        ComAtprotoServerCreateAccount: {
          lexicon: 1,
          id: "com.atproto.server.createAccount",
          defs: {
            main: {
              type: "procedure",
              description: "Create an account. Implemented by PDS.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["handle"],
                  properties: {
                    email: {
                      type: "string"
                    },
                    handle: {
                      type: "string",
                      format: "handle",
                      description: "Requested handle for the account."
                    },
                    did: {
                      type: "string",
                      format: "did",
                      description: "Pre-existing atproto DID, being imported to a new account."
                    },
                    inviteCode: {
                      type: "string"
                    },
                    verificationCode: {
                      type: "string"
                    },
                    verificationPhone: {
                      type: "string"
                    },
                    password: {
                      type: "string",
                      description: "Initial account password. May need to meet instance-specific password strength requirements."
                    },
                    recoveryKey: {
                      type: "string",
                      description: "DID PLC rotation key (aka, recovery key) to be included in PLC creation operation."
                    },
                    plcOp: {
                      type: "unknown",
                      description: "A signed DID PLC operation to be submitted as part of importing an existing account to this instance. NOTE: this optional field may be updated when full account migration is implemented."
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  description: "Account login session returned on successful account creation.",
                  required: ["accessJwt", "refreshJwt", "handle", "did"],
                  properties: {
                    accessJwt: {
                      type: "string"
                    },
                    refreshJwt: {
                      type: "string"
                    },
                    handle: {
                      type: "string",
                      format: "handle"
                    },
                    did: {
                      type: "string",
                      format: "did",
                      description: "The DID of the new account."
                    },
                    didDoc: {
                      type: "unknown",
                      description: "Complete DID document."
                    }
                  }
                }
              },
              errors: [
                {
                  name: "InvalidHandle"
                },
                {
                  name: "InvalidPassword"
                },
                {
                  name: "InvalidInviteCode"
                },
                {
                  name: "HandleNotAvailable"
                },
                {
                  name: "UnsupportedDomain"
                },
                {
                  name: "UnresolvableDid"
                },
                {
                  name: "IncompatibleDidDoc"
                }
              ]
            }
          }
        },
        ComAtprotoServerCreateAppPassword: {
          lexicon: 1,
          id: "com.atproto.server.createAppPassword",
          defs: {
            main: {
              type: "procedure",
              description: "Create an App Password.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["name"],
                  properties: {
                    name: {
                      type: "string",
                      description: "A short name for the App Password, to help distinguish them."
                    },
                    privileged: {
                      type: "boolean",
                      description: "If an app password has 'privileged' access to possibly sensitive account state. Meant for use with trusted clients."
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "ref",
                  ref: "lex:com.atproto.server.createAppPassword#appPassword"
                }
              },
              errors: [
                {
                  name: "AccountTakedown"
                }
              ]
            },
            appPassword: {
              type: "object",
              required: ["name", "password", "createdAt"],
              properties: {
                name: {
                  type: "string"
                },
                password: {
                  type: "string"
                },
                createdAt: {
                  type: "string",
                  format: "datetime"
                },
                privileged: {
                  type: "boolean"
                }
              }
            }
          }
        },
        ComAtprotoServerCreateInviteCode: {
          lexicon: 1,
          id: "com.atproto.server.createInviteCode",
          defs: {
            main: {
              type: "procedure",
              description: "Create an invite code.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["useCount"],
                  properties: {
                    useCount: {
                      type: "integer"
                    },
                    forAccount: {
                      type: "string",
                      format: "did"
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["code"],
                  properties: {
                    code: {
                      type: "string"
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoServerCreateInviteCodes: {
          lexicon: 1,
          id: "com.atproto.server.createInviteCodes",
          defs: {
            main: {
              type: "procedure",
              description: "Create invite codes.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["codeCount", "useCount"],
                  properties: {
                    codeCount: {
                      type: "integer",
                      default: 1
                    },
                    useCount: {
                      type: "integer"
                    },
                    forAccounts: {
                      type: "array",
                      items: {
                        type: "string",
                        format: "did"
                      }
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["codes"],
                  properties: {
                    codes: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:com.atproto.server.createInviteCodes#accountCodes"
                      }
                    }
                  }
                }
              }
            },
            accountCodes: {
              type: "object",
              required: ["account", "codes"],
              properties: {
                account: {
                  type: "string"
                },
                codes: {
                  type: "array",
                  items: {
                    type: "string"
                  }
                }
              }
            }
          }
        },
        ComAtprotoServerCreateSession: {
          lexicon: 1,
          id: "com.atproto.server.createSession",
          defs: {
            main: {
              type: "procedure",
              description: "Create an authentication session.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["identifier", "password"],
                  properties: {
                    identifier: {
                      type: "string",
                      description: "Handle or other identifier supported by the server for the authenticating user."
                    },
                    password: {
                      type: "string"
                    },
                    authFactorToken: {
                      type: "string"
                    },
                    allowTakendown: {
                      type: "boolean",
                      description: "When true, instead of throwing error for takendown accounts, a valid response with a narrow scoped token will be returned"
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["accessJwt", "refreshJwt", "handle", "did"],
                  properties: {
                    accessJwt: {
                      type: "string"
                    },
                    refreshJwt: {
                      type: "string"
                    },
                    handle: {
                      type: "string",
                      format: "handle"
                    },
                    did: {
                      type: "string",
                      format: "did"
                    },
                    didDoc: {
                      type: "unknown"
                    },
                    email: {
                      type: "string"
                    },
                    emailConfirmed: {
                      type: "boolean"
                    },
                    emailAuthFactor: {
                      type: "boolean"
                    },
                    active: {
                      type: "boolean"
                    },
                    status: {
                      type: "string",
                      description: "If active=false, this optional field indicates a possible reason for why the account is not active. If active=false and no status is supplied, then the host makes no claim for why the repository is no longer being hosted.",
                      knownValues: ["takendown", "suspended", "deactivated"]
                    }
                  }
                }
              },
              errors: [
                {
                  name: "AccountTakedown"
                },
                {
                  name: "AuthFactorTokenRequired"
                }
              ]
            }
          }
        },
        ComAtprotoServerDeactivateAccount: {
          lexicon: 1,
          id: "com.atproto.server.deactivateAccount",
          defs: {
            main: {
              type: "procedure",
              description: "Deactivates a currently active account. Stops serving of repo, and future writes to repo until reactivated. Used to finalize account migration with the old host after the account has been activated on the new host.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  properties: {
                    deleteAfter: {
                      type: "string",
                      format: "datetime",
                      description: "A recommendation to server as to how long they should hold onto the deactivated account before deleting."
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoServerDefs: {
          lexicon: 1,
          id: "com.atproto.server.defs",
          defs: {
            inviteCode: {
              type: "object",
              required: [
                "code",
                "available",
                "disabled",
                "forAccount",
                "createdBy",
                "createdAt",
                "uses"
              ],
              properties: {
                code: {
                  type: "string"
                },
                available: {
                  type: "integer"
                },
                disabled: {
                  type: "boolean"
                },
                forAccount: {
                  type: "string"
                },
                createdBy: {
                  type: "string"
                },
                createdAt: {
                  type: "string",
                  format: "datetime"
                },
                uses: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.server.defs#inviteCodeUse"
                  }
                }
              }
            },
            inviteCodeUse: {
              type: "object",
              required: ["usedBy", "usedAt"],
              properties: {
                usedBy: {
                  type: "string",
                  format: "did"
                },
                usedAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            }
          }
        },
        ComAtprotoServerDeleteAccount: {
          lexicon: 1,
          id: "com.atproto.server.deleteAccount",
          defs: {
            main: {
              type: "procedure",
              description: "Delete an actor's account with a token and password. Can only be called after requesting a deletion token. Requires auth.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["did", "password", "token"],
                  properties: {
                    did: {
                      type: "string",
                      format: "did"
                    },
                    password: {
                      type: "string"
                    },
                    token: {
                      type: "string"
                    }
                  }
                }
              },
              errors: [
                {
                  name: "ExpiredToken"
                },
                {
                  name: "InvalidToken"
                }
              ]
            }
          }
        },
        ComAtprotoServerDeleteSession: {
          lexicon: 1,
          id: "com.atproto.server.deleteSession",
          defs: {
            main: {
              type: "procedure",
              description: "Delete the current session. Requires auth."
            }
          }
        },
        ComAtprotoServerDescribeServer: {
          lexicon: 1,
          id: "com.atproto.server.describeServer",
          defs: {
            main: {
              type: "query",
              description: "Describes the server's account creation requirements and capabilities. Implemented by PDS.",
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["did", "availableUserDomains"],
                  properties: {
                    inviteCodeRequired: {
                      type: "boolean",
                      description: "If true, an invite code must be supplied to create an account on this instance."
                    },
                    phoneVerificationRequired: {
                      type: "boolean",
                      description: "If true, a phone verification token must be supplied to create an account on this instance."
                    },
                    availableUserDomains: {
                      type: "array",
                      description: "List of domain suffixes that can be used in account handles.",
                      items: {
                        type: "string"
                      }
                    },
                    links: {
                      type: "ref",
                      description: "URLs of service policy documents.",
                      ref: "lex:com.atproto.server.describeServer#links"
                    },
                    contact: {
                      type: "ref",
                      description: "Contact information",
                      ref: "lex:com.atproto.server.describeServer#contact"
                    },
                    did: {
                      type: "string",
                      format: "did"
                    }
                  }
                }
              }
            },
            links: {
              type: "object",
              properties: {
                privacyPolicy: {
                  type: "string",
                  format: "uri"
                },
                termsOfService: {
                  type: "string",
                  format: "uri"
                }
              }
            },
            contact: {
              type: "object",
              properties: {
                email: {
                  type: "string"
                }
              }
            }
          }
        },
        ComAtprotoServerGetAccountInviteCodes: {
          lexicon: 1,
          id: "com.atproto.server.getAccountInviteCodes",
          defs: {
            main: {
              type: "query",
              description: "Get all invite codes for the current account. Requires auth.",
              parameters: {
                type: "params",
                properties: {
                  includeUsed: {
                    type: "boolean",
                    default: true
                  },
                  createAvailable: {
                    type: "boolean",
                    default: true,
                    description: "Controls whether any new 'earned' but not 'created' invites should be created."
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["codes"],
                  properties: {
                    codes: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:com.atproto.server.defs#inviteCode"
                      }
                    }
                  }
                }
              },
              errors: [
                {
                  name: "DuplicateCreate"
                }
              ]
            }
          }
        },
        ComAtprotoServerGetServiceAuth: {
          lexicon: 1,
          id: "com.atproto.server.getServiceAuth",
          defs: {
            main: {
              type: "query",
              description: "Get a signed token on behalf of the requesting DID for the requested service.",
              parameters: {
                type: "params",
                required: ["aud"],
                properties: {
                  aud: {
                    type: "string",
                    format: "did",
                    description: "The DID of the service that the token will be used to authenticate with"
                  },
                  exp: {
                    type: "integer",
                    description: "The time in Unix Epoch seconds that the JWT expires. Defaults to 60 seconds in the future. The service may enforce certain time bounds on tokens depending on the requested scope."
                  },
                  lxm: {
                    type: "string",
                    format: "nsid",
                    description: "Lexicon (XRPC) method to bind the requested token to"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["token"],
                  properties: {
                    token: {
                      type: "string"
                    }
                  }
                }
              },
              errors: [
                {
                  name: "BadExpiration",
                  description: "Indicates that the requested expiration date is not a valid. May be in the past or may be reliant on the requested scopes."
                }
              ]
            }
          }
        },
        ComAtprotoServerGetSession: {
          lexicon: 1,
          id: "com.atproto.server.getSession",
          defs: {
            main: {
              type: "query",
              description: "Get information about the current auth session. Requires auth.",
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["handle", "did"],
                  properties: {
                    handle: {
                      type: "string",
                      format: "handle"
                    },
                    did: {
                      type: "string",
                      format: "did"
                    },
                    email: {
                      type: "string"
                    },
                    emailConfirmed: {
                      type: "boolean"
                    },
                    emailAuthFactor: {
                      type: "boolean"
                    },
                    didDoc: {
                      type: "unknown"
                    },
                    active: {
                      type: "boolean"
                    },
                    status: {
                      type: "string",
                      description: "If active=false, this optional field indicates a possible reason for why the account is not active. If active=false and no status is supplied, then the host makes no claim for why the repository is no longer being hosted.",
                      knownValues: ["takendown", "suspended", "deactivated"]
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoServerListAppPasswords: {
          lexicon: 1,
          id: "com.atproto.server.listAppPasswords",
          defs: {
            main: {
              type: "query",
              description: "List all App Passwords.",
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["passwords"],
                  properties: {
                    passwords: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:com.atproto.server.listAppPasswords#appPassword"
                      }
                    }
                  }
                }
              },
              errors: [
                {
                  name: "AccountTakedown"
                }
              ]
            },
            appPassword: {
              type: "object",
              required: ["name", "createdAt"],
              properties: {
                name: {
                  type: "string"
                },
                createdAt: {
                  type: "string",
                  format: "datetime"
                },
                privileged: {
                  type: "boolean"
                }
              }
            }
          }
        },
        ComAtprotoServerRefreshSession: {
          lexicon: 1,
          id: "com.atproto.server.refreshSession",
          defs: {
            main: {
              type: "procedure",
              description: "Refresh an authentication session. Requires auth using the 'refreshJwt' (not the 'accessJwt').",
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["accessJwt", "refreshJwt", "handle", "did"],
                  properties: {
                    accessJwt: {
                      type: "string"
                    },
                    refreshJwt: {
                      type: "string"
                    },
                    handle: {
                      type: "string",
                      format: "handle"
                    },
                    did: {
                      type: "string",
                      format: "did"
                    },
                    didDoc: {
                      type: "unknown"
                    },
                    active: {
                      type: "boolean"
                    },
                    status: {
                      type: "string",
                      description: "Hosting status of the account. If not specified, then assume 'active'.",
                      knownValues: ["takendown", "suspended", "deactivated"]
                    }
                  }
                }
              },
              errors: [
                {
                  name: "AccountTakedown"
                }
              ]
            }
          }
        },
        ComAtprotoServerRequestAccountDelete: {
          lexicon: 1,
          id: "com.atproto.server.requestAccountDelete",
          defs: {
            main: {
              type: "procedure",
              description: "Initiate a user account deletion via email."
            }
          }
        },
        ComAtprotoServerRequestEmailConfirmation: {
          lexicon: 1,
          id: "com.atproto.server.requestEmailConfirmation",
          defs: {
            main: {
              type: "procedure",
              description: "Request an email with a code to confirm ownership of email."
            }
          }
        },
        ComAtprotoServerRequestEmailUpdate: {
          lexicon: 1,
          id: "com.atproto.server.requestEmailUpdate",
          defs: {
            main: {
              type: "procedure",
              description: "Request a token in order to update email.",
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["tokenRequired"],
                  properties: {
                    tokenRequired: {
                      type: "boolean"
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoServerRequestPasswordReset: {
          lexicon: 1,
          id: "com.atproto.server.requestPasswordReset",
          defs: {
            main: {
              type: "procedure",
              description: "Initiate a user account password reset via email.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["email"],
                  properties: {
                    email: {
                      type: "string"
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoServerReserveSigningKey: {
          lexicon: 1,
          id: "com.atproto.server.reserveSigningKey",
          defs: {
            main: {
              type: "procedure",
              description: "Reserve a repo signing key, for use with account creation. Necessary so that a DID PLC update operation can be constructed during an account migraiton. Public and does not require auth; implemented by PDS. NOTE: this endpoint may change when full account migration is implemented.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  properties: {
                    did: {
                      type: "string",
                      format: "did",
                      description: "The DID to reserve a key for."
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["signingKey"],
                  properties: {
                    signingKey: {
                      type: "string",
                      description: "The public key for the reserved signing key, in did:key serialization."
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoServerResetPassword: {
          lexicon: 1,
          id: "com.atproto.server.resetPassword",
          defs: {
            main: {
              type: "procedure",
              description: "Reset a user account password using a token.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["token", "password"],
                  properties: {
                    token: {
                      type: "string"
                    },
                    password: {
                      type: "string"
                    }
                  }
                }
              },
              errors: [
                {
                  name: "ExpiredToken"
                },
                {
                  name: "InvalidToken"
                }
              ]
            }
          }
        },
        ComAtprotoServerRevokeAppPassword: {
          lexicon: 1,
          id: "com.atproto.server.revokeAppPassword",
          defs: {
            main: {
              type: "procedure",
              description: "Revoke an App Password by name.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["name"],
                  properties: {
                    name: {
                      type: "string"
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoServerUpdateEmail: {
          lexicon: 1,
          id: "com.atproto.server.updateEmail",
          defs: {
            main: {
              type: "procedure",
              description: "Update an account's email.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["email"],
                  properties: {
                    email: {
                      type: "string"
                    },
                    emailAuthFactor: {
                      type: "boolean"
                    },
                    token: {
                      type: "string",
                      description: "Requires a token from com.atproto.sever.requestEmailUpdate if the account's email has been confirmed."
                    }
                  }
                }
              },
              errors: [
                {
                  name: "ExpiredToken"
                },
                {
                  name: "InvalidToken"
                },
                {
                  name: "TokenRequired"
                }
              ]
            }
          }
        },
        ComAtprotoSyncGetBlob: {
          lexicon: 1,
          id: "com.atproto.sync.getBlob",
          defs: {
            main: {
              type: "query",
              description: "Get a blob associated with a given account. Returns the full blob as originally uploaded. Does not require auth; implemented by PDS.",
              parameters: {
                type: "params",
                required: ["did", "cid"],
                properties: {
                  did: {
                    type: "string",
                    format: "did",
                    description: "The DID of the account."
                  },
                  cid: {
                    type: "string",
                    format: "cid",
                    description: "The CID of the blob to fetch"
                  }
                }
              },
              output: {
                encoding: "*/*"
              },
              errors: [
                {
                  name: "BlobNotFound"
                },
                {
                  name: "RepoNotFound"
                },
                {
                  name: "RepoTakendown"
                },
                {
                  name: "RepoSuspended"
                },
                {
                  name: "RepoDeactivated"
                }
              ]
            }
          }
        },
        ComAtprotoSyncGetBlocks: {
          lexicon: 1,
          id: "com.atproto.sync.getBlocks",
          defs: {
            main: {
              type: "query",
              description: "Get data blocks from a given repo, by CID. For example, intermediate MST nodes, or records. Does not require auth; implemented by PDS.",
              parameters: {
                type: "params",
                required: ["did", "cids"],
                properties: {
                  did: {
                    type: "string",
                    format: "did",
                    description: "The DID of the repo."
                  },
                  cids: {
                    type: "array",
                    items: {
                      type: "string",
                      format: "cid"
                    }
                  }
                }
              },
              output: {
                encoding: "application/vnd.ipld.car"
              },
              errors: [
                {
                  name: "BlockNotFound"
                },
                {
                  name: "RepoNotFound"
                },
                {
                  name: "RepoTakendown"
                },
                {
                  name: "RepoSuspended"
                },
                {
                  name: "RepoDeactivated"
                }
              ]
            }
          }
        },
        ComAtprotoSyncGetCheckout: {
          lexicon: 1,
          id: "com.atproto.sync.getCheckout",
          defs: {
            main: {
              type: "query",
              description: "DEPRECATED - please use com.atproto.sync.getRepo instead",
              parameters: {
                type: "params",
                required: ["did"],
                properties: {
                  did: {
                    type: "string",
                    format: "did",
                    description: "The DID of the repo."
                  }
                }
              },
              output: {
                encoding: "application/vnd.ipld.car"
              }
            }
          }
        },
        ComAtprotoSyncGetHead: {
          lexicon: 1,
          id: "com.atproto.sync.getHead",
          defs: {
            main: {
              type: "query",
              description: "DEPRECATED - please use com.atproto.sync.getLatestCommit instead",
              parameters: {
                type: "params",
                required: ["did"],
                properties: {
                  did: {
                    type: "string",
                    format: "did",
                    description: "The DID of the repo."
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["root"],
                  properties: {
                    root: {
                      type: "string",
                      format: "cid"
                    }
                  }
                }
              },
              errors: [
                {
                  name: "HeadNotFound"
                }
              ]
            }
          }
        },
        ComAtprotoSyncGetLatestCommit: {
          lexicon: 1,
          id: "com.atproto.sync.getLatestCommit",
          defs: {
            main: {
              type: "query",
              description: "Get the current commit CID & revision of the specified repo. Does not require auth.",
              parameters: {
                type: "params",
                required: ["did"],
                properties: {
                  did: {
                    type: "string",
                    format: "did",
                    description: "The DID of the repo."
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["cid", "rev"],
                  properties: {
                    cid: {
                      type: "string",
                      format: "cid"
                    },
                    rev: {
                      type: "string"
                    }
                  }
                }
              },
              errors: [
                {
                  name: "RepoNotFound"
                },
                {
                  name: "RepoTakendown"
                },
                {
                  name: "RepoSuspended"
                },
                {
                  name: "RepoDeactivated"
                }
              ]
            }
          }
        },
        ComAtprotoSyncGetRecord: {
          lexicon: 1,
          id: "com.atproto.sync.getRecord",
          defs: {
            main: {
              type: "query",
              description: "Get data blocks needed to prove the existence or non-existence of record in the current version of repo. Does not require auth.",
              parameters: {
                type: "params",
                required: ["did", "collection", "rkey"],
                properties: {
                  did: {
                    type: "string",
                    format: "did",
                    description: "The DID of the repo."
                  },
                  collection: {
                    type: "string",
                    format: "nsid"
                  },
                  rkey: {
                    type: "string",
                    description: "Record Key"
                  },
                  commit: {
                    type: "string",
                    format: "cid",
                    description: "DEPRECATED: referenced a repo commit by CID, and retrieved record as of that commit"
                  }
                }
              },
              output: {
                encoding: "application/vnd.ipld.car"
              },
              errors: [
                {
                  name: "RecordNotFound"
                },
                {
                  name: "RepoNotFound"
                },
                {
                  name: "RepoTakendown"
                },
                {
                  name: "RepoSuspended"
                },
                {
                  name: "RepoDeactivated"
                }
              ]
            }
          }
        },
        ComAtprotoSyncGetRepo: {
          lexicon: 1,
          id: "com.atproto.sync.getRepo",
          defs: {
            main: {
              type: "query",
              description: "Download a repository export as CAR file. Optionally only a 'diff' since a previous revision. Does not require auth; implemented by PDS.",
              parameters: {
                type: "params",
                required: ["did"],
                properties: {
                  did: {
                    type: "string",
                    format: "did",
                    description: "The DID of the repo."
                  },
                  since: {
                    type: "string",
                    description: "The revision ('rev') of the repo to create a diff from."
                  }
                }
              },
              output: {
                encoding: "application/vnd.ipld.car"
              },
              errors: [
                {
                  name: "RepoNotFound"
                },
                {
                  name: "RepoTakendown"
                },
                {
                  name: "RepoSuspended"
                },
                {
                  name: "RepoDeactivated"
                }
              ]
            }
          }
        },
        ComAtprotoSyncGetRepoStatus: {
          lexicon: 1,
          id: "com.atproto.sync.getRepoStatus",
          defs: {
            main: {
              type: "query",
              description: "Get the hosting status for a repository, on this server. Expected to be implemented by PDS and Relay.",
              parameters: {
                type: "params",
                required: ["did"],
                properties: {
                  did: {
                    type: "string",
                    format: "did",
                    description: "The DID of the repo."
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["did", "active"],
                  properties: {
                    did: {
                      type: "string",
                      format: "did"
                    },
                    active: {
                      type: "boolean"
                    },
                    status: {
                      type: "string",
                      description: "If active=false, this optional field indicates a possible reason for why the account is not active. If active=false and no status is supplied, then the host makes no claim for why the repository is no longer being hosted.",
                      knownValues: ["takendown", "suspended", "deactivated"]
                    },
                    rev: {
                      type: "string",
                      description: "Optional field, the current rev of the repo, if active=true"
                    }
                  }
                }
              },
              errors: [
                {
                  name: "RepoNotFound"
                }
              ]
            }
          }
        },
        ComAtprotoSyncListBlobs: {
          lexicon: 1,
          id: "com.atproto.sync.listBlobs",
          defs: {
            main: {
              type: "query",
              description: "List blob CIDs for an account, since some repo revision. Does not require auth; implemented by PDS.",
              parameters: {
                type: "params",
                required: ["did"],
                properties: {
                  did: {
                    type: "string",
                    format: "did",
                    description: "The DID of the repo."
                  },
                  since: {
                    type: "string",
                    description: "Optional revision of the repo to list blobs since."
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 1e3,
                    default: 500
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["cids"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    cids: {
                      type: "array",
                      items: {
                        type: "string",
                        format: "cid"
                      }
                    }
                  }
                }
              },
              errors: [
                {
                  name: "RepoNotFound"
                },
                {
                  name: "RepoTakendown"
                },
                {
                  name: "RepoSuspended"
                },
                {
                  name: "RepoDeactivated"
                }
              ]
            }
          }
        },
        ComAtprotoSyncListRepos: {
          lexicon: 1,
          id: "com.atproto.sync.listRepos",
          defs: {
            main: {
              type: "query",
              description: "Enumerates all the DID, rev, and commit CID for all repos hosted by this service. Does not require auth; implemented by PDS and Relay.",
              parameters: {
                type: "params",
                properties: {
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 1e3,
                    default: 500
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["repos"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    repos: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:com.atproto.sync.listRepos#repo"
                      }
                    }
                  }
                }
              }
            },
            repo: {
              type: "object",
              required: ["did", "head", "rev"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                },
                head: {
                  type: "string",
                  format: "cid",
                  description: "Current repo commit CID"
                },
                rev: {
                  type: "string"
                },
                active: {
                  type: "boolean"
                },
                status: {
                  type: "string",
                  description: "If active=false, this optional field indicates a possible reason for why the account is not active. If active=false and no status is supplied, then the host makes no claim for why the repository is no longer being hosted.",
                  knownValues: ["takendown", "suspended", "deactivated"]
                }
              }
            }
          }
        },
        ComAtprotoSyncNotifyOfUpdate: {
          lexicon: 1,
          id: "com.atproto.sync.notifyOfUpdate",
          defs: {
            main: {
              type: "procedure",
              description: "Notify a crawling service of a recent update, and that crawling should resume. Intended use is after a gap between repo stream events caused the crawling service to disconnect. Does not require auth; implemented by Relay.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["hostname"],
                  properties: {
                    hostname: {
                      type: "string",
                      description: "Hostname of the current service (usually a PDS) that is notifying of update."
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoSyncRequestCrawl: {
          lexicon: 1,
          id: "com.atproto.sync.requestCrawl",
          defs: {
            main: {
              type: "procedure",
              description: "Request a service to persistently crawl hosted repos. Expected use is new PDS instances declaring their existence to Relays. Does not require auth.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["hostname"],
                  properties: {
                    hostname: {
                      type: "string",
                      description: "Hostname of the current service (eg, PDS) that is requesting to be crawled."
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoSyncSubscribeRepos: {
          lexicon: 1,
          id: "com.atproto.sync.subscribeRepos",
          defs: {
            main: {
              type: "subscription",
              description: "Repository event stream, aka Firehose endpoint. Outputs repo commits with diff data, and identity update events, for all repositories on the current server. See the atproto specifications for details around stream sequencing, repo versioning, CAR diff format, and more. Public and does not require auth; implemented by PDS and Relay.",
              parameters: {
                type: "params",
                properties: {
                  cursor: {
                    type: "integer",
                    description: "The last known event seq number to backfill from."
                  }
                }
              },
              message: {
                schema: {
                  type: "union",
                  refs: [
                    "lex:com.atproto.sync.subscribeRepos#commit",
                    "lex:com.atproto.sync.subscribeRepos#identity",
                    "lex:com.atproto.sync.subscribeRepos#account",
                    "lex:com.atproto.sync.subscribeRepos#handle",
                    "lex:com.atproto.sync.subscribeRepos#migrate",
                    "lex:com.atproto.sync.subscribeRepos#tombstone",
                    "lex:com.atproto.sync.subscribeRepos#info"
                  ]
                }
              },
              errors: [
                {
                  name: "FutureCursor"
                },
                {
                  name: "ConsumerTooSlow",
                  description: "If the consumer of the stream can not keep up with events, and a backlog gets too large, the server will drop the connection."
                }
              ]
            },
            commit: {
              type: "object",
              description: "Represents an update of repository state. Note that empty commits are allowed, which include no repo data changes, but an update to rev and signature.",
              required: [
                "seq",
                "rebase",
                "tooBig",
                "repo",
                "commit",
                "rev",
                "since",
                "blocks",
                "ops",
                "blobs",
                "time"
              ],
              nullable: ["prev", "since"],
              properties: {
                seq: {
                  type: "integer",
                  description: "The stream sequence number of this message."
                },
                rebase: {
                  type: "boolean",
                  description: "DEPRECATED -- unused"
                },
                tooBig: {
                  type: "boolean",
                  description: "Indicates that this commit contained too many ops, or data size was too large. Consumers will need to make a separate request to get missing data."
                },
                repo: {
                  type: "string",
                  format: "did",
                  description: "The repo this event comes from."
                },
                commit: {
                  type: "cid-link",
                  description: "Repo commit object CID."
                },
                prev: {
                  type: "cid-link",
                  description: "DEPRECATED -- unused. WARNING -- nullable and optional; stick with optional to ensure golang interoperability."
                },
                rev: {
                  type: "string",
                  description: "The rev of the emitted commit. Note that this information is also in the commit object included in blocks, unless this is a tooBig event."
                },
                since: {
                  type: "string",
                  description: "The rev of the last emitted commit from this repo (if any)."
                },
                blocks: {
                  type: "bytes",
                  description: "CAR file containing relevant blocks, as a diff since the previous repo state.",
                  maxLength: 1e6
                },
                ops: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.sync.subscribeRepos#repoOp",
                    description: "List of repo mutation operations in this commit (eg, records created, updated, or deleted)."
                  },
                  maxLength: 200
                },
                blobs: {
                  type: "array",
                  items: {
                    type: "cid-link",
                    description: "List of new blobs (by CID) referenced by records in this commit."
                  }
                },
                time: {
                  type: "string",
                  format: "datetime",
                  description: "Timestamp of when this message was originally broadcast."
                }
              }
            },
            identity: {
              type: "object",
              description: "Represents a change to an account's identity. Could be an updated handle, signing key, or pds hosting endpoint. Serves as a prod to all downstream services to refresh their identity cache.",
              required: ["seq", "did", "time"],
              properties: {
                seq: {
                  type: "integer"
                },
                did: {
                  type: "string",
                  format: "did"
                },
                time: {
                  type: "string",
                  format: "datetime"
                },
                handle: {
                  type: "string",
                  format: "handle",
                  description: "The current handle for the account, or 'handle.invalid' if validation fails. This field is optional, might have been validated or passed-through from an upstream source. Semantics and behaviors for PDS vs Relay may evolve in the future; see atproto specs for more details."
                }
              }
            },
            account: {
              type: "object",
              description: "Represents a change to an account's status on a host (eg, PDS or Relay). The semantics of this event are that the status is at the host which emitted the event, not necessarily that at the currently active PDS. Eg, a Relay takedown would emit a takedown with active=false, even if the PDS is still active.",
              required: ["seq", "did", "time", "active"],
              properties: {
                seq: {
                  type: "integer"
                },
                did: {
                  type: "string",
                  format: "did"
                },
                time: {
                  type: "string",
                  format: "datetime"
                },
                active: {
                  type: "boolean",
                  description: "Indicates that the account has a repository which can be fetched from the host that emitted this event."
                },
                status: {
                  type: "string",
                  description: "If active=false, this optional field indicates a reason for why the account is not active.",
                  knownValues: ["takendown", "suspended", "deleted", "deactivated"]
                }
              }
            },
            handle: {
              type: "object",
              description: "DEPRECATED -- Use #identity event instead",
              required: ["seq", "did", "handle", "time"],
              properties: {
                seq: {
                  type: "integer"
                },
                did: {
                  type: "string",
                  format: "did"
                },
                handle: {
                  type: "string",
                  format: "handle"
                },
                time: {
                  type: "string",
                  format: "datetime"
                }
              }
            },
            migrate: {
              type: "object",
              description: "DEPRECATED -- Use #account event instead",
              required: ["seq", "did", "migrateTo", "time"],
              nullable: ["migrateTo"],
              properties: {
                seq: {
                  type: "integer"
                },
                did: {
                  type: "string",
                  format: "did"
                },
                migrateTo: {
                  type: "string"
                },
                time: {
                  type: "string",
                  format: "datetime"
                }
              }
            },
            tombstone: {
              type: "object",
              description: "DEPRECATED -- Use #account event instead",
              required: ["seq", "did", "time"],
              properties: {
                seq: {
                  type: "integer"
                },
                did: {
                  type: "string",
                  format: "did"
                },
                time: {
                  type: "string",
                  format: "datetime"
                }
              }
            },
            info: {
              type: "object",
              required: ["name"],
              properties: {
                name: {
                  type: "string",
                  knownValues: ["OutdatedCursor"]
                },
                message: {
                  type: "string"
                }
              }
            },
            repoOp: {
              type: "object",
              description: "A repo operation, ie a mutation of a single record.",
              required: ["action", "path", "cid"],
              nullable: ["cid"],
              properties: {
                action: {
                  type: "string",
                  knownValues: ["create", "update", "delete"]
                },
                path: {
                  type: "string"
                },
                cid: {
                  type: "cid-link",
                  description: "For creates and updates, the new record CID. For deletions, null."
                }
              }
            }
          }
        },
        ComAtprotoTempAddReservedHandle: {
          lexicon: 1,
          id: "com.atproto.temp.addReservedHandle",
          defs: {
            main: {
              type: "procedure",
              description: "Add a handle to the set of reserved handles.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["handle"],
                  properties: {
                    handle: {
                      type: "string"
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  properties: {}
                }
              }
            }
          }
        },
        ComAtprotoTempCheckSignupQueue: {
          lexicon: 1,
          id: "com.atproto.temp.checkSignupQueue",
          defs: {
            main: {
              type: "query",
              description: "Check accounts location in signup queue.",
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["activated"],
                  properties: {
                    activated: {
                      type: "boolean"
                    },
                    placeInQueue: {
                      type: "integer"
                    },
                    estimatedTimeMs: {
                      type: "integer"
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoTempFetchLabels: {
          lexicon: 1,
          id: "com.atproto.temp.fetchLabels",
          defs: {
            main: {
              type: "query",
              description: "DEPRECATED: use queryLabels or subscribeLabels instead -- Fetch all labels from a labeler created after a certain date.",
              parameters: {
                type: "params",
                properties: {
                  since: {
                    type: "integer"
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 250,
                    default: 50
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["labels"],
                  properties: {
                    labels: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:com.atproto.label.defs#label"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoTempRequestPhoneVerification: {
          lexicon: 1,
          id: "com.atproto.temp.requestPhoneVerification",
          defs: {
            main: {
              type: "procedure",
              description: "Request a verification code to be sent to the supplied phone number",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["phoneNumber"],
                  properties: {
                    phoneNumber: {
                      type: "string"
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyActorDefs: {
          lexicon: 1,
          id: "app.bsky.actor.defs",
          defs: {
            profileViewBasic: {
              type: "object",
              required: ["did", "handle"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                },
                handle: {
                  type: "string",
                  format: "handle"
                },
                displayName: {
                  type: "string",
                  maxGraphemes: 64,
                  maxLength: 640
                },
                avatar: {
                  type: "string",
                  format: "uri"
                },
                associated: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#profileAssociated"
                },
                viewer: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#viewerState"
                },
                labels: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.label.defs#label"
                  }
                },
                createdAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            },
            profileView: {
              type: "object",
              required: ["did", "handle"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                },
                handle: {
                  type: "string",
                  format: "handle"
                },
                displayName: {
                  type: "string",
                  maxGraphemes: 64,
                  maxLength: 640
                },
                description: {
                  type: "string",
                  maxGraphemes: 256,
                  maxLength: 2560
                },
                avatar: {
                  type: "string",
                  format: "uri"
                },
                associated: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#profileAssociated"
                },
                indexedAt: {
                  type: "string",
                  format: "datetime"
                },
                createdAt: {
                  type: "string",
                  format: "datetime"
                },
                viewer: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#viewerState"
                },
                labels: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.label.defs#label"
                  }
                }
              }
            },
            profileViewDetailed: {
              type: "object",
              required: ["did", "handle"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                },
                handle: {
                  type: "string",
                  format: "handle"
                },
                displayName: {
                  type: "string",
                  maxGraphemes: 64,
                  maxLength: 640
                },
                description: {
                  type: "string",
                  maxGraphemes: 256,
                  maxLength: 2560
                },
                avatar: {
                  type: "string",
                  format: "uri"
                },
                banner: {
                  type: "string",
                  format: "uri"
                },
                followersCount: {
                  type: "integer"
                },
                followsCount: {
                  type: "integer"
                },
                postsCount: {
                  type: "integer"
                },
                associated: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#profileAssociated"
                },
                joinedViaStarterPack: {
                  type: "ref",
                  ref: "lex:app.bsky.graph.defs#starterPackViewBasic"
                },
                indexedAt: {
                  type: "string",
                  format: "datetime"
                },
                createdAt: {
                  type: "string",
                  format: "datetime"
                },
                viewer: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#viewerState"
                },
                labels: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.label.defs#label"
                  }
                },
                pinnedPost: {
                  type: "ref",
                  ref: "lex:com.atproto.repo.strongRef"
                }
              }
            },
            profileAssociated: {
              type: "object",
              properties: {
                lists: {
                  type: "integer"
                },
                feedgens: {
                  type: "integer"
                },
                starterPacks: {
                  type: "integer"
                },
                labeler: {
                  type: "boolean"
                },
                chat: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#profileAssociatedChat"
                }
              }
            },
            profileAssociatedChat: {
              type: "object",
              required: ["allowIncoming"],
              properties: {
                allowIncoming: {
                  type: "string",
                  knownValues: ["all", "none", "following"]
                }
              }
            },
            viewerState: {
              type: "object",
              description: "Metadata about the requesting account's relationship with the subject account. Only has meaningful content for authed requests.",
              properties: {
                muted: {
                  type: "boolean"
                },
                mutedByList: {
                  type: "ref",
                  ref: "lex:app.bsky.graph.defs#listViewBasic"
                },
                blockedBy: {
                  type: "boolean"
                },
                blocking: {
                  type: "string",
                  format: "at-uri"
                },
                blockingByList: {
                  type: "ref",
                  ref: "lex:app.bsky.graph.defs#listViewBasic"
                },
                following: {
                  type: "string",
                  format: "at-uri"
                },
                followedBy: {
                  type: "string",
                  format: "at-uri"
                },
                knownFollowers: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#knownFollowers"
                }
              }
            },
            knownFollowers: {
              type: "object",
              description: "The subject's followers whom you also follow",
              required: ["count", "followers"],
              properties: {
                count: {
                  type: "integer"
                },
                followers: {
                  type: "array",
                  minLength: 0,
                  maxLength: 5,
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.actor.defs#profileViewBasic"
                  }
                }
              }
            },
            preferences: {
              type: "array",
              items: {
                type: "union",
                refs: [
                  "lex:app.bsky.actor.defs#adultContentPref",
                  "lex:app.bsky.actor.defs#contentLabelPref",
                  "lex:app.bsky.actor.defs#savedFeedsPref",
                  "lex:app.bsky.actor.defs#savedFeedsPrefV2",
                  "lex:app.bsky.actor.defs#personalDetailsPref",
                  "lex:app.bsky.actor.defs#feedViewPref",
                  "lex:app.bsky.actor.defs#threadViewPref",
                  "lex:app.bsky.actor.defs#interestsPref",
                  "lex:app.bsky.actor.defs#mutedWordsPref",
                  "lex:app.bsky.actor.defs#hiddenPostsPref",
                  "lex:app.bsky.actor.defs#bskyAppStatePref",
                  "lex:app.bsky.actor.defs#labelersPref",
                  "lex:app.bsky.actor.defs#postInteractionSettingsPref"
                ]
              }
            },
            adultContentPref: {
              type: "object",
              required: ["enabled"],
              properties: {
                enabled: {
                  type: "boolean",
                  default: false
                }
              }
            },
            contentLabelPref: {
              type: "object",
              required: ["label", "visibility"],
              properties: {
                labelerDid: {
                  type: "string",
                  description: "Which labeler does this preference apply to? If undefined, applies globally.",
                  format: "did"
                },
                label: {
                  type: "string"
                },
                visibility: {
                  type: "string",
                  knownValues: ["ignore", "show", "warn", "hide"]
                }
              }
            },
            savedFeed: {
              type: "object",
              required: ["id", "type", "value", "pinned"],
              properties: {
                id: {
                  type: "string"
                },
                type: {
                  type: "string",
                  knownValues: ["feed", "list", "timeline"]
                },
                value: {
                  type: "string"
                },
                pinned: {
                  type: "boolean"
                }
              }
            },
            savedFeedsPrefV2: {
              type: "object",
              required: ["items"],
              properties: {
                items: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.actor.defs#savedFeed"
                  }
                }
              }
            },
            savedFeedsPref: {
              type: "object",
              required: ["pinned", "saved"],
              properties: {
                pinned: {
                  type: "array",
                  items: {
                    type: "string",
                    format: "at-uri"
                  }
                },
                saved: {
                  type: "array",
                  items: {
                    type: "string",
                    format: "at-uri"
                  }
                },
                timelineIndex: {
                  type: "integer"
                }
              }
            },
            personalDetailsPref: {
              type: "object",
              properties: {
                birthDate: {
                  type: "string",
                  format: "datetime",
                  description: "The birth date of account owner."
                }
              }
            },
            feedViewPref: {
              type: "object",
              required: ["feed"],
              properties: {
                feed: {
                  type: "string",
                  description: "The URI of the feed, or an identifier which describes the feed."
                },
                hideReplies: {
                  type: "boolean",
                  description: "Hide replies in the feed."
                },
                hideRepliesByUnfollowed: {
                  type: "boolean",
                  description: "Hide replies in the feed if they are not by followed users.",
                  default: true
                },
                hideRepliesByLikeCount: {
                  type: "integer",
                  description: "Hide replies in the feed if they do not have this number of likes."
                },
                hideReposts: {
                  type: "boolean",
                  description: "Hide reposts in the feed."
                },
                hideQuotePosts: {
                  type: "boolean",
                  description: "Hide quote posts in the feed."
                }
              }
            },
            threadViewPref: {
              type: "object",
              properties: {
                sort: {
                  type: "string",
                  description: "Sorting mode for threads.",
                  knownValues: [
                    "oldest",
                    "newest",
                    "most-likes",
                    "random",
                    "hotness"
                  ]
                },
                prioritizeFollowedUsers: {
                  type: "boolean",
                  description: "Show followed users at the top of all replies."
                }
              }
            },
            interestsPref: {
              type: "object",
              required: ["tags"],
              properties: {
                tags: {
                  type: "array",
                  maxLength: 100,
                  items: {
                    type: "string",
                    maxLength: 640,
                    maxGraphemes: 64
                  },
                  description: "A list of tags which describe the account owner's interests gathered during onboarding."
                }
              }
            },
            mutedWordTarget: {
              type: "string",
              knownValues: ["content", "tag"],
              maxLength: 640,
              maxGraphemes: 64
            },
            mutedWord: {
              type: "object",
              description: "A word that the account owner has muted.",
              required: ["value", "targets"],
              properties: {
                id: {
                  type: "string"
                },
                value: {
                  type: "string",
                  description: "The muted word itself.",
                  maxLength: 1e4,
                  maxGraphemes: 1e3
                },
                targets: {
                  type: "array",
                  description: "The intended targets of the muted word.",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.actor.defs#mutedWordTarget"
                  }
                },
                actorTarget: {
                  type: "string",
                  description: "Groups of users to apply the muted word to. If undefined, applies to all users.",
                  knownValues: ["all", "exclude-following"],
                  default: "all"
                },
                expiresAt: {
                  type: "string",
                  format: "datetime",
                  description: "The date and time at which the muted word will expire and no longer be applied."
                }
              }
            },
            mutedWordsPref: {
              type: "object",
              required: ["items"],
              properties: {
                items: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.actor.defs#mutedWord"
                  },
                  description: "A list of words the account owner has muted."
                }
              }
            },
            hiddenPostsPref: {
              type: "object",
              required: ["items"],
              properties: {
                items: {
                  type: "array",
                  items: {
                    type: "string",
                    format: "at-uri"
                  },
                  description: "A list of URIs of posts the account owner has hidden."
                }
              }
            },
            labelersPref: {
              type: "object",
              required: ["labelers"],
              properties: {
                labelers: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.actor.defs#labelerPrefItem"
                  }
                }
              }
            },
            labelerPrefItem: {
              type: "object",
              required: ["did"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                }
              }
            },
            bskyAppStatePref: {
              description: "A grab bag of state that's specific to the bsky.app program. Third-party apps shouldn't use this.",
              type: "object",
              properties: {
                activeProgressGuide: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#bskyAppProgressGuide"
                },
                queuedNudges: {
                  description: "An array of tokens which identify nudges (modals, popups, tours, highlight dots) that should be shown to the user.",
                  type: "array",
                  maxLength: 1e3,
                  items: {
                    type: "string",
                    maxLength: 100
                  }
                },
                nuxs: {
                  description: "Storage for NUXs the user has encountered.",
                  type: "array",
                  maxLength: 100,
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.actor.defs#nux"
                  }
                }
              }
            },
            bskyAppProgressGuide: {
              description: "If set, an active progress guide. Once completed, can be set to undefined. Should have unspecced fields tracking progress.",
              type: "object",
              required: ["guide"],
              properties: {
                guide: {
                  type: "string",
                  maxLength: 100
                }
              }
            },
            nux: {
              type: "object",
              description: "A new user experiences (NUX) storage object",
              required: ["id", "completed"],
              properties: {
                id: {
                  type: "string",
                  maxLength: 100
                },
                completed: {
                  type: "boolean",
                  default: false
                },
                data: {
                  description: "Arbitrary data for the NUX. The structure is defined by the NUX itself. Limited to 300 characters.",
                  type: "string",
                  maxLength: 3e3,
                  maxGraphemes: 300
                },
                expiresAt: {
                  type: "string",
                  format: "datetime",
                  description: "The date and time at which the NUX will expire and should be considered completed."
                }
              }
            },
            postInteractionSettingsPref: {
              type: "object",
              description: "Default post interaction settings for the account. These values should be applied as default values when creating new posts. These refs should mirror the threadgate and postgate records exactly.",
              required: [],
              properties: {
                threadgateAllowRules: {
                  description: "Matches threadgate record. List of rules defining who can reply to this users posts. If value is an empty array, no one can reply. If value is undefined, anyone can reply.",
                  type: "array",
                  maxLength: 5,
                  items: {
                    type: "union",
                    refs: [
                      "lex:app.bsky.feed.threadgate#mentionRule",
                      "lex:app.bsky.feed.threadgate#followerRule",
                      "lex:app.bsky.feed.threadgate#followingRule",
                      "lex:app.bsky.feed.threadgate#listRule"
                    ]
                  }
                },
                postgateEmbeddingRules: {
                  description: "Matches postgate record. List of rules defining who can embed this users posts. If value is an empty array or is undefined, no particular rules apply and anyone can embed.",
                  type: "array",
                  maxLength: 5,
                  items: {
                    type: "union",
                    refs: ["lex:app.bsky.feed.postgate#disableRule"]
                  }
                }
              }
            }
          }
        },
        AppBskyActorGetPreferences: {
          lexicon: 1,
          id: "app.bsky.actor.getPreferences",
          defs: {
            main: {
              type: "query",
              description: "Get private preferences attached to the current account. Expected use is synchronization between multiple devices, and import/export during account migration. Requires auth.",
              parameters: {
                type: "params",
                properties: {}
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["preferences"],
                  properties: {
                    preferences: {
                      type: "ref",
                      ref: "lex:app.bsky.actor.defs#preferences"
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyActorGetProfile: {
          lexicon: 1,
          id: "app.bsky.actor.getProfile",
          defs: {
            main: {
              type: "query",
              description: "Get detailed profile view of an actor. Does not require auth, but contains relevant metadata with auth.",
              parameters: {
                type: "params",
                required: ["actor"],
                properties: {
                  actor: {
                    type: "string",
                    format: "at-identifier",
                    description: "Handle or DID of account to fetch profile of."
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#profileViewDetailed"
                }
              }
            }
          }
        },
        AppBskyActorGetProfiles: {
          lexicon: 1,
          id: "app.bsky.actor.getProfiles",
          defs: {
            main: {
              type: "query",
              description: "Get detailed profile views of multiple actors.",
              parameters: {
                type: "params",
                required: ["actors"],
                properties: {
                  actors: {
                    type: "array",
                    items: {
                      type: "string",
                      format: "at-identifier"
                    },
                    maxLength: 25
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["profiles"],
                  properties: {
                    profiles: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.actor.defs#profileViewDetailed"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyActorGetSuggestions: {
          lexicon: 1,
          id: "app.bsky.actor.getSuggestions",
          defs: {
            main: {
              type: "query",
              description: "Get a list of suggested actors. Expected use is discovery of accounts to follow during new account onboarding.",
              parameters: {
                type: "params",
                properties: {
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["actors"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    actors: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.actor.defs#profileView"
                      }
                    },
                    recId: {
                      type: "integer",
                      description: "Snowflake for this recommendation, use when submitting recommendation events."
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyActorProfile: {
          lexicon: 1,
          id: "app.bsky.actor.profile",
          defs: {
            main: {
              type: "record",
              description: "A declaration of a Bluesky account profile.",
              key: "literal:self",
              record: {
                type: "object",
                properties: {
                  displayName: {
                    type: "string",
                    maxGraphemes: 64,
                    maxLength: 640
                  },
                  description: {
                    type: "string",
                    description: "Free-form profile description text.",
                    maxGraphemes: 256,
                    maxLength: 2560
                  },
                  avatar: {
                    type: "blob",
                    description: "Small image to be displayed next to posts from account. AKA, 'profile picture'",
                    accept: ["image/png", "image/jpeg"],
                    maxSize: 1e6
                  },
                  banner: {
                    type: "blob",
                    description: "Larger horizontal image to display behind profile view.",
                    accept: ["image/png", "image/jpeg"],
                    maxSize: 1e6
                  },
                  labels: {
                    type: "union",
                    description: "Self-label values, specific to the Bluesky application, on the overall account.",
                    refs: ["lex:com.atproto.label.defs#selfLabels"]
                  },
                  joinedViaStarterPack: {
                    type: "ref",
                    ref: "lex:com.atproto.repo.strongRef"
                  },
                  pinnedPost: {
                    type: "ref",
                    ref: "lex:com.atproto.repo.strongRef"
                  },
                  createdAt: {
                    type: "string",
                    format: "datetime"
                  }
                }
              }
            }
          }
        },
        AppBskyActorPutPreferences: {
          lexicon: 1,
          id: "app.bsky.actor.putPreferences",
          defs: {
            main: {
              type: "procedure",
              description: "Set the private preferences attached to the account.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["preferences"],
                  properties: {
                    preferences: {
                      type: "ref",
                      ref: "lex:app.bsky.actor.defs#preferences"
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyActorSearchActors: {
          lexicon: 1,
          id: "app.bsky.actor.searchActors",
          defs: {
            main: {
              type: "query",
              description: "Find actors (profiles) matching search criteria. Does not require auth.",
              parameters: {
                type: "params",
                properties: {
                  term: {
                    type: "string",
                    description: "DEPRECATED: use 'q' instead."
                  },
                  q: {
                    type: "string",
                    description: "Search query string. Syntax, phrase, boolean, and faceting is unspecified, but Lucene query syntax is recommended."
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 25
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["actors"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    actors: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.actor.defs#profileView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyActorSearchActorsTypeahead: {
          lexicon: 1,
          id: "app.bsky.actor.searchActorsTypeahead",
          defs: {
            main: {
              type: "query",
              description: "Find actor suggestions for a prefix search term. Expected use is for auto-completion during text field entry. Does not require auth.",
              parameters: {
                type: "params",
                properties: {
                  term: {
                    type: "string",
                    description: "DEPRECATED: use 'q' instead."
                  },
                  q: {
                    type: "string",
                    description: "Search query prefix; not a full query string."
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 10
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["actors"],
                  properties: {
                    actors: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.actor.defs#profileViewBasic"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyEmbedDefs: {
          lexicon: 1,
          id: "app.bsky.embed.defs",
          defs: {
            aspectRatio: {
              type: "object",
              description: "width:height represents an aspect ratio. It may be approximate, and may not correspond to absolute dimensions in any given unit.",
              required: ["width", "height"],
              properties: {
                width: {
                  type: "integer",
                  minimum: 1
                },
                height: {
                  type: "integer",
                  minimum: 1
                }
              }
            }
          }
        },
        AppBskyEmbedExternal: {
          lexicon: 1,
          id: "app.bsky.embed.external",
          defs: {
            main: {
              type: "object",
              description: "A representation of some externally linked content (eg, a URL and 'card'), embedded in a Bluesky record (eg, a post).",
              required: ["external"],
              properties: {
                external: {
                  type: "ref",
                  ref: "lex:app.bsky.embed.external#external"
                }
              }
            },
            external: {
              type: "object",
              required: ["uri", "title", "description"],
              properties: {
                uri: {
                  type: "string",
                  format: "uri"
                },
                title: {
                  type: "string"
                },
                description: {
                  type: "string"
                },
                thumb: {
                  type: "blob",
                  accept: ["image/*"],
                  maxSize: 1e6
                }
              }
            },
            view: {
              type: "object",
              required: ["external"],
              properties: {
                external: {
                  type: "ref",
                  ref: "lex:app.bsky.embed.external#viewExternal"
                }
              }
            },
            viewExternal: {
              type: "object",
              required: ["uri", "title", "description"],
              properties: {
                uri: {
                  type: "string",
                  format: "uri"
                },
                title: {
                  type: "string"
                },
                description: {
                  type: "string"
                },
                thumb: {
                  type: "string",
                  format: "uri"
                }
              }
            }
          }
        },
        AppBskyEmbedImages: {
          lexicon: 1,
          id: "app.bsky.embed.images",
          description: "A set of images embedded in a Bluesky record (eg, a post).",
          defs: {
            main: {
              type: "object",
              required: ["images"],
              properties: {
                images: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.embed.images#image"
                  },
                  maxLength: 4
                }
              }
            },
            image: {
              type: "object",
              required: ["image", "alt"],
              properties: {
                image: {
                  type: "blob",
                  accept: ["image/*"],
                  maxSize: 1e6
                },
                alt: {
                  type: "string",
                  description: "Alt text description of the image, for accessibility."
                },
                aspectRatio: {
                  type: "ref",
                  ref: "lex:app.bsky.embed.defs#aspectRatio"
                }
              }
            },
            view: {
              type: "object",
              required: ["images"],
              properties: {
                images: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.embed.images#viewImage"
                  },
                  maxLength: 4
                }
              }
            },
            viewImage: {
              type: "object",
              required: ["thumb", "fullsize", "alt"],
              properties: {
                thumb: {
                  type: "string",
                  format: "uri",
                  description: "Fully-qualified URL where a thumbnail of the image can be fetched. For example, CDN location provided by the App View."
                },
                fullsize: {
                  type: "string",
                  format: "uri",
                  description: "Fully-qualified URL where a large version of the image can be fetched. May or may not be the exact original blob. For example, CDN location provided by the App View."
                },
                alt: {
                  type: "string",
                  description: "Alt text description of the image, for accessibility."
                },
                aspectRatio: {
                  type: "ref",
                  ref: "lex:app.bsky.embed.defs#aspectRatio"
                }
              }
            }
          }
        },
        AppBskyEmbedRecord: {
          lexicon: 1,
          id: "app.bsky.embed.record",
          description: "A representation of a record embedded in a Bluesky record (eg, a post). For example, a quote-post, or sharing a feed generator record.",
          defs: {
            main: {
              type: "object",
              required: ["record"],
              properties: {
                record: {
                  type: "ref",
                  ref: "lex:com.atproto.repo.strongRef"
                }
              }
            },
            view: {
              type: "object",
              required: ["record"],
              properties: {
                record: {
                  type: "union",
                  refs: [
                    "lex:app.bsky.embed.record#viewRecord",
                    "lex:app.bsky.embed.record#viewNotFound",
                    "lex:app.bsky.embed.record#viewBlocked",
                    "lex:app.bsky.embed.record#viewDetached",
                    "lex:app.bsky.feed.defs#generatorView",
                    "lex:app.bsky.graph.defs#listView",
                    "lex:app.bsky.labeler.defs#labelerView",
                    "lex:app.bsky.graph.defs#starterPackViewBasic"
                  ]
                }
              }
            },
            viewRecord: {
              type: "object",
              required: ["uri", "cid", "author", "value", "indexedAt"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                cid: {
                  type: "string",
                  format: "cid"
                },
                author: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#profileViewBasic"
                },
                value: {
                  type: "unknown",
                  description: "The record data itself."
                },
                labels: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.label.defs#label"
                  }
                },
                replyCount: {
                  type: "integer"
                },
                repostCount: {
                  type: "integer"
                },
                likeCount: {
                  type: "integer"
                },
                quoteCount: {
                  type: "integer"
                },
                embeds: {
                  type: "array",
                  items: {
                    type: "union",
                    refs: [
                      "lex:app.bsky.embed.images#view",
                      "lex:app.bsky.embed.video#view",
                      "lex:app.bsky.embed.external#view",
                      "lex:app.bsky.embed.record#view",
                      "lex:app.bsky.embed.recordWithMedia#view"
                    ]
                  }
                },
                indexedAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            },
            viewNotFound: {
              type: "object",
              required: ["uri", "notFound"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                notFound: {
                  type: "boolean",
                  const: true
                }
              }
            },
            viewBlocked: {
              type: "object",
              required: ["uri", "blocked", "author"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                blocked: {
                  type: "boolean",
                  const: true
                },
                author: {
                  type: "ref",
                  ref: "lex:app.bsky.feed.defs#blockedAuthor"
                }
              }
            },
            viewDetached: {
              type: "object",
              required: ["uri", "detached"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                detached: {
                  type: "boolean",
                  const: true
                }
              }
            }
          }
        },
        AppBskyEmbedRecordWithMedia: {
          lexicon: 1,
          id: "app.bsky.embed.recordWithMedia",
          description: "A representation of a record embedded in a Bluesky record (eg, a post), alongside other compatible embeds. For example, a quote post and image, or a quote post and external URL card.",
          defs: {
            main: {
              type: "object",
              required: ["record", "media"],
              properties: {
                record: {
                  type: "ref",
                  ref: "lex:app.bsky.embed.record"
                },
                media: {
                  type: "union",
                  refs: [
                    "lex:app.bsky.embed.images",
                    "lex:app.bsky.embed.video",
                    "lex:app.bsky.embed.external"
                  ]
                }
              }
            },
            view: {
              type: "object",
              required: ["record", "media"],
              properties: {
                record: {
                  type: "ref",
                  ref: "lex:app.bsky.embed.record#view"
                },
                media: {
                  type: "union",
                  refs: [
                    "lex:app.bsky.embed.images#view",
                    "lex:app.bsky.embed.video#view",
                    "lex:app.bsky.embed.external#view"
                  ]
                }
              }
            }
          }
        },
        AppBskyEmbedVideo: {
          lexicon: 1,
          id: "app.bsky.embed.video",
          description: "A video embedded in a Bluesky record (eg, a post).",
          defs: {
            main: {
              type: "object",
              required: ["video"],
              properties: {
                video: {
                  type: "blob",
                  accept: ["video/mp4"],
                  maxSize: 5e7
                },
                captions: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.embed.video#caption"
                  },
                  maxLength: 20
                },
                alt: {
                  type: "string",
                  description: "Alt text description of the video, for accessibility.",
                  maxGraphemes: 1e3,
                  maxLength: 1e4
                },
                aspectRatio: {
                  type: "ref",
                  ref: "lex:app.bsky.embed.defs#aspectRatio"
                }
              }
            },
            caption: {
              type: "object",
              required: ["lang", "file"],
              properties: {
                lang: {
                  type: "string",
                  format: "language"
                },
                file: {
                  type: "blob",
                  accept: ["text/vtt"],
                  maxSize: 2e4
                }
              }
            },
            view: {
              type: "object",
              required: ["cid", "playlist"],
              properties: {
                cid: {
                  type: "string",
                  format: "cid"
                },
                playlist: {
                  type: "string",
                  format: "uri"
                },
                thumbnail: {
                  type: "string",
                  format: "uri"
                },
                alt: {
                  type: "string",
                  maxGraphemes: 1e3,
                  maxLength: 1e4
                },
                aspectRatio: {
                  type: "ref",
                  ref: "lex:app.bsky.embed.defs#aspectRatio"
                }
              }
            }
          }
        },
        AppBskyFeedDefs: {
          lexicon: 1,
          id: "app.bsky.feed.defs",
          defs: {
            postView: {
              type: "object",
              required: ["uri", "cid", "author", "record", "indexedAt"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                cid: {
                  type: "string",
                  format: "cid"
                },
                author: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#profileViewBasic"
                },
                record: {
                  type: "unknown"
                },
                embed: {
                  type: "union",
                  refs: [
                    "lex:app.bsky.embed.images#view",
                    "lex:app.bsky.embed.video#view",
                    "lex:app.bsky.embed.external#view",
                    "lex:app.bsky.embed.record#view",
                    "lex:app.bsky.embed.recordWithMedia#view"
                  ]
                },
                replyCount: {
                  type: "integer"
                },
                repostCount: {
                  type: "integer"
                },
                likeCount: {
                  type: "integer"
                },
                quoteCount: {
                  type: "integer"
                },
                indexedAt: {
                  type: "string",
                  format: "datetime"
                },
                viewer: {
                  type: "ref",
                  ref: "lex:app.bsky.feed.defs#viewerState"
                },
                labels: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.label.defs#label"
                  }
                },
                threadgate: {
                  type: "ref",
                  ref: "lex:app.bsky.feed.defs#threadgateView"
                }
              }
            },
            viewerState: {
              type: "object",
              description: "Metadata about the requesting account's relationship with the subject content. Only has meaningful content for authed requests.",
              properties: {
                repost: {
                  type: "string",
                  format: "at-uri"
                },
                like: {
                  type: "string",
                  format: "at-uri"
                },
                threadMuted: {
                  type: "boolean"
                },
                replyDisabled: {
                  type: "boolean"
                },
                embeddingDisabled: {
                  type: "boolean"
                },
                pinned: {
                  type: "boolean"
                }
              }
            },
            threadContext: {
              type: "object",
              description: "Metadata about this post within the context of the thread it is in.",
              properties: {
                rootAuthorLike: {
                  type: "string",
                  format: "at-uri"
                }
              }
            },
            feedViewPost: {
              type: "object",
              required: ["post"],
              properties: {
                post: {
                  type: "ref",
                  ref: "lex:app.bsky.feed.defs#postView"
                },
                reply: {
                  type: "ref",
                  ref: "lex:app.bsky.feed.defs#replyRef"
                },
                reason: {
                  type: "union",
                  refs: [
                    "lex:app.bsky.feed.defs#reasonRepost",
                    "lex:app.bsky.feed.defs#reasonPin"
                  ]
                },
                feedContext: {
                  type: "string",
                  description: "Context provided by feed generator that may be passed back alongside interactions.",
                  maxLength: 2e3
                }
              }
            },
            replyRef: {
              type: "object",
              required: ["root", "parent"],
              properties: {
                root: {
                  type: "union",
                  refs: [
                    "lex:app.bsky.feed.defs#postView",
                    "lex:app.bsky.feed.defs#notFoundPost",
                    "lex:app.bsky.feed.defs#blockedPost"
                  ]
                },
                parent: {
                  type: "union",
                  refs: [
                    "lex:app.bsky.feed.defs#postView",
                    "lex:app.bsky.feed.defs#notFoundPost",
                    "lex:app.bsky.feed.defs#blockedPost"
                  ]
                },
                grandparentAuthor: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#profileViewBasic",
                  description: "When parent is a reply to another post, this is the author of that post."
                }
              }
            },
            reasonRepost: {
              type: "object",
              required: ["by", "indexedAt"],
              properties: {
                by: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#profileViewBasic"
                },
                indexedAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            },
            reasonPin: {
              type: "object",
              properties: {}
            },
            threadViewPost: {
              type: "object",
              required: ["post"],
              properties: {
                post: {
                  type: "ref",
                  ref: "lex:app.bsky.feed.defs#postView"
                },
                parent: {
                  type: "union",
                  refs: [
                    "lex:app.bsky.feed.defs#threadViewPost",
                    "lex:app.bsky.feed.defs#notFoundPost",
                    "lex:app.bsky.feed.defs#blockedPost"
                  ]
                },
                replies: {
                  type: "array",
                  items: {
                    type: "union",
                    refs: [
                      "lex:app.bsky.feed.defs#threadViewPost",
                      "lex:app.bsky.feed.defs#notFoundPost",
                      "lex:app.bsky.feed.defs#blockedPost"
                    ]
                  }
                },
                threadContext: {
                  type: "ref",
                  ref: "lex:app.bsky.feed.defs#threadContext"
                }
              }
            },
            notFoundPost: {
              type: "object",
              required: ["uri", "notFound"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                notFound: {
                  type: "boolean",
                  const: true
                }
              }
            },
            blockedPost: {
              type: "object",
              required: ["uri", "blocked", "author"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                blocked: {
                  type: "boolean",
                  const: true
                },
                author: {
                  type: "ref",
                  ref: "lex:app.bsky.feed.defs#blockedAuthor"
                }
              }
            },
            blockedAuthor: {
              type: "object",
              required: ["did"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                },
                viewer: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#viewerState"
                }
              }
            },
            generatorView: {
              type: "object",
              required: ["uri", "cid", "did", "creator", "displayName", "indexedAt"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                cid: {
                  type: "string",
                  format: "cid"
                },
                did: {
                  type: "string",
                  format: "did"
                },
                creator: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#profileView"
                },
                displayName: {
                  type: "string"
                },
                description: {
                  type: "string",
                  maxGraphemes: 300,
                  maxLength: 3e3
                },
                descriptionFacets: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.richtext.facet"
                  }
                },
                avatar: {
                  type: "string",
                  format: "uri"
                },
                likeCount: {
                  type: "integer",
                  minimum: 0
                },
                acceptsInteractions: {
                  type: "boolean"
                },
                labels: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.label.defs#label"
                  }
                },
                viewer: {
                  type: "ref",
                  ref: "lex:app.bsky.feed.defs#generatorViewerState"
                },
                contentMode: {
                  type: "string",
                  knownValues: [
                    "app.bsky.feed.defs#contentModeUnspecified",
                    "app.bsky.feed.defs#contentModeVideo"
                  ]
                },
                indexedAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            },
            generatorViewerState: {
              type: "object",
              properties: {
                like: {
                  type: "string",
                  format: "at-uri"
                }
              }
            },
            skeletonFeedPost: {
              type: "object",
              required: ["post"],
              properties: {
                post: {
                  type: "string",
                  format: "at-uri"
                },
                reason: {
                  type: "union",
                  refs: [
                    "lex:app.bsky.feed.defs#skeletonReasonRepost",
                    "lex:app.bsky.feed.defs#skeletonReasonPin"
                  ]
                },
                feedContext: {
                  type: "string",
                  description: "Context that will be passed through to client and may be passed to feed generator back alongside interactions.",
                  maxLength: 2e3
                }
              }
            },
            skeletonReasonRepost: {
              type: "object",
              required: ["repost"],
              properties: {
                repost: {
                  type: "string",
                  format: "at-uri"
                }
              }
            },
            skeletonReasonPin: {
              type: "object",
              properties: {}
            },
            threadgateView: {
              type: "object",
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                cid: {
                  type: "string",
                  format: "cid"
                },
                record: {
                  type: "unknown"
                },
                lists: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.graph.defs#listViewBasic"
                  }
                }
              }
            },
            interaction: {
              type: "object",
              properties: {
                item: {
                  type: "string",
                  format: "at-uri"
                },
                event: {
                  type: "string",
                  knownValues: [
                    "app.bsky.feed.defs#requestLess",
                    "app.bsky.feed.defs#requestMore",
                    "app.bsky.feed.defs#clickthroughItem",
                    "app.bsky.feed.defs#clickthroughAuthor",
                    "app.bsky.feed.defs#clickthroughReposter",
                    "app.bsky.feed.defs#clickthroughEmbed",
                    "app.bsky.feed.defs#interactionSeen",
                    "app.bsky.feed.defs#interactionLike",
                    "app.bsky.feed.defs#interactionRepost",
                    "app.bsky.feed.defs#interactionReply",
                    "app.bsky.feed.defs#interactionQuote",
                    "app.bsky.feed.defs#interactionShare"
                  ]
                },
                feedContext: {
                  type: "string",
                  description: "Context on a feed item that was originally supplied by the feed generator on getFeedSkeleton.",
                  maxLength: 2e3
                }
              }
            },
            requestLess: {
              type: "token",
              description: "Request that less content like the given feed item be shown in the feed"
            },
            requestMore: {
              type: "token",
              description: "Request that more content like the given feed item be shown in the feed"
            },
            clickthroughItem: {
              type: "token",
              description: "User clicked through to the feed item"
            },
            clickthroughAuthor: {
              type: "token",
              description: "User clicked through to the author of the feed item"
            },
            clickthroughReposter: {
              type: "token",
              description: "User clicked through to the reposter of the feed item"
            },
            clickthroughEmbed: {
              type: "token",
              description: "User clicked through to the embedded content of the feed item"
            },
            contentModeUnspecified: {
              type: "token",
              description: "Declares the feed generator returns any types of posts."
            },
            contentModeVideo: {
              type: "token",
              description: "Declares the feed generator returns posts containing app.bsky.embed.video embeds."
            },
            interactionSeen: {
              type: "token",
              description: "Feed item was seen by user"
            },
            interactionLike: {
              type: "token",
              description: "User liked the feed item"
            },
            interactionRepost: {
              type: "token",
              description: "User reposted the feed item"
            },
            interactionReply: {
              type: "token",
              description: "User replied to the feed item"
            },
            interactionQuote: {
              type: "token",
              description: "User quoted the feed item"
            },
            interactionShare: {
              type: "token",
              description: "User shared the feed item"
            }
          }
        },
        AppBskyFeedDescribeFeedGenerator: {
          lexicon: 1,
          id: "app.bsky.feed.describeFeedGenerator",
          defs: {
            main: {
              type: "query",
              description: "Get information about a feed generator, including policies and offered feed URIs. Does not require auth; implemented by Feed Generator services (not App View).",
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["did", "feeds"],
                  properties: {
                    did: {
                      type: "string",
                      format: "did"
                    },
                    feeds: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.feed.describeFeedGenerator#feed"
                      }
                    },
                    links: {
                      type: "ref",
                      ref: "lex:app.bsky.feed.describeFeedGenerator#links"
                    }
                  }
                }
              }
            },
            feed: {
              type: "object",
              required: ["uri"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                }
              }
            },
            links: {
              type: "object",
              properties: {
                privacyPolicy: {
                  type: "string"
                },
                termsOfService: {
                  type: "string"
                }
              }
            }
          }
        },
        AppBskyFeedGenerator: {
          lexicon: 1,
          id: "app.bsky.feed.generator",
          defs: {
            main: {
              type: "record",
              description: "Record declaring of the existence of a feed generator, and containing metadata about it. The record can exist in any repository.",
              key: "any",
              record: {
                type: "object",
                required: ["did", "displayName", "createdAt"],
                properties: {
                  did: {
                    type: "string",
                    format: "did"
                  },
                  displayName: {
                    type: "string",
                    maxGraphemes: 24,
                    maxLength: 240
                  },
                  description: {
                    type: "string",
                    maxGraphemes: 300,
                    maxLength: 3e3
                  },
                  descriptionFacets: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.richtext.facet"
                    }
                  },
                  avatar: {
                    type: "blob",
                    accept: ["image/png", "image/jpeg"],
                    maxSize: 1e6
                  },
                  acceptsInteractions: {
                    type: "boolean",
                    description: "Declaration that a feed accepts feedback interactions from a client through app.bsky.feed.sendInteractions"
                  },
                  labels: {
                    type: "union",
                    description: "Self-label values",
                    refs: ["lex:com.atproto.label.defs#selfLabels"]
                  },
                  contentMode: {
                    type: "string",
                    knownValues: [
                      "app.bsky.feed.defs#contentModeUnspecified",
                      "app.bsky.feed.defs#contentModeVideo"
                    ]
                  },
                  createdAt: {
                    type: "string",
                    format: "datetime"
                  }
                }
              }
            }
          }
        },
        AppBskyFeedGetActorFeeds: {
          lexicon: 1,
          id: "app.bsky.feed.getActorFeeds",
          defs: {
            main: {
              type: "query",
              description: "Get a list of feeds (feed generator records) created by the actor (in the actor's repo).",
              parameters: {
                type: "params",
                required: ["actor"],
                properties: {
                  actor: {
                    type: "string",
                    format: "at-identifier"
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["feeds"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    feeds: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.feed.defs#generatorView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyFeedGetActorLikes: {
          lexicon: 1,
          id: "app.bsky.feed.getActorLikes",
          defs: {
            main: {
              type: "query",
              description: "Get a list of posts liked by an actor. Requires auth, actor must be the requesting account.",
              parameters: {
                type: "params",
                required: ["actor"],
                properties: {
                  actor: {
                    type: "string",
                    format: "at-identifier"
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["feed"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    feed: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.feed.defs#feedViewPost"
                      }
                    }
                  }
                }
              },
              errors: [
                {
                  name: "BlockedActor"
                },
                {
                  name: "BlockedByActor"
                }
              ]
            }
          }
        },
        AppBskyFeedGetAuthorFeed: {
          lexicon: 1,
          id: "app.bsky.feed.getAuthorFeed",
          defs: {
            main: {
              type: "query",
              description: "Get a view of an actor's 'author feed' (post and reposts by the author). Does not require auth.",
              parameters: {
                type: "params",
                required: ["actor"],
                properties: {
                  actor: {
                    type: "string",
                    format: "at-identifier"
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  },
                  filter: {
                    type: "string",
                    description: "Combinations of post/repost types to include in response.",
                    knownValues: [
                      "posts_with_replies",
                      "posts_no_replies",
                      "posts_with_media",
                      "posts_and_author_threads",
                      "posts_with_video"
                    ],
                    default: "posts_with_replies"
                  },
                  includePins: {
                    type: "boolean",
                    default: false
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["feed"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    feed: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.feed.defs#feedViewPost"
                      }
                    }
                  }
                }
              },
              errors: [
                {
                  name: "BlockedActor"
                },
                {
                  name: "BlockedByActor"
                }
              ]
            }
          }
        },
        AppBskyFeedGetFeed: {
          lexicon: 1,
          id: "app.bsky.feed.getFeed",
          defs: {
            main: {
              type: "query",
              description: "Get a hydrated feed from an actor's selected feed generator. Implemented by App View.",
              parameters: {
                type: "params",
                required: ["feed"],
                properties: {
                  feed: {
                    type: "string",
                    format: "at-uri"
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["feed"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    feed: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.feed.defs#feedViewPost"
                      }
                    }
                  }
                }
              },
              errors: [
                {
                  name: "UnknownFeed"
                }
              ]
            }
          }
        },
        AppBskyFeedGetFeedGenerator: {
          lexicon: 1,
          id: "app.bsky.feed.getFeedGenerator",
          defs: {
            main: {
              type: "query",
              description: "Get information about a feed generator. Implemented by AppView.",
              parameters: {
                type: "params",
                required: ["feed"],
                properties: {
                  feed: {
                    type: "string",
                    format: "at-uri",
                    description: "AT-URI of the feed generator record."
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["view", "isOnline", "isValid"],
                  properties: {
                    view: {
                      type: "ref",
                      ref: "lex:app.bsky.feed.defs#generatorView"
                    },
                    isOnline: {
                      type: "boolean",
                      description: "Indicates whether the feed generator service has been online recently, or else seems to be inactive."
                    },
                    isValid: {
                      type: "boolean",
                      description: "Indicates whether the feed generator service is compatible with the record declaration."
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyFeedGetFeedGenerators: {
          lexicon: 1,
          id: "app.bsky.feed.getFeedGenerators",
          defs: {
            main: {
              type: "query",
              description: "Get information about a list of feed generators.",
              parameters: {
                type: "params",
                required: ["feeds"],
                properties: {
                  feeds: {
                    type: "array",
                    items: {
                      type: "string",
                      format: "at-uri"
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["feeds"],
                  properties: {
                    feeds: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.feed.defs#generatorView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyFeedGetFeedSkeleton: {
          lexicon: 1,
          id: "app.bsky.feed.getFeedSkeleton",
          defs: {
            main: {
              type: "query",
              description: "Get a skeleton of a feed provided by a feed generator. Auth is optional, depending on provider requirements, and provides the DID of the requester. Implemented by Feed Generator Service.",
              parameters: {
                type: "params",
                required: ["feed"],
                properties: {
                  feed: {
                    type: "string",
                    format: "at-uri",
                    description: "Reference to feed generator record describing the specific feed being requested."
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["feed"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    feed: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.feed.defs#skeletonFeedPost"
                      }
                    }
                  }
                }
              },
              errors: [
                {
                  name: "UnknownFeed"
                }
              ]
            }
          }
        },
        AppBskyFeedGetLikes: {
          lexicon: 1,
          id: "app.bsky.feed.getLikes",
          defs: {
            main: {
              type: "query",
              description: "Get like records which reference a subject (by AT-URI and CID).",
              parameters: {
                type: "params",
                required: ["uri"],
                properties: {
                  uri: {
                    type: "string",
                    format: "at-uri",
                    description: "AT-URI of the subject (eg, a post record)."
                  },
                  cid: {
                    type: "string",
                    format: "cid",
                    description: "CID of the subject record (aka, specific version of record), to filter likes."
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["uri", "likes"],
                  properties: {
                    uri: {
                      type: "string",
                      format: "at-uri"
                    },
                    cid: {
                      type: "string",
                      format: "cid"
                    },
                    cursor: {
                      type: "string"
                    },
                    likes: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.feed.getLikes#like"
                      }
                    }
                  }
                }
              }
            },
            like: {
              type: "object",
              required: ["indexedAt", "createdAt", "actor"],
              properties: {
                indexedAt: {
                  type: "string",
                  format: "datetime"
                },
                createdAt: {
                  type: "string",
                  format: "datetime"
                },
                actor: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#profileView"
                }
              }
            }
          }
        },
        AppBskyFeedGetListFeed: {
          lexicon: 1,
          id: "app.bsky.feed.getListFeed",
          defs: {
            main: {
              type: "query",
              description: "Get a feed of recent posts from a list (posts and reposts from any actors on the list). Does not require auth.",
              parameters: {
                type: "params",
                required: ["list"],
                properties: {
                  list: {
                    type: "string",
                    format: "at-uri",
                    description: "Reference (AT-URI) to the list record."
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["feed"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    feed: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.feed.defs#feedViewPost"
                      }
                    }
                  }
                }
              },
              errors: [
                {
                  name: "UnknownList"
                }
              ]
            }
          }
        },
        AppBskyFeedGetPostThread: {
          lexicon: 1,
          id: "app.bsky.feed.getPostThread",
          defs: {
            main: {
              type: "query",
              description: "Get posts in a thread. Does not require auth, but additional metadata and filtering will be applied for authed requests.",
              parameters: {
                type: "params",
                required: ["uri"],
                properties: {
                  uri: {
                    type: "string",
                    format: "at-uri",
                    description: "Reference (AT-URI) to post record."
                  },
                  depth: {
                    type: "integer",
                    description: "How many levels of reply depth should be included in response.",
                    default: 6,
                    minimum: 0,
                    maximum: 1e3
                  },
                  parentHeight: {
                    type: "integer",
                    description: "How many levels of parent (and grandparent, etc) post to include.",
                    default: 80,
                    minimum: 0,
                    maximum: 1e3
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["thread"],
                  properties: {
                    thread: {
                      type: "union",
                      refs: [
                        "lex:app.bsky.feed.defs#threadViewPost",
                        "lex:app.bsky.feed.defs#notFoundPost",
                        "lex:app.bsky.feed.defs#blockedPost"
                      ]
                    },
                    threadgate: {
                      type: "ref",
                      ref: "lex:app.bsky.feed.defs#threadgateView"
                    }
                  }
                }
              },
              errors: [
                {
                  name: "NotFound"
                }
              ]
            }
          }
        },
        AppBskyFeedGetPosts: {
          lexicon: 1,
          id: "app.bsky.feed.getPosts",
          defs: {
            main: {
              type: "query",
              description: "Gets post views for a specified list of posts (by AT-URI). This is sometimes referred to as 'hydrating' a 'feed skeleton'.",
              parameters: {
                type: "params",
                required: ["uris"],
                properties: {
                  uris: {
                    type: "array",
                    description: "List of post AT-URIs to return hydrated views for.",
                    items: {
                      type: "string",
                      format: "at-uri"
                    },
                    maxLength: 25
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["posts"],
                  properties: {
                    posts: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.feed.defs#postView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyFeedGetQuotes: {
          lexicon: 1,
          id: "app.bsky.feed.getQuotes",
          defs: {
            main: {
              type: "query",
              description: "Get a list of quotes for a given post.",
              parameters: {
                type: "params",
                required: ["uri"],
                properties: {
                  uri: {
                    type: "string",
                    format: "at-uri",
                    description: "Reference (AT-URI) of post record"
                  },
                  cid: {
                    type: "string",
                    format: "cid",
                    description: "If supplied, filters to quotes of specific version (by CID) of the post record."
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["uri", "posts"],
                  properties: {
                    uri: {
                      type: "string",
                      format: "at-uri"
                    },
                    cid: {
                      type: "string",
                      format: "cid"
                    },
                    cursor: {
                      type: "string"
                    },
                    posts: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.feed.defs#postView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyFeedGetRepostedBy: {
          lexicon: 1,
          id: "app.bsky.feed.getRepostedBy",
          defs: {
            main: {
              type: "query",
              description: "Get a list of reposts for a given post.",
              parameters: {
                type: "params",
                required: ["uri"],
                properties: {
                  uri: {
                    type: "string",
                    format: "at-uri",
                    description: "Reference (AT-URI) of post record"
                  },
                  cid: {
                    type: "string",
                    format: "cid",
                    description: "If supplied, filters to reposts of specific version (by CID) of the post record."
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["uri", "repostedBy"],
                  properties: {
                    uri: {
                      type: "string",
                      format: "at-uri"
                    },
                    cid: {
                      type: "string",
                      format: "cid"
                    },
                    cursor: {
                      type: "string"
                    },
                    repostedBy: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.actor.defs#profileView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyFeedGetSuggestedFeeds: {
          lexicon: 1,
          id: "app.bsky.feed.getSuggestedFeeds",
          defs: {
            main: {
              type: "query",
              description: "Get a list of suggested feeds (feed generators) for the requesting account.",
              parameters: {
                type: "params",
                properties: {
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["feeds"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    feeds: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.feed.defs#generatorView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyFeedGetTimeline: {
          lexicon: 1,
          id: "app.bsky.feed.getTimeline",
          defs: {
            main: {
              type: "query",
              description: "Get a view of the requesting account's home timeline. This is expected to be some form of reverse-chronological feed.",
              parameters: {
                type: "params",
                properties: {
                  algorithm: {
                    type: "string",
                    description: "Variant 'algorithm' for timeline. Implementation-specific. NOTE: most feed flexibility has been moved to feed generator mechanism."
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["feed"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    feed: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.feed.defs#feedViewPost"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyFeedLike: {
          lexicon: 1,
          id: "app.bsky.feed.like",
          defs: {
            main: {
              type: "record",
              description: "Record declaring a 'like' of a piece of subject content.",
              key: "tid",
              record: {
                type: "object",
                required: ["subject", "createdAt"],
                properties: {
                  subject: {
                    type: "ref",
                    ref: "lex:com.atproto.repo.strongRef"
                  },
                  createdAt: {
                    type: "string",
                    format: "datetime"
                  }
                }
              }
            }
          }
        },
        AppBskyFeedPost: {
          lexicon: 1,
          id: "app.bsky.feed.post",
          defs: {
            main: {
              type: "record",
              description: "Record containing a Bluesky post.",
              key: "tid",
              record: {
                type: "object",
                required: ["text", "createdAt"],
                properties: {
                  text: {
                    type: "string",
                    maxLength: 3e3,
                    maxGraphemes: 300,
                    description: "The primary post content. May be an empty string, if there are embeds."
                  },
                  entities: {
                    type: "array",
                    description: "DEPRECATED: replaced by app.bsky.richtext.facet.",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.feed.post#entity"
                    }
                  },
                  facets: {
                    type: "array",
                    description: "Annotations of text (mentions, URLs, hashtags, etc)",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.richtext.facet"
                    }
                  },
                  reply: {
                    type: "ref",
                    ref: "lex:app.bsky.feed.post#replyRef"
                  },
                  embed: {
                    type: "union",
                    refs: [
                      "lex:app.bsky.embed.images",
                      "lex:app.bsky.embed.video",
                      "lex:app.bsky.embed.external",
                      "lex:app.bsky.embed.record",
                      "lex:app.bsky.embed.recordWithMedia"
                    ]
                  },
                  langs: {
                    type: "array",
                    description: "Indicates human language of post primary text content.",
                    maxLength: 3,
                    items: {
                      type: "string",
                      format: "language"
                    }
                  },
                  labels: {
                    type: "union",
                    description: "Self-label values for this post. Effectively content warnings.",
                    refs: ["lex:com.atproto.label.defs#selfLabels"]
                  },
                  tags: {
                    type: "array",
                    description: "Additional hashtags, in addition to any included in post text and facets.",
                    maxLength: 8,
                    items: {
                      type: "string",
                      maxLength: 640,
                      maxGraphemes: 64
                    }
                  },
                  createdAt: {
                    type: "string",
                    format: "datetime",
                    description: "Client-declared timestamp when this post was originally created."
                  }
                }
              }
            },
            replyRef: {
              type: "object",
              required: ["root", "parent"],
              properties: {
                root: {
                  type: "ref",
                  ref: "lex:com.atproto.repo.strongRef"
                },
                parent: {
                  type: "ref",
                  ref: "lex:com.atproto.repo.strongRef"
                }
              }
            },
            entity: {
              type: "object",
              description: "Deprecated: use facets instead.",
              required: ["index", "type", "value"],
              properties: {
                index: {
                  type: "ref",
                  ref: "lex:app.bsky.feed.post#textSlice"
                },
                type: {
                  type: "string",
                  description: "Expected values are 'mention' and 'link'."
                },
                value: {
                  type: "string"
                }
              }
            },
            textSlice: {
              type: "object",
              description: "Deprecated. Use app.bsky.richtext instead -- A text segment. Start is inclusive, end is exclusive. Indices are for utf16-encoded strings.",
              required: ["start", "end"],
              properties: {
                start: {
                  type: "integer",
                  minimum: 0
                },
                end: {
                  type: "integer",
                  minimum: 0
                }
              }
            }
          }
        },
        AppBskyFeedPostgate: {
          lexicon: 1,
          id: "app.bsky.feed.postgate",
          defs: {
            main: {
              type: "record",
              key: "tid",
              description: "Record defining interaction rules for a post. The record key (rkey) of the postgate record must match the record key of the post, and that record must be in the same repository.",
              record: {
                type: "object",
                required: ["post", "createdAt"],
                properties: {
                  createdAt: {
                    type: "string",
                    format: "datetime"
                  },
                  post: {
                    type: "string",
                    format: "at-uri",
                    description: "Reference (AT-URI) to the post record."
                  },
                  detachedEmbeddingUris: {
                    type: "array",
                    maxLength: 50,
                    items: {
                      type: "string",
                      format: "at-uri"
                    },
                    description: "List of AT-URIs embedding this post that the author has detached from."
                  },
                  embeddingRules: {
                    description: "List of rules defining who can embed this post. If value is an empty array or is undefined, no particular rules apply and anyone can embed.",
                    type: "array",
                    maxLength: 5,
                    items: {
                      type: "union",
                      refs: ["lex:app.bsky.feed.postgate#disableRule"]
                    }
                  }
                }
              }
            },
            disableRule: {
              type: "object",
              description: "Disables embedding of this post.",
              properties: {}
            }
          }
        },
        AppBskyFeedRepost: {
          lexicon: 1,
          id: "app.bsky.feed.repost",
          defs: {
            main: {
              description: "Record representing a 'repost' of an existing Bluesky post.",
              type: "record",
              key: "tid",
              record: {
                type: "object",
                required: ["subject", "createdAt"],
                properties: {
                  subject: {
                    type: "ref",
                    ref: "lex:com.atproto.repo.strongRef"
                  },
                  createdAt: {
                    type: "string",
                    format: "datetime"
                  }
                }
              }
            }
          }
        },
        AppBskyFeedSearchPosts: {
          lexicon: 1,
          id: "app.bsky.feed.searchPosts",
          defs: {
            main: {
              type: "query",
              description: "Find posts matching search criteria, returning views of those posts.",
              parameters: {
                type: "params",
                required: ["q"],
                properties: {
                  q: {
                    type: "string",
                    description: "Search query string; syntax, phrase, boolean, and faceting is unspecified, but Lucene query syntax is recommended."
                  },
                  sort: {
                    type: "string",
                    knownValues: ["top", "latest"],
                    default: "latest",
                    description: "Specifies the ranking order of results."
                  },
                  since: {
                    type: "string",
                    description: "Filter results for posts after the indicated datetime (inclusive). Expected to use 'sortAt' timestamp, which may not match 'createdAt'. Can be a datetime, or just an ISO date (YYYY-MM-DD)."
                  },
                  until: {
                    type: "string",
                    description: "Filter results for posts before the indicated datetime (not inclusive). Expected to use 'sortAt' timestamp, which may not match 'createdAt'. Can be a datetime, or just an ISO date (YYY-MM-DD)."
                  },
                  mentions: {
                    type: "string",
                    format: "at-identifier",
                    description: "Filter to posts which mention the given account. Handles are resolved to DID before query-time. Only matches rich-text facet mentions."
                  },
                  author: {
                    type: "string",
                    format: "at-identifier",
                    description: "Filter to posts by the given account. Handles are resolved to DID before query-time."
                  },
                  lang: {
                    type: "string",
                    format: "language",
                    description: "Filter to posts in the given language. Expected to be based on post language field, though server may override language detection."
                  },
                  domain: {
                    type: "string",
                    description: "Filter to posts with URLs (facet links or embeds) linking to the given domain (hostname). Server may apply hostname normalization."
                  },
                  url: {
                    type: "string",
                    format: "uri",
                    description: "Filter to posts with links (facet links or embeds) pointing to this URL. Server may apply URL normalization or fuzzy matching."
                  },
                  tag: {
                    type: "array",
                    items: {
                      type: "string",
                      maxLength: 640,
                      maxGraphemes: 64
                    },
                    description: "Filter to posts with the given tag (hashtag), based on rich-text facet or tag field. Do not include the hash (#) prefix. Multiple tags can be specified, with 'AND' matching."
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 25
                  },
                  cursor: {
                    type: "string",
                    description: "Optional pagination mechanism; may not necessarily allow scrolling through entire result set."
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["posts"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    hitsTotal: {
                      type: "integer",
                      description: "Count of search hits. Optional, may be rounded/truncated, and may not be possible to paginate through all hits."
                    },
                    posts: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.feed.defs#postView"
                      }
                    }
                  }
                }
              },
              errors: [
                {
                  name: "BadQueryString"
                }
              ]
            }
          }
        },
        AppBskyFeedSendInteractions: {
          lexicon: 1,
          id: "app.bsky.feed.sendInteractions",
          defs: {
            main: {
              type: "procedure",
              description: "Send information about interactions with feed items back to the feed generator that served them.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["interactions"],
                  properties: {
                    interactions: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.feed.defs#interaction"
                      }
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  properties: {}
                }
              }
            }
          }
        },
        AppBskyFeedThreadgate: {
          lexicon: 1,
          id: "app.bsky.feed.threadgate",
          defs: {
            main: {
              type: "record",
              key: "tid",
              description: "Record defining interaction gating rules for a thread (aka, reply controls). The record key (rkey) of the threadgate record must match the record key of the thread's root post, and that record must be in the same repository.",
              record: {
                type: "object",
                required: ["post", "createdAt"],
                properties: {
                  post: {
                    type: "string",
                    format: "at-uri",
                    description: "Reference (AT-URI) to the post record."
                  },
                  allow: {
                    description: "List of rules defining who can reply to this post. If value is an empty array, no one can reply. If value is undefined, anyone can reply.",
                    type: "array",
                    maxLength: 5,
                    items: {
                      type: "union",
                      refs: [
                        "lex:app.bsky.feed.threadgate#mentionRule",
                        "lex:app.bsky.feed.threadgate#followerRule",
                        "lex:app.bsky.feed.threadgate#followingRule",
                        "lex:app.bsky.feed.threadgate#listRule"
                      ]
                    }
                  },
                  createdAt: {
                    type: "string",
                    format: "datetime"
                  },
                  hiddenReplies: {
                    type: "array",
                    maxLength: 50,
                    items: {
                      type: "string",
                      format: "at-uri"
                    },
                    description: "List of hidden reply URIs."
                  }
                }
              }
            },
            mentionRule: {
              type: "object",
              description: "Allow replies from actors mentioned in your post.",
              properties: {}
            },
            followerRule: {
              type: "object",
              description: "Allow replies from actors who follow you.",
              properties: {}
            },
            followingRule: {
              type: "object",
              description: "Allow replies from actors you follow.",
              properties: {}
            },
            listRule: {
              type: "object",
              description: "Allow replies from actors on a list.",
              required: ["list"],
              properties: {
                list: {
                  type: "string",
                  format: "at-uri"
                }
              }
            }
          }
        },
        AppBskyGraphBlock: {
          lexicon: 1,
          id: "app.bsky.graph.block",
          defs: {
            main: {
              type: "record",
              description: "Record declaring a 'block' relationship against another account. NOTE: blocks are public in Bluesky; see blog posts for details.",
              key: "tid",
              record: {
                type: "object",
                required: ["subject", "createdAt"],
                properties: {
                  subject: {
                    type: "string",
                    format: "did",
                    description: "DID of the account to be blocked."
                  },
                  createdAt: {
                    type: "string",
                    format: "datetime"
                  }
                }
              }
            }
          }
        },
        AppBskyGraphDefs: {
          lexicon: 1,
          id: "app.bsky.graph.defs",
          defs: {
            listViewBasic: {
              type: "object",
              required: ["uri", "cid", "name", "purpose"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                cid: {
                  type: "string",
                  format: "cid"
                },
                name: {
                  type: "string",
                  maxLength: 64,
                  minLength: 1
                },
                purpose: {
                  type: "ref",
                  ref: "lex:app.bsky.graph.defs#listPurpose"
                },
                avatar: {
                  type: "string",
                  format: "uri"
                },
                listItemCount: {
                  type: "integer",
                  minimum: 0
                },
                labels: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.label.defs#label"
                  }
                },
                viewer: {
                  type: "ref",
                  ref: "lex:app.bsky.graph.defs#listViewerState"
                },
                indexedAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            },
            listView: {
              type: "object",
              required: ["uri", "cid", "creator", "name", "purpose", "indexedAt"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                cid: {
                  type: "string",
                  format: "cid"
                },
                creator: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#profileView"
                },
                name: {
                  type: "string",
                  maxLength: 64,
                  minLength: 1
                },
                purpose: {
                  type: "ref",
                  ref: "lex:app.bsky.graph.defs#listPurpose"
                },
                description: {
                  type: "string",
                  maxGraphemes: 300,
                  maxLength: 3e3
                },
                descriptionFacets: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.richtext.facet"
                  }
                },
                avatar: {
                  type: "string",
                  format: "uri"
                },
                listItemCount: {
                  type: "integer",
                  minimum: 0
                },
                labels: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.label.defs#label"
                  }
                },
                viewer: {
                  type: "ref",
                  ref: "lex:app.bsky.graph.defs#listViewerState"
                },
                indexedAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            },
            listItemView: {
              type: "object",
              required: ["uri", "subject"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                subject: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#profileView"
                }
              }
            },
            starterPackView: {
              type: "object",
              required: ["uri", "cid", "record", "creator", "indexedAt"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                cid: {
                  type: "string",
                  format: "cid"
                },
                record: {
                  type: "unknown"
                },
                creator: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#profileViewBasic"
                },
                list: {
                  type: "ref",
                  ref: "lex:app.bsky.graph.defs#listViewBasic"
                },
                listItemsSample: {
                  type: "array",
                  maxLength: 12,
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.graph.defs#listItemView"
                  }
                },
                feeds: {
                  type: "array",
                  maxLength: 3,
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.feed.defs#generatorView"
                  }
                },
                joinedWeekCount: {
                  type: "integer",
                  minimum: 0
                },
                joinedAllTimeCount: {
                  type: "integer",
                  minimum: 0
                },
                labels: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.label.defs#label"
                  }
                },
                indexedAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            },
            starterPackViewBasic: {
              type: "object",
              required: ["uri", "cid", "record", "creator", "indexedAt"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                cid: {
                  type: "string",
                  format: "cid"
                },
                record: {
                  type: "unknown"
                },
                creator: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#profileViewBasic"
                },
                listItemCount: {
                  type: "integer",
                  minimum: 0
                },
                joinedWeekCount: {
                  type: "integer",
                  minimum: 0
                },
                joinedAllTimeCount: {
                  type: "integer",
                  minimum: 0
                },
                labels: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.label.defs#label"
                  }
                },
                indexedAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            },
            listPurpose: {
              type: "string",
              knownValues: [
                "app.bsky.graph.defs#modlist",
                "app.bsky.graph.defs#curatelist",
                "app.bsky.graph.defs#referencelist"
              ]
            },
            modlist: {
              type: "token",
              description: "A list of actors to apply an aggregate moderation action (mute/block) on."
            },
            curatelist: {
              type: "token",
              description: "A list of actors used for curation purposes such as list feeds or interaction gating."
            },
            referencelist: {
              type: "token",
              description: "A list of actors used for only for reference purposes such as within a starter pack."
            },
            listViewerState: {
              type: "object",
              properties: {
                muted: {
                  type: "boolean"
                },
                blocked: {
                  type: "string",
                  format: "at-uri"
                }
              }
            },
            notFoundActor: {
              type: "object",
              description: "indicates that a handle or DID could not be resolved",
              required: ["actor", "notFound"],
              properties: {
                actor: {
                  type: "string",
                  format: "at-identifier"
                },
                notFound: {
                  type: "boolean",
                  const: true
                }
              }
            },
            relationship: {
              type: "object",
              description: "lists the bi-directional graph relationships between one actor (not indicated in the object), and the target actors (the DID included in the object)",
              required: ["did"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                },
                following: {
                  type: "string",
                  format: "at-uri",
                  description: "if the actor follows this DID, this is the AT-URI of the follow record"
                },
                followedBy: {
                  type: "string",
                  format: "at-uri",
                  description: "if the actor is followed by this DID, contains the AT-URI of the follow record"
                }
              }
            }
          }
        },
        AppBskyGraphFollow: {
          lexicon: 1,
          id: "app.bsky.graph.follow",
          defs: {
            main: {
              type: "record",
              description: "Record declaring a social 'follow' relationship of another account. Duplicate follows will be ignored by the AppView.",
              key: "tid",
              record: {
                type: "object",
                required: ["subject", "createdAt"],
                properties: {
                  subject: {
                    type: "string",
                    format: "did"
                  },
                  createdAt: {
                    type: "string",
                    format: "datetime"
                  }
                }
              }
            }
          }
        },
        AppBskyGraphGetActorStarterPacks: {
          lexicon: 1,
          id: "app.bsky.graph.getActorStarterPacks",
          defs: {
            main: {
              type: "query",
              description: "Get a list of starter packs created by the actor.",
              parameters: {
                type: "params",
                required: ["actor"],
                properties: {
                  actor: {
                    type: "string",
                    format: "at-identifier"
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["starterPacks"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    starterPacks: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.graph.defs#starterPackViewBasic"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyGraphGetBlocks: {
          lexicon: 1,
          id: "app.bsky.graph.getBlocks",
          defs: {
            main: {
              type: "query",
              description: "Enumerates which accounts the requesting account is currently blocking. Requires auth.",
              parameters: {
                type: "params",
                properties: {
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["blocks"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    blocks: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.actor.defs#profileView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyGraphGetFollowers: {
          lexicon: 1,
          id: "app.bsky.graph.getFollowers",
          defs: {
            main: {
              type: "query",
              description: "Enumerates accounts which follow a specified account (actor).",
              parameters: {
                type: "params",
                required: ["actor"],
                properties: {
                  actor: {
                    type: "string",
                    format: "at-identifier"
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["subject", "followers"],
                  properties: {
                    subject: {
                      type: "ref",
                      ref: "lex:app.bsky.actor.defs#profileView"
                    },
                    cursor: {
                      type: "string"
                    },
                    followers: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.actor.defs#profileView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyGraphGetFollows: {
          lexicon: 1,
          id: "app.bsky.graph.getFollows",
          defs: {
            main: {
              type: "query",
              description: "Enumerates accounts which a specified account (actor) follows.",
              parameters: {
                type: "params",
                required: ["actor"],
                properties: {
                  actor: {
                    type: "string",
                    format: "at-identifier"
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["subject", "follows"],
                  properties: {
                    subject: {
                      type: "ref",
                      ref: "lex:app.bsky.actor.defs#profileView"
                    },
                    cursor: {
                      type: "string"
                    },
                    follows: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.actor.defs#profileView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyGraphGetKnownFollowers: {
          lexicon: 1,
          id: "app.bsky.graph.getKnownFollowers",
          defs: {
            main: {
              type: "query",
              description: "Enumerates accounts which follow a specified account (actor) and are followed by the viewer.",
              parameters: {
                type: "params",
                required: ["actor"],
                properties: {
                  actor: {
                    type: "string",
                    format: "at-identifier"
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["subject", "followers"],
                  properties: {
                    subject: {
                      type: "ref",
                      ref: "lex:app.bsky.actor.defs#profileView"
                    },
                    cursor: {
                      type: "string"
                    },
                    followers: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.actor.defs#profileView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyGraphGetList: {
          lexicon: 1,
          id: "app.bsky.graph.getList",
          defs: {
            main: {
              type: "query",
              description: "Gets a 'view' (with additional context) of a specified list.",
              parameters: {
                type: "params",
                required: ["list"],
                properties: {
                  list: {
                    type: "string",
                    format: "at-uri",
                    description: "Reference (AT-URI) of the list record to hydrate."
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["list", "items"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    list: {
                      type: "ref",
                      ref: "lex:app.bsky.graph.defs#listView"
                    },
                    items: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.graph.defs#listItemView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyGraphGetListBlocks: {
          lexicon: 1,
          id: "app.bsky.graph.getListBlocks",
          defs: {
            main: {
              type: "query",
              description: "Get mod lists that the requesting account (actor) is blocking. Requires auth.",
              parameters: {
                type: "params",
                properties: {
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["lists"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    lists: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.graph.defs#listView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyGraphGetListMutes: {
          lexicon: 1,
          id: "app.bsky.graph.getListMutes",
          defs: {
            main: {
              type: "query",
              description: "Enumerates mod lists that the requesting account (actor) currently has muted. Requires auth.",
              parameters: {
                type: "params",
                properties: {
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["lists"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    lists: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.graph.defs#listView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyGraphGetLists: {
          lexicon: 1,
          id: "app.bsky.graph.getLists",
          defs: {
            main: {
              type: "query",
              description: "Enumerates the lists created by a specified account (actor).",
              parameters: {
                type: "params",
                required: ["actor"],
                properties: {
                  actor: {
                    type: "string",
                    format: "at-identifier",
                    description: "The account (actor) to enumerate lists from."
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["lists"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    lists: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.graph.defs#listView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyGraphGetMutes: {
          lexicon: 1,
          id: "app.bsky.graph.getMutes",
          defs: {
            main: {
              type: "query",
              description: "Enumerates accounts that the requesting account (actor) currently has muted. Requires auth.",
              parameters: {
                type: "params",
                properties: {
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["mutes"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    mutes: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.actor.defs#profileView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyGraphGetRelationships: {
          lexicon: 1,
          id: "app.bsky.graph.getRelationships",
          defs: {
            main: {
              type: "query",
              description: "Enumerates public relationships between one account, and a list of other accounts. Does not require auth.",
              parameters: {
                type: "params",
                required: ["actor"],
                properties: {
                  actor: {
                    type: "string",
                    format: "at-identifier",
                    description: "Primary account requesting relationships for."
                  },
                  others: {
                    type: "array",
                    description: "List of 'other' accounts to be related back to the primary.",
                    maxLength: 30,
                    items: {
                      type: "string",
                      format: "at-identifier"
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["relationships"],
                  properties: {
                    actor: {
                      type: "string",
                      format: "did"
                    },
                    relationships: {
                      type: "array",
                      items: {
                        type: "union",
                        refs: [
                          "lex:app.bsky.graph.defs#relationship",
                          "lex:app.bsky.graph.defs#notFoundActor"
                        ]
                      }
                    }
                  }
                }
              },
              errors: [
                {
                  name: "ActorNotFound",
                  description: "the primary actor at-identifier could not be resolved"
                }
              ]
            }
          }
        },
        AppBskyGraphGetStarterPack: {
          lexicon: 1,
          id: "app.bsky.graph.getStarterPack",
          defs: {
            main: {
              type: "query",
              description: "Gets a view of a starter pack.",
              parameters: {
                type: "params",
                required: ["starterPack"],
                properties: {
                  starterPack: {
                    type: "string",
                    format: "at-uri",
                    description: "Reference (AT-URI) of the starter pack record."
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["starterPack"],
                  properties: {
                    starterPack: {
                      type: "ref",
                      ref: "lex:app.bsky.graph.defs#starterPackView"
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyGraphGetStarterPacks: {
          lexicon: 1,
          id: "app.bsky.graph.getStarterPacks",
          defs: {
            main: {
              type: "query",
              description: "Get views for a list of starter packs.",
              parameters: {
                type: "params",
                required: ["uris"],
                properties: {
                  uris: {
                    type: "array",
                    items: {
                      type: "string",
                      format: "at-uri"
                    },
                    maxLength: 25
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["starterPacks"],
                  properties: {
                    starterPacks: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.graph.defs#starterPackViewBasic"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyGraphGetSuggestedFollowsByActor: {
          lexicon: 1,
          id: "app.bsky.graph.getSuggestedFollowsByActor",
          defs: {
            main: {
              type: "query",
              description: "Enumerates follows similar to a given account (actor). Expected use is to recommend additional accounts immediately after following one account.",
              parameters: {
                type: "params",
                required: ["actor"],
                properties: {
                  actor: {
                    type: "string",
                    format: "at-identifier"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["suggestions"],
                  properties: {
                    suggestions: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.actor.defs#profileView"
                      }
                    },
                    isFallback: {
                      type: "boolean",
                      description: "If true, response has fallen-back to generic results, and is not scoped using relativeToDid",
                      default: false
                    },
                    recId: {
                      type: "integer",
                      description: "Snowflake for this recommendation, use when submitting recommendation events."
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyGraphList: {
          lexicon: 1,
          id: "app.bsky.graph.list",
          defs: {
            main: {
              type: "record",
              description: "Record representing a list of accounts (actors). Scope includes both moderation-oriented lists and curration-oriented lists.",
              key: "tid",
              record: {
                type: "object",
                required: ["name", "purpose", "createdAt"],
                properties: {
                  purpose: {
                    type: "ref",
                    description: "Defines the purpose of the list (aka, moderation-oriented or curration-oriented)",
                    ref: "lex:app.bsky.graph.defs#listPurpose"
                  },
                  name: {
                    type: "string",
                    maxLength: 64,
                    minLength: 1,
                    description: "Display name for list; can not be empty."
                  },
                  description: {
                    type: "string",
                    maxGraphemes: 300,
                    maxLength: 3e3
                  },
                  descriptionFacets: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.richtext.facet"
                    }
                  },
                  avatar: {
                    type: "blob",
                    accept: ["image/png", "image/jpeg"],
                    maxSize: 1e6
                  },
                  labels: {
                    type: "union",
                    refs: ["lex:com.atproto.label.defs#selfLabels"]
                  },
                  createdAt: {
                    type: "string",
                    format: "datetime"
                  }
                }
              }
            }
          }
        },
        AppBskyGraphListblock: {
          lexicon: 1,
          id: "app.bsky.graph.listblock",
          defs: {
            main: {
              type: "record",
              description: "Record representing a block relationship against an entire an entire list of accounts (actors).",
              key: "tid",
              record: {
                type: "object",
                required: ["subject", "createdAt"],
                properties: {
                  subject: {
                    type: "string",
                    format: "at-uri",
                    description: "Reference (AT-URI) to the mod list record."
                  },
                  createdAt: {
                    type: "string",
                    format: "datetime"
                  }
                }
              }
            }
          }
        },
        AppBskyGraphListitem: {
          lexicon: 1,
          id: "app.bsky.graph.listitem",
          defs: {
            main: {
              type: "record",
              description: "Record representing an account's inclusion on a specific list. The AppView will ignore duplicate listitem records.",
              key: "tid",
              record: {
                type: "object",
                required: ["subject", "list", "createdAt"],
                properties: {
                  subject: {
                    type: "string",
                    format: "did",
                    description: "The account which is included on the list."
                  },
                  list: {
                    type: "string",
                    format: "at-uri",
                    description: "Reference (AT-URI) to the list record (app.bsky.graph.list)."
                  },
                  createdAt: {
                    type: "string",
                    format: "datetime"
                  }
                }
              }
            }
          }
        },
        AppBskyGraphMuteActor: {
          lexicon: 1,
          id: "app.bsky.graph.muteActor",
          defs: {
            main: {
              type: "procedure",
              description: "Creates a mute relationship for the specified account. Mutes are private in Bluesky. Requires auth.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["actor"],
                  properties: {
                    actor: {
                      type: "string",
                      format: "at-identifier"
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyGraphMuteActorList: {
          lexicon: 1,
          id: "app.bsky.graph.muteActorList",
          defs: {
            main: {
              type: "procedure",
              description: "Creates a mute relationship for the specified list of accounts. Mutes are private in Bluesky. Requires auth.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["list"],
                  properties: {
                    list: {
                      type: "string",
                      format: "at-uri"
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyGraphMuteThread: {
          lexicon: 1,
          id: "app.bsky.graph.muteThread",
          defs: {
            main: {
              type: "procedure",
              description: "Mutes a thread preventing notifications from the thread and any of its children. Mutes are private in Bluesky. Requires auth.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["root"],
                  properties: {
                    root: {
                      type: "string",
                      format: "at-uri"
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyGraphSearchStarterPacks: {
          lexicon: 1,
          id: "app.bsky.graph.searchStarterPacks",
          defs: {
            main: {
              type: "query",
              description: "Find starter packs matching search criteria. Does not require auth.",
              parameters: {
                type: "params",
                required: ["q"],
                properties: {
                  q: {
                    type: "string",
                    description: "Search query string. Syntax, phrase, boolean, and faceting is unspecified, but Lucene query syntax is recommended."
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 25
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["starterPacks"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    starterPacks: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.graph.defs#starterPackViewBasic"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyGraphStarterpack: {
          lexicon: 1,
          id: "app.bsky.graph.starterpack",
          defs: {
            main: {
              type: "record",
              description: "Record defining a starter pack of actors and feeds for new users.",
              key: "tid",
              record: {
                type: "object",
                required: ["name", "list", "createdAt"],
                properties: {
                  name: {
                    type: "string",
                    maxGraphemes: 50,
                    maxLength: 500,
                    minLength: 1,
                    description: "Display name for starter pack; can not be empty."
                  },
                  description: {
                    type: "string",
                    maxGraphemes: 300,
                    maxLength: 3e3
                  },
                  descriptionFacets: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.richtext.facet"
                    }
                  },
                  list: {
                    type: "string",
                    format: "at-uri",
                    description: "Reference (AT-URI) to the list record."
                  },
                  feeds: {
                    type: "array",
                    maxLength: 3,
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.graph.starterpack#feedItem"
                    }
                  },
                  createdAt: {
                    type: "string",
                    format: "datetime"
                  }
                }
              }
            },
            feedItem: {
              type: "object",
              required: ["uri"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                }
              }
            }
          }
        },
        AppBskyGraphUnmuteActor: {
          lexicon: 1,
          id: "app.bsky.graph.unmuteActor",
          defs: {
            main: {
              type: "procedure",
              description: "Unmutes the specified account. Requires auth.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["actor"],
                  properties: {
                    actor: {
                      type: "string",
                      format: "at-identifier"
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyGraphUnmuteActorList: {
          lexicon: 1,
          id: "app.bsky.graph.unmuteActorList",
          defs: {
            main: {
              type: "procedure",
              description: "Unmutes the specified list of accounts. Requires auth.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["list"],
                  properties: {
                    list: {
                      type: "string",
                      format: "at-uri"
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyGraphUnmuteThread: {
          lexicon: 1,
          id: "app.bsky.graph.unmuteThread",
          defs: {
            main: {
              type: "procedure",
              description: "Unmutes the specified thread. Requires auth.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["root"],
                  properties: {
                    root: {
                      type: "string",
                      format: "at-uri"
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyLabelerDefs: {
          lexicon: 1,
          id: "app.bsky.labeler.defs",
          defs: {
            labelerView: {
              type: "object",
              required: ["uri", "cid", "creator", "indexedAt"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                cid: {
                  type: "string",
                  format: "cid"
                },
                creator: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#profileView"
                },
                likeCount: {
                  type: "integer",
                  minimum: 0
                },
                viewer: {
                  type: "ref",
                  ref: "lex:app.bsky.labeler.defs#labelerViewerState"
                },
                indexedAt: {
                  type: "string",
                  format: "datetime"
                },
                labels: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.label.defs#label"
                  }
                }
              }
            },
            labelerViewDetailed: {
              type: "object",
              required: ["uri", "cid", "creator", "policies", "indexedAt"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                cid: {
                  type: "string",
                  format: "cid"
                },
                creator: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#profileView"
                },
                policies: {
                  type: "ref",
                  ref: "lex:app.bsky.labeler.defs#labelerPolicies"
                },
                likeCount: {
                  type: "integer",
                  minimum: 0
                },
                viewer: {
                  type: "ref",
                  ref: "lex:app.bsky.labeler.defs#labelerViewerState"
                },
                indexedAt: {
                  type: "string",
                  format: "datetime"
                },
                labels: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.label.defs#label"
                  }
                }
              }
            },
            labelerViewerState: {
              type: "object",
              properties: {
                like: {
                  type: "string",
                  format: "at-uri"
                }
              }
            },
            labelerPolicies: {
              type: "object",
              required: ["labelValues"],
              properties: {
                labelValues: {
                  type: "array",
                  description: "The label values which this labeler publishes. May include global or custom labels.",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.label.defs#labelValue"
                  }
                },
                labelValueDefinitions: {
                  type: "array",
                  description: "Label values created by this labeler and scoped exclusively to it. Labels defined here will override global label definitions for this labeler.",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.label.defs#labelValueDefinition"
                  }
                }
              }
            }
          }
        },
        AppBskyLabelerGetServices: {
          lexicon: 1,
          id: "app.bsky.labeler.getServices",
          defs: {
            main: {
              type: "query",
              description: "Get information about a list of labeler services.",
              parameters: {
                type: "params",
                required: ["dids"],
                properties: {
                  dids: {
                    type: "array",
                    items: {
                      type: "string",
                      format: "did"
                    }
                  },
                  detailed: {
                    type: "boolean",
                    default: false
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["views"],
                  properties: {
                    views: {
                      type: "array",
                      items: {
                        type: "union",
                        refs: [
                          "lex:app.bsky.labeler.defs#labelerView",
                          "lex:app.bsky.labeler.defs#labelerViewDetailed"
                        ]
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyLabelerService: {
          lexicon: 1,
          id: "app.bsky.labeler.service",
          defs: {
            main: {
              type: "record",
              description: "A declaration of the existence of labeler service.",
              key: "literal:self",
              record: {
                type: "object",
                required: ["policies", "createdAt"],
                properties: {
                  policies: {
                    type: "ref",
                    ref: "lex:app.bsky.labeler.defs#labelerPolicies"
                  },
                  labels: {
                    type: "union",
                    refs: ["lex:com.atproto.label.defs#selfLabels"]
                  },
                  createdAt: {
                    type: "string",
                    format: "datetime"
                  }
                }
              }
            }
          }
        },
        AppBskyNotificationGetUnreadCount: {
          lexicon: 1,
          id: "app.bsky.notification.getUnreadCount",
          defs: {
            main: {
              type: "query",
              description: "Count the number of unread notifications for the requesting account. Requires auth.",
              parameters: {
                type: "params",
                properties: {
                  priority: {
                    type: "boolean"
                  },
                  seenAt: {
                    type: "string",
                    format: "datetime"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["count"],
                  properties: {
                    count: {
                      type: "integer"
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyNotificationListNotifications: {
          lexicon: 1,
          id: "app.bsky.notification.listNotifications",
          defs: {
            main: {
              type: "query",
              description: "Enumerate notifications for the requesting account. Requires auth.",
              parameters: {
                type: "params",
                properties: {
                  reasons: {
                    description: "Notification reasons to include in response.",
                    type: "array",
                    items: {
                      type: "string",
                      description: "A reason that matches the reason property of #notification."
                    }
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  priority: {
                    type: "boolean"
                  },
                  cursor: {
                    type: "string"
                  },
                  seenAt: {
                    type: "string",
                    format: "datetime"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["notifications"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    notifications: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.notification.listNotifications#notification"
                      }
                    },
                    priority: {
                      type: "boolean"
                    },
                    seenAt: {
                      type: "string",
                      format: "datetime"
                    }
                  }
                }
              }
            },
            notification: {
              type: "object",
              required: [
                "uri",
                "cid",
                "author",
                "reason",
                "record",
                "isRead",
                "indexedAt"
              ],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                cid: {
                  type: "string",
                  format: "cid"
                },
                author: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#profileView"
                },
                reason: {
                  type: "string",
                  description: "Expected values are 'like', 'repost', 'follow', 'mention', 'reply', 'quote', and 'starterpack-joined'.",
                  knownValues: [
                    "like",
                    "repost",
                    "follow",
                    "mention",
                    "reply",
                    "quote",
                    "starterpack-joined"
                  ]
                },
                reasonSubject: {
                  type: "string",
                  format: "at-uri"
                },
                record: {
                  type: "unknown"
                },
                isRead: {
                  type: "boolean"
                },
                indexedAt: {
                  type: "string",
                  format: "datetime"
                },
                labels: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.label.defs#label"
                  }
                }
              }
            }
          }
        },
        AppBskyNotificationPutPreferences: {
          lexicon: 1,
          id: "app.bsky.notification.putPreferences",
          defs: {
            main: {
              type: "procedure",
              description: "Set notification-related preferences for an account. Requires auth.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["priority"],
                  properties: {
                    priority: {
                      type: "boolean"
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyNotificationRegisterPush: {
          lexicon: 1,
          id: "app.bsky.notification.registerPush",
          defs: {
            main: {
              type: "procedure",
              description: "Register to receive push notifications, via a specified service, for the requesting account. Requires auth.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["serviceDid", "token", "platform", "appId"],
                  properties: {
                    serviceDid: {
                      type: "string",
                      format: "did"
                    },
                    token: {
                      type: "string"
                    },
                    platform: {
                      type: "string",
                      knownValues: ["ios", "android", "web"]
                    },
                    appId: {
                      type: "string"
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyNotificationUpdateSeen: {
          lexicon: 1,
          id: "app.bsky.notification.updateSeen",
          defs: {
            main: {
              type: "procedure",
              description: "Notify server that the requesting account has seen notifications. Requires auth.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["seenAt"],
                  properties: {
                    seenAt: {
                      type: "string",
                      format: "datetime"
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyRichtextFacet: {
          lexicon: 1,
          id: "app.bsky.richtext.facet",
          defs: {
            main: {
              type: "object",
              description: "Annotation of a sub-string within rich text.",
              required: ["index", "features"],
              properties: {
                index: {
                  type: "ref",
                  ref: "lex:app.bsky.richtext.facet#byteSlice"
                },
                features: {
                  type: "array",
                  items: {
                    type: "union",
                    refs: [
                      "lex:app.bsky.richtext.facet#mention",
                      "lex:app.bsky.richtext.facet#link",
                      "lex:app.bsky.richtext.facet#tag"
                    ]
                  }
                }
              }
            },
            mention: {
              type: "object",
              description: "Facet feature for mention of another account. The text is usually a handle, including a '@' prefix, but the facet reference is a DID.",
              required: ["did"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                }
              }
            },
            link: {
              type: "object",
              description: "Facet feature for a URL. The text URL may have been simplified or truncated, but the facet reference should be a complete URL.",
              required: ["uri"],
              properties: {
                uri: {
                  type: "string",
                  format: "uri"
                }
              }
            },
            tag: {
              type: "object",
              description: "Facet feature for a hashtag. The text usually includes a '#' prefix, but the facet reference should not (except in the case of 'double hash tags').",
              required: ["tag"],
              properties: {
                tag: {
                  type: "string",
                  maxLength: 640,
                  maxGraphemes: 64
                }
              }
            },
            byteSlice: {
              type: "object",
              description: "Specifies the sub-string range a facet feature applies to. Start index is inclusive, end index is exclusive. Indices are zero-indexed, counting bytes of the UTF-8 encoded text. NOTE: some languages, like Javascript, use UTF-16 or Unicode codepoints for string slice indexing; in these languages, convert to byte arrays before working with facets.",
              required: ["byteStart", "byteEnd"],
              properties: {
                byteStart: {
                  type: "integer",
                  minimum: 0
                },
                byteEnd: {
                  type: "integer",
                  minimum: 0
                }
              }
            }
          }
        },
        AppBskyUnspeccedDefs: {
          lexicon: 1,
          id: "app.bsky.unspecced.defs",
          defs: {
            skeletonSearchPost: {
              type: "object",
              required: ["uri"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                }
              }
            },
            skeletonSearchActor: {
              type: "object",
              required: ["did"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                }
              }
            },
            skeletonSearchStarterPack: {
              type: "object",
              required: ["uri"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                }
              }
            },
            trendingTopic: {
              type: "object",
              required: ["topic", "link"],
              properties: {
                topic: {
                  type: "string"
                },
                displayName: {
                  type: "string"
                },
                description: {
                  type: "string"
                },
                link: {
                  type: "string"
                }
              }
            }
          }
        },
        AppBskyUnspeccedGetConfig: {
          lexicon: 1,
          id: "app.bsky.unspecced.getConfig",
          defs: {
            main: {
              type: "query",
              description: "Get miscellaneous runtime configuration.",
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: [],
                  properties: {
                    checkEmailConfirmed: {
                      type: "boolean"
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyUnspeccedGetPopularFeedGenerators: {
          lexicon: 1,
          id: "app.bsky.unspecced.getPopularFeedGenerators",
          defs: {
            main: {
              type: "query",
              description: "An unspecced view of globally popular feed generators.",
              parameters: {
                type: "params",
                properties: {
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  },
                  query: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["feeds"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    feeds: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.feed.defs#generatorView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyUnspeccedGetSuggestionsSkeleton: {
          lexicon: 1,
          id: "app.bsky.unspecced.getSuggestionsSkeleton",
          defs: {
            main: {
              type: "query",
              description: "Get a skeleton of suggested actors. Intended to be called and then hydrated through app.bsky.actor.getSuggestions",
              parameters: {
                type: "params",
                properties: {
                  viewer: {
                    type: "string",
                    format: "did",
                    description: "DID of the account making the request (not included for public/unauthenticated queries). Used to boost followed accounts in ranking."
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  },
                  relativeToDid: {
                    type: "string",
                    format: "did",
                    description: "DID of the account to get suggestions relative to. If not provided, suggestions will be based on the viewer."
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["actors"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    actors: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.unspecced.defs#skeletonSearchActor"
                      }
                    },
                    relativeToDid: {
                      type: "string",
                      format: "did",
                      description: "DID of the account these suggestions are relative to. If this is returned undefined, suggestions are based on the viewer."
                    },
                    recId: {
                      type: "integer",
                      description: "Snowflake for this recommendation, use when submitting recommendation events."
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyUnspeccedGetTaggedSuggestions: {
          lexicon: 1,
          id: "app.bsky.unspecced.getTaggedSuggestions",
          defs: {
            main: {
              type: "query",
              description: "Get a list of suggestions (feeds and users) tagged with categories",
              parameters: {
                type: "params",
                properties: {}
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["suggestions"],
                  properties: {
                    suggestions: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.unspecced.getTaggedSuggestions#suggestion"
                      }
                    }
                  }
                }
              }
            },
            suggestion: {
              type: "object",
              required: ["tag", "subjectType", "subject"],
              properties: {
                tag: {
                  type: "string"
                },
                subjectType: {
                  type: "string",
                  knownValues: ["actor", "feed"]
                },
                subject: {
                  type: "string",
                  format: "uri"
                }
              }
            }
          }
        },
        AppBskyUnspeccedGetTrendingTopics: {
          lexicon: 1,
          id: "app.bsky.unspecced.getTrendingTopics",
          defs: {
            main: {
              type: "query",
              description: "Get a list of trending topics",
              parameters: {
                type: "params",
                properties: {
                  viewer: {
                    type: "string",
                    format: "did",
                    description: "DID of the account making the request (not included for public/unauthenticated queries). Used to boost followed accounts in ranking."
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 25,
                    default: 10
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["topics", "suggested"],
                  properties: {
                    topics: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.unspecced.defs#trendingTopic"
                      }
                    },
                    suggested: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.unspecced.defs#trendingTopic"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyUnspeccedSearchActorsSkeleton: {
          lexicon: 1,
          id: "app.bsky.unspecced.searchActorsSkeleton",
          defs: {
            main: {
              type: "query",
              description: "Backend Actors (profile) search, returns only skeleton.",
              parameters: {
                type: "params",
                required: ["q"],
                properties: {
                  q: {
                    type: "string",
                    description: "Search query string; syntax, phrase, boolean, and faceting is unspecified, but Lucene query syntax is recommended. For typeahead search, only simple term match is supported, not full syntax."
                  },
                  viewer: {
                    type: "string",
                    format: "did",
                    description: "DID of the account making the request (not included for public/unauthenticated queries). Used to boost followed accounts in ranking."
                  },
                  typeahead: {
                    type: "boolean",
                    description: "If true, acts as fast/simple 'typeahead' query."
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 25
                  },
                  cursor: {
                    type: "string",
                    description: "Optional pagination mechanism; may not necessarily allow scrolling through entire result set."
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["actors"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    hitsTotal: {
                      type: "integer",
                      description: "Count of search hits. Optional, may be rounded/truncated, and may not be possible to paginate through all hits."
                    },
                    actors: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.unspecced.defs#skeletonSearchActor"
                      }
                    }
                  }
                }
              },
              errors: [
                {
                  name: "BadQueryString"
                }
              ]
            }
          }
        },
        AppBskyUnspeccedSearchPostsSkeleton: {
          lexicon: 1,
          id: "app.bsky.unspecced.searchPostsSkeleton",
          defs: {
            main: {
              type: "query",
              description: "Backend Posts search, returns only skeleton",
              parameters: {
                type: "params",
                required: ["q"],
                properties: {
                  q: {
                    type: "string",
                    description: "Search query string; syntax, phrase, boolean, and faceting is unspecified, but Lucene query syntax is recommended."
                  },
                  sort: {
                    type: "string",
                    knownValues: ["top", "latest"],
                    default: "latest",
                    description: "Specifies the ranking order of results."
                  },
                  since: {
                    type: "string",
                    description: "Filter results for posts after the indicated datetime (inclusive). Expected to use 'sortAt' timestamp, which may not match 'createdAt'. Can be a datetime, or just an ISO date (YYYY-MM-DD)."
                  },
                  until: {
                    type: "string",
                    description: "Filter results for posts before the indicated datetime (not inclusive). Expected to use 'sortAt' timestamp, which may not match 'createdAt'. Can be a datetime, or just an ISO date (YYY-MM-DD)."
                  },
                  mentions: {
                    type: "string",
                    format: "at-identifier",
                    description: "Filter to posts which mention the given account. Handles are resolved to DID before query-time. Only matches rich-text facet mentions."
                  },
                  author: {
                    type: "string",
                    format: "at-identifier",
                    description: "Filter to posts by the given account. Handles are resolved to DID before query-time."
                  },
                  lang: {
                    type: "string",
                    format: "language",
                    description: "Filter to posts in the given language. Expected to be based on post language field, though server may override language detection."
                  },
                  domain: {
                    type: "string",
                    description: "Filter to posts with URLs (facet links or embeds) linking to the given domain (hostname). Server may apply hostname normalization."
                  },
                  url: {
                    type: "string",
                    format: "uri",
                    description: "Filter to posts with links (facet links or embeds) pointing to this URL. Server may apply URL normalization or fuzzy matching."
                  },
                  tag: {
                    type: "array",
                    items: {
                      type: "string",
                      maxLength: 640,
                      maxGraphemes: 64
                    },
                    description: "Filter to posts with the given tag (hashtag), based on rich-text facet or tag field. Do not include the hash (#) prefix. Multiple tags can be specified, with 'AND' matching."
                  },
                  viewer: {
                    type: "string",
                    format: "did",
                    description: "DID of the account making the request (not included for public/unauthenticated queries). Used for 'from:me' queries."
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 25
                  },
                  cursor: {
                    type: "string",
                    description: "Optional pagination mechanism; may not necessarily allow scrolling through entire result set."
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["posts"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    hitsTotal: {
                      type: "integer",
                      description: "Count of search hits. Optional, may be rounded/truncated, and may not be possible to paginate through all hits."
                    },
                    posts: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.unspecced.defs#skeletonSearchPost"
                      }
                    }
                  }
                }
              },
              errors: [
                {
                  name: "BadQueryString"
                }
              ]
            }
          }
        },
        AppBskyUnspeccedSearchStarterPacksSkeleton: {
          lexicon: 1,
          id: "app.bsky.unspecced.searchStarterPacksSkeleton",
          defs: {
            main: {
              type: "query",
              description: "Backend Starter Pack search, returns only skeleton.",
              parameters: {
                type: "params",
                required: ["q"],
                properties: {
                  q: {
                    type: "string",
                    description: "Search query string; syntax, phrase, boolean, and faceting is unspecified, but Lucene query syntax is recommended."
                  },
                  viewer: {
                    type: "string",
                    format: "did",
                    description: "DID of the account making the request (not included for public/unauthenticated queries)."
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 25
                  },
                  cursor: {
                    type: "string",
                    description: "Optional pagination mechanism; may not necessarily allow scrolling through entire result set."
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["starterPacks"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    hitsTotal: {
                      type: "integer",
                      description: "Count of search hits. Optional, may be rounded/truncated, and may not be possible to paginate through all hits."
                    },
                    starterPacks: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.unspecced.defs#skeletonSearchStarterPack"
                      }
                    }
                  }
                }
              },
              errors: [
                {
                  name: "BadQueryString"
                }
              ]
            }
          }
        },
        AppBskyVideoDefs: {
          lexicon: 1,
          id: "app.bsky.video.defs",
          defs: {
            jobStatus: {
              type: "object",
              required: ["jobId", "did", "state"],
              properties: {
                jobId: {
                  type: "string"
                },
                did: {
                  type: "string",
                  format: "did"
                },
                state: {
                  type: "string",
                  description: "The state of the video processing job. All values not listed as a known value indicate that the job is in process.",
                  knownValues: ["JOB_STATE_COMPLETED", "JOB_STATE_FAILED"]
                },
                progress: {
                  type: "integer",
                  minimum: 0,
                  maximum: 100,
                  description: "Progress within the current processing state."
                },
                blob: {
                  type: "blob"
                },
                error: {
                  type: "string"
                },
                message: {
                  type: "string"
                }
              }
            }
          }
        },
        AppBskyVideoGetJobStatus: {
          lexicon: 1,
          id: "app.bsky.video.getJobStatus",
          defs: {
            main: {
              type: "query",
              description: "Get status details for a video processing job.",
              parameters: {
                type: "params",
                required: ["jobId"],
                properties: {
                  jobId: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["jobStatus"],
                  properties: {
                    jobStatus: {
                      type: "ref",
                      ref: "lex:app.bsky.video.defs#jobStatus"
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyVideoGetUploadLimits: {
          lexicon: 1,
          id: "app.bsky.video.getUploadLimits",
          defs: {
            main: {
              type: "query",
              description: "Get video upload limits for the authenticated user.",
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["canUpload"],
                  properties: {
                    canUpload: {
                      type: "boolean"
                    },
                    remainingDailyVideos: {
                      type: "integer"
                    },
                    remainingDailyBytes: {
                      type: "integer"
                    },
                    message: {
                      type: "string"
                    },
                    error: {
                      type: "string"
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyVideoUploadVideo: {
          lexicon: 1,
          id: "app.bsky.video.uploadVideo",
          defs: {
            main: {
              type: "procedure",
              description: "Upload a video to be processed then stored on the PDS.",
              input: {
                encoding: "video/mp4"
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["jobStatus"],
                  properties: {
                    jobStatus: {
                      type: "ref",
                      ref: "lex:app.bsky.video.defs#jobStatus"
                    }
                  }
                }
              }
            }
          }
        },
        ChatBskyActorDeclaration: {
          lexicon: 1,
          id: "chat.bsky.actor.declaration",
          defs: {
            main: {
              type: "record",
              description: "A declaration of a Bluesky chat account.",
              key: "literal:self",
              record: {
                type: "object",
                required: ["allowIncoming"],
                properties: {
                  allowIncoming: {
                    type: "string",
                    knownValues: ["all", "none", "following"]
                  }
                }
              }
            }
          }
        },
        ChatBskyActorDefs: {
          lexicon: 1,
          id: "chat.bsky.actor.defs",
          defs: {
            profileViewBasic: {
              type: "object",
              required: ["did", "handle"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                },
                handle: {
                  type: "string",
                  format: "handle"
                },
                displayName: {
                  type: "string",
                  maxGraphemes: 64,
                  maxLength: 640
                },
                avatar: {
                  type: "string",
                  format: "uri"
                },
                associated: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#profileAssociated"
                },
                viewer: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#viewerState"
                },
                labels: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.label.defs#label"
                  }
                },
                chatDisabled: {
                  type: "boolean",
                  description: "Set to true when the actor cannot actively participate in converations"
                }
              }
            }
          }
        },
        ChatBskyActorDeleteAccount: {
          lexicon: 1,
          id: "chat.bsky.actor.deleteAccount",
          defs: {
            main: {
              type: "procedure",
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  properties: {}
                }
              }
            }
          }
        },
        ChatBskyActorExportAccountData: {
          lexicon: 1,
          id: "chat.bsky.actor.exportAccountData",
          defs: {
            main: {
              type: "query",
              output: {
                encoding: "application/jsonl"
              }
            }
          }
        },
        ChatBskyConvoDefs: {
          lexicon: 1,
          id: "chat.bsky.convo.defs",
          defs: {
            messageRef: {
              type: "object",
              required: ["did", "messageId", "convoId"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                },
                convoId: {
                  type: "string"
                },
                messageId: {
                  type: "string"
                }
              }
            },
            messageInput: {
              type: "object",
              required: ["text"],
              properties: {
                text: {
                  type: "string",
                  maxLength: 1e4,
                  maxGraphemes: 1e3
                },
                facets: {
                  type: "array",
                  description: "Annotations of text (mentions, URLs, hashtags, etc)",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.richtext.facet"
                  }
                },
                embed: {
                  type: "union",
                  refs: ["lex:app.bsky.embed.record"]
                }
              }
            },
            messageView: {
              type: "object",
              required: ["id", "rev", "text", "sender", "sentAt"],
              properties: {
                id: {
                  type: "string"
                },
                rev: {
                  type: "string"
                },
                text: {
                  type: "string",
                  maxLength: 1e4,
                  maxGraphemes: 1e3
                },
                facets: {
                  type: "array",
                  description: "Annotations of text (mentions, URLs, hashtags, etc)",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.richtext.facet"
                  }
                },
                embed: {
                  type: "union",
                  refs: ["lex:app.bsky.embed.record#view"]
                },
                sender: {
                  type: "ref",
                  ref: "lex:chat.bsky.convo.defs#messageViewSender"
                },
                sentAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            },
            deletedMessageView: {
              type: "object",
              required: ["id", "rev", "sender", "sentAt"],
              properties: {
                id: {
                  type: "string"
                },
                rev: {
                  type: "string"
                },
                sender: {
                  type: "ref",
                  ref: "lex:chat.bsky.convo.defs#messageViewSender"
                },
                sentAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            },
            messageViewSender: {
              type: "object",
              required: ["did"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                }
              }
            },
            convoView: {
              type: "object",
              required: ["id", "rev", "members", "muted", "unreadCount"],
              properties: {
                id: {
                  type: "string"
                },
                rev: {
                  type: "string"
                },
                members: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:chat.bsky.actor.defs#profileViewBasic"
                  }
                },
                lastMessage: {
                  type: "union",
                  refs: [
                    "lex:chat.bsky.convo.defs#messageView",
                    "lex:chat.bsky.convo.defs#deletedMessageView"
                  ]
                },
                muted: {
                  type: "boolean"
                },
                opened: {
                  type: "boolean"
                },
                unreadCount: {
                  type: "integer"
                }
              }
            },
            logBeginConvo: {
              type: "object",
              required: ["rev", "convoId"],
              properties: {
                rev: {
                  type: "string"
                },
                convoId: {
                  type: "string"
                }
              }
            },
            logLeaveConvo: {
              type: "object",
              required: ["rev", "convoId"],
              properties: {
                rev: {
                  type: "string"
                },
                convoId: {
                  type: "string"
                }
              }
            },
            logCreateMessage: {
              type: "object",
              required: ["rev", "convoId", "message"],
              properties: {
                rev: {
                  type: "string"
                },
                convoId: {
                  type: "string"
                },
                message: {
                  type: "union",
                  refs: [
                    "lex:chat.bsky.convo.defs#messageView",
                    "lex:chat.bsky.convo.defs#deletedMessageView"
                  ]
                }
              }
            },
            logDeleteMessage: {
              type: "object",
              required: ["rev", "convoId", "message"],
              properties: {
                rev: {
                  type: "string"
                },
                convoId: {
                  type: "string"
                },
                message: {
                  type: "union",
                  refs: [
                    "lex:chat.bsky.convo.defs#messageView",
                    "lex:chat.bsky.convo.defs#deletedMessageView"
                  ]
                }
              }
            }
          }
        },
        ChatBskyConvoDeleteMessageForSelf: {
          lexicon: 1,
          id: "chat.bsky.convo.deleteMessageForSelf",
          defs: {
            main: {
              type: "procedure",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["convoId", "messageId"],
                  properties: {
                    convoId: {
                      type: "string"
                    },
                    messageId: {
                      type: "string"
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "ref",
                  ref: "lex:chat.bsky.convo.defs#deletedMessageView"
                }
              }
            }
          }
        },
        ChatBskyConvoGetConvo: {
          lexicon: 1,
          id: "chat.bsky.convo.getConvo",
          defs: {
            main: {
              type: "query",
              parameters: {
                type: "params",
                required: ["convoId"],
                properties: {
                  convoId: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["convo"],
                  properties: {
                    convo: {
                      type: "ref",
                      ref: "lex:chat.bsky.convo.defs#convoView"
                    }
                  }
                }
              }
            }
          }
        },
        ChatBskyConvoGetConvoForMembers: {
          lexicon: 1,
          id: "chat.bsky.convo.getConvoForMembers",
          defs: {
            main: {
              type: "query",
              parameters: {
                type: "params",
                required: ["members"],
                properties: {
                  members: {
                    type: "array",
                    minLength: 1,
                    maxLength: 10,
                    items: {
                      type: "string",
                      format: "did"
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["convo"],
                  properties: {
                    convo: {
                      type: "ref",
                      ref: "lex:chat.bsky.convo.defs#convoView"
                    }
                  }
                }
              }
            }
          }
        },
        ChatBskyConvoGetLog: {
          lexicon: 1,
          id: "chat.bsky.convo.getLog",
          defs: {
            main: {
              type: "query",
              parameters: {
                type: "params",
                required: [],
                properties: {
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["logs"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    logs: {
                      type: "array",
                      items: {
                        type: "union",
                        refs: [
                          "lex:chat.bsky.convo.defs#logBeginConvo",
                          "lex:chat.bsky.convo.defs#logLeaveConvo",
                          "lex:chat.bsky.convo.defs#logCreateMessage",
                          "lex:chat.bsky.convo.defs#logDeleteMessage"
                        ]
                      }
                    }
                  }
                }
              }
            }
          }
        },
        ChatBskyConvoGetMessages: {
          lexicon: 1,
          id: "chat.bsky.convo.getMessages",
          defs: {
            main: {
              type: "query",
              parameters: {
                type: "params",
                required: ["convoId"],
                properties: {
                  convoId: {
                    type: "string"
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["messages"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    messages: {
                      type: "array",
                      items: {
                        type: "union",
                        refs: [
                          "lex:chat.bsky.convo.defs#messageView",
                          "lex:chat.bsky.convo.defs#deletedMessageView"
                        ]
                      }
                    }
                  }
                }
              }
            }
          }
        },
        ChatBskyConvoLeaveConvo: {
          lexicon: 1,
          id: "chat.bsky.convo.leaveConvo",
          defs: {
            main: {
              type: "procedure",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["convoId"],
                  properties: {
                    convoId: {
                      type: "string"
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["convoId", "rev"],
                  properties: {
                    convoId: {
                      type: "string"
                    },
                    rev: {
                      type: "string"
                    }
                  }
                }
              }
            }
          }
        },
        ChatBskyConvoListConvos: {
          lexicon: 1,
          id: "chat.bsky.convo.listConvos",
          defs: {
            main: {
              type: "query",
              parameters: {
                type: "params",
                properties: {
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["convos"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    convos: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:chat.bsky.convo.defs#convoView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        ChatBskyConvoMuteConvo: {
          lexicon: 1,
          id: "chat.bsky.convo.muteConvo",
          defs: {
            main: {
              type: "procedure",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["convoId"],
                  properties: {
                    convoId: {
                      type: "string"
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["convo"],
                  properties: {
                    convo: {
                      type: "ref",
                      ref: "lex:chat.bsky.convo.defs#convoView"
                    }
                  }
                }
              }
            }
          }
        },
        ChatBskyConvoSendMessage: {
          lexicon: 1,
          id: "chat.bsky.convo.sendMessage",
          defs: {
            main: {
              type: "procedure",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["convoId", "message"],
                  properties: {
                    convoId: {
                      type: "string"
                    },
                    message: {
                      type: "ref",
                      ref: "lex:chat.bsky.convo.defs#messageInput"
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "ref",
                  ref: "lex:chat.bsky.convo.defs#messageView"
                }
              }
            }
          }
        },
        ChatBskyConvoSendMessageBatch: {
          lexicon: 1,
          id: "chat.bsky.convo.sendMessageBatch",
          defs: {
            main: {
              type: "procedure",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["items"],
                  properties: {
                    items: {
                      type: "array",
                      maxLength: 100,
                      items: {
                        type: "ref",
                        ref: "lex:chat.bsky.convo.sendMessageBatch#batchItem"
                      }
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["items"],
                  properties: {
                    items: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:chat.bsky.convo.defs#messageView"
                      }
                    }
                  }
                }
              }
            },
            batchItem: {
              type: "object",
              required: ["convoId", "message"],
              properties: {
                convoId: {
                  type: "string"
                },
                message: {
                  type: "ref",
                  ref: "lex:chat.bsky.convo.defs#messageInput"
                }
              }
            }
          }
        },
        ChatBskyConvoUnmuteConvo: {
          lexicon: 1,
          id: "chat.bsky.convo.unmuteConvo",
          defs: {
            main: {
              type: "procedure",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["convoId"],
                  properties: {
                    convoId: {
                      type: "string"
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["convo"],
                  properties: {
                    convo: {
                      type: "ref",
                      ref: "lex:chat.bsky.convo.defs#convoView"
                    }
                  }
                }
              }
            }
          }
        },
        ChatBskyConvoUpdateRead: {
          lexicon: 1,
          id: "chat.bsky.convo.updateRead",
          defs: {
            main: {
              type: "procedure",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["convoId"],
                  properties: {
                    convoId: {
                      type: "string"
                    },
                    messageId: {
                      type: "string"
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["convo"],
                  properties: {
                    convo: {
                      type: "ref",
                      ref: "lex:chat.bsky.convo.defs#convoView"
                    }
                  }
                }
              }
            }
          }
        },
        ChatBskyModerationGetActorMetadata: {
          lexicon: 1,
          id: "chat.bsky.moderation.getActorMetadata",
          defs: {
            main: {
              type: "query",
              parameters: {
                type: "params",
                required: ["actor"],
                properties: {
                  actor: {
                    type: "string",
                    format: "did"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["day", "month", "all"],
                  properties: {
                    day: {
                      type: "ref",
                      ref: "lex:chat.bsky.moderation.getActorMetadata#metadata"
                    },
                    month: {
                      type: "ref",
                      ref: "lex:chat.bsky.moderation.getActorMetadata#metadata"
                    },
                    all: {
                      type: "ref",
                      ref: "lex:chat.bsky.moderation.getActorMetadata#metadata"
                    }
                  }
                }
              }
            },
            metadata: {
              type: "object",
              required: [
                "messagesSent",
                "messagesReceived",
                "convos",
                "convosStarted"
              ],
              properties: {
                messagesSent: {
                  type: "integer"
                },
                messagesReceived: {
                  type: "integer"
                },
                convos: {
                  type: "integer"
                },
                convosStarted: {
                  type: "integer"
                }
              }
            }
          }
        },
        ChatBskyModerationGetMessageContext: {
          lexicon: 1,
          id: "chat.bsky.moderation.getMessageContext",
          defs: {
            main: {
              type: "query",
              parameters: {
                type: "params",
                required: ["messageId"],
                properties: {
                  convoId: {
                    type: "string",
                    description: "Conversation that the message is from. NOTE: this field will eventually be required."
                  },
                  messageId: {
                    type: "string"
                  },
                  before: {
                    type: "integer",
                    default: 5
                  },
                  after: {
                    type: "integer",
                    default: 5
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["messages"],
                  properties: {
                    messages: {
                      type: "array",
                      items: {
                        type: "union",
                        refs: [
                          "lex:chat.bsky.convo.defs#messageView",
                          "lex:chat.bsky.convo.defs#deletedMessageView"
                        ]
                      }
                    }
                  }
                }
              }
            }
          }
        },
        ChatBskyModerationUpdateActorAccess: {
          lexicon: 1,
          id: "chat.bsky.moderation.updateActorAccess",
          defs: {
            main: {
              type: "procedure",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["actor", "allowAccess"],
                  properties: {
                    actor: {
                      type: "string",
                      format: "did"
                    },
                    allowAccess: {
                      type: "boolean"
                    },
                    ref: {
                      type: "string"
                    }
                  }
                }
              }
            }
          }
        },
        ToolsOzoneCommunicationCreateTemplate: {
          lexicon: 1,
          id: "tools.ozone.communication.createTemplate",
          defs: {
            main: {
              type: "procedure",
              description: "Administrative action to create a new, re-usable communication (email for now) template.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["subject", "contentMarkdown", "name"],
                  properties: {
                    name: {
                      type: "string",
                      description: "Name of the template."
                    },
                    contentMarkdown: {
                      type: "string",
                      description: "Content of the template, markdown supported, can contain variable placeholders."
                    },
                    subject: {
                      type: "string",
                      description: "Subject of the message, used in emails."
                    },
                    lang: {
                      type: "string",
                      format: "language",
                      description: "Message language."
                    },
                    createdBy: {
                      type: "string",
                      format: "did",
                      description: "DID of the user who is creating the template."
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "ref",
                  ref: "lex:tools.ozone.communication.defs#templateView"
                }
              },
              errors: [
                {
                  name: "DuplicateTemplateName"
                }
              ]
            }
          }
        },
        ToolsOzoneCommunicationDefs: {
          lexicon: 1,
          id: "tools.ozone.communication.defs",
          defs: {
            templateView: {
              type: "object",
              required: [
                "id",
                "name",
                "contentMarkdown",
                "disabled",
                "lastUpdatedBy",
                "createdAt",
                "updatedAt"
              ],
              properties: {
                id: {
                  type: "string"
                },
                name: {
                  type: "string",
                  description: "Name of the template."
                },
                subject: {
                  type: "string",
                  description: "Content of the template, can contain markdown and variable placeholders."
                },
                contentMarkdown: {
                  type: "string",
                  description: "Subject of the message, used in emails."
                },
                disabled: {
                  type: "boolean"
                },
                lang: {
                  type: "string",
                  format: "language",
                  description: "Message language."
                },
                lastUpdatedBy: {
                  type: "string",
                  format: "did",
                  description: "DID of the user who last updated the template."
                },
                createdAt: {
                  type: "string",
                  format: "datetime"
                },
                updatedAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            }
          }
        },
        ToolsOzoneCommunicationDeleteTemplate: {
          lexicon: 1,
          id: "tools.ozone.communication.deleteTemplate",
          defs: {
            main: {
              type: "procedure",
              description: "Delete a communication template.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["id"],
                  properties: {
                    id: {
                      type: "string"
                    }
                  }
                }
              }
            }
          }
        },
        ToolsOzoneCommunicationListTemplates: {
          lexicon: 1,
          id: "tools.ozone.communication.listTemplates",
          defs: {
            main: {
              type: "query",
              description: "Get list of all communication templates.",
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["communicationTemplates"],
                  properties: {
                    communicationTemplates: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:tools.ozone.communication.defs#templateView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        ToolsOzoneCommunicationUpdateTemplate: {
          lexicon: 1,
          id: "tools.ozone.communication.updateTemplate",
          defs: {
            main: {
              type: "procedure",
              description: "Administrative action to update an existing communication template. Allows passing partial fields to patch specific fields only.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["id"],
                  properties: {
                    id: {
                      type: "string",
                      description: "ID of the template to be updated."
                    },
                    name: {
                      type: "string",
                      description: "Name of the template."
                    },
                    lang: {
                      type: "string",
                      format: "language",
                      description: "Message language."
                    },
                    contentMarkdown: {
                      type: "string",
                      description: "Content of the template, markdown supported, can contain variable placeholders."
                    },
                    subject: {
                      type: "string",
                      description: "Subject of the message, used in emails."
                    },
                    updatedBy: {
                      type: "string",
                      format: "did",
                      description: "DID of the user who is updating the template."
                    },
                    disabled: {
                      type: "boolean"
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "ref",
                  ref: "lex:tools.ozone.communication.defs#templateView"
                }
              },
              errors: [
                {
                  name: "DuplicateTemplateName"
                }
              ]
            }
          }
        },
        ToolsOzoneModerationDefs: {
          lexicon: 1,
          id: "tools.ozone.moderation.defs",
          defs: {
            modEventView: {
              type: "object",
              required: [
                "id",
                "event",
                "subject",
                "subjectBlobCids",
                "createdBy",
                "createdAt"
              ],
              properties: {
                id: {
                  type: "integer"
                },
                event: {
                  type: "union",
                  refs: [
                    "lex:tools.ozone.moderation.defs#modEventTakedown",
                    "lex:tools.ozone.moderation.defs#modEventReverseTakedown",
                    "lex:tools.ozone.moderation.defs#modEventComment",
                    "lex:tools.ozone.moderation.defs#modEventReport",
                    "lex:tools.ozone.moderation.defs#modEventLabel",
                    "lex:tools.ozone.moderation.defs#modEventAcknowledge",
                    "lex:tools.ozone.moderation.defs#modEventEscalate",
                    "lex:tools.ozone.moderation.defs#modEventMute",
                    "lex:tools.ozone.moderation.defs#modEventUnmute",
                    "lex:tools.ozone.moderation.defs#modEventMuteReporter",
                    "lex:tools.ozone.moderation.defs#modEventUnmuteReporter",
                    "lex:tools.ozone.moderation.defs#modEventEmail",
                    "lex:tools.ozone.moderation.defs#modEventResolveAppeal",
                    "lex:tools.ozone.moderation.defs#modEventDivert",
                    "lex:tools.ozone.moderation.defs#modEventTag",
                    "lex:tools.ozone.moderation.defs#accountEvent",
                    "lex:tools.ozone.moderation.defs#identityEvent",
                    "lex:tools.ozone.moderation.defs#recordEvent",
                    "lex:tools.ozone.moderation.defs#modEventPriorityScore"
                  ]
                },
                subject: {
                  type: "union",
                  refs: [
                    "lex:com.atproto.admin.defs#repoRef",
                    "lex:com.atproto.repo.strongRef",
                    "lex:chat.bsky.convo.defs#messageRef"
                  ]
                },
                subjectBlobCids: {
                  type: "array",
                  items: {
                    type: "string"
                  }
                },
                createdBy: {
                  type: "string",
                  format: "did"
                },
                createdAt: {
                  type: "string",
                  format: "datetime"
                },
                creatorHandle: {
                  type: "string"
                },
                subjectHandle: {
                  type: "string"
                }
              }
            },
            modEventViewDetail: {
              type: "object",
              required: [
                "id",
                "event",
                "subject",
                "subjectBlobs",
                "createdBy",
                "createdAt"
              ],
              properties: {
                id: {
                  type: "integer"
                },
                event: {
                  type: "union",
                  refs: [
                    "lex:tools.ozone.moderation.defs#modEventTakedown",
                    "lex:tools.ozone.moderation.defs#modEventReverseTakedown",
                    "lex:tools.ozone.moderation.defs#modEventComment",
                    "lex:tools.ozone.moderation.defs#modEventReport",
                    "lex:tools.ozone.moderation.defs#modEventLabel",
                    "lex:tools.ozone.moderation.defs#modEventAcknowledge",
                    "lex:tools.ozone.moderation.defs#modEventEscalate",
                    "lex:tools.ozone.moderation.defs#modEventMute",
                    "lex:tools.ozone.moderation.defs#modEventUnmute",
                    "lex:tools.ozone.moderation.defs#modEventMuteReporter",
                    "lex:tools.ozone.moderation.defs#modEventUnmuteReporter",
                    "lex:tools.ozone.moderation.defs#modEventEmail",
                    "lex:tools.ozone.moderation.defs#modEventResolveAppeal",
                    "lex:tools.ozone.moderation.defs#modEventDivert",
                    "lex:tools.ozone.moderation.defs#modEventTag",
                    "lex:tools.ozone.moderation.defs#accountEvent",
                    "lex:tools.ozone.moderation.defs#identityEvent",
                    "lex:tools.ozone.moderation.defs#recordEvent",
                    "lex:tools.ozone.moderation.defs#modEventPriorityScore"
                  ]
                },
                subject: {
                  type: "union",
                  refs: [
                    "lex:tools.ozone.moderation.defs#repoView",
                    "lex:tools.ozone.moderation.defs#repoViewNotFound",
                    "lex:tools.ozone.moderation.defs#recordView",
                    "lex:tools.ozone.moderation.defs#recordViewNotFound"
                  ]
                },
                subjectBlobs: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:tools.ozone.moderation.defs#blobView"
                  }
                },
                createdBy: {
                  type: "string",
                  format: "did"
                },
                createdAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            },
            subjectStatusView: {
              type: "object",
              required: ["id", "subject", "createdAt", "updatedAt", "reviewState"],
              properties: {
                id: {
                  type: "integer"
                },
                subject: {
                  type: "union",
                  refs: [
                    "lex:com.atproto.admin.defs#repoRef",
                    "lex:com.atproto.repo.strongRef"
                  ]
                },
                hosting: {
                  type: "union",
                  refs: [
                    "lex:tools.ozone.moderation.defs#accountHosting",
                    "lex:tools.ozone.moderation.defs#recordHosting"
                  ]
                },
                subjectBlobCids: {
                  type: "array",
                  items: {
                    type: "string",
                    format: "cid"
                  }
                },
                subjectRepoHandle: {
                  type: "string"
                },
                updatedAt: {
                  type: "string",
                  format: "datetime",
                  description: "Timestamp referencing when the last update was made to the moderation status of the subject"
                },
                createdAt: {
                  type: "string",
                  format: "datetime",
                  description: "Timestamp referencing the first moderation status impacting event was emitted on the subject"
                },
                reviewState: {
                  type: "ref",
                  ref: "lex:tools.ozone.moderation.defs#subjectReviewState"
                },
                comment: {
                  type: "string",
                  description: "Sticky comment on the subject."
                },
                priorityScore: {
                  type: "integer",
                  description: "Numeric value representing the level of priority. Higher score means higher priority.",
                  minimum: 0,
                  maximum: 100
                },
                muteUntil: {
                  type: "string",
                  format: "datetime"
                },
                muteReportingUntil: {
                  type: "string",
                  format: "datetime"
                },
                lastReviewedBy: {
                  type: "string",
                  format: "did"
                },
                lastReviewedAt: {
                  type: "string",
                  format: "datetime"
                },
                lastReportedAt: {
                  type: "string",
                  format: "datetime"
                },
                lastAppealedAt: {
                  type: "string",
                  format: "datetime",
                  description: "Timestamp referencing when the author of the subject appealed a moderation action"
                },
                takendown: {
                  type: "boolean"
                },
                appealed: {
                  type: "boolean",
                  description: "True indicates that the a previously taken moderator action was appealed against, by the author of the content. False indicates last appeal was resolved by moderators."
                },
                suspendUntil: {
                  type: "string",
                  format: "datetime"
                },
                tags: {
                  type: "array",
                  items: {
                    type: "string"
                  }
                },
                accountStats: {
                  description: "Statistics related to the account subject",
                  type: "ref",
                  ref: "lex:tools.ozone.moderation.defs#accountStats"
                },
                recordsStats: {
                  description: "Statistics related to the record subjects authored by the subject's account",
                  type: "ref",
                  ref: "lex:tools.ozone.moderation.defs#recordsStats"
                }
              }
            },
            accountStats: {
              description: "Statistics about a particular account subject",
              type: "object",
              properties: {
                reportCount: {
                  description: "Total number of reports on the account",
                  type: "integer"
                },
                appealCount: {
                  description: "Total number of appeals against a moderation action on the account",
                  type: "integer"
                },
                suspendCount: {
                  description: "Number of times the account was suspended",
                  type: "integer"
                },
                escalateCount: {
                  description: "Number of times the account was escalated",
                  type: "integer"
                },
                takedownCount: {
                  description: "Number of times the account was taken down",
                  type: "integer"
                }
              }
            },
            recordsStats: {
              description: "Statistics about a set of record subject items",
              type: "object",
              properties: {
                totalReports: {
                  description: "Cumulative sum of the number of reports on the items in the set",
                  type: "integer"
                },
                reportedCount: {
                  description: "Number of items that were reported at least once",
                  type: "integer"
                },
                escalatedCount: {
                  description: "Number of items that were escalated at least once",
                  type: "integer"
                },
                appealedCount: {
                  description: "Number of items that were appealed at least once",
                  type: "integer"
                },
                subjectCount: {
                  description: "Total number of item in the set",
                  type: "integer"
                },
                pendingCount: {
                  description: 'Number of item currently in "reviewOpen" or "reviewEscalated" state',
                  type: "integer"
                },
                processedCount: {
                  description: 'Number of item currently in "reviewNone" or "reviewClosed" state',
                  type: "integer"
                },
                takendownCount: {
                  description: "Number of item currently taken down",
                  type: "integer"
                }
              }
            },
            subjectReviewState: {
              type: "string",
              knownValues: [
                "lex:tools.ozone.moderation.defs#reviewOpen",
                "lex:tools.ozone.moderation.defs#reviewEscalated",
                "lex:tools.ozone.moderation.defs#reviewClosed",
                "lex:tools.ozone.moderation.defs#reviewNone"
              ]
            },
            reviewOpen: {
              type: "token",
              description: "Moderator review status of a subject: Open. Indicates that the subject needs to be reviewed by a moderator"
            },
            reviewEscalated: {
              type: "token",
              description: "Moderator review status of a subject: Escalated. Indicates that the subject was escalated for review by a moderator"
            },
            reviewClosed: {
              type: "token",
              description: "Moderator review status of a subject: Closed. Indicates that the subject was already reviewed and resolved by a moderator"
            },
            reviewNone: {
              type: "token",
              description: "Moderator review status of a subject: Unnecessary. Indicates that the subject does not need a review at the moment but there is probably some moderation related metadata available for it"
            },
            modEventTakedown: {
              type: "object",
              description: "Take down a subject permanently or temporarily",
              properties: {
                comment: {
                  type: "string"
                },
                durationInHours: {
                  type: "integer",
                  description: "Indicates how long the takedown should be in effect before automatically expiring."
                },
                acknowledgeAccountSubjects: {
                  type: "boolean",
                  description: "If true, all other reports on content authored by this account will be resolved (acknowledged)."
                },
                policies: {
                  type: "array",
                  maxLength: 5,
                  items: {
                    type: "string"
                  },
                  description: "Names/Keywords of the policies that drove the decision."
                }
              }
            },
            modEventReverseTakedown: {
              type: "object",
              description: "Revert take down action on a subject",
              properties: {
                comment: {
                  type: "string",
                  description: "Describe reasoning behind the reversal."
                }
              }
            },
            modEventResolveAppeal: {
              type: "object",
              description: "Resolve appeal on a subject",
              properties: {
                comment: {
                  type: "string",
                  description: "Describe resolution."
                }
              }
            },
            modEventComment: {
              type: "object",
              description: "Add a comment to a subject",
              required: ["comment"],
              properties: {
                comment: {
                  type: "string"
                },
                sticky: {
                  type: "boolean",
                  description: "Make the comment persistent on the subject"
                }
              }
            },
            modEventReport: {
              type: "object",
              description: "Report a subject",
              required: ["reportType"],
              properties: {
                comment: {
                  type: "string"
                },
                isReporterMuted: {
                  type: "boolean",
                  description: "Set to true if the reporter was muted from reporting at the time of the event. These reports won't impact the reviewState of the subject."
                },
                reportType: {
                  type: "ref",
                  ref: "lex:com.atproto.moderation.defs#reasonType"
                }
              }
            },
            modEventLabel: {
              type: "object",
              description: "Apply/Negate labels on a subject",
              required: ["createLabelVals", "negateLabelVals"],
              properties: {
                comment: {
                  type: "string"
                },
                createLabelVals: {
                  type: "array",
                  items: {
                    type: "string"
                  }
                },
                negateLabelVals: {
                  type: "array",
                  items: {
                    type: "string"
                  }
                },
                durationInHours: {
                  type: "integer",
                  description: "Indicates how long the label will remain on the subject. Only applies on labels that are being added."
                }
              }
            },
            modEventPriorityScore: {
              type: "object",
              description: "Set priority score of the subject. Higher score means higher priority.",
              required: ["score"],
              properties: {
                comment: {
                  type: "string"
                },
                score: {
                  type: "integer",
                  minimum: 0,
                  maximum: 100
                }
              }
            },
            modEventAcknowledge: {
              type: "object",
              properties: {
                comment: {
                  type: "string"
                },
                acknowledgeAccountSubjects: {
                  type: "boolean",
                  description: "If true, all other reports on content authored by this account will be resolved (acknowledged)."
                }
              }
            },
            modEventEscalate: {
              type: "object",
              properties: {
                comment: {
                  type: "string"
                }
              }
            },
            modEventMute: {
              type: "object",
              description: "Mute incoming reports on a subject",
              required: ["durationInHours"],
              properties: {
                comment: {
                  type: "string"
                },
                durationInHours: {
                  type: "integer",
                  description: "Indicates how long the subject should remain muted."
                }
              }
            },
            modEventUnmute: {
              type: "object",
              description: "Unmute action on a subject",
              properties: {
                comment: {
                  type: "string",
                  description: "Describe reasoning behind the reversal."
                }
              }
            },
            modEventMuteReporter: {
              type: "object",
              description: "Mute incoming reports from an account",
              properties: {
                comment: {
                  type: "string"
                },
                durationInHours: {
                  type: "integer",
                  description: "Indicates how long the account should remain muted. Falsy value here means a permanent mute."
                }
              }
            },
            modEventUnmuteReporter: {
              type: "object",
              description: "Unmute incoming reports from an account",
              properties: {
                comment: {
                  type: "string",
                  description: "Describe reasoning behind the reversal."
                }
              }
            },
            modEventEmail: {
              type: "object",
              description: "Keep a log of outgoing email to a user",
              required: ["subjectLine"],
              properties: {
                subjectLine: {
                  type: "string",
                  description: "The subject line of the email sent to the user."
                },
                content: {
                  type: "string",
                  description: "The content of the email sent to the user."
                },
                comment: {
                  type: "string",
                  description: "Additional comment about the outgoing comm."
                }
              }
            },
            modEventDivert: {
              type: "object",
              description: "Divert a record's blobs to a 3rd party service for further scanning/tagging",
              properties: {
                comment: {
                  type: "string"
                }
              }
            },
            modEventTag: {
              type: "object",
              description: "Add/Remove a tag on a subject",
              required: ["add", "remove"],
              properties: {
                add: {
                  type: "array",
                  items: {
                    type: "string"
                  },
                  description: "Tags to be added to the subject. If already exists, won't be duplicated."
                },
                remove: {
                  type: "array",
                  items: {
                    type: "string"
                  },
                  description: "Tags to be removed to the subject. Ignores a tag If it doesn't exist, won't be duplicated."
                },
                comment: {
                  type: "string",
                  description: "Additional comment about added/removed tags."
                }
              }
            },
            accountEvent: {
              type: "object",
              description: "Logs account status related events on a repo subject. Normally captured by automod from the firehose and emitted to ozone for historical tracking.",
              required: ["timestamp", "active"],
              properties: {
                comment: {
                  type: "string"
                },
                active: {
                  type: "boolean",
                  description: "Indicates that the account has a repository which can be fetched from the host that emitted this event."
                },
                status: {
                  type: "string",
                  knownValues: [
                    "unknown",
                    "deactivated",
                    "deleted",
                    "takendown",
                    "suspended",
                    "tombstoned"
                  ]
                },
                timestamp: {
                  type: "string",
                  format: "datetime"
                }
              }
            },
            identityEvent: {
              type: "object",
              description: "Logs identity related events on a repo subject. Normally captured by automod from the firehose and emitted to ozone for historical tracking.",
              required: ["timestamp"],
              properties: {
                comment: {
                  type: "string"
                },
                handle: {
                  type: "string",
                  format: "handle"
                },
                pdsHost: {
                  type: "string",
                  format: "uri"
                },
                tombstone: {
                  type: "boolean"
                },
                timestamp: {
                  type: "string",
                  format: "datetime"
                }
              }
            },
            recordEvent: {
              type: "object",
              description: "Logs lifecycle event on a record subject. Normally captured by automod from the firehose and emitted to ozone for historical tracking.",
              required: ["timestamp", "op"],
              properties: {
                comment: {
                  type: "string"
                },
                op: {
                  type: "string",
                  knownValues: ["create", "update", "delete"]
                },
                cid: {
                  type: "string",
                  format: "cid"
                },
                timestamp: {
                  type: "string",
                  format: "datetime"
                }
              }
            },
            repoView: {
              type: "object",
              required: [
                "did",
                "handle",
                "relatedRecords",
                "indexedAt",
                "moderation"
              ],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                },
                handle: {
                  type: "string",
                  format: "handle"
                },
                email: {
                  type: "string"
                },
                relatedRecords: {
                  type: "array",
                  items: {
                    type: "unknown"
                  }
                },
                indexedAt: {
                  type: "string",
                  format: "datetime"
                },
                moderation: {
                  type: "ref",
                  ref: "lex:tools.ozone.moderation.defs#moderation"
                },
                invitedBy: {
                  type: "ref",
                  ref: "lex:com.atproto.server.defs#inviteCode"
                },
                invitesDisabled: {
                  type: "boolean"
                },
                inviteNote: {
                  type: "string"
                },
                deactivatedAt: {
                  type: "string",
                  format: "datetime"
                },
                threatSignatures: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.admin.defs#threatSignature"
                  }
                }
              }
            },
            repoViewDetail: {
              type: "object",
              required: [
                "did",
                "handle",
                "relatedRecords",
                "indexedAt",
                "moderation"
              ],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                },
                handle: {
                  type: "string",
                  format: "handle"
                },
                email: {
                  type: "string"
                },
                relatedRecords: {
                  type: "array",
                  items: {
                    type: "unknown"
                  }
                },
                indexedAt: {
                  type: "string",
                  format: "datetime"
                },
                moderation: {
                  type: "ref",
                  ref: "lex:tools.ozone.moderation.defs#moderationDetail"
                },
                labels: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.label.defs#label"
                  }
                },
                invitedBy: {
                  type: "ref",
                  ref: "lex:com.atproto.server.defs#inviteCode"
                },
                invites: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.server.defs#inviteCode"
                  }
                },
                invitesDisabled: {
                  type: "boolean"
                },
                inviteNote: {
                  type: "string"
                },
                emailConfirmedAt: {
                  type: "string",
                  format: "datetime"
                },
                deactivatedAt: {
                  type: "string",
                  format: "datetime"
                },
                threatSignatures: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.admin.defs#threatSignature"
                  }
                }
              }
            },
            repoViewNotFound: {
              type: "object",
              required: ["did"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                }
              }
            },
            recordView: {
              type: "object",
              required: [
                "uri",
                "cid",
                "value",
                "blobCids",
                "indexedAt",
                "moderation",
                "repo"
              ],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                cid: {
                  type: "string",
                  format: "cid"
                },
                value: {
                  type: "unknown"
                },
                blobCids: {
                  type: "array",
                  items: {
                    type: "string",
                    format: "cid"
                  }
                },
                indexedAt: {
                  type: "string",
                  format: "datetime"
                },
                moderation: {
                  type: "ref",
                  ref: "lex:tools.ozone.moderation.defs#moderation"
                },
                repo: {
                  type: "ref",
                  ref: "lex:tools.ozone.moderation.defs#repoView"
                }
              }
            },
            recordViewDetail: {
              type: "object",
              required: [
                "uri",
                "cid",
                "value",
                "blobs",
                "indexedAt",
                "moderation",
                "repo"
              ],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                cid: {
                  type: "string",
                  format: "cid"
                },
                value: {
                  type: "unknown"
                },
                blobs: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:tools.ozone.moderation.defs#blobView"
                  }
                },
                labels: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.label.defs#label"
                  }
                },
                indexedAt: {
                  type: "string",
                  format: "datetime"
                },
                moderation: {
                  type: "ref",
                  ref: "lex:tools.ozone.moderation.defs#moderationDetail"
                },
                repo: {
                  type: "ref",
                  ref: "lex:tools.ozone.moderation.defs#repoView"
                }
              }
            },
            recordViewNotFound: {
              type: "object",
              required: ["uri"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                }
              }
            },
            moderation: {
              type: "object",
              properties: {
                subjectStatus: {
                  type: "ref",
                  ref: "lex:tools.ozone.moderation.defs#subjectStatusView"
                }
              }
            },
            moderationDetail: {
              type: "object",
              properties: {
                subjectStatus: {
                  type: "ref",
                  ref: "lex:tools.ozone.moderation.defs#subjectStatusView"
                }
              }
            },
            blobView: {
              type: "object",
              required: ["cid", "mimeType", "size", "createdAt"],
              properties: {
                cid: {
                  type: "string",
                  format: "cid"
                },
                mimeType: {
                  type: "string"
                },
                size: {
                  type: "integer"
                },
                createdAt: {
                  type: "string",
                  format: "datetime"
                },
                details: {
                  type: "union",
                  refs: [
                    "lex:tools.ozone.moderation.defs#imageDetails",
                    "lex:tools.ozone.moderation.defs#videoDetails"
                  ]
                },
                moderation: {
                  type: "ref",
                  ref: "lex:tools.ozone.moderation.defs#moderation"
                }
              }
            },
            imageDetails: {
              type: "object",
              required: ["width", "height"],
              properties: {
                width: {
                  type: "integer"
                },
                height: {
                  type: "integer"
                }
              }
            },
            videoDetails: {
              type: "object",
              required: ["width", "height", "length"],
              properties: {
                width: {
                  type: "integer"
                },
                height: {
                  type: "integer"
                },
                length: {
                  type: "integer"
                }
              }
            },
            accountHosting: {
              type: "object",
              required: ["status"],
              properties: {
                status: {
                  type: "string",
                  knownValues: [
                    "takendown",
                    "suspended",
                    "deleted",
                    "deactivated",
                    "unknown"
                  ]
                },
                updatedAt: {
                  type: "string",
                  format: "datetime"
                },
                createdAt: {
                  type: "string",
                  format: "datetime"
                },
                deletedAt: {
                  type: "string",
                  format: "datetime"
                },
                deactivatedAt: {
                  type: "string",
                  format: "datetime"
                },
                reactivatedAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            },
            recordHosting: {
              type: "object",
              required: ["status"],
              properties: {
                status: {
                  type: "string",
                  knownValues: ["deleted", "unknown"]
                },
                updatedAt: {
                  type: "string",
                  format: "datetime"
                },
                createdAt: {
                  type: "string",
                  format: "datetime"
                },
                deletedAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            }
          }
        },
        ToolsOzoneModerationEmitEvent: {
          lexicon: 1,
          id: "tools.ozone.moderation.emitEvent",
          defs: {
            main: {
              type: "procedure",
              description: "Take a moderation action on an actor.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["event", "subject", "createdBy"],
                  properties: {
                    event: {
                      type: "union",
                      refs: [
                        "lex:tools.ozone.moderation.defs#modEventTakedown",
                        "lex:tools.ozone.moderation.defs#modEventAcknowledge",
                        "lex:tools.ozone.moderation.defs#modEventEscalate",
                        "lex:tools.ozone.moderation.defs#modEventComment",
                        "lex:tools.ozone.moderation.defs#modEventLabel",
                        "lex:tools.ozone.moderation.defs#modEventReport",
                        "lex:tools.ozone.moderation.defs#modEventMute",
                        "lex:tools.ozone.moderation.defs#modEventUnmute",
                        "lex:tools.ozone.moderation.defs#modEventMuteReporter",
                        "lex:tools.ozone.moderation.defs#modEventUnmuteReporter",
                        "lex:tools.ozone.moderation.defs#modEventReverseTakedown",
                        "lex:tools.ozone.moderation.defs#modEventResolveAppeal",
                        "lex:tools.ozone.moderation.defs#modEventEmail",
                        "lex:tools.ozone.moderation.defs#modEventTag",
                        "lex:tools.ozone.moderation.defs#accountEvent",
                        "lex:tools.ozone.moderation.defs#identityEvent",
                        "lex:tools.ozone.moderation.defs#recordEvent",
                        "lex:tools.ozone.moderation.defs#modEventPriorityScore"
                      ]
                    },
                    subject: {
                      type: "union",
                      refs: [
                        "lex:com.atproto.admin.defs#repoRef",
                        "lex:com.atproto.repo.strongRef"
                      ]
                    },
                    subjectBlobCids: {
                      type: "array",
                      items: {
                        type: "string",
                        format: "cid"
                      }
                    },
                    createdBy: {
                      type: "string",
                      format: "did"
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "ref",
                  ref: "lex:tools.ozone.moderation.defs#modEventView"
                }
              },
              errors: [
                {
                  name: "SubjectHasAction"
                }
              ]
            }
          }
        },
        ToolsOzoneModerationGetEvent: {
          lexicon: 1,
          id: "tools.ozone.moderation.getEvent",
          defs: {
            main: {
              type: "query",
              description: "Get details about a moderation event.",
              parameters: {
                type: "params",
                required: ["id"],
                properties: {
                  id: {
                    type: "integer"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "ref",
                  ref: "lex:tools.ozone.moderation.defs#modEventViewDetail"
                }
              }
            }
          }
        },
        ToolsOzoneModerationGetRecord: {
          lexicon: 1,
          id: "tools.ozone.moderation.getRecord",
          defs: {
            main: {
              type: "query",
              description: "Get details about a record.",
              parameters: {
                type: "params",
                required: ["uri"],
                properties: {
                  uri: {
                    type: "string",
                    format: "at-uri"
                  },
                  cid: {
                    type: "string",
                    format: "cid"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "ref",
                  ref: "lex:tools.ozone.moderation.defs#recordViewDetail"
                }
              },
              errors: [
                {
                  name: "RecordNotFound"
                }
              ]
            }
          }
        },
        ToolsOzoneModerationGetRecords: {
          lexicon: 1,
          id: "tools.ozone.moderation.getRecords",
          defs: {
            main: {
              type: "query",
              description: "Get details about some records.",
              parameters: {
                type: "params",
                required: ["uris"],
                properties: {
                  uris: {
                    type: "array",
                    maxLength: 100,
                    items: {
                      type: "string",
                      format: "at-uri"
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["records"],
                  properties: {
                    records: {
                      type: "array",
                      items: {
                        type: "union",
                        refs: [
                          "lex:tools.ozone.moderation.defs#recordViewDetail",
                          "lex:tools.ozone.moderation.defs#recordViewNotFound"
                        ]
                      }
                    }
                  }
                }
              }
            }
          }
        },
        ToolsOzoneModerationGetRepo: {
          lexicon: 1,
          id: "tools.ozone.moderation.getRepo",
          defs: {
            main: {
              type: "query",
              description: "Get details about a repository.",
              parameters: {
                type: "params",
                required: ["did"],
                properties: {
                  did: {
                    type: "string",
                    format: "did"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "ref",
                  ref: "lex:tools.ozone.moderation.defs#repoViewDetail"
                }
              },
              errors: [
                {
                  name: "RepoNotFound"
                }
              ]
            }
          }
        },
        ToolsOzoneModerationGetRepos: {
          lexicon: 1,
          id: "tools.ozone.moderation.getRepos",
          defs: {
            main: {
              type: "query",
              description: "Get details about some repositories.",
              parameters: {
                type: "params",
                required: ["dids"],
                properties: {
                  dids: {
                    type: "array",
                    maxLength: 100,
                    items: {
                      type: "string",
                      format: "did"
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["repos"],
                  properties: {
                    repos: {
                      type: "array",
                      items: {
                        type: "union",
                        refs: [
                          "lex:tools.ozone.moderation.defs#repoViewDetail",
                          "lex:tools.ozone.moderation.defs#repoViewNotFound"
                        ]
                      }
                    }
                  }
                }
              }
            }
          }
        },
        ToolsOzoneModerationQueryEvents: {
          lexicon: 1,
          id: "tools.ozone.moderation.queryEvents",
          defs: {
            main: {
              type: "query",
              description: "List moderation events related to a subject.",
              parameters: {
                type: "params",
                properties: {
                  types: {
                    type: "array",
                    items: {
                      type: "string"
                    },
                    description: "The types of events (fully qualified string in the format of tools.ozone.moderation.defs#modEvent<name>) to filter by. If not specified, all events are returned."
                  },
                  createdBy: {
                    type: "string",
                    format: "did"
                  },
                  sortDirection: {
                    type: "string",
                    default: "desc",
                    enum: ["asc", "desc"],
                    description: "Sort direction for the events. Defaults to descending order of created at timestamp."
                  },
                  createdAfter: {
                    type: "string",
                    format: "datetime",
                    description: "Retrieve events created after a given timestamp"
                  },
                  createdBefore: {
                    type: "string",
                    format: "datetime",
                    description: "Retrieve events created before a given timestamp"
                  },
                  subject: {
                    type: "string",
                    format: "uri"
                  },
                  collections: {
                    type: "array",
                    maxLength: 20,
                    description: "If specified, only events where the subject belongs to the given collections will be returned. When subjectType is set to 'account', this will be ignored.",
                    items: {
                      type: "string",
                      format: "nsid"
                    }
                  },
                  subjectType: {
                    type: "string",
                    description: "If specified, only events where the subject is of the given type (account or record) will be returned. When this is set to 'account' the 'collections' parameter will be ignored. When includeAllUserRecords or subject is set, this will be ignored.",
                    knownValues: ["account", "record"]
                  },
                  includeAllUserRecords: {
                    type: "boolean",
                    default: false,
                    description: "If true, events on all record types (posts, lists, profile etc.) or records from given 'collections' param, owned by the did are returned."
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  hasComment: {
                    type: "boolean",
                    description: "If true, only events with comments are returned"
                  },
                  comment: {
                    type: "string",
                    description: "If specified, only events with comments containing the keyword are returned. Apply || separator to use multiple keywords and match using OR condition."
                  },
                  addedLabels: {
                    type: "array",
                    items: {
                      type: "string"
                    },
                    description: "If specified, only events where all of these labels were added are returned"
                  },
                  removedLabels: {
                    type: "array",
                    items: {
                      type: "string"
                    },
                    description: "If specified, only events where all of these labels were removed are returned"
                  },
                  addedTags: {
                    type: "array",
                    items: {
                      type: "string"
                    },
                    description: "If specified, only events where all of these tags were added are returned"
                  },
                  removedTags: {
                    type: "array",
                    items: {
                      type: "string"
                    },
                    description: "If specified, only events where all of these tags were removed are returned"
                  },
                  reportTypes: {
                    type: "array",
                    items: {
                      type: "string"
                    }
                  },
                  policies: {
                    type: "array",
                    items: {
                      type: "string",
                      description: "If specified, only events where the action policies match any of the given policies are returned"
                    }
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["events"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    events: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:tools.ozone.moderation.defs#modEventView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        ToolsOzoneModerationQueryStatuses: {
          lexicon: 1,
          id: "tools.ozone.moderation.queryStatuses",
          defs: {
            main: {
              type: "query",
              description: "View moderation statuses of subjects (record or repo).",
              parameters: {
                type: "params",
                properties: {
                  queueCount: {
                    type: "integer",
                    description: "Number of queues being used by moderators. Subjects will be split among all queues."
                  },
                  queueIndex: {
                    type: "integer",
                    description: "Index of the queue to fetch subjects from. Works only when queueCount value is specified."
                  },
                  queueSeed: {
                    type: "string",
                    description: "A seeder to shuffle/balance the queue items."
                  },
                  includeAllUserRecords: {
                    type: "boolean",
                    description: "All subjects, or subjects from given 'collections' param, belonging to the account specified in the 'subject' param will be returned."
                  },
                  subject: {
                    type: "string",
                    format: "uri",
                    description: "The subject to get the status for."
                  },
                  comment: {
                    type: "string",
                    description: "Search subjects by keyword from comments"
                  },
                  reportedAfter: {
                    type: "string",
                    format: "datetime",
                    description: "Search subjects reported after a given timestamp"
                  },
                  reportedBefore: {
                    type: "string",
                    format: "datetime",
                    description: "Search subjects reported before a given timestamp"
                  },
                  reviewedAfter: {
                    type: "string",
                    format: "datetime",
                    description: "Search subjects reviewed after a given timestamp"
                  },
                  hostingDeletedAfter: {
                    type: "string",
                    format: "datetime",
                    description: "Search subjects where the associated record/account was deleted after a given timestamp"
                  },
                  hostingDeletedBefore: {
                    type: "string",
                    format: "datetime",
                    description: "Search subjects where the associated record/account was deleted before a given timestamp"
                  },
                  hostingUpdatedAfter: {
                    type: "string",
                    format: "datetime",
                    description: "Search subjects where the associated record/account was updated after a given timestamp"
                  },
                  hostingUpdatedBefore: {
                    type: "string",
                    format: "datetime",
                    description: "Search subjects where the associated record/account was updated before a given timestamp"
                  },
                  hostingStatuses: {
                    type: "array",
                    items: {
                      type: "string"
                    },
                    description: "Search subjects by the status of the associated record/account"
                  },
                  reviewedBefore: {
                    type: "string",
                    format: "datetime",
                    description: "Search subjects reviewed before a given timestamp"
                  },
                  includeMuted: {
                    type: "boolean",
                    description: "By default, we don't include muted subjects in the results. Set this to true to include them."
                  },
                  onlyMuted: {
                    type: "boolean",
                    description: "When set to true, only muted subjects and reporters will be returned."
                  },
                  reviewState: {
                    type: "string",
                    description: "Specify when fetching subjects in a certain state"
                  },
                  ignoreSubjects: {
                    type: "array",
                    items: {
                      type: "string",
                      format: "uri"
                    }
                  },
                  lastReviewedBy: {
                    type: "string",
                    format: "did",
                    description: "Get all subject statuses that were reviewed by a specific moderator"
                  },
                  sortField: {
                    type: "string",
                    default: "lastReportedAt",
                    enum: [
                      "lastReviewedAt",
                      "lastReportedAt",
                      "reportedRecordsCount",
                      "takendownRecordsCount",
                      "priorityScore"
                    ]
                  },
                  sortDirection: {
                    type: "string",
                    default: "desc",
                    enum: ["asc", "desc"]
                  },
                  takendown: {
                    type: "boolean",
                    description: "Get subjects that were taken down"
                  },
                  appealed: {
                    type: "boolean",
                    description: "Get subjects in unresolved appealed status"
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  tags: {
                    type: "array",
                    maxLength: 25,
                    items: {
                      type: "string",
                      description: "Items in this array are applied with OR filters. To apply AND filter, put all tags in the same string and separate using && characters"
                    }
                  },
                  excludeTags: {
                    type: "array",
                    items: {
                      type: "string"
                    }
                  },
                  cursor: {
                    type: "string"
                  },
                  collections: {
                    type: "array",
                    maxLength: 20,
                    description: "If specified, subjects belonging to the given collections will be returned. When subjectType is set to 'account', this will be ignored.",
                    items: {
                      type: "string",
                      format: "nsid"
                    }
                  },
                  subjectType: {
                    type: "string",
                    description: "If specified, subjects of the given type (account or record) will be returned. When this is set to 'account' the 'collections' parameter will be ignored. When includeAllUserRecords or subject is set, this will be ignored.",
                    knownValues: ["account", "record"]
                  },
                  minAccountSuspendCount: {
                    type: "integer",
                    description: "If specified, only subjects that belong to an account that has at least this many suspensions will be returned."
                  },
                  minReportedRecordsCount: {
                    type: "integer",
                    description: "If specified, only subjects that belong to an account that has at least this many reported records will be returned."
                  },
                  minTakendownRecordsCount: {
                    type: "integer",
                    description: "If specified, only subjects that belong to an account that has at least this many taken down records will be returned."
                  },
                  minPriorityScore: {
                    minimum: 0,
                    maximum: 100,
                    type: "integer",
                    description: "If specified, only subjects that have priority score value above the given value will be returned."
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["subjectStatuses"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    subjectStatuses: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:tools.ozone.moderation.defs#subjectStatusView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        ToolsOzoneModerationSearchRepos: {
          lexicon: 1,
          id: "tools.ozone.moderation.searchRepos",
          defs: {
            main: {
              type: "query",
              description: "Find repositories based on a search term.",
              parameters: {
                type: "params",
                properties: {
                  term: {
                    type: "string",
                    description: "DEPRECATED: use 'q' instead"
                  },
                  q: {
                    type: "string"
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["repos"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    repos: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:tools.ozone.moderation.defs#repoView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        ToolsOzoneServerGetConfig: {
          lexicon: 1,
          id: "tools.ozone.server.getConfig",
          defs: {
            main: {
              type: "query",
              description: "Get details about ozone's server configuration.",
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  properties: {
                    appview: {
                      type: "ref",
                      ref: "lex:tools.ozone.server.getConfig#serviceConfig"
                    },
                    pds: {
                      type: "ref",
                      ref: "lex:tools.ozone.server.getConfig#serviceConfig"
                    },
                    blobDivert: {
                      type: "ref",
                      ref: "lex:tools.ozone.server.getConfig#serviceConfig"
                    },
                    chat: {
                      type: "ref",
                      ref: "lex:tools.ozone.server.getConfig#serviceConfig"
                    },
                    viewer: {
                      type: "ref",
                      ref: "lex:tools.ozone.server.getConfig#viewerConfig"
                    }
                  }
                }
              }
            },
            serviceConfig: {
              type: "object",
              properties: {
                url: {
                  type: "string",
                  format: "uri"
                }
              }
            },
            viewerConfig: {
              type: "object",
              properties: {
                role: {
                  type: "string",
                  knownValues: [
                    "tools.ozone.team.defs#roleAdmin",
                    "tools.ozone.team.defs#roleModerator",
                    "tools.ozone.team.defs#roleTriage"
                  ]
                }
              }
            }
          }
        },
        ToolsOzoneSetAddValues: {
          lexicon: 1,
          id: "tools.ozone.set.addValues",
          defs: {
            main: {
              type: "procedure",
              description: "Add values to a specific set. Attempting to add values to a set that does not exist will result in an error.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["name", "values"],
                  properties: {
                    name: {
                      type: "string",
                      description: "Name of the set to add values to"
                    },
                    values: {
                      type: "array",
                      minLength: 1,
                      maxLength: 1e3,
                      items: {
                        type: "string"
                      },
                      description: "Array of string values to add to the set"
                    }
                  }
                }
              }
            }
          }
        },
        ToolsOzoneSetDefs: {
          lexicon: 1,
          id: "tools.ozone.set.defs",
          defs: {
            set: {
              type: "object",
              required: ["name"],
              properties: {
                name: {
                  type: "string",
                  minLength: 3,
                  maxLength: 128
                },
                description: {
                  type: "string",
                  maxGraphemes: 1024,
                  maxLength: 10240
                }
              }
            },
            setView: {
              type: "object",
              required: ["name", "setSize", "createdAt", "updatedAt"],
              properties: {
                name: {
                  type: "string",
                  minLength: 3,
                  maxLength: 128
                },
                description: {
                  type: "string",
                  maxGraphemes: 1024,
                  maxLength: 10240
                },
                setSize: {
                  type: "integer"
                },
                createdAt: {
                  type: "string",
                  format: "datetime"
                },
                updatedAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            }
          }
        },
        ToolsOzoneSetDeleteSet: {
          lexicon: 1,
          id: "tools.ozone.set.deleteSet",
          defs: {
            main: {
              type: "procedure",
              description: "Delete an entire set. Attempting to delete a set that does not exist will result in an error.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["name"],
                  properties: {
                    name: {
                      type: "string",
                      description: "Name of the set to delete"
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  properties: {}
                }
              },
              errors: [
                {
                  name: "SetNotFound",
                  description: "set with the given name does not exist"
                }
              ]
            }
          }
        },
        ToolsOzoneSetDeleteValues: {
          lexicon: 1,
          id: "tools.ozone.set.deleteValues",
          defs: {
            main: {
              type: "procedure",
              description: "Delete values from a specific set. Attempting to delete values that are not in the set will not result in an error",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["name", "values"],
                  properties: {
                    name: {
                      type: "string",
                      description: "Name of the set to delete values from"
                    },
                    values: {
                      type: "array",
                      minLength: 1,
                      items: {
                        type: "string"
                      },
                      description: "Array of string values to delete from the set"
                    }
                  }
                }
              },
              errors: [
                {
                  name: "SetNotFound",
                  description: "set with the given name does not exist"
                }
              ]
            }
          }
        },
        ToolsOzoneSetGetValues: {
          lexicon: 1,
          id: "tools.ozone.set.getValues",
          defs: {
            main: {
              type: "query",
              description: "Get a specific set and its values",
              parameters: {
                type: "params",
                required: ["name"],
                properties: {
                  name: {
                    type: "string"
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 1e3,
                    default: 100
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["set", "values"],
                  properties: {
                    set: {
                      type: "ref",
                      ref: "lex:tools.ozone.set.defs#setView"
                    },
                    values: {
                      type: "array",
                      items: {
                        type: "string"
                      }
                    },
                    cursor: {
                      type: "string"
                    }
                  }
                }
              },
              errors: [
                {
                  name: "SetNotFound",
                  description: "set with the given name does not exist"
                }
              ]
            }
          }
        },
        ToolsOzoneSetQuerySets: {
          lexicon: 1,
          id: "tools.ozone.set.querySets",
          defs: {
            main: {
              type: "query",
              description: "Query available sets",
              parameters: {
                type: "params",
                properties: {
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  },
                  namePrefix: {
                    type: "string"
                  },
                  sortBy: {
                    type: "string",
                    enum: ["name", "createdAt", "updatedAt"],
                    default: "name"
                  },
                  sortDirection: {
                    type: "string",
                    default: "asc",
                    enum: ["asc", "desc"],
                    description: "Defaults to ascending order of name field."
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["sets"],
                  properties: {
                    sets: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:tools.ozone.set.defs#setView"
                      }
                    },
                    cursor: {
                      type: "string"
                    }
                  }
                }
              }
            }
          }
        },
        ToolsOzoneSetUpsertSet: {
          lexicon: 1,
          id: "tools.ozone.set.upsertSet",
          defs: {
            main: {
              type: "procedure",
              description: "Create or update set metadata",
              input: {
                encoding: "application/json",
                schema: {
                  type: "ref",
                  ref: "lex:tools.ozone.set.defs#set"
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "ref",
                  ref: "lex:tools.ozone.set.defs#setView"
                }
              }
            }
          }
        },
        ToolsOzoneSettingDefs: {
          lexicon: 1,
          id: "tools.ozone.setting.defs",
          defs: {
            option: {
              type: "object",
              required: [
                "key",
                "value",
                "did",
                "scope",
                "createdBy",
                "lastUpdatedBy"
              ],
              properties: {
                key: {
                  type: "string",
                  format: "nsid"
                },
                did: {
                  type: "string",
                  format: "did"
                },
                value: {
                  type: "unknown"
                },
                description: {
                  type: "string",
                  maxGraphemes: 1024,
                  maxLength: 10240
                },
                createdAt: {
                  type: "string",
                  format: "datetime"
                },
                updatedAt: {
                  type: "string",
                  format: "datetime"
                },
                managerRole: {
                  type: "string",
                  knownValues: [
                    "tools.ozone.team.defs#roleModerator",
                    "tools.ozone.team.defs#roleTriage",
                    "tools.ozone.team.defs#roleAdmin"
                  ]
                },
                scope: {
                  type: "string",
                  knownValues: ["instance", "personal"]
                },
                createdBy: {
                  type: "string",
                  format: "did"
                },
                lastUpdatedBy: {
                  type: "string",
                  format: "did"
                }
              }
            }
          }
        },
        ToolsOzoneSettingListOptions: {
          lexicon: 1,
          id: "tools.ozone.setting.listOptions",
          defs: {
            main: {
              type: "query",
              description: "List settings with optional filtering",
              parameters: {
                type: "params",
                properties: {
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  },
                  scope: {
                    type: "string",
                    knownValues: ["instance", "personal"],
                    default: "instance"
                  },
                  prefix: {
                    type: "string",
                    description: "Filter keys by prefix"
                  },
                  keys: {
                    type: "array",
                    maxLength: 100,
                    items: {
                      type: "string",
                      format: "nsid"
                    },
                    description: "Filter for only the specified keys. Ignored if prefix is provided"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["options"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    options: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:tools.ozone.setting.defs#option"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        ToolsOzoneSettingRemoveOptions: {
          lexicon: 1,
          id: "tools.ozone.setting.removeOptions",
          defs: {
            main: {
              type: "procedure",
              description: "Delete settings by key",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["keys", "scope"],
                  properties: {
                    keys: {
                      type: "array",
                      minLength: 1,
                      maxLength: 200,
                      items: {
                        type: "string",
                        format: "nsid"
                      }
                    },
                    scope: {
                      type: "string",
                      knownValues: ["instance", "personal"]
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  properties: {}
                }
              }
            }
          }
        },
        ToolsOzoneSettingUpsertOption: {
          lexicon: 1,
          id: "tools.ozone.setting.upsertOption",
          defs: {
            main: {
              type: "procedure",
              description: "Create or update setting option",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["key", "scope", "value"],
                  properties: {
                    key: {
                      type: "string",
                      format: "nsid"
                    },
                    scope: {
                      type: "string",
                      knownValues: ["instance", "personal"]
                    },
                    value: {
                      type: "unknown"
                    },
                    description: {
                      type: "string",
                      maxLength: 2e3
                    },
                    managerRole: {
                      type: "string",
                      knownValues: [
                        "tools.ozone.team.defs#roleModerator",
                        "tools.ozone.team.defs#roleTriage",
                        "tools.ozone.team.defs#roleAdmin"
                      ]
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["option"],
                  properties: {
                    option: {
                      type: "ref",
                      ref: "lex:tools.ozone.setting.defs#option"
                    }
                  }
                }
              }
            }
          }
        },
        ToolsOzoneSignatureDefs: {
          lexicon: 1,
          id: "tools.ozone.signature.defs",
          defs: {
            sigDetail: {
              type: "object",
              required: ["property", "value"],
              properties: {
                property: {
                  type: "string"
                },
                value: {
                  type: "string"
                }
              }
            }
          }
        },
        ToolsOzoneSignatureFindCorrelation: {
          lexicon: 1,
          id: "tools.ozone.signature.findCorrelation",
          defs: {
            main: {
              type: "query",
              description: "Find all correlated threat signatures between 2 or more accounts.",
              parameters: {
                type: "params",
                required: ["dids"],
                properties: {
                  dids: {
                    type: "array",
                    items: {
                      type: "string",
                      format: "did"
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["details"],
                  properties: {
                    details: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:tools.ozone.signature.defs#sigDetail"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        ToolsOzoneSignatureFindRelatedAccounts: {
          lexicon: 1,
          id: "tools.ozone.signature.findRelatedAccounts",
          defs: {
            main: {
              type: "query",
              description: "Get accounts that share some matching threat signatures with the root account.",
              parameters: {
                type: "params",
                required: ["did"],
                properties: {
                  did: {
                    type: "string",
                    format: "did"
                  },
                  cursor: {
                    type: "string"
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["accounts"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    accounts: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:tools.ozone.signature.findRelatedAccounts#relatedAccount"
                      }
                    }
                  }
                }
              }
            },
            relatedAccount: {
              type: "object",
              required: ["account"],
              properties: {
                account: {
                  type: "ref",
                  ref: "lex:com.atproto.admin.defs#accountView"
                },
                similarities: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:tools.ozone.signature.defs#sigDetail"
                  }
                }
              }
            }
          }
        },
        ToolsOzoneSignatureSearchAccounts: {
          lexicon: 1,
          id: "tools.ozone.signature.searchAccounts",
          defs: {
            main: {
              type: "query",
              description: "Search for accounts that match one or more threat signature values.",
              parameters: {
                type: "params",
                required: ["values"],
                properties: {
                  values: {
                    type: "array",
                    items: {
                      type: "string"
                    }
                  },
                  cursor: {
                    type: "string"
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["accounts"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    accounts: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:com.atproto.admin.defs#accountView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        ToolsOzoneTeamAddMember: {
          lexicon: 1,
          id: "tools.ozone.team.addMember",
          defs: {
            main: {
              type: "procedure",
              description: "Add a member to the ozone team. Requires admin role.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["did", "role"],
                  properties: {
                    did: {
                      type: "string",
                      format: "did"
                    },
                    role: {
                      type: "string",
                      knownValues: [
                        "tools.ozone.team.defs#roleAdmin",
                        "tools.ozone.team.defs#roleModerator",
                        "tools.ozone.team.defs#roleTriage"
                      ]
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "ref",
                  ref: "lex:tools.ozone.team.defs#member"
                }
              },
              errors: [
                {
                  name: "MemberAlreadyExists",
                  description: "Member already exists in the team."
                }
              ]
            }
          }
        },
        ToolsOzoneTeamDefs: {
          lexicon: 1,
          id: "tools.ozone.team.defs",
          defs: {
            member: {
              type: "object",
              required: ["did", "role"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                },
                disabled: {
                  type: "boolean"
                },
                profile: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#profileViewDetailed"
                },
                createdAt: {
                  type: "string",
                  format: "datetime"
                },
                updatedAt: {
                  type: "string",
                  format: "datetime"
                },
                lastUpdatedBy: {
                  type: "string"
                },
                role: {
                  type: "string",
                  knownValues: [
                    "lex:tools.ozone.team.defs#roleAdmin",
                    "lex:tools.ozone.team.defs#roleModerator",
                    "lex:tools.ozone.team.defs#roleTriage"
                  ]
                }
              }
            },
            roleAdmin: {
              type: "token",
              description: "Admin role. Highest level of access, can perform all actions."
            },
            roleModerator: {
              type: "token",
              description: "Moderator role. Can perform most actions."
            },
            roleTriage: {
              type: "token",
              description: "Triage role. Mostly intended for monitoring and escalating issues."
            }
          }
        },
        ToolsOzoneTeamDeleteMember: {
          lexicon: 1,
          id: "tools.ozone.team.deleteMember",
          defs: {
            main: {
              type: "procedure",
              description: "Delete a member from ozone team. Requires admin role.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["did"],
                  properties: {
                    did: {
                      type: "string",
                      format: "did"
                    }
                  }
                }
              },
              errors: [
                {
                  name: "MemberNotFound",
                  description: "The member being deleted does not exist"
                },
                {
                  name: "CannotDeleteSelf",
                  description: "You can not delete yourself from the team"
                }
              ]
            }
          }
        },
        ToolsOzoneTeamListMembers: {
          lexicon: 1,
          id: "tools.ozone.team.listMembers",
          defs: {
            main: {
              type: "query",
              description: "List all members with access to the ozone service.",
              parameters: {
                type: "params",
                properties: {
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["members"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    members: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:tools.ozone.team.defs#member"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        ToolsOzoneTeamUpdateMember: {
          lexicon: 1,
          id: "tools.ozone.team.updateMember",
          defs: {
            main: {
              type: "procedure",
              description: "Update a member in the ozone service. Requires admin role.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["did"],
                  properties: {
                    did: {
                      type: "string",
                      format: "did"
                    },
                    disabled: {
                      type: "boolean"
                    },
                    role: {
                      type: "string",
                      knownValues: [
                        "tools.ozone.team.defs#roleAdmin",
                        "tools.ozone.team.defs#roleModerator",
                        "tools.ozone.team.defs#roleTriage"
                      ]
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "ref",
                  ref: "lex:tools.ozone.team.defs#member"
                }
              },
              errors: [
                {
                  name: "MemberNotFound",
                  description: "The member being updated does not exist in the team"
                }
              ]
            }
          }
        }
      };
      exports.schemas = Object.values(exports.schemaDict);
      exports.lexicons = new lexicon_1.Lexicons(exports.schemas);
      function validate(v, id, hash, requiredType) {
        return (requiredType ? util_js_1.is$typed : util_js_1.maybe$typed)(v, id, hash) ? exports.lexicons.validate(`${id}#${hash}`, v) : {
          success: false,
          error: new lexicon_1.ValidationError(`Must be an object with "${hash === "main" ? id : `${id}#${hash}`}" $type property`)
        };
      }
      exports.ids = {
        ComAtprotoAdminDefs: "com.atproto.admin.defs",
        ComAtprotoAdminDeleteAccount: "com.atproto.admin.deleteAccount",
        ComAtprotoAdminDisableAccountInvites: "com.atproto.admin.disableAccountInvites",
        ComAtprotoAdminDisableInviteCodes: "com.atproto.admin.disableInviteCodes",
        ComAtprotoAdminEnableAccountInvites: "com.atproto.admin.enableAccountInvites",
        ComAtprotoAdminGetAccountInfo: "com.atproto.admin.getAccountInfo",
        ComAtprotoAdminGetAccountInfos: "com.atproto.admin.getAccountInfos",
        ComAtprotoAdminGetInviteCodes: "com.atproto.admin.getInviteCodes",
        ComAtprotoAdminGetSubjectStatus: "com.atproto.admin.getSubjectStatus",
        ComAtprotoAdminSearchAccounts: "com.atproto.admin.searchAccounts",
        ComAtprotoAdminSendEmail: "com.atproto.admin.sendEmail",
        ComAtprotoAdminUpdateAccountEmail: "com.atproto.admin.updateAccountEmail",
        ComAtprotoAdminUpdateAccountHandle: "com.atproto.admin.updateAccountHandle",
        ComAtprotoAdminUpdateAccountPassword: "com.atproto.admin.updateAccountPassword",
        ComAtprotoAdminUpdateSubjectStatus: "com.atproto.admin.updateSubjectStatus",
        ComAtprotoIdentityGetRecommendedDidCredentials: "com.atproto.identity.getRecommendedDidCredentials",
        ComAtprotoIdentityRequestPlcOperationSignature: "com.atproto.identity.requestPlcOperationSignature",
        ComAtprotoIdentityResolveHandle: "com.atproto.identity.resolveHandle",
        ComAtprotoIdentitySignPlcOperation: "com.atproto.identity.signPlcOperation",
        ComAtprotoIdentitySubmitPlcOperation: "com.atproto.identity.submitPlcOperation",
        ComAtprotoIdentityUpdateHandle: "com.atproto.identity.updateHandle",
        ComAtprotoLabelDefs: "com.atproto.label.defs",
        ComAtprotoLabelQueryLabels: "com.atproto.label.queryLabels",
        ComAtprotoLabelSubscribeLabels: "com.atproto.label.subscribeLabels",
        ComAtprotoLexiconSchema: "com.atproto.lexicon.schema",
        ComAtprotoModerationCreateReport: "com.atproto.moderation.createReport",
        ComAtprotoModerationDefs: "com.atproto.moderation.defs",
        ComAtprotoRepoApplyWrites: "com.atproto.repo.applyWrites",
        ComAtprotoRepoCreateRecord: "com.atproto.repo.createRecord",
        ComAtprotoRepoDefs: "com.atproto.repo.defs",
        ComAtprotoRepoDeleteRecord: "com.atproto.repo.deleteRecord",
        ComAtprotoRepoDescribeRepo: "com.atproto.repo.describeRepo",
        ComAtprotoRepoGetRecord: "com.atproto.repo.getRecord",
        ComAtprotoRepoImportRepo: "com.atproto.repo.importRepo",
        ComAtprotoRepoListMissingBlobs: "com.atproto.repo.listMissingBlobs",
        ComAtprotoRepoListRecords: "com.atproto.repo.listRecords",
        ComAtprotoRepoPutRecord: "com.atproto.repo.putRecord",
        ComAtprotoRepoStrongRef: "com.atproto.repo.strongRef",
        ComAtprotoRepoUploadBlob: "com.atproto.repo.uploadBlob",
        ComAtprotoServerActivateAccount: "com.atproto.server.activateAccount",
        ComAtprotoServerCheckAccountStatus: "com.atproto.server.checkAccountStatus",
        ComAtprotoServerConfirmEmail: "com.atproto.server.confirmEmail",
        ComAtprotoServerCreateAccount: "com.atproto.server.createAccount",
        ComAtprotoServerCreateAppPassword: "com.atproto.server.createAppPassword",
        ComAtprotoServerCreateInviteCode: "com.atproto.server.createInviteCode",
        ComAtprotoServerCreateInviteCodes: "com.atproto.server.createInviteCodes",
        ComAtprotoServerCreateSession: "com.atproto.server.createSession",
        ComAtprotoServerDeactivateAccount: "com.atproto.server.deactivateAccount",
        ComAtprotoServerDefs: "com.atproto.server.defs",
        ComAtprotoServerDeleteAccount: "com.atproto.server.deleteAccount",
        ComAtprotoServerDeleteSession: "com.atproto.server.deleteSession",
        ComAtprotoServerDescribeServer: "com.atproto.server.describeServer",
        ComAtprotoServerGetAccountInviteCodes: "com.atproto.server.getAccountInviteCodes",
        ComAtprotoServerGetServiceAuth: "com.atproto.server.getServiceAuth",
        ComAtprotoServerGetSession: "com.atproto.server.getSession",
        ComAtprotoServerListAppPasswords: "com.atproto.server.listAppPasswords",
        ComAtprotoServerRefreshSession: "com.atproto.server.refreshSession",
        ComAtprotoServerRequestAccountDelete: "com.atproto.server.requestAccountDelete",
        ComAtprotoServerRequestEmailConfirmation: "com.atproto.server.requestEmailConfirmation",
        ComAtprotoServerRequestEmailUpdate: "com.atproto.server.requestEmailUpdate",
        ComAtprotoServerRequestPasswordReset: "com.atproto.server.requestPasswordReset",
        ComAtprotoServerReserveSigningKey: "com.atproto.server.reserveSigningKey",
        ComAtprotoServerResetPassword: "com.atproto.server.resetPassword",
        ComAtprotoServerRevokeAppPassword: "com.atproto.server.revokeAppPassword",
        ComAtprotoServerUpdateEmail: "com.atproto.server.updateEmail",
        ComAtprotoSyncGetBlob: "com.atproto.sync.getBlob",
        ComAtprotoSyncGetBlocks: "com.atproto.sync.getBlocks",
        ComAtprotoSyncGetCheckout: "com.atproto.sync.getCheckout",
        ComAtprotoSyncGetHead: "com.atproto.sync.getHead",
        ComAtprotoSyncGetLatestCommit: "com.atproto.sync.getLatestCommit",
        ComAtprotoSyncGetRecord: "com.atproto.sync.getRecord",
        ComAtprotoSyncGetRepo: "com.atproto.sync.getRepo",
        ComAtprotoSyncGetRepoStatus: "com.atproto.sync.getRepoStatus",
        ComAtprotoSyncListBlobs: "com.atproto.sync.listBlobs",
        ComAtprotoSyncListRepos: "com.atproto.sync.listRepos",
        ComAtprotoSyncNotifyOfUpdate: "com.atproto.sync.notifyOfUpdate",
        ComAtprotoSyncRequestCrawl: "com.atproto.sync.requestCrawl",
        ComAtprotoSyncSubscribeRepos: "com.atproto.sync.subscribeRepos",
        ComAtprotoTempAddReservedHandle: "com.atproto.temp.addReservedHandle",
        ComAtprotoTempCheckSignupQueue: "com.atproto.temp.checkSignupQueue",
        ComAtprotoTempFetchLabels: "com.atproto.temp.fetchLabels",
        ComAtprotoTempRequestPhoneVerification: "com.atproto.temp.requestPhoneVerification",
        AppBskyActorDefs: "app.bsky.actor.defs",
        AppBskyActorGetPreferences: "app.bsky.actor.getPreferences",
        AppBskyActorGetProfile: "app.bsky.actor.getProfile",
        AppBskyActorGetProfiles: "app.bsky.actor.getProfiles",
        AppBskyActorGetSuggestions: "app.bsky.actor.getSuggestions",
        AppBskyActorProfile: "app.bsky.actor.profile",
        AppBskyActorPutPreferences: "app.bsky.actor.putPreferences",
        AppBskyActorSearchActors: "app.bsky.actor.searchActors",
        AppBskyActorSearchActorsTypeahead: "app.bsky.actor.searchActorsTypeahead",
        AppBskyEmbedDefs: "app.bsky.embed.defs",
        AppBskyEmbedExternal: "app.bsky.embed.external",
        AppBskyEmbedImages: "app.bsky.embed.images",
        AppBskyEmbedRecord: "app.bsky.embed.record",
        AppBskyEmbedRecordWithMedia: "app.bsky.embed.recordWithMedia",
        AppBskyEmbedVideo: "app.bsky.embed.video",
        AppBskyFeedDefs: "app.bsky.feed.defs",
        AppBskyFeedDescribeFeedGenerator: "app.bsky.feed.describeFeedGenerator",
        AppBskyFeedGenerator: "app.bsky.feed.generator",
        AppBskyFeedGetActorFeeds: "app.bsky.feed.getActorFeeds",
        AppBskyFeedGetActorLikes: "app.bsky.feed.getActorLikes",
        AppBskyFeedGetAuthorFeed: "app.bsky.feed.getAuthorFeed",
        AppBskyFeedGetFeed: "app.bsky.feed.getFeed",
        AppBskyFeedGetFeedGenerator: "app.bsky.feed.getFeedGenerator",
        AppBskyFeedGetFeedGenerators: "app.bsky.feed.getFeedGenerators",
        AppBskyFeedGetFeedSkeleton: "app.bsky.feed.getFeedSkeleton",
        AppBskyFeedGetLikes: "app.bsky.feed.getLikes",
        AppBskyFeedGetListFeed: "app.bsky.feed.getListFeed",
        AppBskyFeedGetPostThread: "app.bsky.feed.getPostThread",
        AppBskyFeedGetPosts: "app.bsky.feed.getPosts",
        AppBskyFeedGetQuotes: "app.bsky.feed.getQuotes",
        AppBskyFeedGetRepostedBy: "app.bsky.feed.getRepostedBy",
        AppBskyFeedGetSuggestedFeeds: "app.bsky.feed.getSuggestedFeeds",
        AppBskyFeedGetTimeline: "app.bsky.feed.getTimeline",
        AppBskyFeedLike: "app.bsky.feed.like",
        AppBskyFeedPost: "app.bsky.feed.post",
        AppBskyFeedPostgate: "app.bsky.feed.postgate",
        AppBskyFeedRepost: "app.bsky.feed.repost",
        AppBskyFeedSearchPosts: "app.bsky.feed.searchPosts",
        AppBskyFeedSendInteractions: "app.bsky.feed.sendInteractions",
        AppBskyFeedThreadgate: "app.bsky.feed.threadgate",
        AppBskyGraphBlock: "app.bsky.graph.block",
        AppBskyGraphDefs: "app.bsky.graph.defs",
        AppBskyGraphFollow: "app.bsky.graph.follow",
        AppBskyGraphGetActorStarterPacks: "app.bsky.graph.getActorStarterPacks",
        AppBskyGraphGetBlocks: "app.bsky.graph.getBlocks",
        AppBskyGraphGetFollowers: "app.bsky.graph.getFollowers",
        AppBskyGraphGetFollows: "app.bsky.graph.getFollows",
        AppBskyGraphGetKnownFollowers: "app.bsky.graph.getKnownFollowers",
        AppBskyGraphGetList: "app.bsky.graph.getList",
        AppBskyGraphGetListBlocks: "app.bsky.graph.getListBlocks",
        AppBskyGraphGetListMutes: "app.bsky.graph.getListMutes",
        AppBskyGraphGetLists: "app.bsky.graph.getLists",
        AppBskyGraphGetMutes: "app.bsky.graph.getMutes",
        AppBskyGraphGetRelationships: "app.bsky.graph.getRelationships",
        AppBskyGraphGetStarterPack: "app.bsky.graph.getStarterPack",
        AppBskyGraphGetStarterPacks: "app.bsky.graph.getStarterPacks",
        AppBskyGraphGetSuggestedFollowsByActor: "app.bsky.graph.getSuggestedFollowsByActor",
        AppBskyGraphList: "app.bsky.graph.list",
        AppBskyGraphListblock: "app.bsky.graph.listblock",
        AppBskyGraphListitem: "app.bsky.graph.listitem",
        AppBskyGraphMuteActor: "app.bsky.graph.muteActor",
        AppBskyGraphMuteActorList: "app.bsky.graph.muteActorList",
        AppBskyGraphMuteThread: "app.bsky.graph.muteThread",
        AppBskyGraphSearchStarterPacks: "app.bsky.graph.searchStarterPacks",
        AppBskyGraphStarterpack: "app.bsky.graph.starterpack",
        AppBskyGraphUnmuteActor: "app.bsky.graph.unmuteActor",
        AppBskyGraphUnmuteActorList: "app.bsky.graph.unmuteActorList",
        AppBskyGraphUnmuteThread: "app.bsky.graph.unmuteThread",
        AppBskyLabelerDefs: "app.bsky.labeler.defs",
        AppBskyLabelerGetServices: "app.bsky.labeler.getServices",
        AppBskyLabelerService: "app.bsky.labeler.service",
        AppBskyNotificationGetUnreadCount: "app.bsky.notification.getUnreadCount",
        AppBskyNotificationListNotifications: "app.bsky.notification.listNotifications",
        AppBskyNotificationPutPreferences: "app.bsky.notification.putPreferences",
        AppBskyNotificationRegisterPush: "app.bsky.notification.registerPush",
        AppBskyNotificationUpdateSeen: "app.bsky.notification.updateSeen",
        AppBskyRichtextFacet: "app.bsky.richtext.facet",
        AppBskyUnspeccedDefs: "app.bsky.unspecced.defs",
        AppBskyUnspeccedGetConfig: "app.bsky.unspecced.getConfig",
        AppBskyUnspeccedGetPopularFeedGenerators: "app.bsky.unspecced.getPopularFeedGenerators",
        AppBskyUnspeccedGetSuggestionsSkeleton: "app.bsky.unspecced.getSuggestionsSkeleton",
        AppBskyUnspeccedGetTaggedSuggestions: "app.bsky.unspecced.getTaggedSuggestions",
        AppBskyUnspeccedGetTrendingTopics: "app.bsky.unspecced.getTrendingTopics",
        AppBskyUnspeccedSearchActorsSkeleton: "app.bsky.unspecced.searchActorsSkeleton",
        AppBskyUnspeccedSearchPostsSkeleton: "app.bsky.unspecced.searchPostsSkeleton",
        AppBskyUnspeccedSearchStarterPacksSkeleton: "app.bsky.unspecced.searchStarterPacksSkeleton",
        AppBskyVideoDefs: "app.bsky.video.defs",
        AppBskyVideoGetJobStatus: "app.bsky.video.getJobStatus",
        AppBskyVideoGetUploadLimits: "app.bsky.video.getUploadLimits",
        AppBskyVideoUploadVideo: "app.bsky.video.uploadVideo",
        ChatBskyActorDeclaration: "chat.bsky.actor.declaration",
        ChatBskyActorDefs: "chat.bsky.actor.defs",
        ChatBskyActorDeleteAccount: "chat.bsky.actor.deleteAccount",
        ChatBskyActorExportAccountData: "chat.bsky.actor.exportAccountData",
        ChatBskyConvoDefs: "chat.bsky.convo.defs",
        ChatBskyConvoDeleteMessageForSelf: "chat.bsky.convo.deleteMessageForSelf",
        ChatBskyConvoGetConvo: "chat.bsky.convo.getConvo",
        ChatBskyConvoGetConvoForMembers: "chat.bsky.convo.getConvoForMembers",
        ChatBskyConvoGetLog: "chat.bsky.convo.getLog",
        ChatBskyConvoGetMessages: "chat.bsky.convo.getMessages",
        ChatBskyConvoLeaveConvo: "chat.bsky.convo.leaveConvo",
        ChatBskyConvoListConvos: "chat.bsky.convo.listConvos",
        ChatBskyConvoMuteConvo: "chat.bsky.convo.muteConvo",
        ChatBskyConvoSendMessage: "chat.bsky.convo.sendMessage",
        ChatBskyConvoSendMessageBatch: "chat.bsky.convo.sendMessageBatch",
        ChatBskyConvoUnmuteConvo: "chat.bsky.convo.unmuteConvo",
        ChatBskyConvoUpdateRead: "chat.bsky.convo.updateRead",
        ChatBskyModerationGetActorMetadata: "chat.bsky.moderation.getActorMetadata",
        ChatBskyModerationGetMessageContext: "chat.bsky.moderation.getMessageContext",
        ChatBskyModerationUpdateActorAccess: "chat.bsky.moderation.updateActorAccess",
        ToolsOzoneCommunicationCreateTemplate: "tools.ozone.communication.createTemplate",
        ToolsOzoneCommunicationDefs: "tools.ozone.communication.defs",
        ToolsOzoneCommunicationDeleteTemplate: "tools.ozone.communication.deleteTemplate",
        ToolsOzoneCommunicationListTemplates: "tools.ozone.communication.listTemplates",
        ToolsOzoneCommunicationUpdateTemplate: "tools.ozone.communication.updateTemplate",
        ToolsOzoneModerationDefs: "tools.ozone.moderation.defs",
        ToolsOzoneModerationEmitEvent: "tools.ozone.moderation.emitEvent",
        ToolsOzoneModerationGetEvent: "tools.ozone.moderation.getEvent",
        ToolsOzoneModerationGetRecord: "tools.ozone.moderation.getRecord",
        ToolsOzoneModerationGetRecords: "tools.ozone.moderation.getRecords",
        ToolsOzoneModerationGetRepo: "tools.ozone.moderation.getRepo",
        ToolsOzoneModerationGetRepos: "tools.ozone.moderation.getRepos",
        ToolsOzoneModerationQueryEvents: "tools.ozone.moderation.queryEvents",
        ToolsOzoneModerationQueryStatuses: "tools.ozone.moderation.queryStatuses",
        ToolsOzoneModerationSearchRepos: "tools.ozone.moderation.searchRepos",
        ToolsOzoneServerGetConfig: "tools.ozone.server.getConfig",
        ToolsOzoneSetAddValues: "tools.ozone.set.addValues",
        ToolsOzoneSetDefs: "tools.ozone.set.defs",
        ToolsOzoneSetDeleteSet: "tools.ozone.set.deleteSet",
        ToolsOzoneSetDeleteValues: "tools.ozone.set.deleteValues",
        ToolsOzoneSetGetValues: "tools.ozone.set.getValues",
        ToolsOzoneSetQuerySets: "tools.ozone.set.querySets",
        ToolsOzoneSetUpsertSet: "tools.ozone.set.upsertSet",
        ToolsOzoneSettingDefs: "tools.ozone.setting.defs",
        ToolsOzoneSettingListOptions: "tools.ozone.setting.listOptions",
        ToolsOzoneSettingRemoveOptions: "tools.ozone.setting.removeOptions",
        ToolsOzoneSettingUpsertOption: "tools.ozone.setting.upsertOption",
        ToolsOzoneSignatureDefs: "tools.ozone.signature.defs",
        ToolsOzoneSignatureFindCorrelation: "tools.ozone.signature.findCorrelation",
        ToolsOzoneSignatureFindRelatedAccounts: "tools.ozone.signature.findRelatedAccounts",
        ToolsOzoneSignatureSearchAccounts: "tools.ozone.signature.searchAccounts",
        ToolsOzoneTeamAddMember: "tools.ozone.team.addMember",
        ToolsOzoneTeamDefs: "tools.ozone.team.defs",
        ToolsOzoneTeamDeleteMember: "tools.ozone.team.deleteMember",
        ToolsOzoneTeamListMembers: "tools.ozone.team.listMembers",
        ToolsOzoneTeamUpdateMember: "tools.ozone.team.updateMember"
      };
    })(lexicons);
    return lexicons;
  }
  var types$2 = {};
  var hasRequiredTypes$2;
  function requireTypes$2() {
    if (hasRequiredTypes$2) return types$2;
    hasRequiredTypes$2 = 1;
    Object.defineProperty(types$2, "__esModule", { value: true });
    return types$2;
  }
  var _const = {};
  var hasRequired_const;
  function require_const() {
    if (hasRequired_const) return _const;
    hasRequired_const = 1;
    Object.defineProperty(_const, "__esModule", { value: true });
    _const.BSKY_LABELER_DID = void 0;
    _const.BSKY_LABELER_DID = "did:plc:ar7c4by46qjdydhdevvrndac";
    return _const;
  }
  var util$4 = {};
  var hasRequiredUtil$4;
  function requireUtil$4() {
    if (hasRequiredUtil$4) return util$4;
    hasRequiredUtil$4 = 1;
    (function(exports) {
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.nuxSchema = exports.asDid = exports.isDid = void 0;
      exports.sanitizeMutedWordValue = sanitizeMutedWordValue;
      exports.savedFeedsToUriArrays = savedFeedsToUriArrays;
      exports.getSavedFeedType = getSavedFeedType;
      exports.validateSavedFeed = validateSavedFeed;
      exports.validateNux = validateNux;
      const zod_1 = /* @__PURE__ */ requireLib$1();
      const common_web_1 = requireDist$4();
      const syntax_1 = requireDist$5();
      function sanitizeMutedWordValue(value) {
        return value.trim().replace(/^#(?!\ufe0f)/, "").replace(/[\r\n\u00AD\u2060\u200D\u200C\u200B]+/, "");
      }
      function savedFeedsToUriArrays(savedFeeds) {
        const pinned = [];
        const saved = [];
        for (const feed of savedFeeds) {
          if (feed.pinned) {
            pinned.push(feed.value);
            saved.push(feed.value);
          } else {
            saved.push(feed.value);
          }
        }
        return {
          pinned,
          saved
        };
      }
      function getSavedFeedType(uri) {
        const urip = new syntax_1.AtUri(uri);
        switch (urip.collection) {
          case "app.bsky.feed.generator":
            return "feed";
          case "app.bsky.graph.list":
            return "list";
          default:
            return "unknown";
        }
      }
      function validateSavedFeed(savedFeed) {
        new common_web_1.TID(savedFeed.id);
        if (["feed", "list"].includes(savedFeed.type)) {
          const uri = new syntax_1.AtUri(savedFeed.value);
          const isFeed = uri.collection === "app.bsky.feed.generator";
          const isList = uri.collection === "app.bsky.graph.list";
          if (savedFeed.type === "feed" && !isFeed) {
            throw new Error(`Saved feed of type 'feed' must be a feed, got ${uri.collection}`);
          }
          if (savedFeed.type === "list" && !isList) {
            throw new Error(`Saved feed of type 'list' must be a list, got ${uri.collection}`);
          }
        }
      }
      const isDid = (str) => typeof str === "string" && str.startsWith("did:") && str.includes(":", 4) && str.length > 8 && str.length <= 2048;
      exports.isDid = isDid;
      const asDid = (value) => {
        if ((0, exports.isDid)(value))
          return value;
        throw new TypeError(`Invalid DID: ${value}`);
      };
      exports.asDid = asDid;
      exports.nuxSchema = zod_1.z.object({
        id: zod_1.z.string().max(64),
        completed: zod_1.z.boolean(),
        data: zod_1.z.string().max(300).optional(),
        expiresAt: zod_1.z.string().datetime().optional()
      }).strict();
      function validateNux(nux) {
        exports.nuxSchema.parse(nux);
      }
    })(util$4);
    return util$4;
  }
  var client$1 = {};
  var dist = {};
  var client = {};
  var util$3 = {};
  var types$1 = {};
  var hasRequiredTypes$1;
  function requireTypes$1() {
    if (hasRequiredTypes$1) return types$1;
    hasRequiredTypes$1 = 1;
    (function(exports) {
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.XRPCInvalidResponseError = exports.XRPCError = exports.XRPCResponse = exports.ResponseTypeStrings = exports.ResponseTypeNames = exports.ResponseType = exports.errorResponseBody = void 0;
      exports.httpResponseCodeToEnum = httpResponseCodeToEnum;
      exports.httpResponseCodeToName = httpResponseCodeToName;
      exports.httpResponseCodeToString = httpResponseCodeToString;
      const zod_1 = /* @__PURE__ */ requireLib$1();
      exports.errorResponseBody = zod_1.z.object({
        error: zod_1.z.string().optional(),
        message: zod_1.z.string().optional()
      });
      var ResponseType;
      (function(ResponseType2) {
        ResponseType2[ResponseType2["Unknown"] = 1] = "Unknown";
        ResponseType2[ResponseType2["InvalidResponse"] = 2] = "InvalidResponse";
        ResponseType2[ResponseType2["Success"] = 200] = "Success";
        ResponseType2[ResponseType2["InvalidRequest"] = 400] = "InvalidRequest";
        ResponseType2[ResponseType2["AuthRequired"] = 401] = "AuthRequired";
        ResponseType2[ResponseType2["Forbidden"] = 403] = "Forbidden";
        ResponseType2[ResponseType2["XRPCNotSupported"] = 404] = "XRPCNotSupported";
        ResponseType2[ResponseType2["NotAcceptable"] = 406] = "NotAcceptable";
        ResponseType2[ResponseType2["PayloadTooLarge"] = 413] = "PayloadTooLarge";
        ResponseType2[ResponseType2["UnsupportedMediaType"] = 415] = "UnsupportedMediaType";
        ResponseType2[ResponseType2["RateLimitExceeded"] = 429] = "RateLimitExceeded";
        ResponseType2[ResponseType2["InternalServerError"] = 500] = "InternalServerError";
        ResponseType2[ResponseType2["MethodNotImplemented"] = 501] = "MethodNotImplemented";
        ResponseType2[ResponseType2["UpstreamFailure"] = 502] = "UpstreamFailure";
        ResponseType2[ResponseType2["NotEnoughResources"] = 503] = "NotEnoughResources";
        ResponseType2[ResponseType2["UpstreamTimeout"] = 504] = "UpstreamTimeout";
      })(ResponseType || (exports.ResponseType = ResponseType = {}));
      function httpResponseCodeToEnum(status) {
        if (status in ResponseType) {
          return status;
        } else if (status >= 100 && status < 200) {
          return ResponseType.XRPCNotSupported;
        } else if (status >= 200 && status < 300) {
          return ResponseType.Success;
        } else if (status >= 300 && status < 400) {
          return ResponseType.XRPCNotSupported;
        } else if (status >= 400 && status < 500) {
          return ResponseType.InvalidRequest;
        } else {
          return ResponseType.InternalServerError;
        }
      }
      exports.ResponseTypeNames = {
        [ResponseType.Unknown]: "Unknown",
        [ResponseType.InvalidResponse]: "InvalidResponse",
        [ResponseType.Success]: "Success",
        [ResponseType.InvalidRequest]: "InvalidRequest",
        [ResponseType.AuthRequired]: "AuthenticationRequired",
        [ResponseType.Forbidden]: "Forbidden",
        [ResponseType.XRPCNotSupported]: "XRPCNotSupported",
        [ResponseType.PayloadTooLarge]: "PayloadTooLarge",
        [ResponseType.UnsupportedMediaType]: "UnsupportedMediaType",
        [ResponseType.RateLimitExceeded]: "RateLimitExceeded",
        [ResponseType.InternalServerError]: "InternalServerError",
        [ResponseType.MethodNotImplemented]: "MethodNotImplemented",
        [ResponseType.UpstreamFailure]: "UpstreamFailure",
        [ResponseType.NotEnoughResources]: "NotEnoughResources",
        [ResponseType.UpstreamTimeout]: "UpstreamTimeout"
      };
      function httpResponseCodeToName(status) {
        return exports.ResponseTypeNames[httpResponseCodeToEnum(status)];
      }
      exports.ResponseTypeStrings = {
        [ResponseType.Unknown]: "Unknown",
        [ResponseType.InvalidResponse]: "Invalid Response",
        [ResponseType.Success]: "Success",
        [ResponseType.InvalidRequest]: "Invalid Request",
        [ResponseType.AuthRequired]: "Authentication Required",
        [ResponseType.Forbidden]: "Forbidden",
        [ResponseType.XRPCNotSupported]: "XRPC Not Supported",
        [ResponseType.PayloadTooLarge]: "Payload Too Large",
        [ResponseType.UnsupportedMediaType]: "Unsupported Media Type",
        [ResponseType.RateLimitExceeded]: "Rate Limit Exceeded",
        [ResponseType.InternalServerError]: "Internal Server Error",
        [ResponseType.MethodNotImplemented]: "Method Not Implemented",
        [ResponseType.UpstreamFailure]: "Upstream Failure",
        [ResponseType.NotEnoughResources]: "Not Enough Resources",
        [ResponseType.UpstreamTimeout]: "Upstream Timeout"
      };
      function httpResponseCodeToString(status) {
        return exports.ResponseTypeStrings[httpResponseCodeToEnum(status)];
      }
      class XRPCResponse {
        constructor(data, headers) {
          Object.defineProperty(this, "data", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: data
          });
          Object.defineProperty(this, "headers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: headers
          });
          Object.defineProperty(this, "success", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: true
          });
        }
      }
      exports.XRPCResponse = XRPCResponse;
      class XRPCError extends Error {
        constructor(statusCode, error = httpResponseCodeToName(statusCode), message2, headers, options) {
          super(message2 || error || httpResponseCodeToString(statusCode), options);
          Object.defineProperty(this, "error", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: error
          });
          Object.defineProperty(this, "headers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: headers
          });
          Object.defineProperty(this, "success", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
          });
          Object.defineProperty(this, "status", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          this.status = httpResponseCodeToEnum(statusCode);
          const cause = options?.cause;
          if (this.cause === void 0 && cause !== void 0) {
            this.cause = cause;
          }
        }
        static from(cause, fallbackStatus) {
          if (cause instanceof XRPCError) {
            return cause;
          }
          const causeErr = cause instanceof Error ? cause : void 0;
          const causeResponse = cause instanceof Response ? cause : cause?.["response"] instanceof Response ? cause["response"] : void 0;
          const statusCode = (
            // Extract status code from "http-errors" like errors
            causeErr?.["statusCode"] ?? causeErr?.["status"] ?? // Use the status code from the response object as fallback
            causeResponse?.status
          );
          const status = typeof statusCode === "number" ? httpResponseCodeToEnum(statusCode) : fallbackStatus ?? ResponseType.Unknown;
          const message2 = causeErr?.message ?? String(cause);
          const headers = causeResponse ? Object.fromEntries(causeResponse.headers.entries()) : void 0;
          return new XRPCError(status, void 0, message2, headers, { cause });
        }
      }
      exports.XRPCError = XRPCError;
      class XRPCInvalidResponseError extends XRPCError {
        constructor(lexiconNsid, validationError, responseBody) {
          super(ResponseType.InvalidResponse, exports.ResponseTypeStrings[ResponseType.InvalidResponse], `The server gave an invalid response and may be out of date.`, void 0, { cause: validationError });
          Object.defineProperty(this, "lexiconNsid", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: lexiconNsid
          });
          Object.defineProperty(this, "validationError", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: validationError
          });
          Object.defineProperty(this, "responseBody", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: responseBody
          });
        }
      }
      exports.XRPCInvalidResponseError = XRPCInvalidResponseError;
    })(types$1);
    return types$1;
  }
  var hasRequiredUtil$3;
  function requireUtil$3() {
    if (hasRequiredUtil$3) return util$3;
    hasRequiredUtil$3 = 1;
    Object.defineProperty(util$3, "__esModule", { value: true });
    util$3.isErrorResponseBody = isErrorResponseBody;
    util$3.getMethodSchemaHTTPMethod = getMethodSchemaHTTPMethod;
    util$3.constructMethodCallUri = constructMethodCallUri;
    util$3.constructMethodCallUrl = constructMethodCallUrl;
    util$3.encodeQueryParam = encodeQueryParam;
    util$3.constructMethodCallHeaders = constructMethodCallHeaders;
    util$3.combineHeaders = combineHeaders;
    util$3.isBodyInit = isBodyInit;
    util$3.isIterable = isIterable;
    util$3.encodeMethodCallBody = encodeMethodCallBody;
    util$3.httpResponseBodyParse = httpResponseBodyParse;
    const lexicon_1 = requireDist$2();
    const types_1 = requireTypes$1();
    const ReadableStream = globalThis.ReadableStream || class {
      constructor() {
        throw new Error("ReadableStream is not supported in this environment");
      }
    };
    function isErrorResponseBody(v) {
      return types_1.errorResponseBody.safeParse(v).success;
    }
    function getMethodSchemaHTTPMethod(schema2) {
      if (schema2.type === "procedure") {
        return "post";
      }
      return "get";
    }
    function constructMethodCallUri(nsid2, schema2, serviceUri, params) {
      const uri = new URL(constructMethodCallUrl(nsid2, schema2, params), serviceUri);
      return uri.toString();
    }
    function constructMethodCallUrl(nsid2, schema2, params) {
      const pathname = `/xrpc/${encodeURIComponent(nsid2)}`;
      if (!params)
        return pathname;
      const searchParams = [];
      for (const [key, value] of Object.entries(params)) {
        const paramSchema = schema2.parameters?.properties?.[key];
        if (!paramSchema) {
          throw new Error(`Invalid query parameter: ${key}`);
        }
        if (value !== void 0) {
          if (paramSchema.type === "array") {
            const values = Array.isArray(value) ? value : [value];
            for (const val of values) {
              searchParams.push([
                key,
                encodeQueryParam(paramSchema.items.type, val)
              ]);
            }
          } else {
            searchParams.push([key, encodeQueryParam(paramSchema.type, value)]);
          }
        }
      }
      if (!searchParams.length)
        return pathname;
      return `${pathname}?${new URLSearchParams(searchParams).toString()}`;
    }
    function encodeQueryParam(type, value) {
      if (type === "string" || type === "unknown") {
        return String(value);
      }
      if (type === "float") {
        return String(Number(value));
      } else if (type === "integer") {
        return String(Number(value) | 0);
      } else if (type === "boolean") {
        return value ? "true" : "false";
      } else if (type === "datetime") {
        if (value instanceof Date) {
          return value.toISOString();
        }
        return String(value);
      }
      throw new Error(`Unsupported query param type: ${type}`);
    }
    function constructMethodCallHeaders(schema2, data, opts) {
      const headers = new Headers();
      if (opts?.headers) {
        for (const name in opts.headers) {
          if (headers.has(name)) {
            throw new TypeError(`Duplicate header: ${name}`);
          }
          const value = opts.headers[name];
          if (value != null) {
            headers.set(name, value);
          }
        }
      }
      if (schema2.type === "procedure") {
        if (opts?.encoding) {
          headers.set("content-type", opts.encoding);
        } else if (!headers.has("content-type") && typeof data !== "undefined") {
          if (data instanceof ArrayBuffer || data instanceof ReadableStream || ArrayBuffer.isView(data)) {
            headers.set("content-type", "application/octet-stream");
          } else if (data instanceof FormData) {
            headers.set("content-type", "multipart/form-data");
          } else if (data instanceof URLSearchParams) {
            headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
          } else if (isBlobLike(data)) {
            headers.set("content-type", data.type || "application/octet-stream");
          } else if (typeof data === "string") {
            headers.set("content-type", "text/plain;charset=UTF-8");
          } else if (isIterable(data)) {
            headers.set("content-type", "application/octet-stream");
          } else if (typeof data === "boolean" || typeof data === "number" || typeof data === "string" || typeof data === "object") {
            headers.set("content-type", "application/json");
          } else {
            throw new types_1.XRPCError(types_1.ResponseType.InvalidRequest, `Unsupported data type: ${typeof data}`);
          }
        }
      }
      return headers;
    }
    function combineHeaders(headersInit, defaultHeaders) {
      if (!defaultHeaders)
        return headersInit;
      let headers = void 0;
      for (const [name, definition] of defaultHeaders) {
        if (definition === void 0)
          continue;
        headers ?? (headers = new Headers(headersInit));
        if (headers.has(name))
          continue;
        const value = typeof definition === "function" ? definition() : definition;
        if (typeof value === "string")
          headers.set(name, value);
        else if (value === null)
          headers.delete(name);
        else
          throw new TypeError(`Invalid "${name}" header value: ${typeof value}`);
      }
      return headers ?? headersInit;
    }
    function isBlobLike(value) {
      if (value == null)
        return false;
      if (typeof value !== "object")
        return false;
      if (typeof Blob === "function" && value instanceof Blob)
        return true;
      const tag = value[Symbol.toStringTag];
      if (tag === "Blob" || tag === "File") {
        return "stream" in value && typeof value.stream === "function";
      }
      return false;
    }
    function isBodyInit(value) {
      switch (typeof value) {
        case "string":
          return true;
        case "object":
          return value instanceof ArrayBuffer || value instanceof FormData || value instanceof URLSearchParams || value instanceof ReadableStream || ArrayBuffer.isView(value) || isBlobLike(value);
        default:
          return false;
      }
    }
    function isIterable(value) {
      return value != null && typeof value === "object" && (Symbol.iterator in value || Symbol.asyncIterator in value);
    }
    function encodeMethodCallBody(headers, data) {
      const contentType = headers.get("content-type");
      if (!contentType) {
        return void 0;
      }
      if (typeof data === "undefined") {
        throw new types_1.XRPCError(types_1.ResponseType.InvalidRequest, `A request body is expected but none was provided`);
      }
      if (isBodyInit(data)) {
        if (data instanceof FormData && contentType === "multipart/form-data") {
          headers.delete("content-type");
        }
        return data;
      }
      if (isIterable(data)) {
        return iterableToReadableStream(data);
      }
      if (contentType.startsWith("text/")) {
        return new TextEncoder().encode(String(data));
      }
      if (contentType.startsWith("application/json")) {
        const json = (0, lexicon_1.stringifyLex)(data);
        if (json === void 0) {
          throw new types_1.XRPCError(types_1.ResponseType.InvalidRequest, `Failed to encode request body as JSON`);
        }
        return new TextEncoder().encode(json);
      }
      const type = !data || typeof data !== "object" ? typeof data : data.constructor !== Object && typeof data.constructor === "function" && typeof data.constructor?.name === "string" ? data.constructor.name : "object";
      throw new types_1.XRPCError(types_1.ResponseType.InvalidRequest, `Unable to encode ${type} as ${contentType} data`);
    }
    function iterableToReadableStream(iterable) {
      if ("from" in ReadableStream && typeof ReadableStream.from === "function") {
        return ReadableStream.from(iterable);
      }
      throw new TypeError("ReadableStream.from() is not supported in this environment. It is required to support using iterables as the request body. Consider using a polyfill or re-write your code to use a different body type.");
    }
    function httpResponseBodyParse(mimeType, data) {
      try {
        if (mimeType) {
          if (mimeType.includes("application/json")) {
            const str = new TextDecoder().decode(data);
            return (0, lexicon_1.jsonStringToLex)(str);
          }
          if (mimeType.startsWith("text/")) {
            return new TextDecoder().decode(data);
          }
        }
        if (data instanceof ArrayBuffer) {
          return new Uint8Array(data);
        }
        return data;
      } catch (cause) {
        throw new types_1.XRPCError(types_1.ResponseType.InvalidResponse, void 0, `Failed to parse response body: ${String(cause)}`, void 0, { cause });
      }
    }
    return util$3;
  }
  var xrpcClient = {};
  var fetchHandler = {};
  var hasRequiredFetchHandler;
  function requireFetchHandler() {
    if (hasRequiredFetchHandler) return fetchHandler;
    hasRequiredFetchHandler = 1;
    Object.defineProperty(fetchHandler, "__esModule", { value: true });
    fetchHandler.buildFetchHandler = buildFetchHandler;
    const util_1 = requireUtil$3();
    function buildFetchHandler(options) {
      if (typeof options === "function")
        return options;
      if (typeof options === "object" && "fetchHandler" in options) {
        return options.fetchHandler.bind(options);
      }
      const { service: service2, headers: defaultHeaders = void 0, fetch: fetch2 = globalThis.fetch } = typeof options === "string" || options instanceof URL ? { service: options } : options;
      if (typeof fetch2 !== "function") {
        throw new TypeError("XrpcDispatcher requires fetch() to be available in your environment.");
      }
      const defaultHeadersEntries = defaultHeaders != null ? Object.entries(defaultHeaders) : void 0;
      return async function(url, init) {
        const base3 = typeof service2 === "function" ? service2() : service2;
        const fullUrl = new URL(url, base3);
        const headers = (0, util_1.combineHeaders)(init.headers, defaultHeadersEntries);
        return fetch2(fullUrl, { ...init, headers });
      };
    }
    return fetchHandler;
  }
  var hasRequiredXrpcClient;
  function requireXrpcClient() {
    if (hasRequiredXrpcClient) return xrpcClient;
    hasRequiredXrpcClient = 1;
    Object.defineProperty(xrpcClient, "__esModule", { value: true });
    xrpcClient.XrpcClient = void 0;
    const lexicon_1 = requireDist$2();
    const fetch_handler_1 = requireFetchHandler();
    const types_1 = requireTypes$1();
    const util_1 = requireUtil$3();
    class XrpcClient {
      constructor(fetchHandlerOpts, lex) {
        Object.defineProperty(this, "fetchHandler", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "headers", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: /* @__PURE__ */ new Map()
        });
        Object.defineProperty(this, "lex", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.fetchHandler = (0, fetch_handler_1.buildFetchHandler)(fetchHandlerOpts);
        this.lex = lex instanceof lexicon_1.Lexicons ? lex : new lexicon_1.Lexicons(lex);
      }
      setHeader(key, value) {
        this.headers.set(key.toLowerCase(), value);
      }
      unsetHeader(key) {
        this.headers.delete(key.toLowerCase());
      }
      clearHeaders() {
        this.headers.clear();
      }
      async call(methodNsid, params, data, opts) {
        const def = this.lex.getDefOrThrow(methodNsid);
        if (!def || def.type !== "query" && def.type !== "procedure") {
          throw new TypeError(`Invalid lexicon: ${methodNsid}. Must be a query or procedure.`);
        }
        const reqUrl = (0, util_1.constructMethodCallUrl)(methodNsid, def, params);
        const reqMethod = (0, util_1.getMethodSchemaHTTPMethod)(def);
        const reqHeaders = (0, util_1.constructMethodCallHeaders)(def, data, opts);
        const reqBody = (0, util_1.encodeMethodCallBody)(reqHeaders, data);
        const init = {
          method: reqMethod,
          headers: (0, util_1.combineHeaders)(reqHeaders, this.headers),
          body: reqBody,
          duplex: "half",
          signal: opts?.signal
        };
        try {
          const response = await this.fetchHandler.call(void 0, reqUrl, init);
          const resStatus = response.status;
          const resHeaders = Object.fromEntries(response.headers.entries());
          const resBodyBytes = await response.arrayBuffer();
          const resBody = (0, util_1.httpResponseBodyParse)(response.headers.get("content-type"), resBodyBytes);
          const resCode = (0, types_1.httpResponseCodeToEnum)(resStatus);
          if (resCode !== types_1.ResponseType.Success) {
            const { error = void 0, message: message2 = void 0 } = resBody && (0, util_1.isErrorResponseBody)(resBody) ? resBody : {};
            throw new types_1.XRPCError(resCode, error, message2, resHeaders);
          }
          try {
            this.lex.assertValidXrpcOutput(methodNsid, resBody);
          } catch (e) {
            if (e instanceof lexicon_1.ValidationError) {
              throw new types_1.XRPCInvalidResponseError(methodNsid, e, resBody);
            }
            throw e;
          }
          return new types_1.XRPCResponse(resBody, resHeaders);
        } catch (err) {
          throw types_1.XRPCError.from(err);
        }
      }
    }
    xrpcClient.XrpcClient = XrpcClient;
    return xrpcClient;
  }
  var hasRequiredClient$1;
  function requireClient$1() {
    if (hasRequiredClient$1) return client;
    hasRequiredClient$1 = 1;
    Object.defineProperty(client, "__esModule", { value: true });
    client.ServiceClient = client.Client = void 0;
    const lexicon_1 = requireDist$2();
    const util_1 = requireUtil$3();
    const xrpc_client_1 = requireXrpcClient();
    class Client {
      constructor() {
        Object.defineProperty(this, "lex", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: new lexicon_1.Lexicons()
        });
      }
      /** @deprecated */
      get fetch() {
        throw new Error("Client.fetch is no longer supported. Use an XrpcClient instead.");
      }
      /** @deprecated */
      set fetch(_) {
        throw new Error("Client.fetch is no longer supported. Use an XrpcClient instead.");
      }
      // method calls
      //
      async call(serviceUri, methodNsid, params, data, opts) {
        return this.service(serviceUri).call(methodNsid, params, data, opts);
      }
      service(serviceUri) {
        return new ServiceClient(this, serviceUri);
      }
      // schemas
      // =
      addLexicon(doc) {
        this.lex.add(doc);
      }
      addLexicons(docs) {
        for (const doc of docs) {
          this.addLexicon(doc);
        }
      }
      removeLexicon(uri) {
        this.lex.remove(uri);
      }
    }
    client.Client = Client;
    class ServiceClient extends xrpc_client_1.XrpcClient {
      constructor(baseClient, serviceUri) {
        super(async (input, init) => {
          const headers = (0, util_1.combineHeaders)(init.headers, Object.entries(this.headers));
          return fetch(new URL(input, this.uri), { ...init, headers });
        }, baseClient.lex);
        Object.defineProperty(this, "baseClient", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: baseClient
        });
        Object.defineProperty(this, "uri", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.uri = typeof serviceUri === "string" ? new URL(serviceUri) : serviceUri;
      }
    }
    client.ServiceClient = ServiceClient;
    return client;
  }
  var hasRequiredDist$1;
  function requireDist$1() {
    if (hasRequiredDist$1) return dist;
    hasRequiredDist$1 = 1;
    (function(exports) {
      var __createBinding = dist && dist.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      });
      var __exportStar = dist && dist.__exportStar || function(m, exports2) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      __exportStar(requireClient$1(), exports);
      __exportStar(requireFetchHandler(), exports);
      __exportStar(requireTypes$1(), exports);
      __exportStar(requireUtil$3(), exports);
      __exportStar(requireXrpcClient(), exports);
      const client_1 = requireClient$1();
      const defaultInst = new client_1.Client();
      exports.default = defaultInst;
    })(dist);
    return dist;
  }
  var applyWrites = {};
  var hasRequiredApplyWrites;
  function requireApplyWrites() {
    if (hasRequiredApplyWrites) return applyWrites;
    hasRequiredApplyWrites = 1;
    Object.defineProperty(applyWrites, "__esModule", { value: true });
    applyWrites.InvalidSwapError = void 0;
    applyWrites.toKnownErr = toKnownErr;
    applyWrites.isCreate = isCreate;
    applyWrites.validateCreate = validateCreate;
    applyWrites.isUpdate = isUpdate;
    applyWrites.validateUpdate = validateUpdate;
    applyWrites.isDelete = isDelete;
    applyWrites.validateDelete = validateDelete;
    applyWrites.isCreateResult = isCreateResult;
    applyWrites.validateCreateResult = validateCreateResult;
    applyWrites.isUpdateResult = isUpdateResult;
    applyWrites.validateUpdateResult = validateUpdateResult;
    applyWrites.isDeleteResult = isDeleteResult;
    applyWrites.validateDeleteResult = validateDeleteResult;
    const xrpc_1 = requireDist$1();
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "com.atproto.repo.applyWrites";
    class InvalidSwapError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    applyWrites.InvalidSwapError = InvalidSwapError;
    function toKnownErr(e) {
      if (e instanceof xrpc_1.XRPCError) {
        if (e.error === "InvalidSwap")
          return new InvalidSwapError(e);
      }
      return e;
    }
    const hashCreate = "create";
    function isCreate(v) {
      return is$typed(v, id, hashCreate);
    }
    function validateCreate(v) {
      return validate(v, id, hashCreate);
    }
    const hashUpdate = "update";
    function isUpdate(v) {
      return is$typed(v, id, hashUpdate);
    }
    function validateUpdate(v) {
      return validate(v, id, hashUpdate);
    }
    const hashDelete = "delete";
    function isDelete(v) {
      return is$typed(v, id, hashDelete);
    }
    function validateDelete(v) {
      return validate(v, id, hashDelete);
    }
    const hashCreateResult = "createResult";
    function isCreateResult(v) {
      return is$typed(v, id, hashCreateResult);
    }
    function validateCreateResult(v) {
      return validate(v, id, hashCreateResult);
    }
    const hashUpdateResult = "updateResult";
    function isUpdateResult(v) {
      return is$typed(v, id, hashUpdateResult);
    }
    function validateUpdateResult(v) {
      return validate(v, id, hashUpdateResult);
    }
    const hashDeleteResult = "deleteResult";
    function isDeleteResult(v) {
      return is$typed(v, id, hashDeleteResult);
    }
    function validateDeleteResult(v) {
      return validate(v, id, hashDeleteResult);
    }
    return applyWrites;
  }
  var createRecord = {};
  var hasRequiredCreateRecord;
  function requireCreateRecord() {
    if (hasRequiredCreateRecord) return createRecord;
    hasRequiredCreateRecord = 1;
    Object.defineProperty(createRecord, "__esModule", { value: true });
    createRecord.InvalidSwapError = void 0;
    createRecord.toKnownErr = toKnownErr;
    const xrpc_1 = requireDist$1();
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    class InvalidSwapError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    createRecord.InvalidSwapError = InvalidSwapError;
    function toKnownErr(e) {
      if (e instanceof xrpc_1.XRPCError) {
        if (e.error === "InvalidSwap")
          return new InvalidSwapError(e);
      }
      return e;
    }
    return createRecord;
  }
  var deleteRecord = {};
  var hasRequiredDeleteRecord;
  function requireDeleteRecord() {
    if (hasRequiredDeleteRecord) return deleteRecord;
    hasRequiredDeleteRecord = 1;
    Object.defineProperty(deleteRecord, "__esModule", { value: true });
    deleteRecord.InvalidSwapError = void 0;
    deleteRecord.toKnownErr = toKnownErr;
    const xrpc_1 = requireDist$1();
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    class InvalidSwapError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    deleteRecord.InvalidSwapError = InvalidSwapError;
    function toKnownErr(e) {
      if (e instanceof xrpc_1.XRPCError) {
        if (e.error === "InvalidSwap")
          return new InvalidSwapError(e);
      }
      return e;
    }
    return deleteRecord;
  }
  var getRecord$2 = {};
  var hasRequiredGetRecord$2;
  function requireGetRecord$2() {
    if (hasRequiredGetRecord$2) return getRecord$2;
    hasRequiredGetRecord$2 = 1;
    Object.defineProperty(getRecord$2, "__esModule", { value: true });
    getRecord$2.RecordNotFoundError = void 0;
    getRecord$2.toKnownErr = toKnownErr;
    const xrpc_1 = requireDist$1();
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    class RecordNotFoundError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    getRecord$2.RecordNotFoundError = RecordNotFoundError;
    function toKnownErr(e) {
      if (e instanceof xrpc_1.XRPCError) {
        if (e.error === "RecordNotFound")
          return new RecordNotFoundError(e);
      }
      return e;
    }
    return getRecord$2;
  }
  var putRecord = {};
  var hasRequiredPutRecord;
  function requirePutRecord() {
    if (hasRequiredPutRecord) return putRecord;
    hasRequiredPutRecord = 1;
    Object.defineProperty(putRecord, "__esModule", { value: true });
    putRecord.InvalidSwapError = void 0;
    putRecord.toKnownErr = toKnownErr;
    const xrpc_1 = requireDist$1();
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    class InvalidSwapError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    putRecord.InvalidSwapError = InvalidSwapError;
    function toKnownErr(e) {
      if (e instanceof xrpc_1.XRPCError) {
        if (e.error === "InvalidSwap")
          return new InvalidSwapError(e);
      }
      return e;
    }
    return putRecord;
  }
  var confirmEmail = {};
  var hasRequiredConfirmEmail;
  function requireConfirmEmail() {
    if (hasRequiredConfirmEmail) return confirmEmail;
    hasRequiredConfirmEmail = 1;
    Object.defineProperty(confirmEmail, "__esModule", { value: true });
    confirmEmail.InvalidEmailError = confirmEmail.InvalidTokenError = confirmEmail.ExpiredTokenError = confirmEmail.AccountNotFoundError = void 0;
    confirmEmail.toKnownErr = toKnownErr;
    const xrpc_1 = requireDist$1();
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    class AccountNotFoundError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    confirmEmail.AccountNotFoundError = AccountNotFoundError;
    class ExpiredTokenError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    confirmEmail.ExpiredTokenError = ExpiredTokenError;
    class InvalidTokenError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    confirmEmail.InvalidTokenError = InvalidTokenError;
    class InvalidEmailError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    confirmEmail.InvalidEmailError = InvalidEmailError;
    function toKnownErr(e) {
      if (e instanceof xrpc_1.XRPCError) {
        if (e.error === "AccountNotFound")
          return new AccountNotFoundError(e);
        if (e.error === "ExpiredToken")
          return new ExpiredTokenError(e);
        if (e.error === "InvalidToken")
          return new InvalidTokenError(e);
        if (e.error === "InvalidEmail")
          return new InvalidEmailError(e);
      }
      return e;
    }
    return confirmEmail;
  }
  var createAccount = {};
  var hasRequiredCreateAccount;
  function requireCreateAccount() {
    if (hasRequiredCreateAccount) return createAccount;
    hasRequiredCreateAccount = 1;
    Object.defineProperty(createAccount, "__esModule", { value: true });
    createAccount.IncompatibleDidDocError = createAccount.UnresolvableDidError = createAccount.UnsupportedDomainError = createAccount.HandleNotAvailableError = createAccount.InvalidInviteCodeError = createAccount.InvalidPasswordError = createAccount.InvalidHandleError = void 0;
    createAccount.toKnownErr = toKnownErr;
    const xrpc_1 = requireDist$1();
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    class InvalidHandleError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    createAccount.InvalidHandleError = InvalidHandleError;
    class InvalidPasswordError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    createAccount.InvalidPasswordError = InvalidPasswordError;
    class InvalidInviteCodeError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    createAccount.InvalidInviteCodeError = InvalidInviteCodeError;
    class HandleNotAvailableError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    createAccount.HandleNotAvailableError = HandleNotAvailableError;
    class UnsupportedDomainError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    createAccount.UnsupportedDomainError = UnsupportedDomainError;
    class UnresolvableDidError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    createAccount.UnresolvableDidError = UnresolvableDidError;
    class IncompatibleDidDocError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    createAccount.IncompatibleDidDocError = IncompatibleDidDocError;
    function toKnownErr(e) {
      if (e instanceof xrpc_1.XRPCError) {
        if (e.error === "InvalidHandle")
          return new InvalidHandleError(e);
        if (e.error === "InvalidPassword")
          return new InvalidPasswordError(e);
        if (e.error === "InvalidInviteCode")
          return new InvalidInviteCodeError(e);
        if (e.error === "HandleNotAvailable")
          return new HandleNotAvailableError(e);
        if (e.error === "UnsupportedDomain")
          return new UnsupportedDomainError(e);
        if (e.error === "UnresolvableDid")
          return new UnresolvableDidError(e);
        if (e.error === "IncompatibleDidDoc")
          return new IncompatibleDidDocError(e);
      }
      return e;
    }
    return createAccount;
  }
  var createAppPassword = {};
  var hasRequiredCreateAppPassword;
  function requireCreateAppPassword() {
    if (hasRequiredCreateAppPassword) return createAppPassword;
    hasRequiredCreateAppPassword = 1;
    Object.defineProperty(createAppPassword, "__esModule", { value: true });
    createAppPassword.AccountTakedownError = void 0;
    createAppPassword.toKnownErr = toKnownErr;
    createAppPassword.isAppPassword = isAppPassword;
    createAppPassword.validateAppPassword = validateAppPassword;
    const xrpc_1 = requireDist$1();
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "com.atproto.server.createAppPassword";
    class AccountTakedownError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    createAppPassword.AccountTakedownError = AccountTakedownError;
    function toKnownErr(e) {
      if (e instanceof xrpc_1.XRPCError) {
        if (e.error === "AccountTakedown")
          return new AccountTakedownError(e);
      }
      return e;
    }
    const hashAppPassword = "appPassword";
    function isAppPassword(v) {
      return is$typed(v, id, hashAppPassword);
    }
    function validateAppPassword(v) {
      return validate(v, id, hashAppPassword);
    }
    return createAppPassword;
  }
  var createSession = {};
  var hasRequiredCreateSession;
  function requireCreateSession() {
    if (hasRequiredCreateSession) return createSession;
    hasRequiredCreateSession = 1;
    Object.defineProperty(createSession, "__esModule", { value: true });
    createSession.AuthFactorTokenRequiredError = createSession.AccountTakedownError = void 0;
    createSession.toKnownErr = toKnownErr;
    const xrpc_1 = requireDist$1();
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    class AccountTakedownError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    createSession.AccountTakedownError = AccountTakedownError;
    class AuthFactorTokenRequiredError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    createSession.AuthFactorTokenRequiredError = AuthFactorTokenRequiredError;
    function toKnownErr(e) {
      if (e instanceof xrpc_1.XRPCError) {
        if (e.error === "AccountTakedown")
          return new AccountTakedownError(e);
        if (e.error === "AuthFactorTokenRequired")
          return new AuthFactorTokenRequiredError(e);
      }
      return e;
    }
    return createSession;
  }
  var deleteAccount$2 = {};
  var hasRequiredDeleteAccount$2;
  function requireDeleteAccount$2() {
    if (hasRequiredDeleteAccount$2) return deleteAccount$2;
    hasRequiredDeleteAccount$2 = 1;
    Object.defineProperty(deleteAccount$2, "__esModule", { value: true });
    deleteAccount$2.InvalidTokenError = deleteAccount$2.ExpiredTokenError = void 0;
    deleteAccount$2.toKnownErr = toKnownErr;
    const xrpc_1 = requireDist$1();
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    class ExpiredTokenError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    deleteAccount$2.ExpiredTokenError = ExpiredTokenError;
    class InvalidTokenError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    deleteAccount$2.InvalidTokenError = InvalidTokenError;
    function toKnownErr(e) {
      if (e instanceof xrpc_1.XRPCError) {
        if (e.error === "ExpiredToken")
          return new ExpiredTokenError(e);
        if (e.error === "InvalidToken")
          return new InvalidTokenError(e);
      }
      return e;
    }
    return deleteAccount$2;
  }
  var getAccountInviteCodes = {};
  var hasRequiredGetAccountInviteCodes;
  function requireGetAccountInviteCodes() {
    if (hasRequiredGetAccountInviteCodes) return getAccountInviteCodes;
    hasRequiredGetAccountInviteCodes = 1;
    Object.defineProperty(getAccountInviteCodes, "__esModule", { value: true });
    getAccountInviteCodes.DuplicateCreateError = void 0;
    getAccountInviteCodes.toKnownErr = toKnownErr;
    const xrpc_1 = requireDist$1();
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    class DuplicateCreateError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    getAccountInviteCodes.DuplicateCreateError = DuplicateCreateError;
    function toKnownErr(e) {
      if (e instanceof xrpc_1.XRPCError) {
        if (e.error === "DuplicateCreate")
          return new DuplicateCreateError(e);
      }
      return e;
    }
    return getAccountInviteCodes;
  }
  var getServiceAuth = {};
  var hasRequiredGetServiceAuth;
  function requireGetServiceAuth() {
    if (hasRequiredGetServiceAuth) return getServiceAuth;
    hasRequiredGetServiceAuth = 1;
    Object.defineProperty(getServiceAuth, "__esModule", { value: true });
    getServiceAuth.BadExpirationError = void 0;
    getServiceAuth.toKnownErr = toKnownErr;
    const xrpc_1 = requireDist$1();
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    class BadExpirationError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    getServiceAuth.BadExpirationError = BadExpirationError;
    function toKnownErr(e) {
      if (e instanceof xrpc_1.XRPCError) {
        if (e.error === "BadExpiration")
          return new BadExpirationError(e);
      }
      return e;
    }
    return getServiceAuth;
  }
  var listAppPasswords = {};
  var hasRequiredListAppPasswords;
  function requireListAppPasswords() {
    if (hasRequiredListAppPasswords) return listAppPasswords;
    hasRequiredListAppPasswords = 1;
    Object.defineProperty(listAppPasswords, "__esModule", { value: true });
    listAppPasswords.AccountTakedownError = void 0;
    listAppPasswords.toKnownErr = toKnownErr;
    listAppPasswords.isAppPassword = isAppPassword;
    listAppPasswords.validateAppPassword = validateAppPassword;
    const xrpc_1 = requireDist$1();
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "com.atproto.server.listAppPasswords";
    class AccountTakedownError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    listAppPasswords.AccountTakedownError = AccountTakedownError;
    function toKnownErr(e) {
      if (e instanceof xrpc_1.XRPCError) {
        if (e.error === "AccountTakedown")
          return new AccountTakedownError(e);
      }
      return e;
    }
    const hashAppPassword = "appPassword";
    function isAppPassword(v) {
      return is$typed(v, id, hashAppPassword);
    }
    function validateAppPassword(v) {
      return validate(v, id, hashAppPassword);
    }
    return listAppPasswords;
  }
  var refreshSession = {};
  var hasRequiredRefreshSession;
  function requireRefreshSession() {
    if (hasRequiredRefreshSession) return refreshSession;
    hasRequiredRefreshSession = 1;
    Object.defineProperty(refreshSession, "__esModule", { value: true });
    refreshSession.AccountTakedownError = void 0;
    refreshSession.toKnownErr = toKnownErr;
    const xrpc_1 = requireDist$1();
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    class AccountTakedownError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    refreshSession.AccountTakedownError = AccountTakedownError;
    function toKnownErr(e) {
      if (e instanceof xrpc_1.XRPCError) {
        if (e.error === "AccountTakedown")
          return new AccountTakedownError(e);
      }
      return e;
    }
    return refreshSession;
  }
  var resetPassword = {};
  var hasRequiredResetPassword;
  function requireResetPassword() {
    if (hasRequiredResetPassword) return resetPassword;
    hasRequiredResetPassword = 1;
    Object.defineProperty(resetPassword, "__esModule", { value: true });
    resetPassword.InvalidTokenError = resetPassword.ExpiredTokenError = void 0;
    resetPassword.toKnownErr = toKnownErr;
    const xrpc_1 = requireDist$1();
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    class ExpiredTokenError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    resetPassword.ExpiredTokenError = ExpiredTokenError;
    class InvalidTokenError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    resetPassword.InvalidTokenError = InvalidTokenError;
    function toKnownErr(e) {
      if (e instanceof xrpc_1.XRPCError) {
        if (e.error === "ExpiredToken")
          return new ExpiredTokenError(e);
        if (e.error === "InvalidToken")
          return new InvalidTokenError(e);
      }
      return e;
    }
    return resetPassword;
  }
  var updateEmail = {};
  var hasRequiredUpdateEmail;
  function requireUpdateEmail() {
    if (hasRequiredUpdateEmail) return updateEmail;
    hasRequiredUpdateEmail = 1;
    Object.defineProperty(updateEmail, "__esModule", { value: true });
    updateEmail.TokenRequiredError = updateEmail.InvalidTokenError = updateEmail.ExpiredTokenError = void 0;
    updateEmail.toKnownErr = toKnownErr;
    const xrpc_1 = requireDist$1();
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    class ExpiredTokenError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    updateEmail.ExpiredTokenError = ExpiredTokenError;
    class InvalidTokenError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    updateEmail.InvalidTokenError = InvalidTokenError;
    class TokenRequiredError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    updateEmail.TokenRequiredError = TokenRequiredError;
    function toKnownErr(e) {
      if (e instanceof xrpc_1.XRPCError) {
        if (e.error === "ExpiredToken")
          return new ExpiredTokenError(e);
        if (e.error === "InvalidToken")
          return new InvalidTokenError(e);
        if (e.error === "TokenRequired")
          return new TokenRequiredError(e);
      }
      return e;
    }
    return updateEmail;
  }
  var getBlob = {};
  var hasRequiredGetBlob;
  function requireGetBlob() {
    if (hasRequiredGetBlob) return getBlob;
    hasRequiredGetBlob = 1;
    Object.defineProperty(getBlob, "__esModule", { value: true });
    getBlob.RepoDeactivatedError = getBlob.RepoSuspendedError = getBlob.RepoTakendownError = getBlob.RepoNotFoundError = getBlob.BlobNotFoundError = void 0;
    getBlob.toKnownErr = toKnownErr;
    const xrpc_1 = requireDist$1();
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    class BlobNotFoundError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    getBlob.BlobNotFoundError = BlobNotFoundError;
    class RepoNotFoundError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    getBlob.RepoNotFoundError = RepoNotFoundError;
    class RepoTakendownError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    getBlob.RepoTakendownError = RepoTakendownError;
    class RepoSuspendedError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    getBlob.RepoSuspendedError = RepoSuspendedError;
    class RepoDeactivatedError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    getBlob.RepoDeactivatedError = RepoDeactivatedError;
    function toKnownErr(e) {
      if (e instanceof xrpc_1.XRPCError) {
        if (e.error === "BlobNotFound")
          return new BlobNotFoundError(e);
        if (e.error === "RepoNotFound")
          return new RepoNotFoundError(e);
        if (e.error === "RepoTakendown")
          return new RepoTakendownError(e);
        if (e.error === "RepoSuspended")
          return new RepoSuspendedError(e);
        if (e.error === "RepoDeactivated")
          return new RepoDeactivatedError(e);
      }
      return e;
    }
    return getBlob;
  }
  var getBlocks$1 = {};
  var hasRequiredGetBlocks$1;
  function requireGetBlocks$1() {
    if (hasRequiredGetBlocks$1) return getBlocks$1;
    hasRequiredGetBlocks$1 = 1;
    Object.defineProperty(getBlocks$1, "__esModule", { value: true });
    getBlocks$1.RepoDeactivatedError = getBlocks$1.RepoSuspendedError = getBlocks$1.RepoTakendownError = getBlocks$1.RepoNotFoundError = getBlocks$1.BlockNotFoundError = void 0;
    getBlocks$1.toKnownErr = toKnownErr;
    const xrpc_1 = requireDist$1();
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    class BlockNotFoundError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    getBlocks$1.BlockNotFoundError = BlockNotFoundError;
    class RepoNotFoundError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    getBlocks$1.RepoNotFoundError = RepoNotFoundError;
    class RepoTakendownError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    getBlocks$1.RepoTakendownError = RepoTakendownError;
    class RepoSuspendedError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    getBlocks$1.RepoSuspendedError = RepoSuspendedError;
    class RepoDeactivatedError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    getBlocks$1.RepoDeactivatedError = RepoDeactivatedError;
    function toKnownErr(e) {
      if (e instanceof xrpc_1.XRPCError) {
        if (e.error === "BlockNotFound")
          return new BlockNotFoundError(e);
        if (e.error === "RepoNotFound")
          return new RepoNotFoundError(e);
        if (e.error === "RepoTakendown")
          return new RepoTakendownError(e);
        if (e.error === "RepoSuspended")
          return new RepoSuspendedError(e);
        if (e.error === "RepoDeactivated")
          return new RepoDeactivatedError(e);
      }
      return e;
    }
    return getBlocks$1;
  }
  var getHead = {};
  var hasRequiredGetHead;
  function requireGetHead() {
    if (hasRequiredGetHead) return getHead;
    hasRequiredGetHead = 1;
    Object.defineProperty(getHead, "__esModule", { value: true });
    getHead.HeadNotFoundError = void 0;
    getHead.toKnownErr = toKnownErr;
    const xrpc_1 = requireDist$1();
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    class HeadNotFoundError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    getHead.HeadNotFoundError = HeadNotFoundError;
    function toKnownErr(e) {
      if (e instanceof xrpc_1.XRPCError) {
        if (e.error === "HeadNotFound")
          return new HeadNotFoundError(e);
      }
      return e;
    }
    return getHead;
  }
  var getLatestCommit = {};
  var hasRequiredGetLatestCommit;
  function requireGetLatestCommit() {
    if (hasRequiredGetLatestCommit) return getLatestCommit;
    hasRequiredGetLatestCommit = 1;
    Object.defineProperty(getLatestCommit, "__esModule", { value: true });
    getLatestCommit.RepoDeactivatedError = getLatestCommit.RepoSuspendedError = getLatestCommit.RepoTakendownError = getLatestCommit.RepoNotFoundError = void 0;
    getLatestCommit.toKnownErr = toKnownErr;
    const xrpc_1 = requireDist$1();
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    class RepoNotFoundError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    getLatestCommit.RepoNotFoundError = RepoNotFoundError;
    class RepoTakendownError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    getLatestCommit.RepoTakendownError = RepoTakendownError;
    class RepoSuspendedError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    getLatestCommit.RepoSuspendedError = RepoSuspendedError;
    class RepoDeactivatedError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    getLatestCommit.RepoDeactivatedError = RepoDeactivatedError;
    function toKnownErr(e) {
      if (e instanceof xrpc_1.XRPCError) {
        if (e.error === "RepoNotFound")
          return new RepoNotFoundError(e);
        if (e.error === "RepoTakendown")
          return new RepoTakendownError(e);
        if (e.error === "RepoSuspended")
          return new RepoSuspendedError(e);
        if (e.error === "RepoDeactivated")
          return new RepoDeactivatedError(e);
      }
      return e;
    }
    return getLatestCommit;
  }
  var getRecord$1 = {};
  var hasRequiredGetRecord$1;
  function requireGetRecord$1() {
    if (hasRequiredGetRecord$1) return getRecord$1;
    hasRequiredGetRecord$1 = 1;
    Object.defineProperty(getRecord$1, "__esModule", { value: true });
    getRecord$1.RepoDeactivatedError = getRecord$1.RepoSuspendedError = getRecord$1.RepoTakendownError = getRecord$1.RepoNotFoundError = getRecord$1.RecordNotFoundError = void 0;
    getRecord$1.toKnownErr = toKnownErr;
    const xrpc_1 = requireDist$1();
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    class RecordNotFoundError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    getRecord$1.RecordNotFoundError = RecordNotFoundError;
    class RepoNotFoundError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    getRecord$1.RepoNotFoundError = RepoNotFoundError;
    class RepoTakendownError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    getRecord$1.RepoTakendownError = RepoTakendownError;
    class RepoSuspendedError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    getRecord$1.RepoSuspendedError = RepoSuspendedError;
    class RepoDeactivatedError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    getRecord$1.RepoDeactivatedError = RepoDeactivatedError;
    function toKnownErr(e) {
      if (e instanceof xrpc_1.XRPCError) {
        if (e.error === "RecordNotFound")
          return new RecordNotFoundError(e);
        if (e.error === "RepoNotFound")
          return new RepoNotFoundError(e);
        if (e.error === "RepoTakendown")
          return new RepoTakendownError(e);
        if (e.error === "RepoSuspended")
          return new RepoSuspendedError(e);
        if (e.error === "RepoDeactivated")
          return new RepoDeactivatedError(e);
      }
      return e;
    }
    return getRecord$1;
  }
  var getRepo$1 = {};
  var hasRequiredGetRepo$1;
  function requireGetRepo$1() {
    if (hasRequiredGetRepo$1) return getRepo$1;
    hasRequiredGetRepo$1 = 1;
    Object.defineProperty(getRepo$1, "__esModule", { value: true });
    getRepo$1.RepoDeactivatedError = getRepo$1.RepoSuspendedError = getRepo$1.RepoTakendownError = getRepo$1.RepoNotFoundError = void 0;
    getRepo$1.toKnownErr = toKnownErr;
    const xrpc_1 = requireDist$1();
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    class RepoNotFoundError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    getRepo$1.RepoNotFoundError = RepoNotFoundError;
    class RepoTakendownError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    getRepo$1.RepoTakendownError = RepoTakendownError;
    class RepoSuspendedError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    getRepo$1.RepoSuspendedError = RepoSuspendedError;
    class RepoDeactivatedError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    getRepo$1.RepoDeactivatedError = RepoDeactivatedError;
    function toKnownErr(e) {
      if (e instanceof xrpc_1.XRPCError) {
        if (e.error === "RepoNotFound")
          return new RepoNotFoundError(e);
        if (e.error === "RepoTakendown")
          return new RepoTakendownError(e);
        if (e.error === "RepoSuspended")
          return new RepoSuspendedError(e);
        if (e.error === "RepoDeactivated")
          return new RepoDeactivatedError(e);
      }
      return e;
    }
    return getRepo$1;
  }
  var getRepoStatus = {};
  var hasRequiredGetRepoStatus;
  function requireGetRepoStatus() {
    if (hasRequiredGetRepoStatus) return getRepoStatus;
    hasRequiredGetRepoStatus = 1;
    Object.defineProperty(getRepoStatus, "__esModule", { value: true });
    getRepoStatus.RepoNotFoundError = void 0;
    getRepoStatus.toKnownErr = toKnownErr;
    const xrpc_1 = requireDist$1();
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    class RepoNotFoundError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    getRepoStatus.RepoNotFoundError = RepoNotFoundError;
    function toKnownErr(e) {
      if (e instanceof xrpc_1.XRPCError) {
        if (e.error === "RepoNotFound")
          return new RepoNotFoundError(e);
      }
      return e;
    }
    return getRepoStatus;
  }
  var listBlobs = {};
  var hasRequiredListBlobs;
  function requireListBlobs() {
    if (hasRequiredListBlobs) return listBlobs;
    hasRequiredListBlobs = 1;
    Object.defineProperty(listBlobs, "__esModule", { value: true });
    listBlobs.RepoDeactivatedError = listBlobs.RepoSuspendedError = listBlobs.RepoTakendownError = listBlobs.RepoNotFoundError = void 0;
    listBlobs.toKnownErr = toKnownErr;
    const xrpc_1 = requireDist$1();
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    class RepoNotFoundError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    listBlobs.RepoNotFoundError = RepoNotFoundError;
    class RepoTakendownError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    listBlobs.RepoTakendownError = RepoTakendownError;
    class RepoSuspendedError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    listBlobs.RepoSuspendedError = RepoSuspendedError;
    class RepoDeactivatedError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    listBlobs.RepoDeactivatedError = RepoDeactivatedError;
    function toKnownErr(e) {
      if (e instanceof xrpc_1.XRPCError) {
        if (e.error === "RepoNotFound")
          return new RepoNotFoundError(e);
        if (e.error === "RepoTakendown")
          return new RepoTakendownError(e);
        if (e.error === "RepoSuspended")
          return new RepoSuspendedError(e);
        if (e.error === "RepoDeactivated")
          return new RepoDeactivatedError(e);
      }
      return e;
    }
    return listBlobs;
  }
  var getActorLikes = {};
  var hasRequiredGetActorLikes;
  function requireGetActorLikes() {
    if (hasRequiredGetActorLikes) return getActorLikes;
    hasRequiredGetActorLikes = 1;
    Object.defineProperty(getActorLikes, "__esModule", { value: true });
    getActorLikes.BlockedByActorError = getActorLikes.BlockedActorError = void 0;
    getActorLikes.toKnownErr = toKnownErr;
    const xrpc_1 = requireDist$1();
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    class BlockedActorError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    getActorLikes.BlockedActorError = BlockedActorError;
    class BlockedByActorError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    getActorLikes.BlockedByActorError = BlockedByActorError;
    function toKnownErr(e) {
      if (e instanceof xrpc_1.XRPCError) {
        if (e.error === "BlockedActor")
          return new BlockedActorError(e);
        if (e.error === "BlockedByActor")
          return new BlockedByActorError(e);
      }
      return e;
    }
    return getActorLikes;
  }
  var getAuthorFeed = {};
  var hasRequiredGetAuthorFeed;
  function requireGetAuthorFeed() {
    if (hasRequiredGetAuthorFeed) return getAuthorFeed;
    hasRequiredGetAuthorFeed = 1;
    Object.defineProperty(getAuthorFeed, "__esModule", { value: true });
    getAuthorFeed.BlockedByActorError = getAuthorFeed.BlockedActorError = void 0;
    getAuthorFeed.toKnownErr = toKnownErr;
    const xrpc_1 = requireDist$1();
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    class BlockedActorError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    getAuthorFeed.BlockedActorError = BlockedActorError;
    class BlockedByActorError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    getAuthorFeed.BlockedByActorError = BlockedByActorError;
    function toKnownErr(e) {
      if (e instanceof xrpc_1.XRPCError) {
        if (e.error === "BlockedActor")
          return new BlockedActorError(e);
        if (e.error === "BlockedByActor")
          return new BlockedByActorError(e);
      }
      return e;
    }
    return getAuthorFeed;
  }
  var getFeed = {};
  var hasRequiredGetFeed;
  function requireGetFeed() {
    if (hasRequiredGetFeed) return getFeed;
    hasRequiredGetFeed = 1;
    Object.defineProperty(getFeed, "__esModule", { value: true });
    getFeed.UnknownFeedError = void 0;
    getFeed.toKnownErr = toKnownErr;
    const xrpc_1 = requireDist$1();
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    class UnknownFeedError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    getFeed.UnknownFeedError = UnknownFeedError;
    function toKnownErr(e) {
      if (e instanceof xrpc_1.XRPCError) {
        if (e.error === "UnknownFeed")
          return new UnknownFeedError(e);
      }
      return e;
    }
    return getFeed;
  }
  var getFeedSkeleton = {};
  var hasRequiredGetFeedSkeleton;
  function requireGetFeedSkeleton() {
    if (hasRequiredGetFeedSkeleton) return getFeedSkeleton;
    hasRequiredGetFeedSkeleton = 1;
    Object.defineProperty(getFeedSkeleton, "__esModule", { value: true });
    getFeedSkeleton.UnknownFeedError = void 0;
    getFeedSkeleton.toKnownErr = toKnownErr;
    const xrpc_1 = requireDist$1();
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    class UnknownFeedError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    getFeedSkeleton.UnknownFeedError = UnknownFeedError;
    function toKnownErr(e) {
      if (e instanceof xrpc_1.XRPCError) {
        if (e.error === "UnknownFeed")
          return new UnknownFeedError(e);
      }
      return e;
    }
    return getFeedSkeleton;
  }
  var getListFeed = {};
  var hasRequiredGetListFeed;
  function requireGetListFeed() {
    if (hasRequiredGetListFeed) return getListFeed;
    hasRequiredGetListFeed = 1;
    Object.defineProperty(getListFeed, "__esModule", { value: true });
    getListFeed.UnknownListError = void 0;
    getListFeed.toKnownErr = toKnownErr;
    const xrpc_1 = requireDist$1();
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    class UnknownListError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    getListFeed.UnknownListError = UnknownListError;
    function toKnownErr(e) {
      if (e instanceof xrpc_1.XRPCError) {
        if (e.error === "UnknownList")
          return new UnknownListError(e);
      }
      return e;
    }
    return getListFeed;
  }
  var getPostThread = {};
  var hasRequiredGetPostThread;
  function requireGetPostThread() {
    if (hasRequiredGetPostThread) return getPostThread;
    hasRequiredGetPostThread = 1;
    Object.defineProperty(getPostThread, "__esModule", { value: true });
    getPostThread.NotFoundError = void 0;
    getPostThread.toKnownErr = toKnownErr;
    const xrpc_1 = requireDist$1();
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    class NotFoundError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    getPostThread.NotFoundError = NotFoundError;
    function toKnownErr(e) {
      if (e instanceof xrpc_1.XRPCError) {
        if (e.error === "NotFound")
          return new NotFoundError(e);
      }
      return e;
    }
    return getPostThread;
  }
  var searchPosts = {};
  var hasRequiredSearchPosts;
  function requireSearchPosts() {
    if (hasRequiredSearchPosts) return searchPosts;
    hasRequiredSearchPosts = 1;
    Object.defineProperty(searchPosts, "__esModule", { value: true });
    searchPosts.BadQueryStringError = void 0;
    searchPosts.toKnownErr = toKnownErr;
    const xrpc_1 = requireDist$1();
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    class BadQueryStringError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    searchPosts.BadQueryStringError = BadQueryStringError;
    function toKnownErr(e) {
      if (e instanceof xrpc_1.XRPCError) {
        if (e.error === "BadQueryString")
          return new BadQueryStringError(e);
      }
      return e;
    }
    return searchPosts;
  }
  var getRelationships = {};
  var hasRequiredGetRelationships;
  function requireGetRelationships() {
    if (hasRequiredGetRelationships) return getRelationships;
    hasRequiredGetRelationships = 1;
    Object.defineProperty(getRelationships, "__esModule", { value: true });
    getRelationships.ActorNotFoundError = void 0;
    getRelationships.toKnownErr = toKnownErr;
    const xrpc_1 = requireDist$1();
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    class ActorNotFoundError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    getRelationships.ActorNotFoundError = ActorNotFoundError;
    function toKnownErr(e) {
      if (e instanceof xrpc_1.XRPCError) {
        if (e.error === "ActorNotFound")
          return new ActorNotFoundError(e);
      }
      return e;
    }
    return getRelationships;
  }
  var searchActorsSkeleton = {};
  var hasRequiredSearchActorsSkeleton;
  function requireSearchActorsSkeleton() {
    if (hasRequiredSearchActorsSkeleton) return searchActorsSkeleton;
    hasRequiredSearchActorsSkeleton = 1;
    Object.defineProperty(searchActorsSkeleton, "__esModule", { value: true });
    searchActorsSkeleton.BadQueryStringError = void 0;
    searchActorsSkeleton.toKnownErr = toKnownErr;
    const xrpc_1 = requireDist$1();
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    class BadQueryStringError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    searchActorsSkeleton.BadQueryStringError = BadQueryStringError;
    function toKnownErr(e) {
      if (e instanceof xrpc_1.XRPCError) {
        if (e.error === "BadQueryString")
          return new BadQueryStringError(e);
      }
      return e;
    }
    return searchActorsSkeleton;
  }
  var searchPostsSkeleton = {};
  var hasRequiredSearchPostsSkeleton;
  function requireSearchPostsSkeleton() {
    if (hasRequiredSearchPostsSkeleton) return searchPostsSkeleton;
    hasRequiredSearchPostsSkeleton = 1;
    Object.defineProperty(searchPostsSkeleton, "__esModule", { value: true });
    searchPostsSkeleton.BadQueryStringError = void 0;
    searchPostsSkeleton.toKnownErr = toKnownErr;
    const xrpc_1 = requireDist$1();
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    class BadQueryStringError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    searchPostsSkeleton.BadQueryStringError = BadQueryStringError;
    function toKnownErr(e) {
      if (e instanceof xrpc_1.XRPCError) {
        if (e.error === "BadQueryString")
          return new BadQueryStringError(e);
      }
      return e;
    }
    return searchPostsSkeleton;
  }
  var searchStarterPacksSkeleton = {};
  var hasRequiredSearchStarterPacksSkeleton;
  function requireSearchStarterPacksSkeleton() {
    if (hasRequiredSearchStarterPacksSkeleton) return searchStarterPacksSkeleton;
    hasRequiredSearchStarterPacksSkeleton = 1;
    Object.defineProperty(searchStarterPacksSkeleton, "__esModule", { value: true });
    searchStarterPacksSkeleton.BadQueryStringError = void 0;
    searchStarterPacksSkeleton.toKnownErr = toKnownErr;
    const xrpc_1 = requireDist$1();
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    class BadQueryStringError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    searchStarterPacksSkeleton.BadQueryStringError = BadQueryStringError;
    function toKnownErr(e) {
      if (e instanceof xrpc_1.XRPCError) {
        if (e.error === "BadQueryString")
          return new BadQueryStringError(e);
      }
      return e;
    }
    return searchStarterPacksSkeleton;
  }
  var createTemplate = {};
  var hasRequiredCreateTemplate;
  function requireCreateTemplate() {
    if (hasRequiredCreateTemplate) return createTemplate;
    hasRequiredCreateTemplate = 1;
    Object.defineProperty(createTemplate, "__esModule", { value: true });
    createTemplate.DuplicateTemplateNameError = void 0;
    createTemplate.toKnownErr = toKnownErr;
    const xrpc_1 = requireDist$1();
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    class DuplicateTemplateNameError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    createTemplate.DuplicateTemplateNameError = DuplicateTemplateNameError;
    function toKnownErr(e) {
      if (e instanceof xrpc_1.XRPCError) {
        if (e.error === "DuplicateTemplateName")
          return new DuplicateTemplateNameError(e);
      }
      return e;
    }
    return createTemplate;
  }
  var updateTemplate = {};
  var hasRequiredUpdateTemplate;
  function requireUpdateTemplate() {
    if (hasRequiredUpdateTemplate) return updateTemplate;
    hasRequiredUpdateTemplate = 1;
    Object.defineProperty(updateTemplate, "__esModule", { value: true });
    updateTemplate.DuplicateTemplateNameError = void 0;
    updateTemplate.toKnownErr = toKnownErr;
    const xrpc_1 = requireDist$1();
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    class DuplicateTemplateNameError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    updateTemplate.DuplicateTemplateNameError = DuplicateTemplateNameError;
    function toKnownErr(e) {
      if (e instanceof xrpc_1.XRPCError) {
        if (e.error === "DuplicateTemplateName")
          return new DuplicateTemplateNameError(e);
      }
      return e;
    }
    return updateTemplate;
  }
  var emitEvent = {};
  var hasRequiredEmitEvent;
  function requireEmitEvent() {
    if (hasRequiredEmitEvent) return emitEvent;
    hasRequiredEmitEvent = 1;
    Object.defineProperty(emitEvent, "__esModule", { value: true });
    emitEvent.SubjectHasActionError = void 0;
    emitEvent.toKnownErr = toKnownErr;
    const xrpc_1 = requireDist$1();
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    class SubjectHasActionError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    emitEvent.SubjectHasActionError = SubjectHasActionError;
    function toKnownErr(e) {
      if (e instanceof xrpc_1.XRPCError) {
        if (e.error === "SubjectHasAction")
          return new SubjectHasActionError(e);
      }
      return e;
    }
    return emitEvent;
  }
  var getRecord = {};
  var hasRequiredGetRecord;
  function requireGetRecord() {
    if (hasRequiredGetRecord) return getRecord;
    hasRequiredGetRecord = 1;
    Object.defineProperty(getRecord, "__esModule", { value: true });
    getRecord.RecordNotFoundError = void 0;
    getRecord.toKnownErr = toKnownErr;
    const xrpc_1 = requireDist$1();
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    class RecordNotFoundError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    getRecord.RecordNotFoundError = RecordNotFoundError;
    function toKnownErr(e) {
      if (e instanceof xrpc_1.XRPCError) {
        if (e.error === "RecordNotFound")
          return new RecordNotFoundError(e);
      }
      return e;
    }
    return getRecord;
  }
  var getRepo = {};
  var hasRequiredGetRepo;
  function requireGetRepo() {
    if (hasRequiredGetRepo) return getRepo;
    hasRequiredGetRepo = 1;
    Object.defineProperty(getRepo, "__esModule", { value: true });
    getRepo.RepoNotFoundError = void 0;
    getRepo.toKnownErr = toKnownErr;
    const xrpc_1 = requireDist$1();
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    class RepoNotFoundError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    getRepo.RepoNotFoundError = RepoNotFoundError;
    function toKnownErr(e) {
      if (e instanceof xrpc_1.XRPCError) {
        if (e.error === "RepoNotFound")
          return new RepoNotFoundError(e);
      }
      return e;
    }
    return getRepo;
  }
  var deleteSet = {};
  var hasRequiredDeleteSet;
  function requireDeleteSet() {
    if (hasRequiredDeleteSet) return deleteSet;
    hasRequiredDeleteSet = 1;
    Object.defineProperty(deleteSet, "__esModule", { value: true });
    deleteSet.SetNotFoundError = void 0;
    deleteSet.toKnownErr = toKnownErr;
    const xrpc_1 = requireDist$1();
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    class SetNotFoundError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    deleteSet.SetNotFoundError = SetNotFoundError;
    function toKnownErr(e) {
      if (e instanceof xrpc_1.XRPCError) {
        if (e.error === "SetNotFound")
          return new SetNotFoundError(e);
      }
      return e;
    }
    return deleteSet;
  }
  var deleteValues = {};
  var hasRequiredDeleteValues;
  function requireDeleteValues() {
    if (hasRequiredDeleteValues) return deleteValues;
    hasRequiredDeleteValues = 1;
    Object.defineProperty(deleteValues, "__esModule", { value: true });
    deleteValues.SetNotFoundError = void 0;
    deleteValues.toKnownErr = toKnownErr;
    const xrpc_1 = requireDist$1();
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    class SetNotFoundError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    deleteValues.SetNotFoundError = SetNotFoundError;
    function toKnownErr(e) {
      if (e instanceof xrpc_1.XRPCError) {
        if (e.error === "SetNotFound")
          return new SetNotFoundError(e);
      }
      return e;
    }
    return deleteValues;
  }
  var getValues = {};
  var hasRequiredGetValues;
  function requireGetValues() {
    if (hasRequiredGetValues) return getValues;
    hasRequiredGetValues = 1;
    Object.defineProperty(getValues, "__esModule", { value: true });
    getValues.SetNotFoundError = void 0;
    getValues.toKnownErr = toKnownErr;
    const xrpc_1 = requireDist$1();
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    class SetNotFoundError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    getValues.SetNotFoundError = SetNotFoundError;
    function toKnownErr(e) {
      if (e instanceof xrpc_1.XRPCError) {
        if (e.error === "SetNotFound")
          return new SetNotFoundError(e);
      }
      return e;
    }
    return getValues;
  }
  var addMember = {};
  var hasRequiredAddMember;
  function requireAddMember() {
    if (hasRequiredAddMember) return addMember;
    hasRequiredAddMember = 1;
    Object.defineProperty(addMember, "__esModule", { value: true });
    addMember.MemberAlreadyExistsError = void 0;
    addMember.toKnownErr = toKnownErr;
    const xrpc_1 = requireDist$1();
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    class MemberAlreadyExistsError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    addMember.MemberAlreadyExistsError = MemberAlreadyExistsError;
    function toKnownErr(e) {
      if (e instanceof xrpc_1.XRPCError) {
        if (e.error === "MemberAlreadyExists")
          return new MemberAlreadyExistsError(e);
      }
      return e;
    }
    return addMember;
  }
  var deleteMember = {};
  var hasRequiredDeleteMember;
  function requireDeleteMember() {
    if (hasRequiredDeleteMember) return deleteMember;
    hasRequiredDeleteMember = 1;
    Object.defineProperty(deleteMember, "__esModule", { value: true });
    deleteMember.CannotDeleteSelfError = deleteMember.MemberNotFoundError = void 0;
    deleteMember.toKnownErr = toKnownErr;
    const xrpc_1 = requireDist$1();
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    class MemberNotFoundError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    deleteMember.MemberNotFoundError = MemberNotFoundError;
    class CannotDeleteSelfError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    deleteMember.CannotDeleteSelfError = CannotDeleteSelfError;
    function toKnownErr(e) {
      if (e instanceof xrpc_1.XRPCError) {
        if (e.error === "MemberNotFound")
          return new MemberNotFoundError(e);
        if (e.error === "CannotDeleteSelf")
          return new CannotDeleteSelfError(e);
      }
      return e;
    }
    return deleteMember;
  }
  var updateMember = {};
  var hasRequiredUpdateMember;
  function requireUpdateMember() {
    if (hasRequiredUpdateMember) return updateMember;
    hasRequiredUpdateMember = 1;
    Object.defineProperty(updateMember, "__esModule", { value: true });
    updateMember.MemberNotFoundError = void 0;
    updateMember.toKnownErr = toKnownErr;
    const xrpc_1 = requireDist$1();
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    class MemberNotFoundError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    updateMember.MemberNotFoundError = MemberNotFoundError;
    function toKnownErr(e) {
      if (e instanceof xrpc_1.XRPCError) {
        if (e.error === "MemberNotFound")
          return new MemberNotFoundError(e);
      }
      return e;
    }
    return updateMember;
  }
  var defs$j = {};
  var hasRequiredDefs$j;
  function requireDefs$j() {
    if (hasRequiredDefs$j) return defs$j;
    hasRequiredDefs$j = 1;
    Object.defineProperty(defs$j, "__esModule", { value: true });
    defs$j.isStatusAttr = isStatusAttr;
    defs$j.validateStatusAttr = validateStatusAttr;
    defs$j.isAccountView = isAccountView;
    defs$j.validateAccountView = validateAccountView;
    defs$j.isRepoRef = isRepoRef;
    defs$j.validateRepoRef = validateRepoRef;
    defs$j.isRepoBlobRef = isRepoBlobRef;
    defs$j.validateRepoBlobRef = validateRepoBlobRef;
    defs$j.isThreatSignature = isThreatSignature;
    defs$j.validateThreatSignature = validateThreatSignature;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "com.atproto.admin.defs";
    const hashStatusAttr = "statusAttr";
    function isStatusAttr(v) {
      return is$typed(v, id, hashStatusAttr);
    }
    function validateStatusAttr(v) {
      return validate(v, id, hashStatusAttr);
    }
    const hashAccountView = "accountView";
    function isAccountView(v) {
      return is$typed(v, id, hashAccountView);
    }
    function validateAccountView(v) {
      return validate(v, id, hashAccountView);
    }
    const hashRepoRef = "repoRef";
    function isRepoRef(v) {
      return is$typed(v, id, hashRepoRef);
    }
    function validateRepoRef(v) {
      return validate(v, id, hashRepoRef);
    }
    const hashRepoBlobRef = "repoBlobRef";
    function isRepoBlobRef(v) {
      return is$typed(v, id, hashRepoBlobRef);
    }
    function validateRepoBlobRef(v) {
      return validate(v, id, hashRepoBlobRef);
    }
    const hashThreatSignature = "threatSignature";
    function isThreatSignature(v) {
      return is$typed(v, id, hashThreatSignature);
    }
    function validateThreatSignature(v) {
      return validate(v, id, hashThreatSignature);
    }
    return defs$j;
  }
  var deleteAccount$1 = {};
  var hasRequiredDeleteAccount$1;
  function requireDeleteAccount$1() {
    if (hasRequiredDeleteAccount$1) return deleteAccount$1;
    hasRequiredDeleteAccount$1 = 1;
    Object.defineProperty(deleteAccount$1, "__esModule", { value: true });
    deleteAccount$1.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return deleteAccount$1;
  }
  var disableAccountInvites = {};
  var hasRequiredDisableAccountInvites;
  function requireDisableAccountInvites() {
    if (hasRequiredDisableAccountInvites) return disableAccountInvites;
    hasRequiredDisableAccountInvites = 1;
    Object.defineProperty(disableAccountInvites, "__esModule", { value: true });
    disableAccountInvites.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return disableAccountInvites;
  }
  var disableInviteCodes = {};
  var hasRequiredDisableInviteCodes;
  function requireDisableInviteCodes() {
    if (hasRequiredDisableInviteCodes) return disableInviteCodes;
    hasRequiredDisableInviteCodes = 1;
    Object.defineProperty(disableInviteCodes, "__esModule", { value: true });
    disableInviteCodes.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return disableInviteCodes;
  }
  var enableAccountInvites = {};
  var hasRequiredEnableAccountInvites;
  function requireEnableAccountInvites() {
    if (hasRequiredEnableAccountInvites) return enableAccountInvites;
    hasRequiredEnableAccountInvites = 1;
    Object.defineProperty(enableAccountInvites, "__esModule", { value: true });
    enableAccountInvites.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return enableAccountInvites;
  }
  var getAccountInfo = {};
  var hasRequiredGetAccountInfo;
  function requireGetAccountInfo() {
    if (hasRequiredGetAccountInfo) return getAccountInfo;
    hasRequiredGetAccountInfo = 1;
    Object.defineProperty(getAccountInfo, "__esModule", { value: true });
    getAccountInfo.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return getAccountInfo;
  }
  var getAccountInfos = {};
  var hasRequiredGetAccountInfos;
  function requireGetAccountInfos() {
    if (hasRequiredGetAccountInfos) return getAccountInfos;
    hasRequiredGetAccountInfos = 1;
    Object.defineProperty(getAccountInfos, "__esModule", { value: true });
    getAccountInfos.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return getAccountInfos;
  }
  var getInviteCodes = {};
  var hasRequiredGetInviteCodes;
  function requireGetInviteCodes() {
    if (hasRequiredGetInviteCodes) return getInviteCodes;
    hasRequiredGetInviteCodes = 1;
    Object.defineProperty(getInviteCodes, "__esModule", { value: true });
    getInviteCodes.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return getInviteCodes;
  }
  var getSubjectStatus = {};
  var hasRequiredGetSubjectStatus;
  function requireGetSubjectStatus() {
    if (hasRequiredGetSubjectStatus) return getSubjectStatus;
    hasRequiredGetSubjectStatus = 1;
    Object.defineProperty(getSubjectStatus, "__esModule", { value: true });
    getSubjectStatus.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return getSubjectStatus;
  }
  var searchAccounts$1 = {};
  var hasRequiredSearchAccounts$1;
  function requireSearchAccounts$1() {
    if (hasRequiredSearchAccounts$1) return searchAccounts$1;
    hasRequiredSearchAccounts$1 = 1;
    Object.defineProperty(searchAccounts$1, "__esModule", { value: true });
    searchAccounts$1.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return searchAccounts$1;
  }
  var sendEmail = {};
  var hasRequiredSendEmail;
  function requireSendEmail() {
    if (hasRequiredSendEmail) return sendEmail;
    hasRequiredSendEmail = 1;
    Object.defineProperty(sendEmail, "__esModule", { value: true });
    sendEmail.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return sendEmail;
  }
  var updateAccountEmail = {};
  var hasRequiredUpdateAccountEmail;
  function requireUpdateAccountEmail() {
    if (hasRequiredUpdateAccountEmail) return updateAccountEmail;
    hasRequiredUpdateAccountEmail = 1;
    Object.defineProperty(updateAccountEmail, "__esModule", { value: true });
    updateAccountEmail.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return updateAccountEmail;
  }
  var updateAccountHandle = {};
  var hasRequiredUpdateAccountHandle;
  function requireUpdateAccountHandle() {
    if (hasRequiredUpdateAccountHandle) return updateAccountHandle;
    hasRequiredUpdateAccountHandle = 1;
    Object.defineProperty(updateAccountHandle, "__esModule", { value: true });
    updateAccountHandle.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return updateAccountHandle;
  }
  var updateAccountPassword = {};
  var hasRequiredUpdateAccountPassword;
  function requireUpdateAccountPassword() {
    if (hasRequiredUpdateAccountPassword) return updateAccountPassword;
    hasRequiredUpdateAccountPassword = 1;
    Object.defineProperty(updateAccountPassword, "__esModule", { value: true });
    updateAccountPassword.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return updateAccountPassword;
  }
  var updateSubjectStatus = {};
  var hasRequiredUpdateSubjectStatus;
  function requireUpdateSubjectStatus() {
    if (hasRequiredUpdateSubjectStatus) return updateSubjectStatus;
    hasRequiredUpdateSubjectStatus = 1;
    Object.defineProperty(updateSubjectStatus, "__esModule", { value: true });
    updateSubjectStatus.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return updateSubjectStatus;
  }
  var getRecommendedDidCredentials = {};
  var hasRequiredGetRecommendedDidCredentials;
  function requireGetRecommendedDidCredentials() {
    if (hasRequiredGetRecommendedDidCredentials) return getRecommendedDidCredentials;
    hasRequiredGetRecommendedDidCredentials = 1;
    Object.defineProperty(getRecommendedDidCredentials, "__esModule", { value: true });
    getRecommendedDidCredentials.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return getRecommendedDidCredentials;
  }
  var requestPlcOperationSignature = {};
  var hasRequiredRequestPlcOperationSignature;
  function requireRequestPlcOperationSignature() {
    if (hasRequiredRequestPlcOperationSignature) return requestPlcOperationSignature;
    hasRequiredRequestPlcOperationSignature = 1;
    Object.defineProperty(requestPlcOperationSignature, "__esModule", { value: true });
    requestPlcOperationSignature.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return requestPlcOperationSignature;
  }
  var resolveHandle = {};
  var hasRequiredResolveHandle;
  function requireResolveHandle() {
    if (hasRequiredResolveHandle) return resolveHandle;
    hasRequiredResolveHandle = 1;
    Object.defineProperty(resolveHandle, "__esModule", { value: true });
    resolveHandle.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return resolveHandle;
  }
  var signPlcOperation = {};
  var hasRequiredSignPlcOperation;
  function requireSignPlcOperation() {
    if (hasRequiredSignPlcOperation) return signPlcOperation;
    hasRequiredSignPlcOperation = 1;
    Object.defineProperty(signPlcOperation, "__esModule", { value: true });
    signPlcOperation.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return signPlcOperation;
  }
  var submitPlcOperation = {};
  var hasRequiredSubmitPlcOperation;
  function requireSubmitPlcOperation() {
    if (hasRequiredSubmitPlcOperation) return submitPlcOperation;
    hasRequiredSubmitPlcOperation = 1;
    Object.defineProperty(submitPlcOperation, "__esModule", { value: true });
    submitPlcOperation.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return submitPlcOperation;
  }
  var updateHandle = {};
  var hasRequiredUpdateHandle;
  function requireUpdateHandle() {
    if (hasRequiredUpdateHandle) return updateHandle;
    hasRequiredUpdateHandle = 1;
    Object.defineProperty(updateHandle, "__esModule", { value: true });
    updateHandle.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return updateHandle;
  }
  var defs$i = {};
  var hasRequiredDefs$i;
  function requireDefs$i() {
    if (hasRequiredDefs$i) return defs$i;
    hasRequiredDefs$i = 1;
    Object.defineProperty(defs$i, "__esModule", { value: true });
    defs$i.isLabel = isLabel;
    defs$i.validateLabel = validateLabel;
    defs$i.isSelfLabels = isSelfLabels;
    defs$i.validateSelfLabels = validateSelfLabels;
    defs$i.isSelfLabel = isSelfLabel;
    defs$i.validateSelfLabel = validateSelfLabel;
    defs$i.isLabelValueDefinition = isLabelValueDefinition;
    defs$i.validateLabelValueDefinition = validateLabelValueDefinition;
    defs$i.isLabelValueDefinitionStrings = isLabelValueDefinitionStrings;
    defs$i.validateLabelValueDefinitionStrings = validateLabelValueDefinitionStrings;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "com.atproto.label.defs";
    const hashLabel = "label";
    function isLabel(v) {
      return is$typed(v, id, hashLabel);
    }
    function validateLabel(v) {
      return validate(v, id, hashLabel);
    }
    const hashSelfLabels = "selfLabels";
    function isSelfLabels(v) {
      return is$typed(v, id, hashSelfLabels);
    }
    function validateSelfLabels(v) {
      return validate(v, id, hashSelfLabels);
    }
    const hashSelfLabel = "selfLabel";
    function isSelfLabel(v) {
      return is$typed(v, id, hashSelfLabel);
    }
    function validateSelfLabel(v) {
      return validate(v, id, hashSelfLabel);
    }
    const hashLabelValueDefinition = "labelValueDefinition";
    function isLabelValueDefinition(v) {
      return is$typed(v, id, hashLabelValueDefinition);
    }
    function validateLabelValueDefinition(v) {
      return validate(v, id, hashLabelValueDefinition);
    }
    const hashLabelValueDefinitionStrings = "labelValueDefinitionStrings";
    function isLabelValueDefinitionStrings(v) {
      return is$typed(v, id, hashLabelValueDefinitionStrings);
    }
    function validateLabelValueDefinitionStrings(v) {
      return validate(v, id, hashLabelValueDefinitionStrings);
    }
    return defs$i;
  }
  var queryLabels = {};
  var hasRequiredQueryLabels;
  function requireQueryLabels() {
    if (hasRequiredQueryLabels) return queryLabels;
    hasRequiredQueryLabels = 1;
    Object.defineProperty(queryLabels, "__esModule", { value: true });
    queryLabels.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return queryLabels;
  }
  var subscribeLabels = {};
  var hasRequiredSubscribeLabels;
  function requireSubscribeLabels() {
    if (hasRequiredSubscribeLabels) return subscribeLabels;
    hasRequiredSubscribeLabels = 1;
    Object.defineProperty(subscribeLabels, "__esModule", { value: true });
    subscribeLabels.isLabels = isLabels;
    subscribeLabels.validateLabels = validateLabels;
    subscribeLabels.isInfo = isInfo;
    subscribeLabels.validateInfo = validateInfo;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "com.atproto.label.subscribeLabels";
    const hashLabels = "labels";
    function isLabels(v) {
      return is$typed(v, id, hashLabels);
    }
    function validateLabels(v) {
      return validate(v, id, hashLabels);
    }
    const hashInfo = "info";
    function isInfo(v) {
      return is$typed(v, id, hashInfo);
    }
    function validateInfo(v) {
      return validate(v, id, hashInfo);
    }
    return subscribeLabels;
  }
  var schema = {};
  var hasRequiredSchema;
  function requireSchema() {
    if (hasRequiredSchema) return schema;
    hasRequiredSchema = 1;
    Object.defineProperty(schema, "__esModule", { value: true });
    schema.isRecord = isRecord;
    schema.validateRecord = validateRecord;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "com.atproto.lexicon.schema";
    const hashRecord = "main";
    function isRecord(v) {
      return is$typed(v, id, hashRecord);
    }
    function validateRecord(v) {
      return validate(v, id, hashRecord, true);
    }
    return schema;
  }
  var createReport = {};
  var hasRequiredCreateReport;
  function requireCreateReport() {
    if (hasRequiredCreateReport) return createReport;
    hasRequiredCreateReport = 1;
    Object.defineProperty(createReport, "__esModule", { value: true });
    createReport.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return createReport;
  }
  var defs$h = {};
  var hasRequiredDefs$h;
  function requireDefs$h() {
    if (hasRequiredDefs$h) return defs$h;
    hasRequiredDefs$h = 1;
    Object.defineProperty(defs$h, "__esModule", { value: true });
    defs$h.REASONAPPEAL = defs$h.REASONOTHER = defs$h.REASONRUDE = defs$h.REASONSEXUAL = defs$h.REASONMISLEADING = defs$h.REASONVIOLATION = defs$h.REASONSPAM = void 0;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    const id = "com.atproto.moderation.defs";
    defs$h.REASONSPAM = `${id}#reasonSpam`;
    defs$h.REASONVIOLATION = `${id}#reasonViolation`;
    defs$h.REASONMISLEADING = `${id}#reasonMisleading`;
    defs$h.REASONSEXUAL = `${id}#reasonSexual`;
    defs$h.REASONRUDE = `${id}#reasonRude`;
    defs$h.REASONOTHER = `${id}#reasonOther`;
    defs$h.REASONAPPEAL = `${id}#reasonAppeal`;
    return defs$h;
  }
  var defs$g = {};
  var hasRequiredDefs$g;
  function requireDefs$g() {
    if (hasRequiredDefs$g) return defs$g;
    hasRequiredDefs$g = 1;
    Object.defineProperty(defs$g, "__esModule", { value: true });
    defs$g.isCommitMeta = isCommitMeta;
    defs$g.validateCommitMeta = validateCommitMeta;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "com.atproto.repo.defs";
    const hashCommitMeta = "commitMeta";
    function isCommitMeta(v) {
      return is$typed(v, id, hashCommitMeta);
    }
    function validateCommitMeta(v) {
      return validate(v, id, hashCommitMeta);
    }
    return defs$g;
  }
  var describeRepo = {};
  var hasRequiredDescribeRepo;
  function requireDescribeRepo() {
    if (hasRequiredDescribeRepo) return describeRepo;
    hasRequiredDescribeRepo = 1;
    Object.defineProperty(describeRepo, "__esModule", { value: true });
    describeRepo.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return describeRepo;
  }
  var importRepo = {};
  var hasRequiredImportRepo;
  function requireImportRepo() {
    if (hasRequiredImportRepo) return importRepo;
    hasRequiredImportRepo = 1;
    Object.defineProperty(importRepo, "__esModule", { value: true });
    importRepo.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return importRepo;
  }
  var listMissingBlobs = {};
  var hasRequiredListMissingBlobs;
  function requireListMissingBlobs() {
    if (hasRequiredListMissingBlobs) return listMissingBlobs;
    hasRequiredListMissingBlobs = 1;
    Object.defineProperty(listMissingBlobs, "__esModule", { value: true });
    listMissingBlobs.toKnownErr = toKnownErr;
    listMissingBlobs.isRecordBlob = isRecordBlob;
    listMissingBlobs.validateRecordBlob = validateRecordBlob;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "com.atproto.repo.listMissingBlobs";
    function toKnownErr(e) {
      return e;
    }
    const hashRecordBlob = "recordBlob";
    function isRecordBlob(v) {
      return is$typed(v, id, hashRecordBlob);
    }
    function validateRecordBlob(v) {
      return validate(v, id, hashRecordBlob);
    }
    return listMissingBlobs;
  }
  var listRecords = {};
  var hasRequiredListRecords;
  function requireListRecords() {
    if (hasRequiredListRecords) return listRecords;
    hasRequiredListRecords = 1;
    Object.defineProperty(listRecords, "__esModule", { value: true });
    listRecords.toKnownErr = toKnownErr;
    listRecords.isRecord = isRecord;
    listRecords.validateRecord = validateRecord;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "com.atproto.repo.listRecords";
    function toKnownErr(e) {
      return e;
    }
    const hashRecord = "record";
    function isRecord(v) {
      return is$typed(v, id, hashRecord);
    }
    function validateRecord(v) {
      return validate(v, id, hashRecord);
    }
    return listRecords;
  }
  var strongRef = {};
  var hasRequiredStrongRef;
  function requireStrongRef() {
    if (hasRequiredStrongRef) return strongRef;
    hasRequiredStrongRef = 1;
    Object.defineProperty(strongRef, "__esModule", { value: true });
    strongRef.isMain = isMain;
    strongRef.validateMain = validateMain;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "com.atproto.repo.strongRef";
    const hashMain = "main";
    function isMain(v) {
      return is$typed(v, id, hashMain);
    }
    function validateMain(v) {
      return validate(v, id, hashMain);
    }
    return strongRef;
  }
  var uploadBlob = {};
  var hasRequiredUploadBlob;
  function requireUploadBlob() {
    if (hasRequiredUploadBlob) return uploadBlob;
    hasRequiredUploadBlob = 1;
    Object.defineProperty(uploadBlob, "__esModule", { value: true });
    uploadBlob.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return uploadBlob;
  }
  var activateAccount = {};
  var hasRequiredActivateAccount;
  function requireActivateAccount() {
    if (hasRequiredActivateAccount) return activateAccount;
    hasRequiredActivateAccount = 1;
    Object.defineProperty(activateAccount, "__esModule", { value: true });
    activateAccount.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return activateAccount;
  }
  var checkAccountStatus = {};
  var hasRequiredCheckAccountStatus;
  function requireCheckAccountStatus() {
    if (hasRequiredCheckAccountStatus) return checkAccountStatus;
    hasRequiredCheckAccountStatus = 1;
    Object.defineProperty(checkAccountStatus, "__esModule", { value: true });
    checkAccountStatus.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return checkAccountStatus;
  }
  var createInviteCode = {};
  var hasRequiredCreateInviteCode;
  function requireCreateInviteCode() {
    if (hasRequiredCreateInviteCode) return createInviteCode;
    hasRequiredCreateInviteCode = 1;
    Object.defineProperty(createInviteCode, "__esModule", { value: true });
    createInviteCode.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return createInviteCode;
  }
  var createInviteCodes = {};
  var hasRequiredCreateInviteCodes;
  function requireCreateInviteCodes() {
    if (hasRequiredCreateInviteCodes) return createInviteCodes;
    hasRequiredCreateInviteCodes = 1;
    Object.defineProperty(createInviteCodes, "__esModule", { value: true });
    createInviteCodes.toKnownErr = toKnownErr;
    createInviteCodes.isAccountCodes = isAccountCodes;
    createInviteCodes.validateAccountCodes = validateAccountCodes;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "com.atproto.server.createInviteCodes";
    function toKnownErr(e) {
      return e;
    }
    const hashAccountCodes = "accountCodes";
    function isAccountCodes(v) {
      return is$typed(v, id, hashAccountCodes);
    }
    function validateAccountCodes(v) {
      return validate(v, id, hashAccountCodes);
    }
    return createInviteCodes;
  }
  var deactivateAccount = {};
  var hasRequiredDeactivateAccount;
  function requireDeactivateAccount() {
    if (hasRequiredDeactivateAccount) return deactivateAccount;
    hasRequiredDeactivateAccount = 1;
    Object.defineProperty(deactivateAccount, "__esModule", { value: true });
    deactivateAccount.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return deactivateAccount;
  }
  var defs$f = {};
  var hasRequiredDefs$f;
  function requireDefs$f() {
    if (hasRequiredDefs$f) return defs$f;
    hasRequiredDefs$f = 1;
    Object.defineProperty(defs$f, "__esModule", { value: true });
    defs$f.isInviteCode = isInviteCode;
    defs$f.validateInviteCode = validateInviteCode;
    defs$f.isInviteCodeUse = isInviteCodeUse;
    defs$f.validateInviteCodeUse = validateInviteCodeUse;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "com.atproto.server.defs";
    const hashInviteCode = "inviteCode";
    function isInviteCode(v) {
      return is$typed(v, id, hashInviteCode);
    }
    function validateInviteCode(v) {
      return validate(v, id, hashInviteCode);
    }
    const hashInviteCodeUse = "inviteCodeUse";
    function isInviteCodeUse(v) {
      return is$typed(v, id, hashInviteCodeUse);
    }
    function validateInviteCodeUse(v) {
      return validate(v, id, hashInviteCodeUse);
    }
    return defs$f;
  }
  var deleteSession = {};
  var hasRequiredDeleteSession;
  function requireDeleteSession() {
    if (hasRequiredDeleteSession) return deleteSession;
    hasRequiredDeleteSession = 1;
    Object.defineProperty(deleteSession, "__esModule", { value: true });
    deleteSession.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return deleteSession;
  }
  var describeServer = {};
  var hasRequiredDescribeServer;
  function requireDescribeServer() {
    if (hasRequiredDescribeServer) return describeServer;
    hasRequiredDescribeServer = 1;
    Object.defineProperty(describeServer, "__esModule", { value: true });
    describeServer.toKnownErr = toKnownErr;
    describeServer.isLinks = isLinks;
    describeServer.validateLinks = validateLinks;
    describeServer.isContact = isContact;
    describeServer.validateContact = validateContact;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "com.atproto.server.describeServer";
    function toKnownErr(e) {
      return e;
    }
    const hashLinks = "links";
    function isLinks(v) {
      return is$typed(v, id, hashLinks);
    }
    function validateLinks(v) {
      return validate(v, id, hashLinks);
    }
    const hashContact = "contact";
    function isContact(v) {
      return is$typed(v, id, hashContact);
    }
    function validateContact(v) {
      return validate(v, id, hashContact);
    }
    return describeServer;
  }
  var getSession = {};
  var hasRequiredGetSession;
  function requireGetSession() {
    if (hasRequiredGetSession) return getSession;
    hasRequiredGetSession = 1;
    Object.defineProperty(getSession, "__esModule", { value: true });
    getSession.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return getSession;
  }
  var requestAccountDelete = {};
  var hasRequiredRequestAccountDelete;
  function requireRequestAccountDelete() {
    if (hasRequiredRequestAccountDelete) return requestAccountDelete;
    hasRequiredRequestAccountDelete = 1;
    Object.defineProperty(requestAccountDelete, "__esModule", { value: true });
    requestAccountDelete.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return requestAccountDelete;
  }
  var requestEmailConfirmation = {};
  var hasRequiredRequestEmailConfirmation;
  function requireRequestEmailConfirmation() {
    if (hasRequiredRequestEmailConfirmation) return requestEmailConfirmation;
    hasRequiredRequestEmailConfirmation = 1;
    Object.defineProperty(requestEmailConfirmation, "__esModule", { value: true });
    requestEmailConfirmation.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return requestEmailConfirmation;
  }
  var requestEmailUpdate = {};
  var hasRequiredRequestEmailUpdate;
  function requireRequestEmailUpdate() {
    if (hasRequiredRequestEmailUpdate) return requestEmailUpdate;
    hasRequiredRequestEmailUpdate = 1;
    Object.defineProperty(requestEmailUpdate, "__esModule", { value: true });
    requestEmailUpdate.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return requestEmailUpdate;
  }
  var requestPasswordReset = {};
  var hasRequiredRequestPasswordReset;
  function requireRequestPasswordReset() {
    if (hasRequiredRequestPasswordReset) return requestPasswordReset;
    hasRequiredRequestPasswordReset = 1;
    Object.defineProperty(requestPasswordReset, "__esModule", { value: true });
    requestPasswordReset.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return requestPasswordReset;
  }
  var reserveSigningKey = {};
  var hasRequiredReserveSigningKey;
  function requireReserveSigningKey() {
    if (hasRequiredReserveSigningKey) return reserveSigningKey;
    hasRequiredReserveSigningKey = 1;
    Object.defineProperty(reserveSigningKey, "__esModule", { value: true });
    reserveSigningKey.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return reserveSigningKey;
  }
  var revokeAppPassword = {};
  var hasRequiredRevokeAppPassword;
  function requireRevokeAppPassword() {
    if (hasRequiredRevokeAppPassword) return revokeAppPassword;
    hasRequiredRevokeAppPassword = 1;
    Object.defineProperty(revokeAppPassword, "__esModule", { value: true });
    revokeAppPassword.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return revokeAppPassword;
  }
  var getCheckout = {};
  var hasRequiredGetCheckout;
  function requireGetCheckout() {
    if (hasRequiredGetCheckout) return getCheckout;
    hasRequiredGetCheckout = 1;
    Object.defineProperty(getCheckout, "__esModule", { value: true });
    getCheckout.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return getCheckout;
  }
  var listRepos = {};
  var hasRequiredListRepos;
  function requireListRepos() {
    if (hasRequiredListRepos) return listRepos;
    hasRequiredListRepos = 1;
    Object.defineProperty(listRepos, "__esModule", { value: true });
    listRepos.toKnownErr = toKnownErr;
    listRepos.isRepo = isRepo;
    listRepos.validateRepo = validateRepo;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "com.atproto.sync.listRepos";
    function toKnownErr(e) {
      return e;
    }
    const hashRepo = "repo";
    function isRepo(v) {
      return is$typed(v, id, hashRepo);
    }
    function validateRepo(v) {
      return validate(v, id, hashRepo);
    }
    return listRepos;
  }
  var notifyOfUpdate = {};
  var hasRequiredNotifyOfUpdate;
  function requireNotifyOfUpdate() {
    if (hasRequiredNotifyOfUpdate) return notifyOfUpdate;
    hasRequiredNotifyOfUpdate = 1;
    Object.defineProperty(notifyOfUpdate, "__esModule", { value: true });
    notifyOfUpdate.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return notifyOfUpdate;
  }
  var requestCrawl = {};
  var hasRequiredRequestCrawl;
  function requireRequestCrawl() {
    if (hasRequiredRequestCrawl) return requestCrawl;
    hasRequiredRequestCrawl = 1;
    Object.defineProperty(requestCrawl, "__esModule", { value: true });
    requestCrawl.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return requestCrawl;
  }
  var subscribeRepos = {};
  var hasRequiredSubscribeRepos;
  function requireSubscribeRepos() {
    if (hasRequiredSubscribeRepos) return subscribeRepos;
    hasRequiredSubscribeRepos = 1;
    Object.defineProperty(subscribeRepos, "__esModule", { value: true });
    subscribeRepos.isCommit = isCommit;
    subscribeRepos.validateCommit = validateCommit;
    subscribeRepos.isIdentity = isIdentity;
    subscribeRepos.validateIdentity = validateIdentity;
    subscribeRepos.isAccount = isAccount;
    subscribeRepos.validateAccount = validateAccount;
    subscribeRepos.isHandle = isHandle;
    subscribeRepos.validateHandle = validateHandle;
    subscribeRepos.isMigrate = isMigrate;
    subscribeRepos.validateMigrate = validateMigrate;
    subscribeRepos.isTombstone = isTombstone;
    subscribeRepos.validateTombstone = validateTombstone;
    subscribeRepos.isInfo = isInfo;
    subscribeRepos.validateInfo = validateInfo;
    subscribeRepos.isRepoOp = isRepoOp;
    subscribeRepos.validateRepoOp = validateRepoOp;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "com.atproto.sync.subscribeRepos";
    const hashCommit = "commit";
    function isCommit(v) {
      return is$typed(v, id, hashCommit);
    }
    function validateCommit(v) {
      return validate(v, id, hashCommit);
    }
    const hashIdentity = "identity";
    function isIdentity(v) {
      return is$typed(v, id, hashIdentity);
    }
    function validateIdentity(v) {
      return validate(v, id, hashIdentity);
    }
    const hashAccount = "account";
    function isAccount(v) {
      return is$typed(v, id, hashAccount);
    }
    function validateAccount(v) {
      return validate(v, id, hashAccount);
    }
    const hashHandle = "handle";
    function isHandle(v) {
      return is$typed(v, id, hashHandle);
    }
    function validateHandle(v) {
      return validate(v, id, hashHandle);
    }
    const hashMigrate = "migrate";
    function isMigrate(v) {
      return is$typed(v, id, hashMigrate);
    }
    function validateMigrate(v) {
      return validate(v, id, hashMigrate);
    }
    const hashTombstone = "tombstone";
    function isTombstone(v) {
      return is$typed(v, id, hashTombstone);
    }
    function validateTombstone(v) {
      return validate(v, id, hashTombstone);
    }
    const hashInfo = "info";
    function isInfo(v) {
      return is$typed(v, id, hashInfo);
    }
    function validateInfo(v) {
      return validate(v, id, hashInfo);
    }
    const hashRepoOp = "repoOp";
    function isRepoOp(v) {
      return is$typed(v, id, hashRepoOp);
    }
    function validateRepoOp(v) {
      return validate(v, id, hashRepoOp);
    }
    return subscribeRepos;
  }
  var addReservedHandle = {};
  var hasRequiredAddReservedHandle;
  function requireAddReservedHandle() {
    if (hasRequiredAddReservedHandle) return addReservedHandle;
    hasRequiredAddReservedHandle = 1;
    Object.defineProperty(addReservedHandle, "__esModule", { value: true });
    addReservedHandle.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return addReservedHandle;
  }
  var checkSignupQueue = {};
  var hasRequiredCheckSignupQueue;
  function requireCheckSignupQueue() {
    if (hasRequiredCheckSignupQueue) return checkSignupQueue;
    hasRequiredCheckSignupQueue = 1;
    Object.defineProperty(checkSignupQueue, "__esModule", { value: true });
    checkSignupQueue.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return checkSignupQueue;
  }
  var fetchLabels = {};
  var hasRequiredFetchLabels;
  function requireFetchLabels() {
    if (hasRequiredFetchLabels) return fetchLabels;
    hasRequiredFetchLabels = 1;
    Object.defineProperty(fetchLabels, "__esModule", { value: true });
    fetchLabels.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return fetchLabels;
  }
  var requestPhoneVerification = {};
  var hasRequiredRequestPhoneVerification;
  function requireRequestPhoneVerification() {
    if (hasRequiredRequestPhoneVerification) return requestPhoneVerification;
    hasRequiredRequestPhoneVerification = 1;
    Object.defineProperty(requestPhoneVerification, "__esModule", { value: true });
    requestPhoneVerification.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return requestPhoneVerification;
  }
  var defs$e = {};
  var hasRequiredDefs$e;
  function requireDefs$e() {
    if (hasRequiredDefs$e) return defs$e;
    hasRequiredDefs$e = 1;
    Object.defineProperty(defs$e, "__esModule", { value: true });
    defs$e.isProfileViewBasic = isProfileViewBasic;
    defs$e.validateProfileViewBasic = validateProfileViewBasic;
    defs$e.isProfileView = isProfileView;
    defs$e.validateProfileView = validateProfileView;
    defs$e.isProfileViewDetailed = isProfileViewDetailed;
    defs$e.validateProfileViewDetailed = validateProfileViewDetailed;
    defs$e.isProfileAssociated = isProfileAssociated;
    defs$e.validateProfileAssociated = validateProfileAssociated;
    defs$e.isProfileAssociatedChat = isProfileAssociatedChat;
    defs$e.validateProfileAssociatedChat = validateProfileAssociatedChat;
    defs$e.isViewerState = isViewerState;
    defs$e.validateViewerState = validateViewerState;
    defs$e.isKnownFollowers = isKnownFollowers;
    defs$e.validateKnownFollowers = validateKnownFollowers;
    defs$e.isAdultContentPref = isAdultContentPref;
    defs$e.validateAdultContentPref = validateAdultContentPref;
    defs$e.isContentLabelPref = isContentLabelPref;
    defs$e.validateContentLabelPref = validateContentLabelPref;
    defs$e.isSavedFeed = isSavedFeed;
    defs$e.validateSavedFeed = validateSavedFeed;
    defs$e.isSavedFeedsPrefV2 = isSavedFeedsPrefV2;
    defs$e.validateSavedFeedsPrefV2 = validateSavedFeedsPrefV2;
    defs$e.isSavedFeedsPref = isSavedFeedsPref;
    defs$e.validateSavedFeedsPref = validateSavedFeedsPref;
    defs$e.isPersonalDetailsPref = isPersonalDetailsPref;
    defs$e.validatePersonalDetailsPref = validatePersonalDetailsPref;
    defs$e.isFeedViewPref = isFeedViewPref;
    defs$e.validateFeedViewPref = validateFeedViewPref;
    defs$e.isThreadViewPref = isThreadViewPref;
    defs$e.validateThreadViewPref = validateThreadViewPref;
    defs$e.isInterestsPref = isInterestsPref;
    defs$e.validateInterestsPref = validateInterestsPref;
    defs$e.isMutedWord = isMutedWord;
    defs$e.validateMutedWord = validateMutedWord;
    defs$e.isMutedWordsPref = isMutedWordsPref;
    defs$e.validateMutedWordsPref = validateMutedWordsPref;
    defs$e.isHiddenPostsPref = isHiddenPostsPref;
    defs$e.validateHiddenPostsPref = validateHiddenPostsPref;
    defs$e.isLabelersPref = isLabelersPref;
    defs$e.validateLabelersPref = validateLabelersPref;
    defs$e.isLabelerPrefItem = isLabelerPrefItem;
    defs$e.validateLabelerPrefItem = validateLabelerPrefItem;
    defs$e.isBskyAppStatePref = isBskyAppStatePref;
    defs$e.validateBskyAppStatePref = validateBskyAppStatePref;
    defs$e.isBskyAppProgressGuide = isBskyAppProgressGuide;
    defs$e.validateBskyAppProgressGuide = validateBskyAppProgressGuide;
    defs$e.isNux = isNux;
    defs$e.validateNux = validateNux;
    defs$e.isPostInteractionSettingsPref = isPostInteractionSettingsPref;
    defs$e.validatePostInteractionSettingsPref = validatePostInteractionSettingsPref;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "app.bsky.actor.defs";
    const hashProfileViewBasic = "profileViewBasic";
    function isProfileViewBasic(v) {
      return is$typed(v, id, hashProfileViewBasic);
    }
    function validateProfileViewBasic(v) {
      return validate(v, id, hashProfileViewBasic);
    }
    const hashProfileView = "profileView";
    function isProfileView(v) {
      return is$typed(v, id, hashProfileView);
    }
    function validateProfileView(v) {
      return validate(v, id, hashProfileView);
    }
    const hashProfileViewDetailed = "profileViewDetailed";
    function isProfileViewDetailed(v) {
      return is$typed(v, id, hashProfileViewDetailed);
    }
    function validateProfileViewDetailed(v) {
      return validate(v, id, hashProfileViewDetailed);
    }
    const hashProfileAssociated = "profileAssociated";
    function isProfileAssociated(v) {
      return is$typed(v, id, hashProfileAssociated);
    }
    function validateProfileAssociated(v) {
      return validate(v, id, hashProfileAssociated);
    }
    const hashProfileAssociatedChat = "profileAssociatedChat";
    function isProfileAssociatedChat(v) {
      return is$typed(v, id, hashProfileAssociatedChat);
    }
    function validateProfileAssociatedChat(v) {
      return validate(v, id, hashProfileAssociatedChat);
    }
    const hashViewerState = "viewerState";
    function isViewerState(v) {
      return is$typed(v, id, hashViewerState);
    }
    function validateViewerState(v) {
      return validate(v, id, hashViewerState);
    }
    const hashKnownFollowers = "knownFollowers";
    function isKnownFollowers(v) {
      return is$typed(v, id, hashKnownFollowers);
    }
    function validateKnownFollowers(v) {
      return validate(v, id, hashKnownFollowers);
    }
    const hashAdultContentPref = "adultContentPref";
    function isAdultContentPref(v) {
      return is$typed(v, id, hashAdultContentPref);
    }
    function validateAdultContentPref(v) {
      return validate(v, id, hashAdultContentPref);
    }
    const hashContentLabelPref = "contentLabelPref";
    function isContentLabelPref(v) {
      return is$typed(v, id, hashContentLabelPref);
    }
    function validateContentLabelPref(v) {
      return validate(v, id, hashContentLabelPref);
    }
    const hashSavedFeed = "savedFeed";
    function isSavedFeed(v) {
      return is$typed(v, id, hashSavedFeed);
    }
    function validateSavedFeed(v) {
      return validate(v, id, hashSavedFeed);
    }
    const hashSavedFeedsPrefV2 = "savedFeedsPrefV2";
    function isSavedFeedsPrefV2(v) {
      return is$typed(v, id, hashSavedFeedsPrefV2);
    }
    function validateSavedFeedsPrefV2(v) {
      return validate(v, id, hashSavedFeedsPrefV2);
    }
    const hashSavedFeedsPref = "savedFeedsPref";
    function isSavedFeedsPref(v) {
      return is$typed(v, id, hashSavedFeedsPref);
    }
    function validateSavedFeedsPref(v) {
      return validate(v, id, hashSavedFeedsPref);
    }
    const hashPersonalDetailsPref = "personalDetailsPref";
    function isPersonalDetailsPref(v) {
      return is$typed(v, id, hashPersonalDetailsPref);
    }
    function validatePersonalDetailsPref(v) {
      return validate(v, id, hashPersonalDetailsPref);
    }
    const hashFeedViewPref = "feedViewPref";
    function isFeedViewPref(v) {
      return is$typed(v, id, hashFeedViewPref);
    }
    function validateFeedViewPref(v) {
      return validate(v, id, hashFeedViewPref);
    }
    const hashThreadViewPref = "threadViewPref";
    function isThreadViewPref(v) {
      return is$typed(v, id, hashThreadViewPref);
    }
    function validateThreadViewPref(v) {
      return validate(v, id, hashThreadViewPref);
    }
    const hashInterestsPref = "interestsPref";
    function isInterestsPref(v) {
      return is$typed(v, id, hashInterestsPref);
    }
    function validateInterestsPref(v) {
      return validate(v, id, hashInterestsPref);
    }
    const hashMutedWord = "mutedWord";
    function isMutedWord(v) {
      return is$typed(v, id, hashMutedWord);
    }
    function validateMutedWord(v) {
      return validate(v, id, hashMutedWord);
    }
    const hashMutedWordsPref = "mutedWordsPref";
    function isMutedWordsPref(v) {
      return is$typed(v, id, hashMutedWordsPref);
    }
    function validateMutedWordsPref(v) {
      return validate(v, id, hashMutedWordsPref);
    }
    const hashHiddenPostsPref = "hiddenPostsPref";
    function isHiddenPostsPref(v) {
      return is$typed(v, id, hashHiddenPostsPref);
    }
    function validateHiddenPostsPref(v) {
      return validate(v, id, hashHiddenPostsPref);
    }
    const hashLabelersPref = "labelersPref";
    function isLabelersPref(v) {
      return is$typed(v, id, hashLabelersPref);
    }
    function validateLabelersPref(v) {
      return validate(v, id, hashLabelersPref);
    }
    const hashLabelerPrefItem = "labelerPrefItem";
    function isLabelerPrefItem(v) {
      return is$typed(v, id, hashLabelerPrefItem);
    }
    function validateLabelerPrefItem(v) {
      return validate(v, id, hashLabelerPrefItem);
    }
    const hashBskyAppStatePref = "bskyAppStatePref";
    function isBskyAppStatePref(v) {
      return is$typed(v, id, hashBskyAppStatePref);
    }
    function validateBskyAppStatePref(v) {
      return validate(v, id, hashBskyAppStatePref);
    }
    const hashBskyAppProgressGuide = "bskyAppProgressGuide";
    function isBskyAppProgressGuide(v) {
      return is$typed(v, id, hashBskyAppProgressGuide);
    }
    function validateBskyAppProgressGuide(v) {
      return validate(v, id, hashBskyAppProgressGuide);
    }
    const hashNux = "nux";
    function isNux(v) {
      return is$typed(v, id, hashNux);
    }
    function validateNux(v) {
      return validate(v, id, hashNux);
    }
    const hashPostInteractionSettingsPref = "postInteractionSettingsPref";
    function isPostInteractionSettingsPref(v) {
      return is$typed(v, id, hashPostInteractionSettingsPref);
    }
    function validatePostInteractionSettingsPref(v) {
      return validate(v, id, hashPostInteractionSettingsPref);
    }
    return defs$e;
  }
  var getPreferences = {};
  var hasRequiredGetPreferences;
  function requireGetPreferences() {
    if (hasRequiredGetPreferences) return getPreferences;
    hasRequiredGetPreferences = 1;
    Object.defineProperty(getPreferences, "__esModule", { value: true });
    getPreferences.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return getPreferences;
  }
  var getProfile = {};
  var hasRequiredGetProfile;
  function requireGetProfile() {
    if (hasRequiredGetProfile) return getProfile;
    hasRequiredGetProfile = 1;
    Object.defineProperty(getProfile, "__esModule", { value: true });
    getProfile.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return getProfile;
  }
  var getProfiles = {};
  var hasRequiredGetProfiles;
  function requireGetProfiles() {
    if (hasRequiredGetProfiles) return getProfiles;
    hasRequiredGetProfiles = 1;
    Object.defineProperty(getProfiles, "__esModule", { value: true });
    getProfiles.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return getProfiles;
  }
  var getSuggestions = {};
  var hasRequiredGetSuggestions;
  function requireGetSuggestions() {
    if (hasRequiredGetSuggestions) return getSuggestions;
    hasRequiredGetSuggestions = 1;
    Object.defineProperty(getSuggestions, "__esModule", { value: true });
    getSuggestions.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return getSuggestions;
  }
  var profile$1 = {};
  var hasRequiredProfile$1;
  function requireProfile$1() {
    if (hasRequiredProfile$1) return profile$1;
    hasRequiredProfile$1 = 1;
    Object.defineProperty(profile$1, "__esModule", { value: true });
    profile$1.isRecord = isRecord;
    profile$1.validateRecord = validateRecord;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "app.bsky.actor.profile";
    const hashRecord = "main";
    function isRecord(v) {
      return is$typed(v, id, hashRecord);
    }
    function validateRecord(v) {
      return validate(v, id, hashRecord, true);
    }
    return profile$1;
  }
  var putPreferences$1 = {};
  var hasRequiredPutPreferences$1;
  function requirePutPreferences$1() {
    if (hasRequiredPutPreferences$1) return putPreferences$1;
    hasRequiredPutPreferences$1 = 1;
    Object.defineProperty(putPreferences$1, "__esModule", { value: true });
    putPreferences$1.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return putPreferences$1;
  }
  var searchActors = {};
  var hasRequiredSearchActors;
  function requireSearchActors() {
    if (hasRequiredSearchActors) return searchActors;
    hasRequiredSearchActors = 1;
    Object.defineProperty(searchActors, "__esModule", { value: true });
    searchActors.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return searchActors;
  }
  var searchActorsTypeahead = {};
  var hasRequiredSearchActorsTypeahead;
  function requireSearchActorsTypeahead() {
    if (hasRequiredSearchActorsTypeahead) return searchActorsTypeahead;
    hasRequiredSearchActorsTypeahead = 1;
    Object.defineProperty(searchActorsTypeahead, "__esModule", { value: true });
    searchActorsTypeahead.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return searchActorsTypeahead;
  }
  var defs$d = {};
  var hasRequiredDefs$d;
  function requireDefs$d() {
    if (hasRequiredDefs$d) return defs$d;
    hasRequiredDefs$d = 1;
    Object.defineProperty(defs$d, "__esModule", { value: true });
    defs$d.isAspectRatio = isAspectRatio;
    defs$d.validateAspectRatio = validateAspectRatio;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "app.bsky.embed.defs";
    const hashAspectRatio = "aspectRatio";
    function isAspectRatio(v) {
      return is$typed(v, id, hashAspectRatio);
    }
    function validateAspectRatio(v) {
      return validate(v, id, hashAspectRatio);
    }
    return defs$d;
  }
  var external = {};
  var hasRequiredExternal;
  function requireExternal() {
    if (hasRequiredExternal) return external;
    hasRequiredExternal = 1;
    Object.defineProperty(external, "__esModule", { value: true });
    external.isMain = isMain;
    external.validateMain = validateMain;
    external.isExternal = isExternal;
    external.validateExternal = validateExternal;
    external.isView = isView;
    external.validateView = validateView;
    external.isViewExternal = isViewExternal;
    external.validateViewExternal = validateViewExternal;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "app.bsky.embed.external";
    const hashMain = "main";
    function isMain(v) {
      return is$typed(v, id, hashMain);
    }
    function validateMain(v) {
      return validate(v, id, hashMain);
    }
    const hashExternal = "external";
    function isExternal(v) {
      return is$typed(v, id, hashExternal);
    }
    function validateExternal(v) {
      return validate(v, id, hashExternal);
    }
    const hashView = "view";
    function isView(v) {
      return is$typed(v, id, hashView);
    }
    function validateView(v) {
      return validate(v, id, hashView);
    }
    const hashViewExternal = "viewExternal";
    function isViewExternal(v) {
      return is$typed(v, id, hashViewExternal);
    }
    function validateViewExternal(v) {
      return validate(v, id, hashViewExternal);
    }
    return external;
  }
  var images = {};
  var hasRequiredImages;
  function requireImages() {
    if (hasRequiredImages) return images;
    hasRequiredImages = 1;
    Object.defineProperty(images, "__esModule", { value: true });
    images.isMain = isMain;
    images.validateMain = validateMain;
    images.isImage = isImage;
    images.validateImage = validateImage;
    images.isView = isView;
    images.validateView = validateView;
    images.isViewImage = isViewImage;
    images.validateViewImage = validateViewImage;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "app.bsky.embed.images";
    const hashMain = "main";
    function isMain(v) {
      return is$typed(v, id, hashMain);
    }
    function validateMain(v) {
      return validate(v, id, hashMain);
    }
    const hashImage = "image";
    function isImage(v) {
      return is$typed(v, id, hashImage);
    }
    function validateImage(v) {
      return validate(v, id, hashImage);
    }
    const hashView = "view";
    function isView(v) {
      return is$typed(v, id, hashView);
    }
    function validateView(v) {
      return validate(v, id, hashView);
    }
    const hashViewImage = "viewImage";
    function isViewImage(v) {
      return is$typed(v, id, hashViewImage);
    }
    function validateViewImage(v) {
      return validate(v, id, hashViewImage);
    }
    return images;
  }
  var record = {};
  var hasRequiredRecord;
  function requireRecord() {
    if (hasRequiredRecord) return record;
    hasRequiredRecord = 1;
    Object.defineProperty(record, "__esModule", { value: true });
    record.isMain = isMain;
    record.validateMain = validateMain;
    record.isView = isView;
    record.validateView = validateView;
    record.isViewRecord = isViewRecord;
    record.validateViewRecord = validateViewRecord;
    record.isViewNotFound = isViewNotFound;
    record.validateViewNotFound = validateViewNotFound;
    record.isViewBlocked = isViewBlocked;
    record.validateViewBlocked = validateViewBlocked;
    record.isViewDetached = isViewDetached;
    record.validateViewDetached = validateViewDetached;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "app.bsky.embed.record";
    const hashMain = "main";
    function isMain(v) {
      return is$typed(v, id, hashMain);
    }
    function validateMain(v) {
      return validate(v, id, hashMain);
    }
    const hashView = "view";
    function isView(v) {
      return is$typed(v, id, hashView);
    }
    function validateView(v) {
      return validate(v, id, hashView);
    }
    const hashViewRecord = "viewRecord";
    function isViewRecord(v) {
      return is$typed(v, id, hashViewRecord);
    }
    function validateViewRecord(v) {
      return validate(v, id, hashViewRecord);
    }
    const hashViewNotFound = "viewNotFound";
    function isViewNotFound(v) {
      return is$typed(v, id, hashViewNotFound);
    }
    function validateViewNotFound(v) {
      return validate(v, id, hashViewNotFound);
    }
    const hashViewBlocked = "viewBlocked";
    function isViewBlocked(v) {
      return is$typed(v, id, hashViewBlocked);
    }
    function validateViewBlocked(v) {
      return validate(v, id, hashViewBlocked);
    }
    const hashViewDetached = "viewDetached";
    function isViewDetached(v) {
      return is$typed(v, id, hashViewDetached);
    }
    function validateViewDetached(v) {
      return validate(v, id, hashViewDetached);
    }
    return record;
  }
  var recordWithMedia = {};
  var hasRequiredRecordWithMedia;
  function requireRecordWithMedia() {
    if (hasRequiredRecordWithMedia) return recordWithMedia;
    hasRequiredRecordWithMedia = 1;
    Object.defineProperty(recordWithMedia, "__esModule", { value: true });
    recordWithMedia.isMain = isMain;
    recordWithMedia.validateMain = validateMain;
    recordWithMedia.isView = isView;
    recordWithMedia.validateView = validateView;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "app.bsky.embed.recordWithMedia";
    const hashMain = "main";
    function isMain(v) {
      return is$typed(v, id, hashMain);
    }
    function validateMain(v) {
      return validate(v, id, hashMain);
    }
    const hashView = "view";
    function isView(v) {
      return is$typed(v, id, hashView);
    }
    function validateView(v) {
      return validate(v, id, hashView);
    }
    return recordWithMedia;
  }
  var video = {};
  var hasRequiredVideo;
  function requireVideo() {
    if (hasRequiredVideo) return video;
    hasRequiredVideo = 1;
    Object.defineProperty(video, "__esModule", { value: true });
    video.isMain = isMain;
    video.validateMain = validateMain;
    video.isCaption = isCaption;
    video.validateCaption = validateCaption;
    video.isView = isView;
    video.validateView = validateView;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "app.bsky.embed.video";
    const hashMain = "main";
    function isMain(v) {
      return is$typed(v, id, hashMain);
    }
    function validateMain(v) {
      return validate(v, id, hashMain);
    }
    const hashCaption = "caption";
    function isCaption(v) {
      return is$typed(v, id, hashCaption);
    }
    function validateCaption(v) {
      return validate(v, id, hashCaption);
    }
    const hashView = "view";
    function isView(v) {
      return is$typed(v, id, hashView);
    }
    function validateView(v) {
      return validate(v, id, hashView);
    }
    return video;
  }
  var defs$c = {};
  var hasRequiredDefs$c;
  function requireDefs$c() {
    if (hasRequiredDefs$c) return defs$c;
    hasRequiredDefs$c = 1;
    Object.defineProperty(defs$c, "__esModule", { value: true });
    defs$c.INTERACTIONSHARE = defs$c.INTERACTIONQUOTE = defs$c.INTERACTIONREPLY = defs$c.INTERACTIONREPOST = defs$c.INTERACTIONLIKE = defs$c.INTERACTIONSEEN = defs$c.CONTENTMODEVIDEO = defs$c.CONTENTMODEUNSPECIFIED = defs$c.CLICKTHROUGHEMBED = defs$c.CLICKTHROUGHREPOSTER = defs$c.CLICKTHROUGHAUTHOR = defs$c.CLICKTHROUGHITEM = defs$c.REQUESTMORE = defs$c.REQUESTLESS = void 0;
    defs$c.isPostView = isPostView;
    defs$c.validatePostView = validatePostView;
    defs$c.isViewerState = isViewerState;
    defs$c.validateViewerState = validateViewerState;
    defs$c.isThreadContext = isThreadContext;
    defs$c.validateThreadContext = validateThreadContext;
    defs$c.isFeedViewPost = isFeedViewPost;
    defs$c.validateFeedViewPost = validateFeedViewPost;
    defs$c.isReplyRef = isReplyRef;
    defs$c.validateReplyRef = validateReplyRef;
    defs$c.isReasonRepost = isReasonRepost;
    defs$c.validateReasonRepost = validateReasonRepost;
    defs$c.isReasonPin = isReasonPin;
    defs$c.validateReasonPin = validateReasonPin;
    defs$c.isThreadViewPost = isThreadViewPost;
    defs$c.validateThreadViewPost = validateThreadViewPost;
    defs$c.isNotFoundPost = isNotFoundPost;
    defs$c.validateNotFoundPost = validateNotFoundPost;
    defs$c.isBlockedPost = isBlockedPost;
    defs$c.validateBlockedPost = validateBlockedPost;
    defs$c.isBlockedAuthor = isBlockedAuthor;
    defs$c.validateBlockedAuthor = validateBlockedAuthor;
    defs$c.isGeneratorView = isGeneratorView;
    defs$c.validateGeneratorView = validateGeneratorView;
    defs$c.isGeneratorViewerState = isGeneratorViewerState;
    defs$c.validateGeneratorViewerState = validateGeneratorViewerState;
    defs$c.isSkeletonFeedPost = isSkeletonFeedPost;
    defs$c.validateSkeletonFeedPost = validateSkeletonFeedPost;
    defs$c.isSkeletonReasonRepost = isSkeletonReasonRepost;
    defs$c.validateSkeletonReasonRepost = validateSkeletonReasonRepost;
    defs$c.isSkeletonReasonPin = isSkeletonReasonPin;
    defs$c.validateSkeletonReasonPin = validateSkeletonReasonPin;
    defs$c.isThreadgateView = isThreadgateView;
    defs$c.validateThreadgateView = validateThreadgateView;
    defs$c.isInteraction = isInteraction;
    defs$c.validateInteraction = validateInteraction;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "app.bsky.feed.defs";
    const hashPostView = "postView";
    function isPostView(v) {
      return is$typed(v, id, hashPostView);
    }
    function validatePostView(v) {
      return validate(v, id, hashPostView);
    }
    const hashViewerState = "viewerState";
    function isViewerState(v) {
      return is$typed(v, id, hashViewerState);
    }
    function validateViewerState(v) {
      return validate(v, id, hashViewerState);
    }
    const hashThreadContext = "threadContext";
    function isThreadContext(v) {
      return is$typed(v, id, hashThreadContext);
    }
    function validateThreadContext(v) {
      return validate(v, id, hashThreadContext);
    }
    const hashFeedViewPost = "feedViewPost";
    function isFeedViewPost(v) {
      return is$typed(v, id, hashFeedViewPost);
    }
    function validateFeedViewPost(v) {
      return validate(v, id, hashFeedViewPost);
    }
    const hashReplyRef = "replyRef";
    function isReplyRef(v) {
      return is$typed(v, id, hashReplyRef);
    }
    function validateReplyRef(v) {
      return validate(v, id, hashReplyRef);
    }
    const hashReasonRepost = "reasonRepost";
    function isReasonRepost(v) {
      return is$typed(v, id, hashReasonRepost);
    }
    function validateReasonRepost(v) {
      return validate(v, id, hashReasonRepost);
    }
    const hashReasonPin = "reasonPin";
    function isReasonPin(v) {
      return is$typed(v, id, hashReasonPin);
    }
    function validateReasonPin(v) {
      return validate(v, id, hashReasonPin);
    }
    const hashThreadViewPost = "threadViewPost";
    function isThreadViewPost(v) {
      return is$typed(v, id, hashThreadViewPost);
    }
    function validateThreadViewPost(v) {
      return validate(v, id, hashThreadViewPost);
    }
    const hashNotFoundPost = "notFoundPost";
    function isNotFoundPost(v) {
      return is$typed(v, id, hashNotFoundPost);
    }
    function validateNotFoundPost(v) {
      return validate(v, id, hashNotFoundPost);
    }
    const hashBlockedPost = "blockedPost";
    function isBlockedPost(v) {
      return is$typed(v, id, hashBlockedPost);
    }
    function validateBlockedPost(v) {
      return validate(v, id, hashBlockedPost);
    }
    const hashBlockedAuthor = "blockedAuthor";
    function isBlockedAuthor(v) {
      return is$typed(v, id, hashBlockedAuthor);
    }
    function validateBlockedAuthor(v) {
      return validate(v, id, hashBlockedAuthor);
    }
    const hashGeneratorView = "generatorView";
    function isGeneratorView(v) {
      return is$typed(v, id, hashGeneratorView);
    }
    function validateGeneratorView(v) {
      return validate(v, id, hashGeneratorView);
    }
    const hashGeneratorViewerState = "generatorViewerState";
    function isGeneratorViewerState(v) {
      return is$typed(v, id, hashGeneratorViewerState);
    }
    function validateGeneratorViewerState(v) {
      return validate(v, id, hashGeneratorViewerState);
    }
    const hashSkeletonFeedPost = "skeletonFeedPost";
    function isSkeletonFeedPost(v) {
      return is$typed(v, id, hashSkeletonFeedPost);
    }
    function validateSkeletonFeedPost(v) {
      return validate(v, id, hashSkeletonFeedPost);
    }
    const hashSkeletonReasonRepost = "skeletonReasonRepost";
    function isSkeletonReasonRepost(v) {
      return is$typed(v, id, hashSkeletonReasonRepost);
    }
    function validateSkeletonReasonRepost(v) {
      return validate(v, id, hashSkeletonReasonRepost);
    }
    const hashSkeletonReasonPin = "skeletonReasonPin";
    function isSkeletonReasonPin(v) {
      return is$typed(v, id, hashSkeletonReasonPin);
    }
    function validateSkeletonReasonPin(v) {
      return validate(v, id, hashSkeletonReasonPin);
    }
    const hashThreadgateView = "threadgateView";
    function isThreadgateView(v) {
      return is$typed(v, id, hashThreadgateView);
    }
    function validateThreadgateView(v) {
      return validate(v, id, hashThreadgateView);
    }
    const hashInteraction = "interaction";
    function isInteraction(v) {
      return is$typed(v, id, hashInteraction);
    }
    function validateInteraction(v) {
      return validate(v, id, hashInteraction);
    }
    defs$c.REQUESTLESS = `${id}#requestLess`;
    defs$c.REQUESTMORE = `${id}#requestMore`;
    defs$c.CLICKTHROUGHITEM = `${id}#clickthroughItem`;
    defs$c.CLICKTHROUGHAUTHOR = `${id}#clickthroughAuthor`;
    defs$c.CLICKTHROUGHREPOSTER = `${id}#clickthroughReposter`;
    defs$c.CLICKTHROUGHEMBED = `${id}#clickthroughEmbed`;
    defs$c.CONTENTMODEUNSPECIFIED = `${id}#contentModeUnspecified`;
    defs$c.CONTENTMODEVIDEO = `${id}#contentModeVideo`;
    defs$c.INTERACTIONSEEN = `${id}#interactionSeen`;
    defs$c.INTERACTIONLIKE = `${id}#interactionLike`;
    defs$c.INTERACTIONREPOST = `${id}#interactionRepost`;
    defs$c.INTERACTIONREPLY = `${id}#interactionReply`;
    defs$c.INTERACTIONQUOTE = `${id}#interactionQuote`;
    defs$c.INTERACTIONSHARE = `${id}#interactionShare`;
    return defs$c;
  }
  var describeFeedGenerator = {};
  var hasRequiredDescribeFeedGenerator;
  function requireDescribeFeedGenerator() {
    if (hasRequiredDescribeFeedGenerator) return describeFeedGenerator;
    hasRequiredDescribeFeedGenerator = 1;
    Object.defineProperty(describeFeedGenerator, "__esModule", { value: true });
    describeFeedGenerator.toKnownErr = toKnownErr;
    describeFeedGenerator.isFeed = isFeed;
    describeFeedGenerator.validateFeed = validateFeed;
    describeFeedGenerator.isLinks = isLinks;
    describeFeedGenerator.validateLinks = validateLinks;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "app.bsky.feed.describeFeedGenerator";
    function toKnownErr(e) {
      return e;
    }
    const hashFeed = "feed";
    function isFeed(v) {
      return is$typed(v, id, hashFeed);
    }
    function validateFeed(v) {
      return validate(v, id, hashFeed);
    }
    const hashLinks = "links";
    function isLinks(v) {
      return is$typed(v, id, hashLinks);
    }
    function validateLinks(v) {
      return validate(v, id, hashLinks);
    }
    return describeFeedGenerator;
  }
  var generator = {};
  var hasRequiredGenerator;
  function requireGenerator() {
    if (hasRequiredGenerator) return generator;
    hasRequiredGenerator = 1;
    Object.defineProperty(generator, "__esModule", { value: true });
    generator.isRecord = isRecord;
    generator.validateRecord = validateRecord;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "app.bsky.feed.generator";
    const hashRecord = "main";
    function isRecord(v) {
      return is$typed(v, id, hashRecord);
    }
    function validateRecord(v) {
      return validate(v, id, hashRecord, true);
    }
    return generator;
  }
  var getActorFeeds = {};
  var hasRequiredGetActorFeeds;
  function requireGetActorFeeds() {
    if (hasRequiredGetActorFeeds) return getActorFeeds;
    hasRequiredGetActorFeeds = 1;
    Object.defineProperty(getActorFeeds, "__esModule", { value: true });
    getActorFeeds.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return getActorFeeds;
  }
  var getFeedGenerator = {};
  var hasRequiredGetFeedGenerator;
  function requireGetFeedGenerator() {
    if (hasRequiredGetFeedGenerator) return getFeedGenerator;
    hasRequiredGetFeedGenerator = 1;
    Object.defineProperty(getFeedGenerator, "__esModule", { value: true });
    getFeedGenerator.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return getFeedGenerator;
  }
  var getFeedGenerators = {};
  var hasRequiredGetFeedGenerators;
  function requireGetFeedGenerators() {
    if (hasRequiredGetFeedGenerators) return getFeedGenerators;
    hasRequiredGetFeedGenerators = 1;
    Object.defineProperty(getFeedGenerators, "__esModule", { value: true });
    getFeedGenerators.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return getFeedGenerators;
  }
  var getLikes = {};
  var hasRequiredGetLikes;
  function requireGetLikes() {
    if (hasRequiredGetLikes) return getLikes;
    hasRequiredGetLikes = 1;
    Object.defineProperty(getLikes, "__esModule", { value: true });
    getLikes.toKnownErr = toKnownErr;
    getLikes.isLike = isLike;
    getLikes.validateLike = validateLike;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "app.bsky.feed.getLikes";
    function toKnownErr(e) {
      return e;
    }
    const hashLike = "like";
    function isLike(v) {
      return is$typed(v, id, hashLike);
    }
    function validateLike(v) {
      return validate(v, id, hashLike);
    }
    return getLikes;
  }
  var getPosts = {};
  var hasRequiredGetPosts;
  function requireGetPosts() {
    if (hasRequiredGetPosts) return getPosts;
    hasRequiredGetPosts = 1;
    Object.defineProperty(getPosts, "__esModule", { value: true });
    getPosts.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return getPosts;
  }
  var getQuotes = {};
  var hasRequiredGetQuotes;
  function requireGetQuotes() {
    if (hasRequiredGetQuotes) return getQuotes;
    hasRequiredGetQuotes = 1;
    Object.defineProperty(getQuotes, "__esModule", { value: true });
    getQuotes.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return getQuotes;
  }
  var getRepostedBy = {};
  var hasRequiredGetRepostedBy;
  function requireGetRepostedBy() {
    if (hasRequiredGetRepostedBy) return getRepostedBy;
    hasRequiredGetRepostedBy = 1;
    Object.defineProperty(getRepostedBy, "__esModule", { value: true });
    getRepostedBy.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return getRepostedBy;
  }
  var getSuggestedFeeds = {};
  var hasRequiredGetSuggestedFeeds;
  function requireGetSuggestedFeeds() {
    if (hasRequiredGetSuggestedFeeds) return getSuggestedFeeds;
    hasRequiredGetSuggestedFeeds = 1;
    Object.defineProperty(getSuggestedFeeds, "__esModule", { value: true });
    getSuggestedFeeds.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return getSuggestedFeeds;
  }
  var getTimeline = {};
  var hasRequiredGetTimeline;
  function requireGetTimeline() {
    if (hasRequiredGetTimeline) return getTimeline;
    hasRequiredGetTimeline = 1;
    Object.defineProperty(getTimeline, "__esModule", { value: true });
    getTimeline.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return getTimeline;
  }
  var like = {};
  var hasRequiredLike;
  function requireLike() {
    if (hasRequiredLike) return like;
    hasRequiredLike = 1;
    Object.defineProperty(like, "__esModule", { value: true });
    like.isRecord = isRecord;
    like.validateRecord = validateRecord;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "app.bsky.feed.like";
    const hashRecord = "main";
    function isRecord(v) {
      return is$typed(v, id, hashRecord);
    }
    function validateRecord(v) {
      return validate(v, id, hashRecord, true);
    }
    return like;
  }
  var post$1 = {};
  var hasRequiredPost$1;
  function requirePost$1() {
    if (hasRequiredPost$1) return post$1;
    hasRequiredPost$1 = 1;
    Object.defineProperty(post$1, "__esModule", { value: true });
    post$1.isRecord = isRecord;
    post$1.validateRecord = validateRecord;
    post$1.isReplyRef = isReplyRef;
    post$1.validateReplyRef = validateReplyRef;
    post$1.isEntity = isEntity;
    post$1.validateEntity = validateEntity;
    post$1.isTextSlice = isTextSlice;
    post$1.validateTextSlice = validateTextSlice;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "app.bsky.feed.post";
    const hashRecord = "main";
    function isRecord(v) {
      return is$typed(v, id, hashRecord);
    }
    function validateRecord(v) {
      return validate(v, id, hashRecord, true);
    }
    const hashReplyRef = "replyRef";
    function isReplyRef(v) {
      return is$typed(v, id, hashReplyRef);
    }
    function validateReplyRef(v) {
      return validate(v, id, hashReplyRef);
    }
    const hashEntity = "entity";
    function isEntity(v) {
      return is$typed(v, id, hashEntity);
    }
    function validateEntity(v) {
      return validate(v, id, hashEntity);
    }
    const hashTextSlice = "textSlice";
    function isTextSlice(v) {
      return is$typed(v, id, hashTextSlice);
    }
    function validateTextSlice(v) {
      return validate(v, id, hashTextSlice);
    }
    return post$1;
  }
  var postgate = {};
  var hasRequiredPostgate;
  function requirePostgate() {
    if (hasRequiredPostgate) return postgate;
    hasRequiredPostgate = 1;
    Object.defineProperty(postgate, "__esModule", { value: true });
    postgate.isRecord = isRecord;
    postgate.validateRecord = validateRecord;
    postgate.isDisableRule = isDisableRule;
    postgate.validateDisableRule = validateDisableRule;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "app.bsky.feed.postgate";
    const hashRecord = "main";
    function isRecord(v) {
      return is$typed(v, id, hashRecord);
    }
    function validateRecord(v) {
      return validate(v, id, hashRecord, true);
    }
    const hashDisableRule = "disableRule";
    function isDisableRule(v) {
      return is$typed(v, id, hashDisableRule);
    }
    function validateDisableRule(v) {
      return validate(v, id, hashDisableRule);
    }
    return postgate;
  }
  var repost = {};
  var hasRequiredRepost;
  function requireRepost() {
    if (hasRequiredRepost) return repost;
    hasRequiredRepost = 1;
    Object.defineProperty(repost, "__esModule", { value: true });
    repost.isRecord = isRecord;
    repost.validateRecord = validateRecord;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "app.bsky.feed.repost";
    const hashRecord = "main";
    function isRecord(v) {
      return is$typed(v, id, hashRecord);
    }
    function validateRecord(v) {
      return validate(v, id, hashRecord, true);
    }
    return repost;
  }
  var sendInteractions = {};
  var hasRequiredSendInteractions;
  function requireSendInteractions() {
    if (hasRequiredSendInteractions) return sendInteractions;
    hasRequiredSendInteractions = 1;
    Object.defineProperty(sendInteractions, "__esModule", { value: true });
    sendInteractions.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return sendInteractions;
  }
  var threadgate = {};
  var hasRequiredThreadgate;
  function requireThreadgate() {
    if (hasRequiredThreadgate) return threadgate;
    hasRequiredThreadgate = 1;
    Object.defineProperty(threadgate, "__esModule", { value: true });
    threadgate.isRecord = isRecord;
    threadgate.validateRecord = validateRecord;
    threadgate.isMentionRule = isMentionRule;
    threadgate.validateMentionRule = validateMentionRule;
    threadgate.isFollowerRule = isFollowerRule;
    threadgate.validateFollowerRule = validateFollowerRule;
    threadgate.isFollowingRule = isFollowingRule;
    threadgate.validateFollowingRule = validateFollowingRule;
    threadgate.isListRule = isListRule;
    threadgate.validateListRule = validateListRule;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "app.bsky.feed.threadgate";
    const hashRecord = "main";
    function isRecord(v) {
      return is$typed(v, id, hashRecord);
    }
    function validateRecord(v) {
      return validate(v, id, hashRecord, true);
    }
    const hashMentionRule = "mentionRule";
    function isMentionRule(v) {
      return is$typed(v, id, hashMentionRule);
    }
    function validateMentionRule(v) {
      return validate(v, id, hashMentionRule);
    }
    const hashFollowerRule = "followerRule";
    function isFollowerRule(v) {
      return is$typed(v, id, hashFollowerRule);
    }
    function validateFollowerRule(v) {
      return validate(v, id, hashFollowerRule);
    }
    const hashFollowingRule = "followingRule";
    function isFollowingRule(v) {
      return is$typed(v, id, hashFollowingRule);
    }
    function validateFollowingRule(v) {
      return validate(v, id, hashFollowingRule);
    }
    const hashListRule = "listRule";
    function isListRule(v) {
      return is$typed(v, id, hashListRule);
    }
    function validateListRule(v) {
      return validate(v, id, hashListRule);
    }
    return threadgate;
  }
  var block = {};
  var hasRequiredBlock;
  function requireBlock() {
    if (hasRequiredBlock) return block;
    hasRequiredBlock = 1;
    Object.defineProperty(block, "__esModule", { value: true });
    block.isRecord = isRecord;
    block.validateRecord = validateRecord;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "app.bsky.graph.block";
    const hashRecord = "main";
    function isRecord(v) {
      return is$typed(v, id, hashRecord);
    }
    function validateRecord(v) {
      return validate(v, id, hashRecord, true);
    }
    return block;
  }
  var defs$b = {};
  var hasRequiredDefs$b;
  function requireDefs$b() {
    if (hasRequiredDefs$b) return defs$b;
    hasRequiredDefs$b = 1;
    Object.defineProperty(defs$b, "__esModule", { value: true });
    defs$b.REFERENCELIST = defs$b.CURATELIST = defs$b.MODLIST = void 0;
    defs$b.isListViewBasic = isListViewBasic;
    defs$b.validateListViewBasic = validateListViewBasic;
    defs$b.isListView = isListView;
    defs$b.validateListView = validateListView;
    defs$b.isListItemView = isListItemView;
    defs$b.validateListItemView = validateListItemView;
    defs$b.isStarterPackView = isStarterPackView;
    defs$b.validateStarterPackView = validateStarterPackView;
    defs$b.isStarterPackViewBasic = isStarterPackViewBasic;
    defs$b.validateStarterPackViewBasic = validateStarterPackViewBasic;
    defs$b.isListViewerState = isListViewerState;
    defs$b.validateListViewerState = validateListViewerState;
    defs$b.isNotFoundActor = isNotFoundActor;
    defs$b.validateNotFoundActor = validateNotFoundActor;
    defs$b.isRelationship = isRelationship;
    defs$b.validateRelationship = validateRelationship;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "app.bsky.graph.defs";
    const hashListViewBasic = "listViewBasic";
    function isListViewBasic(v) {
      return is$typed(v, id, hashListViewBasic);
    }
    function validateListViewBasic(v) {
      return validate(v, id, hashListViewBasic);
    }
    const hashListView = "listView";
    function isListView(v) {
      return is$typed(v, id, hashListView);
    }
    function validateListView(v) {
      return validate(v, id, hashListView);
    }
    const hashListItemView = "listItemView";
    function isListItemView(v) {
      return is$typed(v, id, hashListItemView);
    }
    function validateListItemView(v) {
      return validate(v, id, hashListItemView);
    }
    const hashStarterPackView = "starterPackView";
    function isStarterPackView(v) {
      return is$typed(v, id, hashStarterPackView);
    }
    function validateStarterPackView(v) {
      return validate(v, id, hashStarterPackView);
    }
    const hashStarterPackViewBasic = "starterPackViewBasic";
    function isStarterPackViewBasic(v) {
      return is$typed(v, id, hashStarterPackViewBasic);
    }
    function validateStarterPackViewBasic(v) {
      return validate(v, id, hashStarterPackViewBasic);
    }
    defs$b.MODLIST = `${id}#modlist`;
    defs$b.CURATELIST = `${id}#curatelist`;
    defs$b.REFERENCELIST = `${id}#referencelist`;
    const hashListViewerState = "listViewerState";
    function isListViewerState(v) {
      return is$typed(v, id, hashListViewerState);
    }
    function validateListViewerState(v) {
      return validate(v, id, hashListViewerState);
    }
    const hashNotFoundActor = "notFoundActor";
    function isNotFoundActor(v) {
      return is$typed(v, id, hashNotFoundActor);
    }
    function validateNotFoundActor(v) {
      return validate(v, id, hashNotFoundActor);
    }
    const hashRelationship = "relationship";
    function isRelationship(v) {
      return is$typed(v, id, hashRelationship);
    }
    function validateRelationship(v) {
      return validate(v, id, hashRelationship);
    }
    return defs$b;
  }
  var follow = {};
  var hasRequiredFollow;
  function requireFollow() {
    if (hasRequiredFollow) return follow;
    hasRequiredFollow = 1;
    Object.defineProperty(follow, "__esModule", { value: true });
    follow.isRecord = isRecord;
    follow.validateRecord = validateRecord;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "app.bsky.graph.follow";
    const hashRecord = "main";
    function isRecord(v) {
      return is$typed(v, id, hashRecord);
    }
    function validateRecord(v) {
      return validate(v, id, hashRecord, true);
    }
    return follow;
  }
  var getActorStarterPacks = {};
  var hasRequiredGetActorStarterPacks;
  function requireGetActorStarterPacks() {
    if (hasRequiredGetActorStarterPacks) return getActorStarterPacks;
    hasRequiredGetActorStarterPacks = 1;
    Object.defineProperty(getActorStarterPacks, "__esModule", { value: true });
    getActorStarterPacks.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return getActorStarterPacks;
  }
  var getBlocks = {};
  var hasRequiredGetBlocks;
  function requireGetBlocks() {
    if (hasRequiredGetBlocks) return getBlocks;
    hasRequiredGetBlocks = 1;
    Object.defineProperty(getBlocks, "__esModule", { value: true });
    getBlocks.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return getBlocks;
  }
  var getFollowers = {};
  var hasRequiredGetFollowers;
  function requireGetFollowers() {
    if (hasRequiredGetFollowers) return getFollowers;
    hasRequiredGetFollowers = 1;
    Object.defineProperty(getFollowers, "__esModule", { value: true });
    getFollowers.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return getFollowers;
  }
  var getFollows = {};
  var hasRequiredGetFollows;
  function requireGetFollows() {
    if (hasRequiredGetFollows) return getFollows;
    hasRequiredGetFollows = 1;
    Object.defineProperty(getFollows, "__esModule", { value: true });
    getFollows.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return getFollows;
  }
  var getKnownFollowers = {};
  var hasRequiredGetKnownFollowers;
  function requireGetKnownFollowers() {
    if (hasRequiredGetKnownFollowers) return getKnownFollowers;
    hasRequiredGetKnownFollowers = 1;
    Object.defineProperty(getKnownFollowers, "__esModule", { value: true });
    getKnownFollowers.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return getKnownFollowers;
  }
  var getList = {};
  var hasRequiredGetList;
  function requireGetList() {
    if (hasRequiredGetList) return getList;
    hasRequiredGetList = 1;
    Object.defineProperty(getList, "__esModule", { value: true });
    getList.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return getList;
  }
  var getListBlocks = {};
  var hasRequiredGetListBlocks;
  function requireGetListBlocks() {
    if (hasRequiredGetListBlocks) return getListBlocks;
    hasRequiredGetListBlocks = 1;
    Object.defineProperty(getListBlocks, "__esModule", { value: true });
    getListBlocks.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return getListBlocks;
  }
  var getListMutes = {};
  var hasRequiredGetListMutes;
  function requireGetListMutes() {
    if (hasRequiredGetListMutes) return getListMutes;
    hasRequiredGetListMutes = 1;
    Object.defineProperty(getListMutes, "__esModule", { value: true });
    getListMutes.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return getListMutes;
  }
  var getLists = {};
  var hasRequiredGetLists;
  function requireGetLists() {
    if (hasRequiredGetLists) return getLists;
    hasRequiredGetLists = 1;
    Object.defineProperty(getLists, "__esModule", { value: true });
    getLists.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return getLists;
  }
  var getMutes = {};
  var hasRequiredGetMutes;
  function requireGetMutes() {
    if (hasRequiredGetMutes) return getMutes;
    hasRequiredGetMutes = 1;
    Object.defineProperty(getMutes, "__esModule", { value: true });
    getMutes.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return getMutes;
  }
  var getStarterPack = {};
  var hasRequiredGetStarterPack;
  function requireGetStarterPack() {
    if (hasRequiredGetStarterPack) return getStarterPack;
    hasRequiredGetStarterPack = 1;
    Object.defineProperty(getStarterPack, "__esModule", { value: true });
    getStarterPack.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return getStarterPack;
  }
  var getStarterPacks = {};
  var hasRequiredGetStarterPacks;
  function requireGetStarterPacks() {
    if (hasRequiredGetStarterPacks) return getStarterPacks;
    hasRequiredGetStarterPacks = 1;
    Object.defineProperty(getStarterPacks, "__esModule", { value: true });
    getStarterPacks.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return getStarterPacks;
  }
  var getSuggestedFollowsByActor = {};
  var hasRequiredGetSuggestedFollowsByActor;
  function requireGetSuggestedFollowsByActor() {
    if (hasRequiredGetSuggestedFollowsByActor) return getSuggestedFollowsByActor;
    hasRequiredGetSuggestedFollowsByActor = 1;
    Object.defineProperty(getSuggestedFollowsByActor, "__esModule", { value: true });
    getSuggestedFollowsByActor.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return getSuggestedFollowsByActor;
  }
  var list = {};
  var hasRequiredList;
  function requireList() {
    if (hasRequiredList) return list;
    hasRequiredList = 1;
    Object.defineProperty(list, "__esModule", { value: true });
    list.isRecord = isRecord;
    list.validateRecord = validateRecord;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "app.bsky.graph.list";
    const hashRecord = "main";
    function isRecord(v) {
      return is$typed(v, id, hashRecord);
    }
    function validateRecord(v) {
      return validate(v, id, hashRecord, true);
    }
    return list;
  }
  var listblock = {};
  var hasRequiredListblock;
  function requireListblock() {
    if (hasRequiredListblock) return listblock;
    hasRequiredListblock = 1;
    Object.defineProperty(listblock, "__esModule", { value: true });
    listblock.isRecord = isRecord;
    listblock.validateRecord = validateRecord;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "app.bsky.graph.listblock";
    const hashRecord = "main";
    function isRecord(v) {
      return is$typed(v, id, hashRecord);
    }
    function validateRecord(v) {
      return validate(v, id, hashRecord, true);
    }
    return listblock;
  }
  var listitem = {};
  var hasRequiredListitem;
  function requireListitem() {
    if (hasRequiredListitem) return listitem;
    hasRequiredListitem = 1;
    Object.defineProperty(listitem, "__esModule", { value: true });
    listitem.isRecord = isRecord;
    listitem.validateRecord = validateRecord;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "app.bsky.graph.listitem";
    const hashRecord = "main";
    function isRecord(v) {
      return is$typed(v, id, hashRecord);
    }
    function validateRecord(v) {
      return validate(v, id, hashRecord, true);
    }
    return listitem;
  }
  var muteActor = {};
  var hasRequiredMuteActor;
  function requireMuteActor() {
    if (hasRequiredMuteActor) return muteActor;
    hasRequiredMuteActor = 1;
    Object.defineProperty(muteActor, "__esModule", { value: true });
    muteActor.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return muteActor;
  }
  var muteActorList = {};
  var hasRequiredMuteActorList;
  function requireMuteActorList() {
    if (hasRequiredMuteActorList) return muteActorList;
    hasRequiredMuteActorList = 1;
    Object.defineProperty(muteActorList, "__esModule", { value: true });
    muteActorList.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return muteActorList;
  }
  var muteThread = {};
  var hasRequiredMuteThread;
  function requireMuteThread() {
    if (hasRequiredMuteThread) return muteThread;
    hasRequiredMuteThread = 1;
    Object.defineProperty(muteThread, "__esModule", { value: true });
    muteThread.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return muteThread;
  }
  var searchStarterPacks = {};
  var hasRequiredSearchStarterPacks;
  function requireSearchStarterPacks() {
    if (hasRequiredSearchStarterPacks) return searchStarterPacks;
    hasRequiredSearchStarterPacks = 1;
    Object.defineProperty(searchStarterPacks, "__esModule", { value: true });
    searchStarterPacks.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return searchStarterPacks;
  }
  var starterpack = {};
  var hasRequiredStarterpack;
  function requireStarterpack() {
    if (hasRequiredStarterpack) return starterpack;
    hasRequiredStarterpack = 1;
    Object.defineProperty(starterpack, "__esModule", { value: true });
    starterpack.isRecord = isRecord;
    starterpack.validateRecord = validateRecord;
    starterpack.isFeedItem = isFeedItem;
    starterpack.validateFeedItem = validateFeedItem;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "app.bsky.graph.starterpack";
    const hashRecord = "main";
    function isRecord(v) {
      return is$typed(v, id, hashRecord);
    }
    function validateRecord(v) {
      return validate(v, id, hashRecord, true);
    }
    const hashFeedItem = "feedItem";
    function isFeedItem(v) {
      return is$typed(v, id, hashFeedItem);
    }
    function validateFeedItem(v) {
      return validate(v, id, hashFeedItem);
    }
    return starterpack;
  }
  var unmuteActor = {};
  var hasRequiredUnmuteActor;
  function requireUnmuteActor() {
    if (hasRequiredUnmuteActor) return unmuteActor;
    hasRequiredUnmuteActor = 1;
    Object.defineProperty(unmuteActor, "__esModule", { value: true });
    unmuteActor.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return unmuteActor;
  }
  var unmuteActorList = {};
  var hasRequiredUnmuteActorList;
  function requireUnmuteActorList() {
    if (hasRequiredUnmuteActorList) return unmuteActorList;
    hasRequiredUnmuteActorList = 1;
    Object.defineProperty(unmuteActorList, "__esModule", { value: true });
    unmuteActorList.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return unmuteActorList;
  }
  var unmuteThread = {};
  var hasRequiredUnmuteThread;
  function requireUnmuteThread() {
    if (hasRequiredUnmuteThread) return unmuteThread;
    hasRequiredUnmuteThread = 1;
    Object.defineProperty(unmuteThread, "__esModule", { value: true });
    unmuteThread.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return unmuteThread;
  }
  var defs$a = {};
  var hasRequiredDefs$a;
  function requireDefs$a() {
    if (hasRequiredDefs$a) return defs$a;
    hasRequiredDefs$a = 1;
    Object.defineProperty(defs$a, "__esModule", { value: true });
    defs$a.isLabelerView = isLabelerView;
    defs$a.validateLabelerView = validateLabelerView;
    defs$a.isLabelerViewDetailed = isLabelerViewDetailed;
    defs$a.validateLabelerViewDetailed = validateLabelerViewDetailed;
    defs$a.isLabelerViewerState = isLabelerViewerState;
    defs$a.validateLabelerViewerState = validateLabelerViewerState;
    defs$a.isLabelerPolicies = isLabelerPolicies;
    defs$a.validateLabelerPolicies = validateLabelerPolicies;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "app.bsky.labeler.defs";
    const hashLabelerView = "labelerView";
    function isLabelerView(v) {
      return is$typed(v, id, hashLabelerView);
    }
    function validateLabelerView(v) {
      return validate(v, id, hashLabelerView);
    }
    const hashLabelerViewDetailed = "labelerViewDetailed";
    function isLabelerViewDetailed(v) {
      return is$typed(v, id, hashLabelerViewDetailed);
    }
    function validateLabelerViewDetailed(v) {
      return validate(v, id, hashLabelerViewDetailed);
    }
    const hashLabelerViewerState = "labelerViewerState";
    function isLabelerViewerState(v) {
      return is$typed(v, id, hashLabelerViewerState);
    }
    function validateLabelerViewerState(v) {
      return validate(v, id, hashLabelerViewerState);
    }
    const hashLabelerPolicies = "labelerPolicies";
    function isLabelerPolicies(v) {
      return is$typed(v, id, hashLabelerPolicies);
    }
    function validateLabelerPolicies(v) {
      return validate(v, id, hashLabelerPolicies);
    }
    return defs$a;
  }
  var getServices = {};
  var hasRequiredGetServices;
  function requireGetServices() {
    if (hasRequiredGetServices) return getServices;
    hasRequiredGetServices = 1;
    Object.defineProperty(getServices, "__esModule", { value: true });
    getServices.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return getServices;
  }
  var service = {};
  var hasRequiredService;
  function requireService() {
    if (hasRequiredService) return service;
    hasRequiredService = 1;
    Object.defineProperty(service, "__esModule", { value: true });
    service.isRecord = isRecord;
    service.validateRecord = validateRecord;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "app.bsky.labeler.service";
    const hashRecord = "main";
    function isRecord(v) {
      return is$typed(v, id, hashRecord);
    }
    function validateRecord(v) {
      return validate(v, id, hashRecord, true);
    }
    return service;
  }
  var getUnreadCount = {};
  var hasRequiredGetUnreadCount;
  function requireGetUnreadCount() {
    if (hasRequiredGetUnreadCount) return getUnreadCount;
    hasRequiredGetUnreadCount = 1;
    Object.defineProperty(getUnreadCount, "__esModule", { value: true });
    getUnreadCount.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return getUnreadCount;
  }
  var listNotifications = {};
  var hasRequiredListNotifications;
  function requireListNotifications() {
    if (hasRequiredListNotifications) return listNotifications;
    hasRequiredListNotifications = 1;
    Object.defineProperty(listNotifications, "__esModule", { value: true });
    listNotifications.toKnownErr = toKnownErr;
    listNotifications.isNotification = isNotification;
    listNotifications.validateNotification = validateNotification;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "app.bsky.notification.listNotifications";
    function toKnownErr(e) {
      return e;
    }
    const hashNotification = "notification";
    function isNotification(v) {
      return is$typed(v, id, hashNotification);
    }
    function validateNotification(v) {
      return validate(v, id, hashNotification);
    }
    return listNotifications;
  }
  var putPreferences = {};
  var hasRequiredPutPreferences;
  function requirePutPreferences() {
    if (hasRequiredPutPreferences) return putPreferences;
    hasRequiredPutPreferences = 1;
    Object.defineProperty(putPreferences, "__esModule", { value: true });
    putPreferences.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return putPreferences;
  }
  var registerPush = {};
  var hasRequiredRegisterPush;
  function requireRegisterPush() {
    if (hasRequiredRegisterPush) return registerPush;
    hasRequiredRegisterPush = 1;
    Object.defineProperty(registerPush, "__esModule", { value: true });
    registerPush.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return registerPush;
  }
  var updateSeen = {};
  var hasRequiredUpdateSeen;
  function requireUpdateSeen() {
    if (hasRequiredUpdateSeen) return updateSeen;
    hasRequiredUpdateSeen = 1;
    Object.defineProperty(updateSeen, "__esModule", { value: true });
    updateSeen.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return updateSeen;
  }
  var facet = {};
  var hasRequiredFacet;
  function requireFacet() {
    if (hasRequiredFacet) return facet;
    hasRequiredFacet = 1;
    Object.defineProperty(facet, "__esModule", { value: true });
    facet.isMain = isMain;
    facet.validateMain = validateMain;
    facet.isMention = isMention;
    facet.validateMention = validateMention;
    facet.isLink = isLink;
    facet.validateLink = validateLink;
    facet.isTag = isTag;
    facet.validateTag = validateTag;
    facet.isByteSlice = isByteSlice;
    facet.validateByteSlice = validateByteSlice;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "app.bsky.richtext.facet";
    const hashMain = "main";
    function isMain(v) {
      return is$typed(v, id, hashMain);
    }
    function validateMain(v) {
      return validate(v, id, hashMain);
    }
    const hashMention = "mention";
    function isMention(v) {
      return is$typed(v, id, hashMention);
    }
    function validateMention(v) {
      return validate(v, id, hashMention);
    }
    const hashLink = "link";
    function isLink(v) {
      return is$typed(v, id, hashLink);
    }
    function validateLink(v) {
      return validate(v, id, hashLink);
    }
    const hashTag = "tag";
    function isTag(v) {
      return is$typed(v, id, hashTag);
    }
    function validateTag(v) {
      return validate(v, id, hashTag);
    }
    const hashByteSlice = "byteSlice";
    function isByteSlice(v) {
      return is$typed(v, id, hashByteSlice);
    }
    function validateByteSlice(v) {
      return validate(v, id, hashByteSlice);
    }
    return facet;
  }
  var defs$9 = {};
  var hasRequiredDefs$9;
  function requireDefs$9() {
    if (hasRequiredDefs$9) return defs$9;
    hasRequiredDefs$9 = 1;
    Object.defineProperty(defs$9, "__esModule", { value: true });
    defs$9.isSkeletonSearchPost = isSkeletonSearchPost;
    defs$9.validateSkeletonSearchPost = validateSkeletonSearchPost;
    defs$9.isSkeletonSearchActor = isSkeletonSearchActor;
    defs$9.validateSkeletonSearchActor = validateSkeletonSearchActor;
    defs$9.isSkeletonSearchStarterPack = isSkeletonSearchStarterPack;
    defs$9.validateSkeletonSearchStarterPack = validateSkeletonSearchStarterPack;
    defs$9.isTrendingTopic = isTrendingTopic;
    defs$9.validateTrendingTopic = validateTrendingTopic;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "app.bsky.unspecced.defs";
    const hashSkeletonSearchPost = "skeletonSearchPost";
    function isSkeletonSearchPost(v) {
      return is$typed(v, id, hashSkeletonSearchPost);
    }
    function validateSkeletonSearchPost(v) {
      return validate(v, id, hashSkeletonSearchPost);
    }
    const hashSkeletonSearchActor = "skeletonSearchActor";
    function isSkeletonSearchActor(v) {
      return is$typed(v, id, hashSkeletonSearchActor);
    }
    function validateSkeletonSearchActor(v) {
      return validate(v, id, hashSkeletonSearchActor);
    }
    const hashSkeletonSearchStarterPack = "skeletonSearchStarterPack";
    function isSkeletonSearchStarterPack(v) {
      return is$typed(v, id, hashSkeletonSearchStarterPack);
    }
    function validateSkeletonSearchStarterPack(v) {
      return validate(v, id, hashSkeletonSearchStarterPack);
    }
    const hashTrendingTopic = "trendingTopic";
    function isTrendingTopic(v) {
      return is$typed(v, id, hashTrendingTopic);
    }
    function validateTrendingTopic(v) {
      return validate(v, id, hashTrendingTopic);
    }
    return defs$9;
  }
  var getConfig$1 = {};
  var hasRequiredGetConfig$1;
  function requireGetConfig$1() {
    if (hasRequiredGetConfig$1) return getConfig$1;
    hasRequiredGetConfig$1 = 1;
    Object.defineProperty(getConfig$1, "__esModule", { value: true });
    getConfig$1.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return getConfig$1;
  }
  var getPopularFeedGenerators = {};
  var hasRequiredGetPopularFeedGenerators;
  function requireGetPopularFeedGenerators() {
    if (hasRequiredGetPopularFeedGenerators) return getPopularFeedGenerators;
    hasRequiredGetPopularFeedGenerators = 1;
    Object.defineProperty(getPopularFeedGenerators, "__esModule", { value: true });
    getPopularFeedGenerators.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return getPopularFeedGenerators;
  }
  var getSuggestionsSkeleton = {};
  var hasRequiredGetSuggestionsSkeleton;
  function requireGetSuggestionsSkeleton() {
    if (hasRequiredGetSuggestionsSkeleton) return getSuggestionsSkeleton;
    hasRequiredGetSuggestionsSkeleton = 1;
    Object.defineProperty(getSuggestionsSkeleton, "__esModule", { value: true });
    getSuggestionsSkeleton.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return getSuggestionsSkeleton;
  }
  var getTaggedSuggestions = {};
  var hasRequiredGetTaggedSuggestions;
  function requireGetTaggedSuggestions() {
    if (hasRequiredGetTaggedSuggestions) return getTaggedSuggestions;
    hasRequiredGetTaggedSuggestions = 1;
    Object.defineProperty(getTaggedSuggestions, "__esModule", { value: true });
    getTaggedSuggestions.toKnownErr = toKnownErr;
    getTaggedSuggestions.isSuggestion = isSuggestion;
    getTaggedSuggestions.validateSuggestion = validateSuggestion;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "app.bsky.unspecced.getTaggedSuggestions";
    function toKnownErr(e) {
      return e;
    }
    const hashSuggestion = "suggestion";
    function isSuggestion(v) {
      return is$typed(v, id, hashSuggestion);
    }
    function validateSuggestion(v) {
      return validate(v, id, hashSuggestion);
    }
    return getTaggedSuggestions;
  }
  var getTrendingTopics = {};
  var hasRequiredGetTrendingTopics;
  function requireGetTrendingTopics() {
    if (hasRequiredGetTrendingTopics) return getTrendingTopics;
    hasRequiredGetTrendingTopics = 1;
    Object.defineProperty(getTrendingTopics, "__esModule", { value: true });
    getTrendingTopics.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return getTrendingTopics;
  }
  var defs$8 = {};
  var hasRequiredDefs$8;
  function requireDefs$8() {
    if (hasRequiredDefs$8) return defs$8;
    hasRequiredDefs$8 = 1;
    Object.defineProperty(defs$8, "__esModule", { value: true });
    defs$8.isJobStatus = isJobStatus;
    defs$8.validateJobStatus = validateJobStatus;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "app.bsky.video.defs";
    const hashJobStatus = "jobStatus";
    function isJobStatus(v) {
      return is$typed(v, id, hashJobStatus);
    }
    function validateJobStatus(v) {
      return validate(v, id, hashJobStatus);
    }
    return defs$8;
  }
  var getJobStatus = {};
  var hasRequiredGetJobStatus;
  function requireGetJobStatus() {
    if (hasRequiredGetJobStatus) return getJobStatus;
    hasRequiredGetJobStatus = 1;
    Object.defineProperty(getJobStatus, "__esModule", { value: true });
    getJobStatus.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return getJobStatus;
  }
  var getUploadLimits = {};
  var hasRequiredGetUploadLimits;
  function requireGetUploadLimits() {
    if (hasRequiredGetUploadLimits) return getUploadLimits;
    hasRequiredGetUploadLimits = 1;
    Object.defineProperty(getUploadLimits, "__esModule", { value: true });
    getUploadLimits.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return getUploadLimits;
  }
  var uploadVideo = {};
  var hasRequiredUploadVideo;
  function requireUploadVideo() {
    if (hasRequiredUploadVideo) return uploadVideo;
    hasRequiredUploadVideo = 1;
    Object.defineProperty(uploadVideo, "__esModule", { value: true });
    uploadVideo.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return uploadVideo;
  }
  var declaration = {};
  var hasRequiredDeclaration;
  function requireDeclaration() {
    if (hasRequiredDeclaration) return declaration;
    hasRequiredDeclaration = 1;
    Object.defineProperty(declaration, "__esModule", { value: true });
    declaration.isRecord = isRecord;
    declaration.validateRecord = validateRecord;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "chat.bsky.actor.declaration";
    const hashRecord = "main";
    function isRecord(v) {
      return is$typed(v, id, hashRecord);
    }
    function validateRecord(v) {
      return validate(v, id, hashRecord, true);
    }
    return declaration;
  }
  var defs$7 = {};
  var hasRequiredDefs$7;
  function requireDefs$7() {
    if (hasRequiredDefs$7) return defs$7;
    hasRequiredDefs$7 = 1;
    Object.defineProperty(defs$7, "__esModule", { value: true });
    defs$7.isProfileViewBasic = isProfileViewBasic;
    defs$7.validateProfileViewBasic = validateProfileViewBasic;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "chat.bsky.actor.defs";
    const hashProfileViewBasic = "profileViewBasic";
    function isProfileViewBasic(v) {
      return is$typed(v, id, hashProfileViewBasic);
    }
    function validateProfileViewBasic(v) {
      return validate(v, id, hashProfileViewBasic);
    }
    return defs$7;
  }
  var deleteAccount = {};
  var hasRequiredDeleteAccount;
  function requireDeleteAccount() {
    if (hasRequiredDeleteAccount) return deleteAccount;
    hasRequiredDeleteAccount = 1;
    Object.defineProperty(deleteAccount, "__esModule", { value: true });
    deleteAccount.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return deleteAccount;
  }
  var exportAccountData = {};
  var hasRequiredExportAccountData;
  function requireExportAccountData() {
    if (hasRequiredExportAccountData) return exportAccountData;
    hasRequiredExportAccountData = 1;
    Object.defineProperty(exportAccountData, "__esModule", { value: true });
    exportAccountData.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return exportAccountData;
  }
  var defs$6 = {};
  var hasRequiredDefs$6;
  function requireDefs$6() {
    if (hasRequiredDefs$6) return defs$6;
    hasRequiredDefs$6 = 1;
    Object.defineProperty(defs$6, "__esModule", { value: true });
    defs$6.isMessageRef = isMessageRef;
    defs$6.validateMessageRef = validateMessageRef;
    defs$6.isMessageInput = isMessageInput;
    defs$6.validateMessageInput = validateMessageInput;
    defs$6.isMessageView = isMessageView;
    defs$6.validateMessageView = validateMessageView;
    defs$6.isDeletedMessageView = isDeletedMessageView;
    defs$6.validateDeletedMessageView = validateDeletedMessageView;
    defs$6.isMessageViewSender = isMessageViewSender;
    defs$6.validateMessageViewSender = validateMessageViewSender;
    defs$6.isConvoView = isConvoView;
    defs$6.validateConvoView = validateConvoView;
    defs$6.isLogBeginConvo = isLogBeginConvo;
    defs$6.validateLogBeginConvo = validateLogBeginConvo;
    defs$6.isLogLeaveConvo = isLogLeaveConvo;
    defs$6.validateLogLeaveConvo = validateLogLeaveConvo;
    defs$6.isLogCreateMessage = isLogCreateMessage;
    defs$6.validateLogCreateMessage = validateLogCreateMessage;
    defs$6.isLogDeleteMessage = isLogDeleteMessage;
    defs$6.validateLogDeleteMessage = validateLogDeleteMessage;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "chat.bsky.convo.defs";
    const hashMessageRef = "messageRef";
    function isMessageRef(v) {
      return is$typed(v, id, hashMessageRef);
    }
    function validateMessageRef(v) {
      return validate(v, id, hashMessageRef);
    }
    const hashMessageInput = "messageInput";
    function isMessageInput(v) {
      return is$typed(v, id, hashMessageInput);
    }
    function validateMessageInput(v) {
      return validate(v, id, hashMessageInput);
    }
    const hashMessageView = "messageView";
    function isMessageView(v) {
      return is$typed(v, id, hashMessageView);
    }
    function validateMessageView(v) {
      return validate(v, id, hashMessageView);
    }
    const hashDeletedMessageView = "deletedMessageView";
    function isDeletedMessageView(v) {
      return is$typed(v, id, hashDeletedMessageView);
    }
    function validateDeletedMessageView(v) {
      return validate(v, id, hashDeletedMessageView);
    }
    const hashMessageViewSender = "messageViewSender";
    function isMessageViewSender(v) {
      return is$typed(v, id, hashMessageViewSender);
    }
    function validateMessageViewSender(v) {
      return validate(v, id, hashMessageViewSender);
    }
    const hashConvoView = "convoView";
    function isConvoView(v) {
      return is$typed(v, id, hashConvoView);
    }
    function validateConvoView(v) {
      return validate(v, id, hashConvoView);
    }
    const hashLogBeginConvo = "logBeginConvo";
    function isLogBeginConvo(v) {
      return is$typed(v, id, hashLogBeginConvo);
    }
    function validateLogBeginConvo(v) {
      return validate(v, id, hashLogBeginConvo);
    }
    const hashLogLeaveConvo = "logLeaveConvo";
    function isLogLeaveConvo(v) {
      return is$typed(v, id, hashLogLeaveConvo);
    }
    function validateLogLeaveConvo(v) {
      return validate(v, id, hashLogLeaveConvo);
    }
    const hashLogCreateMessage = "logCreateMessage";
    function isLogCreateMessage(v) {
      return is$typed(v, id, hashLogCreateMessage);
    }
    function validateLogCreateMessage(v) {
      return validate(v, id, hashLogCreateMessage);
    }
    const hashLogDeleteMessage = "logDeleteMessage";
    function isLogDeleteMessage(v) {
      return is$typed(v, id, hashLogDeleteMessage);
    }
    function validateLogDeleteMessage(v) {
      return validate(v, id, hashLogDeleteMessage);
    }
    return defs$6;
  }
  var deleteMessageForSelf = {};
  var hasRequiredDeleteMessageForSelf;
  function requireDeleteMessageForSelf() {
    if (hasRequiredDeleteMessageForSelf) return deleteMessageForSelf;
    hasRequiredDeleteMessageForSelf = 1;
    Object.defineProperty(deleteMessageForSelf, "__esModule", { value: true });
    deleteMessageForSelf.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return deleteMessageForSelf;
  }
  var getConvo = {};
  var hasRequiredGetConvo;
  function requireGetConvo() {
    if (hasRequiredGetConvo) return getConvo;
    hasRequiredGetConvo = 1;
    Object.defineProperty(getConvo, "__esModule", { value: true });
    getConvo.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return getConvo;
  }
  var getConvoForMembers = {};
  var hasRequiredGetConvoForMembers;
  function requireGetConvoForMembers() {
    if (hasRequiredGetConvoForMembers) return getConvoForMembers;
    hasRequiredGetConvoForMembers = 1;
    Object.defineProperty(getConvoForMembers, "__esModule", { value: true });
    getConvoForMembers.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return getConvoForMembers;
  }
  var getLog = {};
  var hasRequiredGetLog;
  function requireGetLog() {
    if (hasRequiredGetLog) return getLog;
    hasRequiredGetLog = 1;
    Object.defineProperty(getLog, "__esModule", { value: true });
    getLog.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return getLog;
  }
  var getMessages = {};
  var hasRequiredGetMessages;
  function requireGetMessages() {
    if (hasRequiredGetMessages) return getMessages;
    hasRequiredGetMessages = 1;
    Object.defineProperty(getMessages, "__esModule", { value: true });
    getMessages.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return getMessages;
  }
  var leaveConvo = {};
  var hasRequiredLeaveConvo;
  function requireLeaveConvo() {
    if (hasRequiredLeaveConvo) return leaveConvo;
    hasRequiredLeaveConvo = 1;
    Object.defineProperty(leaveConvo, "__esModule", { value: true });
    leaveConvo.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return leaveConvo;
  }
  var listConvos = {};
  var hasRequiredListConvos;
  function requireListConvos() {
    if (hasRequiredListConvos) return listConvos;
    hasRequiredListConvos = 1;
    Object.defineProperty(listConvos, "__esModule", { value: true });
    listConvos.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return listConvos;
  }
  var muteConvo = {};
  var hasRequiredMuteConvo;
  function requireMuteConvo() {
    if (hasRequiredMuteConvo) return muteConvo;
    hasRequiredMuteConvo = 1;
    Object.defineProperty(muteConvo, "__esModule", { value: true });
    muteConvo.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return muteConvo;
  }
  var sendMessage = {};
  var hasRequiredSendMessage;
  function requireSendMessage() {
    if (hasRequiredSendMessage) return sendMessage;
    hasRequiredSendMessage = 1;
    Object.defineProperty(sendMessage, "__esModule", { value: true });
    sendMessage.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return sendMessage;
  }
  var sendMessageBatch = {};
  var hasRequiredSendMessageBatch;
  function requireSendMessageBatch() {
    if (hasRequiredSendMessageBatch) return sendMessageBatch;
    hasRequiredSendMessageBatch = 1;
    Object.defineProperty(sendMessageBatch, "__esModule", { value: true });
    sendMessageBatch.toKnownErr = toKnownErr;
    sendMessageBatch.isBatchItem = isBatchItem;
    sendMessageBatch.validateBatchItem = validateBatchItem;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "chat.bsky.convo.sendMessageBatch";
    function toKnownErr(e) {
      return e;
    }
    const hashBatchItem = "batchItem";
    function isBatchItem(v) {
      return is$typed(v, id, hashBatchItem);
    }
    function validateBatchItem(v) {
      return validate(v, id, hashBatchItem);
    }
    return sendMessageBatch;
  }
  var unmuteConvo = {};
  var hasRequiredUnmuteConvo;
  function requireUnmuteConvo() {
    if (hasRequiredUnmuteConvo) return unmuteConvo;
    hasRequiredUnmuteConvo = 1;
    Object.defineProperty(unmuteConvo, "__esModule", { value: true });
    unmuteConvo.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return unmuteConvo;
  }
  var updateRead = {};
  var hasRequiredUpdateRead;
  function requireUpdateRead() {
    if (hasRequiredUpdateRead) return updateRead;
    hasRequiredUpdateRead = 1;
    Object.defineProperty(updateRead, "__esModule", { value: true });
    updateRead.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return updateRead;
  }
  var getActorMetadata = {};
  var hasRequiredGetActorMetadata;
  function requireGetActorMetadata() {
    if (hasRequiredGetActorMetadata) return getActorMetadata;
    hasRequiredGetActorMetadata = 1;
    Object.defineProperty(getActorMetadata, "__esModule", { value: true });
    getActorMetadata.toKnownErr = toKnownErr;
    getActorMetadata.isMetadata = isMetadata;
    getActorMetadata.validateMetadata = validateMetadata;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "chat.bsky.moderation.getActorMetadata";
    function toKnownErr(e) {
      return e;
    }
    const hashMetadata = "metadata";
    function isMetadata(v) {
      return is$typed(v, id, hashMetadata);
    }
    function validateMetadata(v) {
      return validate(v, id, hashMetadata);
    }
    return getActorMetadata;
  }
  var getMessageContext = {};
  var hasRequiredGetMessageContext;
  function requireGetMessageContext() {
    if (hasRequiredGetMessageContext) return getMessageContext;
    hasRequiredGetMessageContext = 1;
    Object.defineProperty(getMessageContext, "__esModule", { value: true });
    getMessageContext.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return getMessageContext;
  }
  var updateActorAccess = {};
  var hasRequiredUpdateActorAccess;
  function requireUpdateActorAccess() {
    if (hasRequiredUpdateActorAccess) return updateActorAccess;
    hasRequiredUpdateActorAccess = 1;
    Object.defineProperty(updateActorAccess, "__esModule", { value: true });
    updateActorAccess.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return updateActorAccess;
  }
  var defs$5 = {};
  var hasRequiredDefs$5;
  function requireDefs$5() {
    if (hasRequiredDefs$5) return defs$5;
    hasRequiredDefs$5 = 1;
    Object.defineProperty(defs$5, "__esModule", { value: true });
    defs$5.isTemplateView = isTemplateView;
    defs$5.validateTemplateView = validateTemplateView;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "tools.ozone.communication.defs";
    const hashTemplateView = "templateView";
    function isTemplateView(v) {
      return is$typed(v, id, hashTemplateView);
    }
    function validateTemplateView(v) {
      return validate(v, id, hashTemplateView);
    }
    return defs$5;
  }
  var deleteTemplate = {};
  var hasRequiredDeleteTemplate;
  function requireDeleteTemplate() {
    if (hasRequiredDeleteTemplate) return deleteTemplate;
    hasRequiredDeleteTemplate = 1;
    Object.defineProperty(deleteTemplate, "__esModule", { value: true });
    deleteTemplate.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return deleteTemplate;
  }
  var listTemplates = {};
  var hasRequiredListTemplates;
  function requireListTemplates() {
    if (hasRequiredListTemplates) return listTemplates;
    hasRequiredListTemplates = 1;
    Object.defineProperty(listTemplates, "__esModule", { value: true });
    listTemplates.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return listTemplates;
  }
  var defs$4 = {};
  var hasRequiredDefs$4;
  function requireDefs$4() {
    if (hasRequiredDefs$4) return defs$4;
    hasRequiredDefs$4 = 1;
    Object.defineProperty(defs$4, "__esModule", { value: true });
    defs$4.REVIEWNONE = defs$4.REVIEWCLOSED = defs$4.REVIEWESCALATED = defs$4.REVIEWOPEN = void 0;
    defs$4.isModEventView = isModEventView;
    defs$4.validateModEventView = validateModEventView;
    defs$4.isModEventViewDetail = isModEventViewDetail;
    defs$4.validateModEventViewDetail = validateModEventViewDetail;
    defs$4.isSubjectStatusView = isSubjectStatusView;
    defs$4.validateSubjectStatusView = validateSubjectStatusView;
    defs$4.isAccountStats = isAccountStats;
    defs$4.validateAccountStats = validateAccountStats;
    defs$4.isRecordsStats = isRecordsStats;
    defs$4.validateRecordsStats = validateRecordsStats;
    defs$4.isModEventTakedown = isModEventTakedown;
    defs$4.validateModEventTakedown = validateModEventTakedown;
    defs$4.isModEventReverseTakedown = isModEventReverseTakedown;
    defs$4.validateModEventReverseTakedown = validateModEventReverseTakedown;
    defs$4.isModEventResolveAppeal = isModEventResolveAppeal;
    defs$4.validateModEventResolveAppeal = validateModEventResolveAppeal;
    defs$4.isModEventComment = isModEventComment;
    defs$4.validateModEventComment = validateModEventComment;
    defs$4.isModEventReport = isModEventReport;
    defs$4.validateModEventReport = validateModEventReport;
    defs$4.isModEventLabel = isModEventLabel;
    defs$4.validateModEventLabel = validateModEventLabel;
    defs$4.isModEventPriorityScore = isModEventPriorityScore;
    defs$4.validateModEventPriorityScore = validateModEventPriorityScore;
    defs$4.isModEventAcknowledge = isModEventAcknowledge;
    defs$4.validateModEventAcknowledge = validateModEventAcknowledge;
    defs$4.isModEventEscalate = isModEventEscalate;
    defs$4.validateModEventEscalate = validateModEventEscalate;
    defs$4.isModEventMute = isModEventMute;
    defs$4.validateModEventMute = validateModEventMute;
    defs$4.isModEventUnmute = isModEventUnmute;
    defs$4.validateModEventUnmute = validateModEventUnmute;
    defs$4.isModEventMuteReporter = isModEventMuteReporter;
    defs$4.validateModEventMuteReporter = validateModEventMuteReporter;
    defs$4.isModEventUnmuteReporter = isModEventUnmuteReporter;
    defs$4.validateModEventUnmuteReporter = validateModEventUnmuteReporter;
    defs$4.isModEventEmail = isModEventEmail;
    defs$4.validateModEventEmail = validateModEventEmail;
    defs$4.isModEventDivert = isModEventDivert;
    defs$4.validateModEventDivert = validateModEventDivert;
    defs$4.isModEventTag = isModEventTag;
    defs$4.validateModEventTag = validateModEventTag;
    defs$4.isAccountEvent = isAccountEvent;
    defs$4.validateAccountEvent = validateAccountEvent;
    defs$4.isIdentityEvent = isIdentityEvent;
    defs$4.validateIdentityEvent = validateIdentityEvent;
    defs$4.isRecordEvent = isRecordEvent;
    defs$4.validateRecordEvent = validateRecordEvent;
    defs$4.isRepoView = isRepoView;
    defs$4.validateRepoView = validateRepoView;
    defs$4.isRepoViewDetail = isRepoViewDetail;
    defs$4.validateRepoViewDetail = validateRepoViewDetail;
    defs$4.isRepoViewNotFound = isRepoViewNotFound;
    defs$4.validateRepoViewNotFound = validateRepoViewNotFound;
    defs$4.isRecordView = isRecordView;
    defs$4.validateRecordView = validateRecordView;
    defs$4.isRecordViewDetail = isRecordViewDetail;
    defs$4.validateRecordViewDetail = validateRecordViewDetail;
    defs$4.isRecordViewNotFound = isRecordViewNotFound;
    defs$4.validateRecordViewNotFound = validateRecordViewNotFound;
    defs$4.isModeration = isModeration;
    defs$4.validateModeration = validateModeration;
    defs$4.isModerationDetail = isModerationDetail;
    defs$4.validateModerationDetail = validateModerationDetail;
    defs$4.isBlobView = isBlobView;
    defs$4.validateBlobView = validateBlobView;
    defs$4.isImageDetails = isImageDetails;
    defs$4.validateImageDetails = validateImageDetails;
    defs$4.isVideoDetails = isVideoDetails;
    defs$4.validateVideoDetails = validateVideoDetails;
    defs$4.isAccountHosting = isAccountHosting;
    defs$4.validateAccountHosting = validateAccountHosting;
    defs$4.isRecordHosting = isRecordHosting;
    defs$4.validateRecordHosting = validateRecordHosting;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "tools.ozone.moderation.defs";
    const hashModEventView = "modEventView";
    function isModEventView(v) {
      return is$typed(v, id, hashModEventView);
    }
    function validateModEventView(v) {
      return validate(v, id, hashModEventView);
    }
    const hashModEventViewDetail = "modEventViewDetail";
    function isModEventViewDetail(v) {
      return is$typed(v, id, hashModEventViewDetail);
    }
    function validateModEventViewDetail(v) {
      return validate(v, id, hashModEventViewDetail);
    }
    const hashSubjectStatusView = "subjectStatusView";
    function isSubjectStatusView(v) {
      return is$typed(v, id, hashSubjectStatusView);
    }
    function validateSubjectStatusView(v) {
      return validate(v, id, hashSubjectStatusView);
    }
    const hashAccountStats = "accountStats";
    function isAccountStats(v) {
      return is$typed(v, id, hashAccountStats);
    }
    function validateAccountStats(v) {
      return validate(v, id, hashAccountStats);
    }
    const hashRecordsStats = "recordsStats";
    function isRecordsStats(v) {
      return is$typed(v, id, hashRecordsStats);
    }
    function validateRecordsStats(v) {
      return validate(v, id, hashRecordsStats);
    }
    defs$4.REVIEWOPEN = `${id}#reviewOpen`;
    defs$4.REVIEWESCALATED = `${id}#reviewEscalated`;
    defs$4.REVIEWCLOSED = `${id}#reviewClosed`;
    defs$4.REVIEWNONE = `${id}#reviewNone`;
    const hashModEventTakedown = "modEventTakedown";
    function isModEventTakedown(v) {
      return is$typed(v, id, hashModEventTakedown);
    }
    function validateModEventTakedown(v) {
      return validate(v, id, hashModEventTakedown);
    }
    const hashModEventReverseTakedown = "modEventReverseTakedown";
    function isModEventReverseTakedown(v) {
      return is$typed(v, id, hashModEventReverseTakedown);
    }
    function validateModEventReverseTakedown(v) {
      return validate(v, id, hashModEventReverseTakedown);
    }
    const hashModEventResolveAppeal = "modEventResolveAppeal";
    function isModEventResolveAppeal(v) {
      return is$typed(v, id, hashModEventResolveAppeal);
    }
    function validateModEventResolveAppeal(v) {
      return validate(v, id, hashModEventResolveAppeal);
    }
    const hashModEventComment = "modEventComment";
    function isModEventComment(v) {
      return is$typed(v, id, hashModEventComment);
    }
    function validateModEventComment(v) {
      return validate(v, id, hashModEventComment);
    }
    const hashModEventReport = "modEventReport";
    function isModEventReport(v) {
      return is$typed(v, id, hashModEventReport);
    }
    function validateModEventReport(v) {
      return validate(v, id, hashModEventReport);
    }
    const hashModEventLabel = "modEventLabel";
    function isModEventLabel(v) {
      return is$typed(v, id, hashModEventLabel);
    }
    function validateModEventLabel(v) {
      return validate(v, id, hashModEventLabel);
    }
    const hashModEventPriorityScore = "modEventPriorityScore";
    function isModEventPriorityScore(v) {
      return is$typed(v, id, hashModEventPriorityScore);
    }
    function validateModEventPriorityScore(v) {
      return validate(v, id, hashModEventPriorityScore);
    }
    const hashModEventAcknowledge = "modEventAcknowledge";
    function isModEventAcknowledge(v) {
      return is$typed(v, id, hashModEventAcknowledge);
    }
    function validateModEventAcknowledge(v) {
      return validate(v, id, hashModEventAcknowledge);
    }
    const hashModEventEscalate = "modEventEscalate";
    function isModEventEscalate(v) {
      return is$typed(v, id, hashModEventEscalate);
    }
    function validateModEventEscalate(v) {
      return validate(v, id, hashModEventEscalate);
    }
    const hashModEventMute = "modEventMute";
    function isModEventMute(v) {
      return is$typed(v, id, hashModEventMute);
    }
    function validateModEventMute(v) {
      return validate(v, id, hashModEventMute);
    }
    const hashModEventUnmute = "modEventUnmute";
    function isModEventUnmute(v) {
      return is$typed(v, id, hashModEventUnmute);
    }
    function validateModEventUnmute(v) {
      return validate(v, id, hashModEventUnmute);
    }
    const hashModEventMuteReporter = "modEventMuteReporter";
    function isModEventMuteReporter(v) {
      return is$typed(v, id, hashModEventMuteReporter);
    }
    function validateModEventMuteReporter(v) {
      return validate(v, id, hashModEventMuteReporter);
    }
    const hashModEventUnmuteReporter = "modEventUnmuteReporter";
    function isModEventUnmuteReporter(v) {
      return is$typed(v, id, hashModEventUnmuteReporter);
    }
    function validateModEventUnmuteReporter(v) {
      return validate(v, id, hashModEventUnmuteReporter);
    }
    const hashModEventEmail = "modEventEmail";
    function isModEventEmail(v) {
      return is$typed(v, id, hashModEventEmail);
    }
    function validateModEventEmail(v) {
      return validate(v, id, hashModEventEmail);
    }
    const hashModEventDivert = "modEventDivert";
    function isModEventDivert(v) {
      return is$typed(v, id, hashModEventDivert);
    }
    function validateModEventDivert(v) {
      return validate(v, id, hashModEventDivert);
    }
    const hashModEventTag = "modEventTag";
    function isModEventTag(v) {
      return is$typed(v, id, hashModEventTag);
    }
    function validateModEventTag(v) {
      return validate(v, id, hashModEventTag);
    }
    const hashAccountEvent = "accountEvent";
    function isAccountEvent(v) {
      return is$typed(v, id, hashAccountEvent);
    }
    function validateAccountEvent(v) {
      return validate(v, id, hashAccountEvent);
    }
    const hashIdentityEvent = "identityEvent";
    function isIdentityEvent(v) {
      return is$typed(v, id, hashIdentityEvent);
    }
    function validateIdentityEvent(v) {
      return validate(v, id, hashIdentityEvent);
    }
    const hashRecordEvent = "recordEvent";
    function isRecordEvent(v) {
      return is$typed(v, id, hashRecordEvent);
    }
    function validateRecordEvent(v) {
      return validate(v, id, hashRecordEvent);
    }
    const hashRepoView = "repoView";
    function isRepoView(v) {
      return is$typed(v, id, hashRepoView);
    }
    function validateRepoView(v) {
      return validate(v, id, hashRepoView);
    }
    const hashRepoViewDetail = "repoViewDetail";
    function isRepoViewDetail(v) {
      return is$typed(v, id, hashRepoViewDetail);
    }
    function validateRepoViewDetail(v) {
      return validate(v, id, hashRepoViewDetail);
    }
    const hashRepoViewNotFound = "repoViewNotFound";
    function isRepoViewNotFound(v) {
      return is$typed(v, id, hashRepoViewNotFound);
    }
    function validateRepoViewNotFound(v) {
      return validate(v, id, hashRepoViewNotFound);
    }
    const hashRecordView = "recordView";
    function isRecordView(v) {
      return is$typed(v, id, hashRecordView);
    }
    function validateRecordView(v) {
      return validate(v, id, hashRecordView);
    }
    const hashRecordViewDetail = "recordViewDetail";
    function isRecordViewDetail(v) {
      return is$typed(v, id, hashRecordViewDetail);
    }
    function validateRecordViewDetail(v) {
      return validate(v, id, hashRecordViewDetail);
    }
    const hashRecordViewNotFound = "recordViewNotFound";
    function isRecordViewNotFound(v) {
      return is$typed(v, id, hashRecordViewNotFound);
    }
    function validateRecordViewNotFound(v) {
      return validate(v, id, hashRecordViewNotFound);
    }
    const hashModeration = "moderation";
    function isModeration(v) {
      return is$typed(v, id, hashModeration);
    }
    function validateModeration(v) {
      return validate(v, id, hashModeration);
    }
    const hashModerationDetail = "moderationDetail";
    function isModerationDetail(v) {
      return is$typed(v, id, hashModerationDetail);
    }
    function validateModerationDetail(v) {
      return validate(v, id, hashModerationDetail);
    }
    const hashBlobView = "blobView";
    function isBlobView(v) {
      return is$typed(v, id, hashBlobView);
    }
    function validateBlobView(v) {
      return validate(v, id, hashBlobView);
    }
    const hashImageDetails = "imageDetails";
    function isImageDetails(v) {
      return is$typed(v, id, hashImageDetails);
    }
    function validateImageDetails(v) {
      return validate(v, id, hashImageDetails);
    }
    const hashVideoDetails = "videoDetails";
    function isVideoDetails(v) {
      return is$typed(v, id, hashVideoDetails);
    }
    function validateVideoDetails(v) {
      return validate(v, id, hashVideoDetails);
    }
    const hashAccountHosting = "accountHosting";
    function isAccountHosting(v) {
      return is$typed(v, id, hashAccountHosting);
    }
    function validateAccountHosting(v) {
      return validate(v, id, hashAccountHosting);
    }
    const hashRecordHosting = "recordHosting";
    function isRecordHosting(v) {
      return is$typed(v, id, hashRecordHosting);
    }
    function validateRecordHosting(v) {
      return validate(v, id, hashRecordHosting);
    }
    return defs$4;
  }
  var getEvent = {};
  var hasRequiredGetEvent;
  function requireGetEvent() {
    if (hasRequiredGetEvent) return getEvent;
    hasRequiredGetEvent = 1;
    Object.defineProperty(getEvent, "__esModule", { value: true });
    getEvent.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return getEvent;
  }
  var getRecords = {};
  var hasRequiredGetRecords;
  function requireGetRecords() {
    if (hasRequiredGetRecords) return getRecords;
    hasRequiredGetRecords = 1;
    Object.defineProperty(getRecords, "__esModule", { value: true });
    getRecords.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return getRecords;
  }
  var getRepos = {};
  var hasRequiredGetRepos;
  function requireGetRepos() {
    if (hasRequiredGetRepos) return getRepos;
    hasRequiredGetRepos = 1;
    Object.defineProperty(getRepos, "__esModule", { value: true });
    getRepos.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return getRepos;
  }
  var queryEvents = {};
  var hasRequiredQueryEvents;
  function requireQueryEvents() {
    if (hasRequiredQueryEvents) return queryEvents;
    hasRequiredQueryEvents = 1;
    Object.defineProperty(queryEvents, "__esModule", { value: true });
    queryEvents.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return queryEvents;
  }
  var queryStatuses = {};
  var hasRequiredQueryStatuses;
  function requireQueryStatuses() {
    if (hasRequiredQueryStatuses) return queryStatuses;
    hasRequiredQueryStatuses = 1;
    Object.defineProperty(queryStatuses, "__esModule", { value: true });
    queryStatuses.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return queryStatuses;
  }
  var searchRepos = {};
  var hasRequiredSearchRepos;
  function requireSearchRepos() {
    if (hasRequiredSearchRepos) return searchRepos;
    hasRequiredSearchRepos = 1;
    Object.defineProperty(searchRepos, "__esModule", { value: true });
    searchRepos.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return searchRepos;
  }
  var getConfig = {};
  var hasRequiredGetConfig;
  function requireGetConfig() {
    if (hasRequiredGetConfig) return getConfig;
    hasRequiredGetConfig = 1;
    Object.defineProperty(getConfig, "__esModule", { value: true });
    getConfig.toKnownErr = toKnownErr;
    getConfig.isServiceConfig = isServiceConfig;
    getConfig.validateServiceConfig = validateServiceConfig;
    getConfig.isViewerConfig = isViewerConfig;
    getConfig.validateViewerConfig = validateViewerConfig;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "tools.ozone.server.getConfig";
    function toKnownErr(e) {
      return e;
    }
    const hashServiceConfig = "serviceConfig";
    function isServiceConfig(v) {
      return is$typed(v, id, hashServiceConfig);
    }
    function validateServiceConfig(v) {
      return validate(v, id, hashServiceConfig);
    }
    const hashViewerConfig = "viewerConfig";
    function isViewerConfig(v) {
      return is$typed(v, id, hashViewerConfig);
    }
    function validateViewerConfig(v) {
      return validate(v, id, hashViewerConfig);
    }
    return getConfig;
  }
  var addValues = {};
  var hasRequiredAddValues;
  function requireAddValues() {
    if (hasRequiredAddValues) return addValues;
    hasRequiredAddValues = 1;
    Object.defineProperty(addValues, "__esModule", { value: true });
    addValues.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return addValues;
  }
  var defs$3 = {};
  var hasRequiredDefs$3;
  function requireDefs$3() {
    if (hasRequiredDefs$3) return defs$3;
    hasRequiredDefs$3 = 1;
    Object.defineProperty(defs$3, "__esModule", { value: true });
    defs$3.isSet = isSet;
    defs$3.validateSet = validateSet;
    defs$3.isSetView = isSetView;
    defs$3.validateSetView = validateSetView;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "tools.ozone.set.defs";
    const hashSet = "set";
    function isSet(v) {
      return is$typed(v, id, hashSet);
    }
    function validateSet(v) {
      return validate(v, id, hashSet);
    }
    const hashSetView = "setView";
    function isSetView(v) {
      return is$typed(v, id, hashSetView);
    }
    function validateSetView(v) {
      return validate(v, id, hashSetView);
    }
    return defs$3;
  }
  var querySets = {};
  var hasRequiredQuerySets;
  function requireQuerySets() {
    if (hasRequiredQuerySets) return querySets;
    hasRequiredQuerySets = 1;
    Object.defineProperty(querySets, "__esModule", { value: true });
    querySets.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return querySets;
  }
  var upsertSet = {};
  var hasRequiredUpsertSet;
  function requireUpsertSet() {
    if (hasRequiredUpsertSet) return upsertSet;
    hasRequiredUpsertSet = 1;
    Object.defineProperty(upsertSet, "__esModule", { value: true });
    upsertSet.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return upsertSet;
  }
  var defs$2 = {};
  var hasRequiredDefs$2;
  function requireDefs$2() {
    if (hasRequiredDefs$2) return defs$2;
    hasRequiredDefs$2 = 1;
    Object.defineProperty(defs$2, "__esModule", { value: true });
    defs$2.isOption = isOption;
    defs$2.validateOption = validateOption;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "tools.ozone.setting.defs";
    const hashOption = "option";
    function isOption(v) {
      return is$typed(v, id, hashOption);
    }
    function validateOption(v) {
      return validate(v, id, hashOption);
    }
    return defs$2;
  }
  var listOptions = {};
  var hasRequiredListOptions;
  function requireListOptions() {
    if (hasRequiredListOptions) return listOptions;
    hasRequiredListOptions = 1;
    Object.defineProperty(listOptions, "__esModule", { value: true });
    listOptions.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return listOptions;
  }
  var removeOptions = {};
  var hasRequiredRemoveOptions;
  function requireRemoveOptions() {
    if (hasRequiredRemoveOptions) return removeOptions;
    hasRequiredRemoveOptions = 1;
    Object.defineProperty(removeOptions, "__esModule", { value: true });
    removeOptions.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return removeOptions;
  }
  var upsertOption = {};
  var hasRequiredUpsertOption;
  function requireUpsertOption() {
    if (hasRequiredUpsertOption) return upsertOption;
    hasRequiredUpsertOption = 1;
    Object.defineProperty(upsertOption, "__esModule", { value: true });
    upsertOption.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return upsertOption;
  }
  var defs$1 = {};
  var hasRequiredDefs$1;
  function requireDefs$1() {
    if (hasRequiredDefs$1) return defs$1;
    hasRequiredDefs$1 = 1;
    Object.defineProperty(defs$1, "__esModule", { value: true });
    defs$1.isSigDetail = isSigDetail;
    defs$1.validateSigDetail = validateSigDetail;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "tools.ozone.signature.defs";
    const hashSigDetail = "sigDetail";
    function isSigDetail(v) {
      return is$typed(v, id, hashSigDetail);
    }
    function validateSigDetail(v) {
      return validate(v, id, hashSigDetail);
    }
    return defs$1;
  }
  var findCorrelation = {};
  var hasRequiredFindCorrelation;
  function requireFindCorrelation() {
    if (hasRequiredFindCorrelation) return findCorrelation;
    hasRequiredFindCorrelation = 1;
    Object.defineProperty(findCorrelation, "__esModule", { value: true });
    findCorrelation.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return findCorrelation;
  }
  var findRelatedAccounts = {};
  var hasRequiredFindRelatedAccounts;
  function requireFindRelatedAccounts() {
    if (hasRequiredFindRelatedAccounts) return findRelatedAccounts;
    hasRequiredFindRelatedAccounts = 1;
    Object.defineProperty(findRelatedAccounts, "__esModule", { value: true });
    findRelatedAccounts.toKnownErr = toKnownErr;
    findRelatedAccounts.isRelatedAccount = isRelatedAccount;
    findRelatedAccounts.validateRelatedAccount = validateRelatedAccount;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "tools.ozone.signature.findRelatedAccounts";
    function toKnownErr(e) {
      return e;
    }
    const hashRelatedAccount = "relatedAccount";
    function isRelatedAccount(v) {
      return is$typed(v, id, hashRelatedAccount);
    }
    function validateRelatedAccount(v) {
      return validate(v, id, hashRelatedAccount);
    }
    return findRelatedAccounts;
  }
  var searchAccounts = {};
  var hasRequiredSearchAccounts;
  function requireSearchAccounts() {
    if (hasRequiredSearchAccounts) return searchAccounts;
    hasRequiredSearchAccounts = 1;
    Object.defineProperty(searchAccounts, "__esModule", { value: true });
    searchAccounts.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return searchAccounts;
  }
  var defs = {};
  var hasRequiredDefs;
  function requireDefs() {
    if (hasRequiredDefs) return defs;
    hasRequiredDefs = 1;
    Object.defineProperty(defs, "__esModule", { value: true });
    defs.ROLETRIAGE = defs.ROLEMODERATOR = defs.ROLEADMIN = void 0;
    defs.isMember = isMember;
    defs.validateMember = validateMember;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "tools.ozone.team.defs";
    const hashMember = "member";
    function isMember(v) {
      return is$typed(v, id, hashMember);
    }
    function validateMember(v) {
      return validate(v, id, hashMember);
    }
    defs.ROLEADMIN = `${id}#roleAdmin`;
    defs.ROLEMODERATOR = `${id}#roleModerator`;
    defs.ROLETRIAGE = `${id}#roleTriage`;
    return defs;
  }
  var listMembers = {};
  var hasRequiredListMembers;
  function requireListMembers() {
    if (hasRequiredListMembers) return listMembers;
    hasRequiredListMembers = 1;
    Object.defineProperty(listMembers, "__esModule", { value: true });
    listMembers.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return listMembers;
  }
  var hasRequiredClient;
  function requireClient() {
    if (hasRequiredClient) return client$1;
    hasRequiredClient = 1;
    var __createBinding = client$1 && client$1.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = client$1 && client$1.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = client$1 && client$1.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(client$1, "__esModule", { value: true });
    client$1.ComAtprotoServerDeleteAccount = client$1.ComAtprotoServerDefs = client$1.ComAtprotoServerDeactivateAccount = client$1.ComAtprotoServerCreateSession = client$1.ComAtprotoServerCreateInviteCodes = client$1.ComAtprotoServerCreateInviteCode = client$1.ComAtprotoServerCreateAppPassword = client$1.ComAtprotoServerCreateAccount = client$1.ComAtprotoServerConfirmEmail = client$1.ComAtprotoServerCheckAccountStatus = client$1.ComAtprotoServerActivateAccount = client$1.ComAtprotoRepoUploadBlob = client$1.ComAtprotoRepoStrongRef = client$1.ComAtprotoRepoPutRecord = client$1.ComAtprotoRepoListRecords = client$1.ComAtprotoRepoListMissingBlobs = client$1.ComAtprotoRepoImportRepo = client$1.ComAtprotoRepoGetRecord = client$1.ComAtprotoRepoDescribeRepo = client$1.ComAtprotoRepoDeleteRecord = client$1.ComAtprotoRepoDefs = client$1.ComAtprotoRepoCreateRecord = client$1.ComAtprotoRepoApplyWrites = client$1.ComAtprotoModerationDefs = client$1.ComAtprotoModerationCreateReport = client$1.ComAtprotoLexiconSchema = client$1.ComAtprotoLabelSubscribeLabels = client$1.ComAtprotoLabelQueryLabels = client$1.ComAtprotoLabelDefs = client$1.ComAtprotoIdentityUpdateHandle = client$1.ComAtprotoIdentitySubmitPlcOperation = client$1.ComAtprotoIdentitySignPlcOperation = client$1.ComAtprotoIdentityResolveHandle = client$1.ComAtprotoIdentityRequestPlcOperationSignature = client$1.ComAtprotoIdentityGetRecommendedDidCredentials = client$1.ComAtprotoAdminUpdateSubjectStatus = client$1.ComAtprotoAdminUpdateAccountPassword = client$1.ComAtprotoAdminUpdateAccountHandle = client$1.ComAtprotoAdminUpdateAccountEmail = client$1.ComAtprotoAdminSendEmail = client$1.ComAtprotoAdminSearchAccounts = client$1.ComAtprotoAdminGetSubjectStatus = client$1.ComAtprotoAdminGetInviteCodes = client$1.ComAtprotoAdminGetAccountInfos = client$1.ComAtprotoAdminGetAccountInfo = client$1.ComAtprotoAdminEnableAccountInvites = client$1.ComAtprotoAdminDisableInviteCodes = client$1.ComAtprotoAdminDisableAccountInvites = client$1.ComAtprotoAdminDeleteAccount = client$1.ComAtprotoAdminDefs = void 0;
    client$1.AppBskyFeedGenerator = client$1.AppBskyFeedDescribeFeedGenerator = client$1.AppBskyFeedDefs = client$1.AppBskyEmbedVideo = client$1.AppBskyEmbedRecordWithMedia = client$1.AppBskyEmbedRecord = client$1.AppBskyEmbedImages = client$1.AppBskyEmbedExternal = client$1.AppBskyEmbedDefs = client$1.AppBskyActorSearchActorsTypeahead = client$1.AppBskyActorSearchActors = client$1.AppBskyActorPutPreferences = client$1.AppBskyActorProfile = client$1.AppBskyActorGetSuggestions = client$1.AppBskyActorGetProfiles = client$1.AppBskyActorGetProfile = client$1.AppBskyActorGetPreferences = client$1.AppBskyActorDefs = client$1.ComAtprotoTempRequestPhoneVerification = client$1.ComAtprotoTempFetchLabels = client$1.ComAtprotoTempCheckSignupQueue = client$1.ComAtprotoTempAddReservedHandle = client$1.ComAtprotoSyncSubscribeRepos = client$1.ComAtprotoSyncRequestCrawl = client$1.ComAtprotoSyncNotifyOfUpdate = client$1.ComAtprotoSyncListRepos = client$1.ComAtprotoSyncListBlobs = client$1.ComAtprotoSyncGetRepoStatus = client$1.ComAtprotoSyncGetRepo = client$1.ComAtprotoSyncGetRecord = client$1.ComAtprotoSyncGetLatestCommit = client$1.ComAtprotoSyncGetHead = client$1.ComAtprotoSyncGetCheckout = client$1.ComAtprotoSyncGetBlocks = client$1.ComAtprotoSyncGetBlob = client$1.ComAtprotoServerUpdateEmail = client$1.ComAtprotoServerRevokeAppPassword = client$1.ComAtprotoServerResetPassword = client$1.ComAtprotoServerReserveSigningKey = client$1.ComAtprotoServerRequestPasswordReset = client$1.ComAtprotoServerRequestEmailUpdate = client$1.ComAtprotoServerRequestEmailConfirmation = client$1.ComAtprotoServerRequestAccountDelete = client$1.ComAtprotoServerRefreshSession = client$1.ComAtprotoServerListAppPasswords = client$1.ComAtprotoServerGetSession = client$1.ComAtprotoServerGetServiceAuth = client$1.ComAtprotoServerGetAccountInviteCodes = client$1.ComAtprotoServerDescribeServer = client$1.ComAtprotoServerDeleteSession = void 0;
    client$1.AppBskyGraphUnmuteThread = client$1.AppBskyGraphUnmuteActorList = client$1.AppBskyGraphUnmuteActor = client$1.AppBskyGraphStarterpack = client$1.AppBskyGraphSearchStarterPacks = client$1.AppBskyGraphMuteThread = client$1.AppBskyGraphMuteActorList = client$1.AppBskyGraphMuteActor = client$1.AppBskyGraphListitem = client$1.AppBskyGraphListblock = client$1.AppBskyGraphList = client$1.AppBskyGraphGetSuggestedFollowsByActor = client$1.AppBskyGraphGetStarterPacks = client$1.AppBskyGraphGetStarterPack = client$1.AppBskyGraphGetRelationships = client$1.AppBskyGraphGetMutes = client$1.AppBskyGraphGetLists = client$1.AppBskyGraphGetListMutes = client$1.AppBskyGraphGetListBlocks = client$1.AppBskyGraphGetList = client$1.AppBskyGraphGetKnownFollowers = client$1.AppBskyGraphGetFollows = client$1.AppBskyGraphGetFollowers = client$1.AppBskyGraphGetBlocks = client$1.AppBskyGraphGetActorStarterPacks = client$1.AppBskyGraphFollow = client$1.AppBskyGraphDefs = client$1.AppBskyGraphBlock = client$1.AppBskyFeedThreadgate = client$1.AppBskyFeedSendInteractions = client$1.AppBskyFeedSearchPosts = client$1.AppBskyFeedRepost = client$1.AppBskyFeedPostgate = client$1.AppBskyFeedPost = client$1.AppBskyFeedLike = client$1.AppBskyFeedGetTimeline = client$1.AppBskyFeedGetSuggestedFeeds = client$1.AppBskyFeedGetRepostedBy = client$1.AppBskyFeedGetQuotes = client$1.AppBskyFeedGetPosts = client$1.AppBskyFeedGetPostThread = client$1.AppBskyFeedGetListFeed = client$1.AppBskyFeedGetLikes = client$1.AppBskyFeedGetFeedSkeleton = client$1.AppBskyFeedGetFeedGenerators = client$1.AppBskyFeedGetFeedGenerator = client$1.AppBskyFeedGetFeed = client$1.AppBskyFeedGetAuthorFeed = client$1.AppBskyFeedGetActorLikes = client$1.AppBskyFeedGetActorFeeds = void 0;
    client$1.ToolsOzoneModerationGetEvent = client$1.ToolsOzoneModerationEmitEvent = client$1.ToolsOzoneModerationDefs = client$1.ToolsOzoneCommunicationUpdateTemplate = client$1.ToolsOzoneCommunicationListTemplates = client$1.ToolsOzoneCommunicationDeleteTemplate = client$1.ToolsOzoneCommunicationDefs = client$1.ToolsOzoneCommunicationCreateTemplate = client$1.ChatBskyModerationUpdateActorAccess = client$1.ChatBskyModerationGetMessageContext = client$1.ChatBskyModerationGetActorMetadata = client$1.ChatBskyConvoUpdateRead = client$1.ChatBskyConvoUnmuteConvo = client$1.ChatBskyConvoSendMessageBatch = client$1.ChatBskyConvoSendMessage = client$1.ChatBskyConvoMuteConvo = client$1.ChatBskyConvoListConvos = client$1.ChatBskyConvoLeaveConvo = client$1.ChatBskyConvoGetMessages = client$1.ChatBskyConvoGetLog = client$1.ChatBskyConvoGetConvoForMembers = client$1.ChatBskyConvoGetConvo = client$1.ChatBskyConvoDeleteMessageForSelf = client$1.ChatBskyConvoDefs = client$1.ChatBskyActorExportAccountData = client$1.ChatBskyActorDeleteAccount = client$1.ChatBskyActorDefs = client$1.ChatBskyActorDeclaration = client$1.AppBskyVideoUploadVideo = client$1.AppBskyVideoGetUploadLimits = client$1.AppBskyVideoGetJobStatus = client$1.AppBskyVideoDefs = client$1.AppBskyUnspeccedSearchStarterPacksSkeleton = client$1.AppBskyUnspeccedSearchPostsSkeleton = client$1.AppBskyUnspeccedSearchActorsSkeleton = client$1.AppBskyUnspeccedGetTrendingTopics = client$1.AppBskyUnspeccedGetTaggedSuggestions = client$1.AppBskyUnspeccedGetSuggestionsSkeleton = client$1.AppBskyUnspeccedGetPopularFeedGenerators = client$1.AppBskyUnspeccedGetConfig = client$1.AppBskyUnspeccedDefs = client$1.AppBskyRichtextFacet = client$1.AppBskyNotificationUpdateSeen = client$1.AppBskyNotificationRegisterPush = client$1.AppBskyNotificationPutPreferences = client$1.AppBskyNotificationListNotifications = client$1.AppBskyNotificationGetUnreadCount = client$1.AppBskyLabelerService = client$1.AppBskyLabelerGetServices = client$1.AppBskyLabelerDefs = void 0;
    client$1.ProfileRecord = client$1.AppBskyActorNS = client$1.AppBskyNS = client$1.AppNS = client$1.ComAtprotoTempNS = client$1.ComAtprotoSyncNS = client$1.ComAtprotoServerNS = client$1.ComAtprotoRepoNS = client$1.ComAtprotoModerationNS = client$1.SchemaRecord = client$1.ComAtprotoLexiconNS = client$1.ComAtprotoLabelNS = client$1.ComAtprotoIdentityNS = client$1.ComAtprotoAdminNS = client$1.ComAtprotoNS = client$1.ComNS = client$1.AtpBaseClient = client$1.TOOLS_OZONE_TEAM = client$1.TOOLS_OZONE_MODERATION = client$1.APP_BSKY_GRAPH = client$1.APP_BSKY_FEED = client$1.COM_ATPROTO_MODERATION = client$1.ToolsOzoneTeamUpdateMember = client$1.ToolsOzoneTeamListMembers = client$1.ToolsOzoneTeamDeleteMember = client$1.ToolsOzoneTeamDefs = client$1.ToolsOzoneTeamAddMember = client$1.ToolsOzoneSignatureSearchAccounts = client$1.ToolsOzoneSignatureFindRelatedAccounts = client$1.ToolsOzoneSignatureFindCorrelation = client$1.ToolsOzoneSignatureDefs = client$1.ToolsOzoneSettingUpsertOption = client$1.ToolsOzoneSettingRemoveOptions = client$1.ToolsOzoneSettingListOptions = client$1.ToolsOzoneSettingDefs = client$1.ToolsOzoneSetUpsertSet = client$1.ToolsOzoneSetQuerySets = client$1.ToolsOzoneSetGetValues = client$1.ToolsOzoneSetDeleteValues = client$1.ToolsOzoneSetDeleteSet = client$1.ToolsOzoneSetDefs = client$1.ToolsOzoneSetAddValues = client$1.ToolsOzoneServerGetConfig = client$1.ToolsOzoneModerationSearchRepos = client$1.ToolsOzoneModerationQueryStatuses = client$1.ToolsOzoneModerationQueryEvents = client$1.ToolsOzoneModerationGetRepos = client$1.ToolsOzoneModerationGetRepo = client$1.ToolsOzoneModerationGetRecords = client$1.ToolsOzoneModerationGetRecord = void 0;
    client$1.ToolsOzoneTeamNS = client$1.ToolsOzoneSignatureNS = client$1.ToolsOzoneSettingNS = client$1.ToolsOzoneSetNS = client$1.ToolsOzoneServerNS = client$1.ToolsOzoneModerationNS = client$1.ToolsOzoneCommunicationNS = client$1.ToolsOzoneNS = client$1.ToolsNS = client$1.ChatBskyModerationNS = client$1.ChatBskyConvoNS = client$1.DeclarationRecord = client$1.ChatBskyActorNS = client$1.ChatBskyNS = client$1.ChatNS = client$1.AppBskyVideoNS = client$1.AppBskyUnspeccedNS = client$1.AppBskyRichtextNS = client$1.AppBskyNotificationNS = client$1.ServiceRecord = client$1.AppBskyLabelerNS = client$1.StarterpackRecord = client$1.ListitemRecord = client$1.ListblockRecord = client$1.ListRecord = client$1.FollowRecord = client$1.BlockRecord = client$1.AppBskyGraphNS = client$1.ThreadgateRecord = client$1.RepostRecord = client$1.PostgateRecord = client$1.PostRecord = client$1.LikeRecord = client$1.GeneratorRecord = client$1.AppBskyFeedNS = client$1.AppBskyEmbedNS = void 0;
    const xrpc_1 = requireDist$1();
    const lexicons_js_1 = requireLexicons();
    const ComAtprotoRepoApplyWrites = __importStar(requireApplyWrites());
    const ComAtprotoRepoCreateRecord = __importStar(requireCreateRecord());
    const ComAtprotoRepoDeleteRecord = __importStar(requireDeleteRecord());
    const ComAtprotoRepoGetRecord = __importStar(requireGetRecord$2());
    const ComAtprotoRepoPutRecord = __importStar(requirePutRecord());
    const ComAtprotoServerConfirmEmail = __importStar(requireConfirmEmail());
    const ComAtprotoServerCreateAccount = __importStar(requireCreateAccount());
    const ComAtprotoServerCreateAppPassword = __importStar(requireCreateAppPassword());
    const ComAtprotoServerCreateSession = __importStar(requireCreateSession());
    const ComAtprotoServerDeleteAccount = __importStar(requireDeleteAccount$2());
    const ComAtprotoServerGetAccountInviteCodes = __importStar(requireGetAccountInviteCodes());
    const ComAtprotoServerGetServiceAuth = __importStar(requireGetServiceAuth());
    const ComAtprotoServerListAppPasswords = __importStar(requireListAppPasswords());
    const ComAtprotoServerRefreshSession = __importStar(requireRefreshSession());
    const ComAtprotoServerResetPassword = __importStar(requireResetPassword());
    const ComAtprotoServerUpdateEmail = __importStar(requireUpdateEmail());
    const ComAtprotoSyncGetBlob = __importStar(requireGetBlob());
    const ComAtprotoSyncGetBlocks = __importStar(requireGetBlocks$1());
    const ComAtprotoSyncGetHead = __importStar(requireGetHead());
    const ComAtprotoSyncGetLatestCommit = __importStar(requireGetLatestCommit());
    const ComAtprotoSyncGetRecord = __importStar(requireGetRecord$1());
    const ComAtprotoSyncGetRepo = __importStar(requireGetRepo$1());
    const ComAtprotoSyncGetRepoStatus = __importStar(requireGetRepoStatus());
    const ComAtprotoSyncListBlobs = __importStar(requireListBlobs());
    const AppBskyFeedGetActorLikes = __importStar(requireGetActorLikes());
    const AppBskyFeedGetAuthorFeed = __importStar(requireGetAuthorFeed());
    const AppBskyFeedGetFeed = __importStar(requireGetFeed());
    const AppBskyFeedGetFeedSkeleton = __importStar(requireGetFeedSkeleton());
    const AppBskyFeedGetListFeed = __importStar(requireGetListFeed());
    const AppBskyFeedGetPostThread = __importStar(requireGetPostThread());
    const AppBskyFeedSearchPosts = __importStar(requireSearchPosts());
    const AppBskyGraphGetRelationships = __importStar(requireGetRelationships());
    const AppBskyUnspeccedSearchActorsSkeleton = __importStar(requireSearchActorsSkeleton());
    const AppBskyUnspeccedSearchPostsSkeleton = __importStar(requireSearchPostsSkeleton());
    const AppBskyUnspeccedSearchStarterPacksSkeleton = __importStar(requireSearchStarterPacksSkeleton());
    const ToolsOzoneCommunicationCreateTemplate = __importStar(requireCreateTemplate());
    const ToolsOzoneCommunicationUpdateTemplate = __importStar(requireUpdateTemplate());
    const ToolsOzoneModerationEmitEvent = __importStar(requireEmitEvent());
    const ToolsOzoneModerationGetRecord = __importStar(requireGetRecord());
    const ToolsOzoneModerationGetRepo = __importStar(requireGetRepo());
    const ToolsOzoneSetDeleteSet = __importStar(requireDeleteSet());
    const ToolsOzoneSetDeleteValues = __importStar(requireDeleteValues());
    const ToolsOzoneSetGetValues = __importStar(requireGetValues());
    const ToolsOzoneTeamAddMember = __importStar(requireAddMember());
    const ToolsOzoneTeamDeleteMember = __importStar(requireDeleteMember());
    const ToolsOzoneTeamUpdateMember = __importStar(requireUpdateMember());
    client$1.ComAtprotoAdminDefs = __importStar(requireDefs$j());
    client$1.ComAtprotoAdminDeleteAccount = __importStar(requireDeleteAccount$1());
    client$1.ComAtprotoAdminDisableAccountInvites = __importStar(requireDisableAccountInvites());
    client$1.ComAtprotoAdminDisableInviteCodes = __importStar(requireDisableInviteCodes());
    client$1.ComAtprotoAdminEnableAccountInvites = __importStar(requireEnableAccountInvites());
    client$1.ComAtprotoAdminGetAccountInfo = __importStar(requireGetAccountInfo());
    client$1.ComAtprotoAdminGetAccountInfos = __importStar(requireGetAccountInfos());
    client$1.ComAtprotoAdminGetInviteCodes = __importStar(requireGetInviteCodes());
    client$1.ComAtprotoAdminGetSubjectStatus = __importStar(requireGetSubjectStatus());
    client$1.ComAtprotoAdminSearchAccounts = __importStar(requireSearchAccounts$1());
    client$1.ComAtprotoAdminSendEmail = __importStar(requireSendEmail());
    client$1.ComAtprotoAdminUpdateAccountEmail = __importStar(requireUpdateAccountEmail());
    client$1.ComAtprotoAdminUpdateAccountHandle = __importStar(requireUpdateAccountHandle());
    client$1.ComAtprotoAdminUpdateAccountPassword = __importStar(requireUpdateAccountPassword());
    client$1.ComAtprotoAdminUpdateSubjectStatus = __importStar(requireUpdateSubjectStatus());
    client$1.ComAtprotoIdentityGetRecommendedDidCredentials = __importStar(requireGetRecommendedDidCredentials());
    client$1.ComAtprotoIdentityRequestPlcOperationSignature = __importStar(requireRequestPlcOperationSignature());
    client$1.ComAtprotoIdentityResolveHandle = __importStar(requireResolveHandle());
    client$1.ComAtprotoIdentitySignPlcOperation = __importStar(requireSignPlcOperation());
    client$1.ComAtprotoIdentitySubmitPlcOperation = __importStar(requireSubmitPlcOperation());
    client$1.ComAtprotoIdentityUpdateHandle = __importStar(requireUpdateHandle());
    client$1.ComAtprotoLabelDefs = __importStar(requireDefs$i());
    client$1.ComAtprotoLabelQueryLabels = __importStar(requireQueryLabels());
    client$1.ComAtprotoLabelSubscribeLabels = __importStar(requireSubscribeLabels());
    client$1.ComAtprotoLexiconSchema = __importStar(requireSchema());
    client$1.ComAtprotoModerationCreateReport = __importStar(requireCreateReport());
    client$1.ComAtprotoModerationDefs = __importStar(requireDefs$h());
    client$1.ComAtprotoRepoApplyWrites = __importStar(requireApplyWrites());
    client$1.ComAtprotoRepoCreateRecord = __importStar(requireCreateRecord());
    client$1.ComAtprotoRepoDefs = __importStar(requireDefs$g());
    client$1.ComAtprotoRepoDeleteRecord = __importStar(requireDeleteRecord());
    client$1.ComAtprotoRepoDescribeRepo = __importStar(requireDescribeRepo());
    client$1.ComAtprotoRepoGetRecord = __importStar(requireGetRecord$2());
    client$1.ComAtprotoRepoImportRepo = __importStar(requireImportRepo());
    client$1.ComAtprotoRepoListMissingBlobs = __importStar(requireListMissingBlobs());
    client$1.ComAtprotoRepoListRecords = __importStar(requireListRecords());
    client$1.ComAtprotoRepoPutRecord = __importStar(requirePutRecord());
    client$1.ComAtprotoRepoStrongRef = __importStar(requireStrongRef());
    client$1.ComAtprotoRepoUploadBlob = __importStar(requireUploadBlob());
    client$1.ComAtprotoServerActivateAccount = __importStar(requireActivateAccount());
    client$1.ComAtprotoServerCheckAccountStatus = __importStar(requireCheckAccountStatus());
    client$1.ComAtprotoServerConfirmEmail = __importStar(requireConfirmEmail());
    client$1.ComAtprotoServerCreateAccount = __importStar(requireCreateAccount());
    client$1.ComAtprotoServerCreateAppPassword = __importStar(requireCreateAppPassword());
    client$1.ComAtprotoServerCreateInviteCode = __importStar(requireCreateInviteCode());
    client$1.ComAtprotoServerCreateInviteCodes = __importStar(requireCreateInviteCodes());
    client$1.ComAtprotoServerCreateSession = __importStar(requireCreateSession());
    client$1.ComAtprotoServerDeactivateAccount = __importStar(requireDeactivateAccount());
    client$1.ComAtprotoServerDefs = __importStar(requireDefs$f());
    client$1.ComAtprotoServerDeleteAccount = __importStar(requireDeleteAccount$2());
    client$1.ComAtprotoServerDeleteSession = __importStar(requireDeleteSession());
    client$1.ComAtprotoServerDescribeServer = __importStar(requireDescribeServer());
    client$1.ComAtprotoServerGetAccountInviteCodes = __importStar(requireGetAccountInviteCodes());
    client$1.ComAtprotoServerGetServiceAuth = __importStar(requireGetServiceAuth());
    client$1.ComAtprotoServerGetSession = __importStar(requireGetSession());
    client$1.ComAtprotoServerListAppPasswords = __importStar(requireListAppPasswords());
    client$1.ComAtprotoServerRefreshSession = __importStar(requireRefreshSession());
    client$1.ComAtprotoServerRequestAccountDelete = __importStar(requireRequestAccountDelete());
    client$1.ComAtprotoServerRequestEmailConfirmation = __importStar(requireRequestEmailConfirmation());
    client$1.ComAtprotoServerRequestEmailUpdate = __importStar(requireRequestEmailUpdate());
    client$1.ComAtprotoServerRequestPasswordReset = __importStar(requireRequestPasswordReset());
    client$1.ComAtprotoServerReserveSigningKey = __importStar(requireReserveSigningKey());
    client$1.ComAtprotoServerResetPassword = __importStar(requireResetPassword());
    client$1.ComAtprotoServerRevokeAppPassword = __importStar(requireRevokeAppPassword());
    client$1.ComAtprotoServerUpdateEmail = __importStar(requireUpdateEmail());
    client$1.ComAtprotoSyncGetBlob = __importStar(requireGetBlob());
    client$1.ComAtprotoSyncGetBlocks = __importStar(requireGetBlocks$1());
    client$1.ComAtprotoSyncGetCheckout = __importStar(requireGetCheckout());
    client$1.ComAtprotoSyncGetHead = __importStar(requireGetHead());
    client$1.ComAtprotoSyncGetLatestCommit = __importStar(requireGetLatestCommit());
    client$1.ComAtprotoSyncGetRecord = __importStar(requireGetRecord$1());
    client$1.ComAtprotoSyncGetRepo = __importStar(requireGetRepo$1());
    client$1.ComAtprotoSyncGetRepoStatus = __importStar(requireGetRepoStatus());
    client$1.ComAtprotoSyncListBlobs = __importStar(requireListBlobs());
    client$1.ComAtprotoSyncListRepos = __importStar(requireListRepos());
    client$1.ComAtprotoSyncNotifyOfUpdate = __importStar(requireNotifyOfUpdate());
    client$1.ComAtprotoSyncRequestCrawl = __importStar(requireRequestCrawl());
    client$1.ComAtprotoSyncSubscribeRepos = __importStar(requireSubscribeRepos());
    client$1.ComAtprotoTempAddReservedHandle = __importStar(requireAddReservedHandle());
    client$1.ComAtprotoTempCheckSignupQueue = __importStar(requireCheckSignupQueue());
    client$1.ComAtprotoTempFetchLabels = __importStar(requireFetchLabels());
    client$1.ComAtprotoTempRequestPhoneVerification = __importStar(requireRequestPhoneVerification());
    client$1.AppBskyActorDefs = __importStar(requireDefs$e());
    client$1.AppBskyActorGetPreferences = __importStar(requireGetPreferences());
    client$1.AppBskyActorGetProfile = __importStar(requireGetProfile());
    client$1.AppBskyActorGetProfiles = __importStar(requireGetProfiles());
    client$1.AppBskyActorGetSuggestions = __importStar(requireGetSuggestions());
    client$1.AppBskyActorProfile = __importStar(requireProfile$1());
    client$1.AppBskyActorPutPreferences = __importStar(requirePutPreferences$1());
    client$1.AppBskyActorSearchActors = __importStar(requireSearchActors());
    client$1.AppBskyActorSearchActorsTypeahead = __importStar(requireSearchActorsTypeahead());
    client$1.AppBskyEmbedDefs = __importStar(requireDefs$d());
    client$1.AppBskyEmbedExternal = __importStar(requireExternal());
    client$1.AppBskyEmbedImages = __importStar(requireImages());
    client$1.AppBskyEmbedRecord = __importStar(requireRecord());
    client$1.AppBskyEmbedRecordWithMedia = __importStar(requireRecordWithMedia());
    client$1.AppBskyEmbedVideo = __importStar(requireVideo());
    client$1.AppBskyFeedDefs = __importStar(requireDefs$c());
    client$1.AppBskyFeedDescribeFeedGenerator = __importStar(requireDescribeFeedGenerator());
    client$1.AppBskyFeedGenerator = __importStar(requireGenerator());
    client$1.AppBskyFeedGetActorFeeds = __importStar(requireGetActorFeeds());
    client$1.AppBskyFeedGetActorLikes = __importStar(requireGetActorLikes());
    client$1.AppBskyFeedGetAuthorFeed = __importStar(requireGetAuthorFeed());
    client$1.AppBskyFeedGetFeed = __importStar(requireGetFeed());
    client$1.AppBskyFeedGetFeedGenerator = __importStar(requireGetFeedGenerator());
    client$1.AppBskyFeedGetFeedGenerators = __importStar(requireGetFeedGenerators());
    client$1.AppBskyFeedGetFeedSkeleton = __importStar(requireGetFeedSkeleton());
    client$1.AppBskyFeedGetLikes = __importStar(requireGetLikes());
    client$1.AppBskyFeedGetListFeed = __importStar(requireGetListFeed());
    client$1.AppBskyFeedGetPostThread = __importStar(requireGetPostThread());
    client$1.AppBskyFeedGetPosts = __importStar(requireGetPosts());
    client$1.AppBskyFeedGetQuotes = __importStar(requireGetQuotes());
    client$1.AppBskyFeedGetRepostedBy = __importStar(requireGetRepostedBy());
    client$1.AppBskyFeedGetSuggestedFeeds = __importStar(requireGetSuggestedFeeds());
    client$1.AppBskyFeedGetTimeline = __importStar(requireGetTimeline());
    client$1.AppBskyFeedLike = __importStar(requireLike());
    client$1.AppBskyFeedPost = __importStar(requirePost$1());
    client$1.AppBskyFeedPostgate = __importStar(requirePostgate());
    client$1.AppBskyFeedRepost = __importStar(requireRepost());
    client$1.AppBskyFeedSearchPosts = __importStar(requireSearchPosts());
    client$1.AppBskyFeedSendInteractions = __importStar(requireSendInteractions());
    client$1.AppBskyFeedThreadgate = __importStar(requireThreadgate());
    client$1.AppBskyGraphBlock = __importStar(requireBlock());
    client$1.AppBskyGraphDefs = __importStar(requireDefs$b());
    client$1.AppBskyGraphFollow = __importStar(requireFollow());
    client$1.AppBskyGraphGetActorStarterPacks = __importStar(requireGetActorStarterPacks());
    client$1.AppBskyGraphGetBlocks = __importStar(requireGetBlocks());
    client$1.AppBskyGraphGetFollowers = __importStar(requireGetFollowers());
    client$1.AppBskyGraphGetFollows = __importStar(requireGetFollows());
    client$1.AppBskyGraphGetKnownFollowers = __importStar(requireGetKnownFollowers());
    client$1.AppBskyGraphGetList = __importStar(requireGetList());
    client$1.AppBskyGraphGetListBlocks = __importStar(requireGetListBlocks());
    client$1.AppBskyGraphGetListMutes = __importStar(requireGetListMutes());
    client$1.AppBskyGraphGetLists = __importStar(requireGetLists());
    client$1.AppBskyGraphGetMutes = __importStar(requireGetMutes());
    client$1.AppBskyGraphGetRelationships = __importStar(requireGetRelationships());
    client$1.AppBskyGraphGetStarterPack = __importStar(requireGetStarterPack());
    client$1.AppBskyGraphGetStarterPacks = __importStar(requireGetStarterPacks());
    client$1.AppBskyGraphGetSuggestedFollowsByActor = __importStar(requireGetSuggestedFollowsByActor());
    client$1.AppBskyGraphList = __importStar(requireList());
    client$1.AppBskyGraphListblock = __importStar(requireListblock());
    client$1.AppBskyGraphListitem = __importStar(requireListitem());
    client$1.AppBskyGraphMuteActor = __importStar(requireMuteActor());
    client$1.AppBskyGraphMuteActorList = __importStar(requireMuteActorList());
    client$1.AppBskyGraphMuteThread = __importStar(requireMuteThread());
    client$1.AppBskyGraphSearchStarterPacks = __importStar(requireSearchStarterPacks());
    client$1.AppBskyGraphStarterpack = __importStar(requireStarterpack());
    client$1.AppBskyGraphUnmuteActor = __importStar(requireUnmuteActor());
    client$1.AppBskyGraphUnmuteActorList = __importStar(requireUnmuteActorList());
    client$1.AppBskyGraphUnmuteThread = __importStar(requireUnmuteThread());
    client$1.AppBskyLabelerDefs = __importStar(requireDefs$a());
    client$1.AppBskyLabelerGetServices = __importStar(requireGetServices());
    client$1.AppBskyLabelerService = __importStar(requireService());
    client$1.AppBskyNotificationGetUnreadCount = __importStar(requireGetUnreadCount());
    client$1.AppBskyNotificationListNotifications = __importStar(requireListNotifications());
    client$1.AppBskyNotificationPutPreferences = __importStar(requirePutPreferences());
    client$1.AppBskyNotificationRegisterPush = __importStar(requireRegisterPush());
    client$1.AppBskyNotificationUpdateSeen = __importStar(requireUpdateSeen());
    client$1.AppBskyRichtextFacet = __importStar(requireFacet());
    client$1.AppBskyUnspeccedDefs = __importStar(requireDefs$9());
    client$1.AppBskyUnspeccedGetConfig = __importStar(requireGetConfig$1());
    client$1.AppBskyUnspeccedGetPopularFeedGenerators = __importStar(requireGetPopularFeedGenerators());
    client$1.AppBskyUnspeccedGetSuggestionsSkeleton = __importStar(requireGetSuggestionsSkeleton());
    client$1.AppBskyUnspeccedGetTaggedSuggestions = __importStar(requireGetTaggedSuggestions());
    client$1.AppBskyUnspeccedGetTrendingTopics = __importStar(requireGetTrendingTopics());
    client$1.AppBskyUnspeccedSearchActorsSkeleton = __importStar(requireSearchActorsSkeleton());
    client$1.AppBskyUnspeccedSearchPostsSkeleton = __importStar(requireSearchPostsSkeleton());
    client$1.AppBskyUnspeccedSearchStarterPacksSkeleton = __importStar(requireSearchStarterPacksSkeleton());
    client$1.AppBskyVideoDefs = __importStar(requireDefs$8());
    client$1.AppBskyVideoGetJobStatus = __importStar(requireGetJobStatus());
    client$1.AppBskyVideoGetUploadLimits = __importStar(requireGetUploadLimits());
    client$1.AppBskyVideoUploadVideo = __importStar(requireUploadVideo());
    client$1.ChatBskyActorDeclaration = __importStar(requireDeclaration());
    client$1.ChatBskyActorDefs = __importStar(requireDefs$7());
    client$1.ChatBskyActorDeleteAccount = __importStar(requireDeleteAccount());
    client$1.ChatBskyActorExportAccountData = __importStar(requireExportAccountData());
    client$1.ChatBskyConvoDefs = __importStar(requireDefs$6());
    client$1.ChatBskyConvoDeleteMessageForSelf = __importStar(requireDeleteMessageForSelf());
    client$1.ChatBskyConvoGetConvo = __importStar(requireGetConvo());
    client$1.ChatBskyConvoGetConvoForMembers = __importStar(requireGetConvoForMembers());
    client$1.ChatBskyConvoGetLog = __importStar(requireGetLog());
    client$1.ChatBskyConvoGetMessages = __importStar(requireGetMessages());
    client$1.ChatBskyConvoLeaveConvo = __importStar(requireLeaveConvo());
    client$1.ChatBskyConvoListConvos = __importStar(requireListConvos());
    client$1.ChatBskyConvoMuteConvo = __importStar(requireMuteConvo());
    client$1.ChatBskyConvoSendMessage = __importStar(requireSendMessage());
    client$1.ChatBskyConvoSendMessageBatch = __importStar(requireSendMessageBatch());
    client$1.ChatBskyConvoUnmuteConvo = __importStar(requireUnmuteConvo());
    client$1.ChatBskyConvoUpdateRead = __importStar(requireUpdateRead());
    client$1.ChatBskyModerationGetActorMetadata = __importStar(requireGetActorMetadata());
    client$1.ChatBskyModerationGetMessageContext = __importStar(requireGetMessageContext());
    client$1.ChatBskyModerationUpdateActorAccess = __importStar(requireUpdateActorAccess());
    client$1.ToolsOzoneCommunicationCreateTemplate = __importStar(requireCreateTemplate());
    client$1.ToolsOzoneCommunicationDefs = __importStar(requireDefs$5());
    client$1.ToolsOzoneCommunicationDeleteTemplate = __importStar(requireDeleteTemplate());
    client$1.ToolsOzoneCommunicationListTemplates = __importStar(requireListTemplates());
    client$1.ToolsOzoneCommunicationUpdateTemplate = __importStar(requireUpdateTemplate());
    client$1.ToolsOzoneModerationDefs = __importStar(requireDefs$4());
    client$1.ToolsOzoneModerationEmitEvent = __importStar(requireEmitEvent());
    client$1.ToolsOzoneModerationGetEvent = __importStar(requireGetEvent());
    client$1.ToolsOzoneModerationGetRecord = __importStar(requireGetRecord());
    client$1.ToolsOzoneModerationGetRecords = __importStar(requireGetRecords());
    client$1.ToolsOzoneModerationGetRepo = __importStar(requireGetRepo());
    client$1.ToolsOzoneModerationGetRepos = __importStar(requireGetRepos());
    client$1.ToolsOzoneModerationQueryEvents = __importStar(requireQueryEvents());
    client$1.ToolsOzoneModerationQueryStatuses = __importStar(requireQueryStatuses());
    client$1.ToolsOzoneModerationSearchRepos = __importStar(requireSearchRepos());
    client$1.ToolsOzoneServerGetConfig = __importStar(requireGetConfig());
    client$1.ToolsOzoneSetAddValues = __importStar(requireAddValues());
    client$1.ToolsOzoneSetDefs = __importStar(requireDefs$3());
    client$1.ToolsOzoneSetDeleteSet = __importStar(requireDeleteSet());
    client$1.ToolsOzoneSetDeleteValues = __importStar(requireDeleteValues());
    client$1.ToolsOzoneSetGetValues = __importStar(requireGetValues());
    client$1.ToolsOzoneSetQuerySets = __importStar(requireQuerySets());
    client$1.ToolsOzoneSetUpsertSet = __importStar(requireUpsertSet());
    client$1.ToolsOzoneSettingDefs = __importStar(requireDefs$2());
    client$1.ToolsOzoneSettingListOptions = __importStar(requireListOptions());
    client$1.ToolsOzoneSettingRemoveOptions = __importStar(requireRemoveOptions());
    client$1.ToolsOzoneSettingUpsertOption = __importStar(requireUpsertOption());
    client$1.ToolsOzoneSignatureDefs = __importStar(requireDefs$1());
    client$1.ToolsOzoneSignatureFindCorrelation = __importStar(requireFindCorrelation());
    client$1.ToolsOzoneSignatureFindRelatedAccounts = __importStar(requireFindRelatedAccounts());
    client$1.ToolsOzoneSignatureSearchAccounts = __importStar(requireSearchAccounts());
    client$1.ToolsOzoneTeamAddMember = __importStar(requireAddMember());
    client$1.ToolsOzoneTeamDefs = __importStar(requireDefs());
    client$1.ToolsOzoneTeamDeleteMember = __importStar(requireDeleteMember());
    client$1.ToolsOzoneTeamListMembers = __importStar(requireListMembers());
    client$1.ToolsOzoneTeamUpdateMember = __importStar(requireUpdateMember());
    client$1.COM_ATPROTO_MODERATION = {
      DefsReasonSpam: "com.atproto.moderation.defs#reasonSpam",
      DefsReasonViolation: "com.atproto.moderation.defs#reasonViolation",
      DefsReasonMisleading: "com.atproto.moderation.defs#reasonMisleading",
      DefsReasonSexual: "com.atproto.moderation.defs#reasonSexual",
      DefsReasonRude: "com.atproto.moderation.defs#reasonRude",
      DefsReasonOther: "com.atproto.moderation.defs#reasonOther",
      DefsReasonAppeal: "com.atproto.moderation.defs#reasonAppeal"
    };
    client$1.APP_BSKY_FEED = {
      DefsRequestLess: "app.bsky.feed.defs#requestLess",
      DefsRequestMore: "app.bsky.feed.defs#requestMore",
      DefsClickthroughItem: "app.bsky.feed.defs#clickthroughItem",
      DefsClickthroughAuthor: "app.bsky.feed.defs#clickthroughAuthor",
      DefsClickthroughReposter: "app.bsky.feed.defs#clickthroughReposter",
      DefsClickthroughEmbed: "app.bsky.feed.defs#clickthroughEmbed",
      DefsContentModeUnspecified: "app.bsky.feed.defs#contentModeUnspecified",
      DefsContentModeVideo: "app.bsky.feed.defs#contentModeVideo",
      DefsInteractionSeen: "app.bsky.feed.defs#interactionSeen",
      DefsInteractionLike: "app.bsky.feed.defs#interactionLike",
      DefsInteractionRepost: "app.bsky.feed.defs#interactionRepost",
      DefsInteractionReply: "app.bsky.feed.defs#interactionReply",
      DefsInteractionQuote: "app.bsky.feed.defs#interactionQuote",
      DefsInteractionShare: "app.bsky.feed.defs#interactionShare"
    };
    client$1.APP_BSKY_GRAPH = {
      DefsModlist: "app.bsky.graph.defs#modlist",
      DefsCuratelist: "app.bsky.graph.defs#curatelist",
      DefsReferencelist: "app.bsky.graph.defs#referencelist"
    };
    client$1.TOOLS_OZONE_MODERATION = {
      DefsReviewOpen: "tools.ozone.moderation.defs#reviewOpen",
      DefsReviewEscalated: "tools.ozone.moderation.defs#reviewEscalated",
      DefsReviewClosed: "tools.ozone.moderation.defs#reviewClosed",
      DefsReviewNone: "tools.ozone.moderation.defs#reviewNone"
    };
    client$1.TOOLS_OZONE_TEAM = {
      DefsRoleAdmin: "tools.ozone.team.defs#roleAdmin",
      DefsRoleModerator: "tools.ozone.team.defs#roleModerator",
      DefsRoleTriage: "tools.ozone.team.defs#roleTriage"
    };
    class AtpBaseClient extends xrpc_1.XrpcClient {
      constructor(options) {
        super(options, lexicons_js_1.schemas);
        Object.defineProperty(this, "com", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "app", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "chat", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "tools", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.com = new ComNS(this);
        this.app = new AppNS(this);
        this.chat = new ChatNS(this);
        this.tools = new ToolsNS(this);
      }
      /** @deprecated use `this` instead */
      get xrpc() {
        return this;
      }
    }
    client$1.AtpBaseClient = AtpBaseClient;
    class ComNS {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "atproto", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
        this.atproto = new ComAtprotoNS(client2);
      }
    }
    client$1.ComNS = ComNS;
    class ComAtprotoNS {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "admin", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "identity", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "label", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "lexicon", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "moderation", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "repo", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "server", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "sync", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "temp", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
        this.admin = new ComAtprotoAdminNS(client2);
        this.identity = new ComAtprotoIdentityNS(client2);
        this.label = new ComAtprotoLabelNS(client2);
        this.lexicon = new ComAtprotoLexiconNS(client2);
        this.moderation = new ComAtprotoModerationNS(client2);
        this.repo = new ComAtprotoRepoNS(client2);
        this.server = new ComAtprotoServerNS(client2);
        this.sync = new ComAtprotoSyncNS(client2);
        this.temp = new ComAtprotoTempNS(client2);
      }
    }
    client$1.ComAtprotoNS = ComAtprotoNS;
    class ComAtprotoAdminNS {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
      }
      deleteAccount(data, opts) {
        return this._client.call("com.atproto.admin.deleteAccount", opts?.qp, data, opts);
      }
      disableAccountInvites(data, opts) {
        return this._client.call("com.atproto.admin.disableAccountInvites", opts?.qp, data, opts);
      }
      disableInviteCodes(data, opts) {
        return this._client.call("com.atproto.admin.disableInviteCodes", opts?.qp, data, opts);
      }
      enableAccountInvites(data, opts) {
        return this._client.call("com.atproto.admin.enableAccountInvites", opts?.qp, data, opts);
      }
      getAccountInfo(params, opts) {
        return this._client.call("com.atproto.admin.getAccountInfo", params, void 0, opts);
      }
      getAccountInfos(params, opts) {
        return this._client.call("com.atproto.admin.getAccountInfos", params, void 0, opts);
      }
      getInviteCodes(params, opts) {
        return this._client.call("com.atproto.admin.getInviteCodes", params, void 0, opts);
      }
      getSubjectStatus(params, opts) {
        return this._client.call("com.atproto.admin.getSubjectStatus", params, void 0, opts);
      }
      searchAccounts(params, opts) {
        return this._client.call("com.atproto.admin.searchAccounts", params, void 0, opts);
      }
      sendEmail(data, opts) {
        return this._client.call("com.atproto.admin.sendEmail", opts?.qp, data, opts);
      }
      updateAccountEmail(data, opts) {
        return this._client.call("com.atproto.admin.updateAccountEmail", opts?.qp, data, opts);
      }
      updateAccountHandle(data, opts) {
        return this._client.call("com.atproto.admin.updateAccountHandle", opts?.qp, data, opts);
      }
      updateAccountPassword(data, opts) {
        return this._client.call("com.atproto.admin.updateAccountPassword", opts?.qp, data, opts);
      }
      updateSubjectStatus(data, opts) {
        return this._client.call("com.atproto.admin.updateSubjectStatus", opts?.qp, data, opts);
      }
    }
    client$1.ComAtprotoAdminNS = ComAtprotoAdminNS;
    class ComAtprotoIdentityNS {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
      }
      getRecommendedDidCredentials(params, opts) {
        return this._client.call("com.atproto.identity.getRecommendedDidCredentials", params, void 0, opts);
      }
      requestPlcOperationSignature(data, opts) {
        return this._client.call("com.atproto.identity.requestPlcOperationSignature", opts?.qp, data, opts);
      }
      resolveHandle(params, opts) {
        return this._client.call("com.atproto.identity.resolveHandle", params, void 0, opts);
      }
      signPlcOperation(data, opts) {
        return this._client.call("com.atproto.identity.signPlcOperation", opts?.qp, data, opts);
      }
      submitPlcOperation(data, opts) {
        return this._client.call("com.atproto.identity.submitPlcOperation", opts?.qp, data, opts);
      }
      updateHandle(data, opts) {
        return this._client.call("com.atproto.identity.updateHandle", opts?.qp, data, opts);
      }
    }
    client$1.ComAtprotoIdentityNS = ComAtprotoIdentityNS;
    class ComAtprotoLabelNS {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
      }
      queryLabels(params, opts) {
        return this._client.call("com.atproto.label.queryLabels", params, void 0, opts);
      }
    }
    client$1.ComAtprotoLabelNS = ComAtprotoLabelNS;
    class ComAtprotoLexiconNS {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "schema", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
        this.schema = new SchemaRecord(client2);
      }
    }
    client$1.ComAtprotoLexiconNS = ComAtprotoLexiconNS;
    class SchemaRecord {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
      }
      async list(params) {
        const res = await this._client.call("com.atproto.repo.listRecords", {
          collection: "com.atproto.lexicon.schema",
          ...params
        });
        return res.data;
      }
      async get(params) {
        const res = await this._client.call("com.atproto.repo.getRecord", {
          collection: "com.atproto.lexicon.schema",
          ...params
        });
        return res.data;
      }
      async create(params, record2, headers) {
        const collection = "com.atproto.lexicon.schema";
        const res = await this._client.call("com.atproto.repo.createRecord", void 0, { collection, ...params, record: { ...record2, $type: collection } }, { encoding: "application/json", headers });
        return res.data;
      }
      async delete(params, headers) {
        await this._client.call("com.atproto.repo.deleteRecord", void 0, { collection: "com.atproto.lexicon.schema", ...params }, { headers });
      }
    }
    client$1.SchemaRecord = SchemaRecord;
    class ComAtprotoModerationNS {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
      }
      createReport(data, opts) {
        return this._client.call("com.atproto.moderation.createReport", opts?.qp, data, opts);
      }
    }
    client$1.ComAtprotoModerationNS = ComAtprotoModerationNS;
    class ComAtprotoRepoNS {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
      }
      applyWrites(data, opts) {
        return this._client.call("com.atproto.repo.applyWrites", opts?.qp, data, opts).catch((e) => {
          throw ComAtprotoRepoApplyWrites.toKnownErr(e);
        });
      }
      createRecord(data, opts) {
        return this._client.call("com.atproto.repo.createRecord", opts?.qp, data, opts).catch((e) => {
          throw ComAtprotoRepoCreateRecord.toKnownErr(e);
        });
      }
      deleteRecord(data, opts) {
        return this._client.call("com.atproto.repo.deleteRecord", opts?.qp, data, opts).catch((e) => {
          throw ComAtprotoRepoDeleteRecord.toKnownErr(e);
        });
      }
      describeRepo(params, opts) {
        return this._client.call("com.atproto.repo.describeRepo", params, void 0, opts);
      }
      getRecord(params, opts) {
        return this._client.call("com.atproto.repo.getRecord", params, void 0, opts).catch((e) => {
          throw ComAtprotoRepoGetRecord.toKnownErr(e);
        });
      }
      importRepo(data, opts) {
        return this._client.call("com.atproto.repo.importRepo", opts?.qp, data, opts);
      }
      listMissingBlobs(params, opts) {
        return this._client.call("com.atproto.repo.listMissingBlobs", params, void 0, opts);
      }
      listRecords(params, opts) {
        return this._client.call("com.atproto.repo.listRecords", params, void 0, opts);
      }
      putRecord(data, opts) {
        return this._client.call("com.atproto.repo.putRecord", opts?.qp, data, opts).catch((e) => {
          throw ComAtprotoRepoPutRecord.toKnownErr(e);
        });
      }
      uploadBlob(data, opts) {
        return this._client.call("com.atproto.repo.uploadBlob", opts?.qp, data, opts);
      }
    }
    client$1.ComAtprotoRepoNS = ComAtprotoRepoNS;
    class ComAtprotoServerNS {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
      }
      activateAccount(data, opts) {
        return this._client.call("com.atproto.server.activateAccount", opts?.qp, data, opts);
      }
      checkAccountStatus(params, opts) {
        return this._client.call("com.atproto.server.checkAccountStatus", params, void 0, opts);
      }
      confirmEmail(data, opts) {
        return this._client.call("com.atproto.server.confirmEmail", opts?.qp, data, opts).catch((e) => {
          throw ComAtprotoServerConfirmEmail.toKnownErr(e);
        });
      }
      createAccount(data, opts) {
        return this._client.call("com.atproto.server.createAccount", opts?.qp, data, opts).catch((e) => {
          throw ComAtprotoServerCreateAccount.toKnownErr(e);
        });
      }
      createAppPassword(data, opts) {
        return this._client.call("com.atproto.server.createAppPassword", opts?.qp, data, opts).catch((e) => {
          throw ComAtprotoServerCreateAppPassword.toKnownErr(e);
        });
      }
      createInviteCode(data, opts) {
        return this._client.call("com.atproto.server.createInviteCode", opts?.qp, data, opts);
      }
      createInviteCodes(data, opts) {
        return this._client.call("com.atproto.server.createInviteCodes", opts?.qp, data, opts);
      }
      createSession(data, opts) {
        return this._client.call("com.atproto.server.createSession", opts?.qp, data, opts).catch((e) => {
          throw ComAtprotoServerCreateSession.toKnownErr(e);
        });
      }
      deactivateAccount(data, opts) {
        return this._client.call("com.atproto.server.deactivateAccount", opts?.qp, data, opts);
      }
      deleteAccount(data, opts) {
        return this._client.call("com.atproto.server.deleteAccount", opts?.qp, data, opts).catch((e) => {
          throw ComAtprotoServerDeleteAccount.toKnownErr(e);
        });
      }
      deleteSession(data, opts) {
        return this._client.call("com.atproto.server.deleteSession", opts?.qp, data, opts);
      }
      describeServer(params, opts) {
        return this._client.call("com.atproto.server.describeServer", params, void 0, opts);
      }
      getAccountInviteCodes(params, opts) {
        return this._client.call("com.atproto.server.getAccountInviteCodes", params, void 0, opts).catch((e) => {
          throw ComAtprotoServerGetAccountInviteCodes.toKnownErr(e);
        });
      }
      getServiceAuth(params, opts) {
        return this._client.call("com.atproto.server.getServiceAuth", params, void 0, opts).catch((e) => {
          throw ComAtprotoServerGetServiceAuth.toKnownErr(e);
        });
      }
      getSession(params, opts) {
        return this._client.call("com.atproto.server.getSession", params, void 0, opts);
      }
      listAppPasswords(params, opts) {
        return this._client.call("com.atproto.server.listAppPasswords", params, void 0, opts).catch((e) => {
          throw ComAtprotoServerListAppPasswords.toKnownErr(e);
        });
      }
      refreshSession(data, opts) {
        return this._client.call("com.atproto.server.refreshSession", opts?.qp, data, opts).catch((e) => {
          throw ComAtprotoServerRefreshSession.toKnownErr(e);
        });
      }
      requestAccountDelete(data, opts) {
        return this._client.call("com.atproto.server.requestAccountDelete", opts?.qp, data, opts);
      }
      requestEmailConfirmation(data, opts) {
        return this._client.call("com.atproto.server.requestEmailConfirmation", opts?.qp, data, opts);
      }
      requestEmailUpdate(data, opts) {
        return this._client.call("com.atproto.server.requestEmailUpdate", opts?.qp, data, opts);
      }
      requestPasswordReset(data, opts) {
        return this._client.call("com.atproto.server.requestPasswordReset", opts?.qp, data, opts);
      }
      reserveSigningKey(data, opts) {
        return this._client.call("com.atproto.server.reserveSigningKey", opts?.qp, data, opts);
      }
      resetPassword(data, opts) {
        return this._client.call("com.atproto.server.resetPassword", opts?.qp, data, opts).catch((e) => {
          throw ComAtprotoServerResetPassword.toKnownErr(e);
        });
      }
      revokeAppPassword(data, opts) {
        return this._client.call("com.atproto.server.revokeAppPassword", opts?.qp, data, opts);
      }
      updateEmail(data, opts) {
        return this._client.call("com.atproto.server.updateEmail", opts?.qp, data, opts).catch((e) => {
          throw ComAtprotoServerUpdateEmail.toKnownErr(e);
        });
      }
    }
    client$1.ComAtprotoServerNS = ComAtprotoServerNS;
    class ComAtprotoSyncNS {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
      }
      getBlob(params, opts) {
        return this._client.call("com.atproto.sync.getBlob", params, void 0, opts).catch((e) => {
          throw ComAtprotoSyncGetBlob.toKnownErr(e);
        });
      }
      getBlocks(params, opts) {
        return this._client.call("com.atproto.sync.getBlocks", params, void 0, opts).catch((e) => {
          throw ComAtprotoSyncGetBlocks.toKnownErr(e);
        });
      }
      getCheckout(params, opts) {
        return this._client.call("com.atproto.sync.getCheckout", params, void 0, opts);
      }
      getHead(params, opts) {
        return this._client.call("com.atproto.sync.getHead", params, void 0, opts).catch((e) => {
          throw ComAtprotoSyncGetHead.toKnownErr(e);
        });
      }
      getLatestCommit(params, opts) {
        return this._client.call("com.atproto.sync.getLatestCommit", params, void 0, opts).catch((e) => {
          throw ComAtprotoSyncGetLatestCommit.toKnownErr(e);
        });
      }
      getRecord(params, opts) {
        return this._client.call("com.atproto.sync.getRecord", params, void 0, opts).catch((e) => {
          throw ComAtprotoSyncGetRecord.toKnownErr(e);
        });
      }
      getRepo(params, opts) {
        return this._client.call("com.atproto.sync.getRepo", params, void 0, opts).catch((e) => {
          throw ComAtprotoSyncGetRepo.toKnownErr(e);
        });
      }
      getRepoStatus(params, opts) {
        return this._client.call("com.atproto.sync.getRepoStatus", params, void 0, opts).catch((e) => {
          throw ComAtprotoSyncGetRepoStatus.toKnownErr(e);
        });
      }
      listBlobs(params, opts) {
        return this._client.call("com.atproto.sync.listBlobs", params, void 0, opts).catch((e) => {
          throw ComAtprotoSyncListBlobs.toKnownErr(e);
        });
      }
      listRepos(params, opts) {
        return this._client.call("com.atproto.sync.listRepos", params, void 0, opts);
      }
      notifyOfUpdate(data, opts) {
        return this._client.call("com.atproto.sync.notifyOfUpdate", opts?.qp, data, opts);
      }
      requestCrawl(data, opts) {
        return this._client.call("com.atproto.sync.requestCrawl", opts?.qp, data, opts);
      }
    }
    client$1.ComAtprotoSyncNS = ComAtprotoSyncNS;
    class ComAtprotoTempNS {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
      }
      addReservedHandle(data, opts) {
        return this._client.call("com.atproto.temp.addReservedHandle", opts?.qp, data, opts);
      }
      checkSignupQueue(params, opts) {
        return this._client.call("com.atproto.temp.checkSignupQueue", params, void 0, opts);
      }
      fetchLabels(params, opts) {
        return this._client.call("com.atproto.temp.fetchLabels", params, void 0, opts);
      }
      requestPhoneVerification(data, opts) {
        return this._client.call("com.atproto.temp.requestPhoneVerification", opts?.qp, data, opts);
      }
    }
    client$1.ComAtprotoTempNS = ComAtprotoTempNS;
    class AppNS {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "bsky", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
        this.bsky = new AppBskyNS(client2);
      }
    }
    client$1.AppNS = AppNS;
    class AppBskyNS {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "actor", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "embed", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "feed", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "graph", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "labeler", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "notification", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "richtext", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "unspecced", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "video", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
        this.actor = new AppBskyActorNS(client2);
        this.embed = new AppBskyEmbedNS(client2);
        this.feed = new AppBskyFeedNS(client2);
        this.graph = new AppBskyGraphNS(client2);
        this.labeler = new AppBskyLabelerNS(client2);
        this.notification = new AppBskyNotificationNS(client2);
        this.richtext = new AppBskyRichtextNS(client2);
        this.unspecced = new AppBskyUnspeccedNS(client2);
        this.video = new AppBskyVideoNS(client2);
      }
    }
    client$1.AppBskyNS = AppBskyNS;
    class AppBskyActorNS {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "profile", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
        this.profile = new ProfileRecord(client2);
      }
      getPreferences(params, opts) {
        return this._client.call("app.bsky.actor.getPreferences", params, void 0, opts);
      }
      getProfile(params, opts) {
        return this._client.call("app.bsky.actor.getProfile", params, void 0, opts);
      }
      getProfiles(params, opts) {
        return this._client.call("app.bsky.actor.getProfiles", params, void 0, opts);
      }
      getSuggestions(params, opts) {
        return this._client.call("app.bsky.actor.getSuggestions", params, void 0, opts);
      }
      putPreferences(data, opts) {
        return this._client.call("app.bsky.actor.putPreferences", opts?.qp, data, opts);
      }
      searchActors(params, opts) {
        return this._client.call("app.bsky.actor.searchActors", params, void 0, opts);
      }
      searchActorsTypeahead(params, opts) {
        return this._client.call("app.bsky.actor.searchActorsTypeahead", params, void 0, opts);
      }
    }
    client$1.AppBskyActorNS = AppBskyActorNS;
    class ProfileRecord {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
      }
      async list(params) {
        const res = await this._client.call("com.atproto.repo.listRecords", {
          collection: "app.bsky.actor.profile",
          ...params
        });
        return res.data;
      }
      async get(params) {
        const res = await this._client.call("com.atproto.repo.getRecord", {
          collection: "app.bsky.actor.profile",
          ...params
        });
        return res.data;
      }
      async create(params, record2, headers) {
        const collection = "app.bsky.actor.profile";
        const res = await this._client.call("com.atproto.repo.createRecord", void 0, {
          collection,
          rkey: "self",
          ...params,
          record: { ...record2, $type: collection }
        }, { encoding: "application/json", headers });
        return res.data;
      }
      async delete(params, headers) {
        await this._client.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.actor.profile", ...params }, { headers });
      }
    }
    client$1.ProfileRecord = ProfileRecord;
    class AppBskyEmbedNS {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
      }
    }
    client$1.AppBskyEmbedNS = AppBskyEmbedNS;
    class AppBskyFeedNS {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "generator", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "like", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "post", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "postgate", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "repost", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "threadgate", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
        this.generator = new GeneratorRecord(client2);
        this.like = new LikeRecord(client2);
        this.post = new PostRecord(client2);
        this.postgate = new PostgateRecord(client2);
        this.repost = new RepostRecord(client2);
        this.threadgate = new ThreadgateRecord(client2);
      }
      describeFeedGenerator(params, opts) {
        return this._client.call("app.bsky.feed.describeFeedGenerator", params, void 0, opts);
      }
      getActorFeeds(params, opts) {
        return this._client.call("app.bsky.feed.getActorFeeds", params, void 0, opts);
      }
      getActorLikes(params, opts) {
        return this._client.call("app.bsky.feed.getActorLikes", params, void 0, opts).catch((e) => {
          throw AppBskyFeedGetActorLikes.toKnownErr(e);
        });
      }
      getAuthorFeed(params, opts) {
        return this._client.call("app.bsky.feed.getAuthorFeed", params, void 0, opts).catch((e) => {
          throw AppBskyFeedGetAuthorFeed.toKnownErr(e);
        });
      }
      getFeed(params, opts) {
        return this._client.call("app.bsky.feed.getFeed", params, void 0, opts).catch((e) => {
          throw AppBskyFeedGetFeed.toKnownErr(e);
        });
      }
      getFeedGenerator(params, opts) {
        return this._client.call("app.bsky.feed.getFeedGenerator", params, void 0, opts);
      }
      getFeedGenerators(params, opts) {
        return this._client.call("app.bsky.feed.getFeedGenerators", params, void 0, opts);
      }
      getFeedSkeleton(params, opts) {
        return this._client.call("app.bsky.feed.getFeedSkeleton", params, void 0, opts).catch((e) => {
          throw AppBskyFeedGetFeedSkeleton.toKnownErr(e);
        });
      }
      getLikes(params, opts) {
        return this._client.call("app.bsky.feed.getLikes", params, void 0, opts);
      }
      getListFeed(params, opts) {
        return this._client.call("app.bsky.feed.getListFeed", params, void 0, opts).catch((e) => {
          throw AppBskyFeedGetListFeed.toKnownErr(e);
        });
      }
      getPostThread(params, opts) {
        return this._client.call("app.bsky.feed.getPostThread", params, void 0, opts).catch((e) => {
          throw AppBskyFeedGetPostThread.toKnownErr(e);
        });
      }
      getPosts(params, opts) {
        return this._client.call("app.bsky.feed.getPosts", params, void 0, opts);
      }
      getQuotes(params, opts) {
        return this._client.call("app.bsky.feed.getQuotes", params, void 0, opts);
      }
      getRepostedBy(params, opts) {
        return this._client.call("app.bsky.feed.getRepostedBy", params, void 0, opts);
      }
      getSuggestedFeeds(params, opts) {
        return this._client.call("app.bsky.feed.getSuggestedFeeds", params, void 0, opts);
      }
      getTimeline(params, opts) {
        return this._client.call("app.bsky.feed.getTimeline", params, void 0, opts);
      }
      searchPosts(params, opts) {
        return this._client.call("app.bsky.feed.searchPosts", params, void 0, opts).catch((e) => {
          throw AppBskyFeedSearchPosts.toKnownErr(e);
        });
      }
      sendInteractions(data, opts) {
        return this._client.call("app.bsky.feed.sendInteractions", opts?.qp, data, opts);
      }
    }
    client$1.AppBskyFeedNS = AppBskyFeedNS;
    class GeneratorRecord {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
      }
      async list(params) {
        const res = await this._client.call("com.atproto.repo.listRecords", {
          collection: "app.bsky.feed.generator",
          ...params
        });
        return res.data;
      }
      async get(params) {
        const res = await this._client.call("com.atproto.repo.getRecord", {
          collection: "app.bsky.feed.generator",
          ...params
        });
        return res.data;
      }
      async create(params, record2, headers) {
        const collection = "app.bsky.feed.generator";
        const res = await this._client.call("com.atproto.repo.createRecord", void 0, { collection, ...params, record: { ...record2, $type: collection } }, { encoding: "application/json", headers });
        return res.data;
      }
      async delete(params, headers) {
        await this._client.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.feed.generator", ...params }, { headers });
      }
    }
    client$1.GeneratorRecord = GeneratorRecord;
    class LikeRecord {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
      }
      async list(params) {
        const res = await this._client.call("com.atproto.repo.listRecords", {
          collection: "app.bsky.feed.like",
          ...params
        });
        return res.data;
      }
      async get(params) {
        const res = await this._client.call("com.atproto.repo.getRecord", {
          collection: "app.bsky.feed.like",
          ...params
        });
        return res.data;
      }
      async create(params, record2, headers) {
        const collection = "app.bsky.feed.like";
        const res = await this._client.call("com.atproto.repo.createRecord", void 0, { collection, ...params, record: { ...record2, $type: collection } }, { encoding: "application/json", headers });
        return res.data;
      }
      async delete(params, headers) {
        await this._client.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.feed.like", ...params }, { headers });
      }
    }
    client$1.LikeRecord = LikeRecord;
    class PostRecord {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
      }
      async list(params) {
        const res = await this._client.call("com.atproto.repo.listRecords", {
          collection: "app.bsky.feed.post",
          ...params
        });
        return res.data;
      }
      async get(params) {
        const res = await this._client.call("com.atproto.repo.getRecord", {
          collection: "app.bsky.feed.post",
          ...params
        });
        return res.data;
      }
      async create(params, record2, headers) {
        const collection = "app.bsky.feed.post";
        const res = await this._client.call("com.atproto.repo.createRecord", void 0, { collection, ...params, record: { ...record2, $type: collection } }, { encoding: "application/json", headers });
        return res.data;
      }
      async delete(params, headers) {
        await this._client.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.feed.post", ...params }, { headers });
      }
    }
    client$1.PostRecord = PostRecord;
    class PostgateRecord {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
      }
      async list(params) {
        const res = await this._client.call("com.atproto.repo.listRecords", {
          collection: "app.bsky.feed.postgate",
          ...params
        });
        return res.data;
      }
      async get(params) {
        const res = await this._client.call("com.atproto.repo.getRecord", {
          collection: "app.bsky.feed.postgate",
          ...params
        });
        return res.data;
      }
      async create(params, record2, headers) {
        const collection = "app.bsky.feed.postgate";
        const res = await this._client.call("com.atproto.repo.createRecord", void 0, { collection, ...params, record: { ...record2, $type: collection } }, { encoding: "application/json", headers });
        return res.data;
      }
      async delete(params, headers) {
        await this._client.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.feed.postgate", ...params }, { headers });
      }
    }
    client$1.PostgateRecord = PostgateRecord;
    class RepostRecord {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
      }
      async list(params) {
        const res = await this._client.call("com.atproto.repo.listRecords", {
          collection: "app.bsky.feed.repost",
          ...params
        });
        return res.data;
      }
      async get(params) {
        const res = await this._client.call("com.atproto.repo.getRecord", {
          collection: "app.bsky.feed.repost",
          ...params
        });
        return res.data;
      }
      async create(params, record2, headers) {
        const collection = "app.bsky.feed.repost";
        const res = await this._client.call("com.atproto.repo.createRecord", void 0, { collection, ...params, record: { ...record2, $type: collection } }, { encoding: "application/json", headers });
        return res.data;
      }
      async delete(params, headers) {
        await this._client.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.feed.repost", ...params }, { headers });
      }
    }
    client$1.RepostRecord = RepostRecord;
    class ThreadgateRecord {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
      }
      async list(params) {
        const res = await this._client.call("com.atproto.repo.listRecords", {
          collection: "app.bsky.feed.threadgate",
          ...params
        });
        return res.data;
      }
      async get(params) {
        const res = await this._client.call("com.atproto.repo.getRecord", {
          collection: "app.bsky.feed.threadgate",
          ...params
        });
        return res.data;
      }
      async create(params, record2, headers) {
        const collection = "app.bsky.feed.threadgate";
        const res = await this._client.call("com.atproto.repo.createRecord", void 0, { collection, ...params, record: { ...record2, $type: collection } }, { encoding: "application/json", headers });
        return res.data;
      }
      async delete(params, headers) {
        await this._client.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.feed.threadgate", ...params }, { headers });
      }
    }
    client$1.ThreadgateRecord = ThreadgateRecord;
    class AppBskyGraphNS {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "block", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "follow", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "list", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "listblock", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "listitem", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "starterpack", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
        this.block = new BlockRecord(client2);
        this.follow = new FollowRecord(client2);
        this.list = new ListRecord(client2);
        this.listblock = new ListblockRecord(client2);
        this.listitem = new ListitemRecord(client2);
        this.starterpack = new StarterpackRecord(client2);
      }
      getActorStarterPacks(params, opts) {
        return this._client.call("app.bsky.graph.getActorStarterPacks", params, void 0, opts);
      }
      getBlocks(params, opts) {
        return this._client.call("app.bsky.graph.getBlocks", params, void 0, opts);
      }
      getFollowers(params, opts) {
        return this._client.call("app.bsky.graph.getFollowers", params, void 0, opts);
      }
      getFollows(params, opts) {
        return this._client.call("app.bsky.graph.getFollows", params, void 0, opts);
      }
      getKnownFollowers(params, opts) {
        return this._client.call("app.bsky.graph.getKnownFollowers", params, void 0, opts);
      }
      getList(params, opts) {
        return this._client.call("app.bsky.graph.getList", params, void 0, opts);
      }
      getListBlocks(params, opts) {
        return this._client.call("app.bsky.graph.getListBlocks", params, void 0, opts);
      }
      getListMutes(params, opts) {
        return this._client.call("app.bsky.graph.getListMutes", params, void 0, opts);
      }
      getLists(params, opts) {
        return this._client.call("app.bsky.graph.getLists", params, void 0, opts);
      }
      getMutes(params, opts) {
        return this._client.call("app.bsky.graph.getMutes", params, void 0, opts);
      }
      getRelationships(params, opts) {
        return this._client.call("app.bsky.graph.getRelationships", params, void 0, opts).catch((e) => {
          throw AppBskyGraphGetRelationships.toKnownErr(e);
        });
      }
      getStarterPack(params, opts) {
        return this._client.call("app.bsky.graph.getStarterPack", params, void 0, opts);
      }
      getStarterPacks(params, opts) {
        return this._client.call("app.bsky.graph.getStarterPacks", params, void 0, opts);
      }
      getSuggestedFollowsByActor(params, opts) {
        return this._client.call("app.bsky.graph.getSuggestedFollowsByActor", params, void 0, opts);
      }
      muteActor(data, opts) {
        return this._client.call("app.bsky.graph.muteActor", opts?.qp, data, opts);
      }
      muteActorList(data, opts) {
        return this._client.call("app.bsky.graph.muteActorList", opts?.qp, data, opts);
      }
      muteThread(data, opts) {
        return this._client.call("app.bsky.graph.muteThread", opts?.qp, data, opts);
      }
      searchStarterPacks(params, opts) {
        return this._client.call("app.bsky.graph.searchStarterPacks", params, void 0, opts);
      }
      unmuteActor(data, opts) {
        return this._client.call("app.bsky.graph.unmuteActor", opts?.qp, data, opts);
      }
      unmuteActorList(data, opts) {
        return this._client.call("app.bsky.graph.unmuteActorList", opts?.qp, data, opts);
      }
      unmuteThread(data, opts) {
        return this._client.call("app.bsky.graph.unmuteThread", opts?.qp, data, opts);
      }
    }
    client$1.AppBskyGraphNS = AppBskyGraphNS;
    class BlockRecord {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
      }
      async list(params) {
        const res = await this._client.call("com.atproto.repo.listRecords", {
          collection: "app.bsky.graph.block",
          ...params
        });
        return res.data;
      }
      async get(params) {
        const res = await this._client.call("com.atproto.repo.getRecord", {
          collection: "app.bsky.graph.block",
          ...params
        });
        return res.data;
      }
      async create(params, record2, headers) {
        const collection = "app.bsky.graph.block";
        const res = await this._client.call("com.atproto.repo.createRecord", void 0, { collection, ...params, record: { ...record2, $type: collection } }, { encoding: "application/json", headers });
        return res.data;
      }
      async delete(params, headers) {
        await this._client.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.graph.block", ...params }, { headers });
      }
    }
    client$1.BlockRecord = BlockRecord;
    class FollowRecord {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
      }
      async list(params) {
        const res = await this._client.call("com.atproto.repo.listRecords", {
          collection: "app.bsky.graph.follow",
          ...params
        });
        return res.data;
      }
      async get(params) {
        const res = await this._client.call("com.atproto.repo.getRecord", {
          collection: "app.bsky.graph.follow",
          ...params
        });
        return res.data;
      }
      async create(params, record2, headers) {
        const collection = "app.bsky.graph.follow";
        const res = await this._client.call("com.atproto.repo.createRecord", void 0, { collection, ...params, record: { ...record2, $type: collection } }, { encoding: "application/json", headers });
        return res.data;
      }
      async delete(params, headers) {
        await this._client.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.graph.follow", ...params }, { headers });
      }
    }
    client$1.FollowRecord = FollowRecord;
    class ListRecord {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
      }
      async list(params) {
        const res = await this._client.call("com.atproto.repo.listRecords", {
          collection: "app.bsky.graph.list",
          ...params
        });
        return res.data;
      }
      async get(params) {
        const res = await this._client.call("com.atproto.repo.getRecord", {
          collection: "app.bsky.graph.list",
          ...params
        });
        return res.data;
      }
      async create(params, record2, headers) {
        const collection = "app.bsky.graph.list";
        const res = await this._client.call("com.atproto.repo.createRecord", void 0, { collection, ...params, record: { ...record2, $type: collection } }, { encoding: "application/json", headers });
        return res.data;
      }
      async delete(params, headers) {
        await this._client.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.graph.list", ...params }, { headers });
      }
    }
    client$1.ListRecord = ListRecord;
    class ListblockRecord {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
      }
      async list(params) {
        const res = await this._client.call("com.atproto.repo.listRecords", {
          collection: "app.bsky.graph.listblock",
          ...params
        });
        return res.data;
      }
      async get(params) {
        const res = await this._client.call("com.atproto.repo.getRecord", {
          collection: "app.bsky.graph.listblock",
          ...params
        });
        return res.data;
      }
      async create(params, record2, headers) {
        const collection = "app.bsky.graph.listblock";
        const res = await this._client.call("com.atproto.repo.createRecord", void 0, { collection, ...params, record: { ...record2, $type: collection } }, { encoding: "application/json", headers });
        return res.data;
      }
      async delete(params, headers) {
        await this._client.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.graph.listblock", ...params }, { headers });
      }
    }
    client$1.ListblockRecord = ListblockRecord;
    class ListitemRecord {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
      }
      async list(params) {
        const res = await this._client.call("com.atproto.repo.listRecords", {
          collection: "app.bsky.graph.listitem",
          ...params
        });
        return res.data;
      }
      async get(params) {
        const res = await this._client.call("com.atproto.repo.getRecord", {
          collection: "app.bsky.graph.listitem",
          ...params
        });
        return res.data;
      }
      async create(params, record2, headers) {
        const collection = "app.bsky.graph.listitem";
        const res = await this._client.call("com.atproto.repo.createRecord", void 0, { collection, ...params, record: { ...record2, $type: collection } }, { encoding: "application/json", headers });
        return res.data;
      }
      async delete(params, headers) {
        await this._client.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.graph.listitem", ...params }, { headers });
      }
    }
    client$1.ListitemRecord = ListitemRecord;
    class StarterpackRecord {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
      }
      async list(params) {
        const res = await this._client.call("com.atproto.repo.listRecords", {
          collection: "app.bsky.graph.starterpack",
          ...params
        });
        return res.data;
      }
      async get(params) {
        const res = await this._client.call("com.atproto.repo.getRecord", {
          collection: "app.bsky.graph.starterpack",
          ...params
        });
        return res.data;
      }
      async create(params, record2, headers) {
        const collection = "app.bsky.graph.starterpack";
        const res = await this._client.call("com.atproto.repo.createRecord", void 0, { collection, ...params, record: { ...record2, $type: collection } }, { encoding: "application/json", headers });
        return res.data;
      }
      async delete(params, headers) {
        await this._client.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.graph.starterpack", ...params }, { headers });
      }
    }
    client$1.StarterpackRecord = StarterpackRecord;
    class AppBskyLabelerNS {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "service", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
        this.service = new ServiceRecord(client2);
      }
      getServices(params, opts) {
        return this._client.call("app.bsky.labeler.getServices", params, void 0, opts);
      }
    }
    client$1.AppBskyLabelerNS = AppBskyLabelerNS;
    class ServiceRecord {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
      }
      async list(params) {
        const res = await this._client.call("com.atproto.repo.listRecords", {
          collection: "app.bsky.labeler.service",
          ...params
        });
        return res.data;
      }
      async get(params) {
        const res = await this._client.call("com.atproto.repo.getRecord", {
          collection: "app.bsky.labeler.service",
          ...params
        });
        return res.data;
      }
      async create(params, record2, headers) {
        const collection = "app.bsky.labeler.service";
        const res = await this._client.call("com.atproto.repo.createRecord", void 0, {
          collection,
          rkey: "self",
          ...params,
          record: { ...record2, $type: collection }
        }, { encoding: "application/json", headers });
        return res.data;
      }
      async delete(params, headers) {
        await this._client.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.labeler.service", ...params }, { headers });
      }
    }
    client$1.ServiceRecord = ServiceRecord;
    class AppBskyNotificationNS {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
      }
      getUnreadCount(params, opts) {
        return this._client.call("app.bsky.notification.getUnreadCount", params, void 0, opts);
      }
      listNotifications(params, opts) {
        return this._client.call("app.bsky.notification.listNotifications", params, void 0, opts);
      }
      putPreferences(data, opts) {
        return this._client.call("app.bsky.notification.putPreferences", opts?.qp, data, opts);
      }
      registerPush(data, opts) {
        return this._client.call("app.bsky.notification.registerPush", opts?.qp, data, opts);
      }
      updateSeen(data, opts) {
        return this._client.call("app.bsky.notification.updateSeen", opts?.qp, data, opts);
      }
    }
    client$1.AppBskyNotificationNS = AppBskyNotificationNS;
    class AppBskyRichtextNS {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
      }
    }
    client$1.AppBskyRichtextNS = AppBskyRichtextNS;
    class AppBskyUnspeccedNS {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
      }
      getConfig(params, opts) {
        return this._client.call("app.bsky.unspecced.getConfig", params, void 0, opts);
      }
      getPopularFeedGenerators(params, opts) {
        return this._client.call("app.bsky.unspecced.getPopularFeedGenerators", params, void 0, opts);
      }
      getSuggestionsSkeleton(params, opts) {
        return this._client.call("app.bsky.unspecced.getSuggestionsSkeleton", params, void 0, opts);
      }
      getTaggedSuggestions(params, opts) {
        return this._client.call("app.bsky.unspecced.getTaggedSuggestions", params, void 0, opts);
      }
      getTrendingTopics(params, opts) {
        return this._client.call("app.bsky.unspecced.getTrendingTopics", params, void 0, opts);
      }
      searchActorsSkeleton(params, opts) {
        return this._client.call("app.bsky.unspecced.searchActorsSkeleton", params, void 0, opts).catch((e) => {
          throw AppBskyUnspeccedSearchActorsSkeleton.toKnownErr(e);
        });
      }
      searchPostsSkeleton(params, opts) {
        return this._client.call("app.bsky.unspecced.searchPostsSkeleton", params, void 0, opts).catch((e) => {
          throw AppBskyUnspeccedSearchPostsSkeleton.toKnownErr(e);
        });
      }
      searchStarterPacksSkeleton(params, opts) {
        return this._client.call("app.bsky.unspecced.searchStarterPacksSkeleton", params, void 0, opts).catch((e) => {
          throw AppBskyUnspeccedSearchStarterPacksSkeleton.toKnownErr(e);
        });
      }
    }
    client$1.AppBskyUnspeccedNS = AppBskyUnspeccedNS;
    class AppBskyVideoNS {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
      }
      getJobStatus(params, opts) {
        return this._client.call("app.bsky.video.getJobStatus", params, void 0, opts);
      }
      getUploadLimits(params, opts) {
        return this._client.call("app.bsky.video.getUploadLimits", params, void 0, opts);
      }
      uploadVideo(data, opts) {
        return this._client.call("app.bsky.video.uploadVideo", opts?.qp, data, opts);
      }
    }
    client$1.AppBskyVideoNS = AppBskyVideoNS;
    class ChatNS {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "bsky", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
        this.bsky = new ChatBskyNS(client2);
      }
    }
    client$1.ChatNS = ChatNS;
    class ChatBskyNS {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "actor", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "convo", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "moderation", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
        this.actor = new ChatBskyActorNS(client2);
        this.convo = new ChatBskyConvoNS(client2);
        this.moderation = new ChatBskyModerationNS(client2);
      }
    }
    client$1.ChatBskyNS = ChatBskyNS;
    class ChatBskyActorNS {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "declaration", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
        this.declaration = new DeclarationRecord(client2);
      }
      deleteAccount(data, opts) {
        return this._client.call("chat.bsky.actor.deleteAccount", opts?.qp, data, opts);
      }
      exportAccountData(params, opts) {
        return this._client.call("chat.bsky.actor.exportAccountData", params, void 0, opts);
      }
    }
    client$1.ChatBskyActorNS = ChatBskyActorNS;
    class DeclarationRecord {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
      }
      async list(params) {
        const res = await this._client.call("com.atproto.repo.listRecords", {
          collection: "chat.bsky.actor.declaration",
          ...params
        });
        return res.data;
      }
      async get(params) {
        const res = await this._client.call("com.atproto.repo.getRecord", {
          collection: "chat.bsky.actor.declaration",
          ...params
        });
        return res.data;
      }
      async create(params, record2, headers) {
        const collection = "chat.bsky.actor.declaration";
        const res = await this._client.call("com.atproto.repo.createRecord", void 0, {
          collection,
          rkey: "self",
          ...params,
          record: { ...record2, $type: collection }
        }, { encoding: "application/json", headers });
        return res.data;
      }
      async delete(params, headers) {
        await this._client.call("com.atproto.repo.deleteRecord", void 0, { collection: "chat.bsky.actor.declaration", ...params }, { headers });
      }
    }
    client$1.DeclarationRecord = DeclarationRecord;
    class ChatBskyConvoNS {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
      }
      deleteMessageForSelf(data, opts) {
        return this._client.call("chat.bsky.convo.deleteMessageForSelf", opts?.qp, data, opts);
      }
      getConvo(params, opts) {
        return this._client.call("chat.bsky.convo.getConvo", params, void 0, opts);
      }
      getConvoForMembers(params, opts) {
        return this._client.call("chat.bsky.convo.getConvoForMembers", params, void 0, opts);
      }
      getLog(params, opts) {
        return this._client.call("chat.bsky.convo.getLog", params, void 0, opts);
      }
      getMessages(params, opts) {
        return this._client.call("chat.bsky.convo.getMessages", params, void 0, opts);
      }
      leaveConvo(data, opts) {
        return this._client.call("chat.bsky.convo.leaveConvo", opts?.qp, data, opts);
      }
      listConvos(params, opts) {
        return this._client.call("chat.bsky.convo.listConvos", params, void 0, opts);
      }
      muteConvo(data, opts) {
        return this._client.call("chat.bsky.convo.muteConvo", opts?.qp, data, opts);
      }
      sendMessage(data, opts) {
        return this._client.call("chat.bsky.convo.sendMessage", opts?.qp, data, opts);
      }
      sendMessageBatch(data, opts) {
        return this._client.call("chat.bsky.convo.sendMessageBatch", opts?.qp, data, opts);
      }
      unmuteConvo(data, opts) {
        return this._client.call("chat.bsky.convo.unmuteConvo", opts?.qp, data, opts);
      }
      updateRead(data, opts) {
        return this._client.call("chat.bsky.convo.updateRead", opts?.qp, data, opts);
      }
    }
    client$1.ChatBskyConvoNS = ChatBskyConvoNS;
    class ChatBskyModerationNS {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
      }
      getActorMetadata(params, opts) {
        return this._client.call("chat.bsky.moderation.getActorMetadata", params, void 0, opts);
      }
      getMessageContext(params, opts) {
        return this._client.call("chat.bsky.moderation.getMessageContext", params, void 0, opts);
      }
      updateActorAccess(data, opts) {
        return this._client.call("chat.bsky.moderation.updateActorAccess", opts?.qp, data, opts);
      }
    }
    client$1.ChatBskyModerationNS = ChatBskyModerationNS;
    class ToolsNS {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "ozone", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
        this.ozone = new ToolsOzoneNS(client2);
      }
    }
    client$1.ToolsNS = ToolsNS;
    class ToolsOzoneNS {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "communication", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "moderation", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "server", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "set", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "setting", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "signature", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "team", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
        this.communication = new ToolsOzoneCommunicationNS(client2);
        this.moderation = new ToolsOzoneModerationNS(client2);
        this.server = new ToolsOzoneServerNS(client2);
        this.set = new ToolsOzoneSetNS(client2);
        this.setting = new ToolsOzoneSettingNS(client2);
        this.signature = new ToolsOzoneSignatureNS(client2);
        this.team = new ToolsOzoneTeamNS(client2);
      }
    }
    client$1.ToolsOzoneNS = ToolsOzoneNS;
    class ToolsOzoneCommunicationNS {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
      }
      createTemplate(data, opts) {
        return this._client.call("tools.ozone.communication.createTemplate", opts?.qp, data, opts).catch((e) => {
          throw ToolsOzoneCommunicationCreateTemplate.toKnownErr(e);
        });
      }
      deleteTemplate(data, opts) {
        return this._client.call("tools.ozone.communication.deleteTemplate", opts?.qp, data, opts);
      }
      listTemplates(params, opts) {
        return this._client.call("tools.ozone.communication.listTemplates", params, void 0, opts);
      }
      updateTemplate(data, opts) {
        return this._client.call("tools.ozone.communication.updateTemplate", opts?.qp, data, opts).catch((e) => {
          throw ToolsOzoneCommunicationUpdateTemplate.toKnownErr(e);
        });
      }
    }
    client$1.ToolsOzoneCommunicationNS = ToolsOzoneCommunicationNS;
    class ToolsOzoneModerationNS {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
      }
      emitEvent(data, opts) {
        return this._client.call("tools.ozone.moderation.emitEvent", opts?.qp, data, opts).catch((e) => {
          throw ToolsOzoneModerationEmitEvent.toKnownErr(e);
        });
      }
      getEvent(params, opts) {
        return this._client.call("tools.ozone.moderation.getEvent", params, void 0, opts);
      }
      getRecord(params, opts) {
        return this._client.call("tools.ozone.moderation.getRecord", params, void 0, opts).catch((e) => {
          throw ToolsOzoneModerationGetRecord.toKnownErr(e);
        });
      }
      getRecords(params, opts) {
        return this._client.call("tools.ozone.moderation.getRecords", params, void 0, opts);
      }
      getRepo(params, opts) {
        return this._client.call("tools.ozone.moderation.getRepo", params, void 0, opts).catch((e) => {
          throw ToolsOzoneModerationGetRepo.toKnownErr(e);
        });
      }
      getRepos(params, opts) {
        return this._client.call("tools.ozone.moderation.getRepos", params, void 0, opts);
      }
      queryEvents(params, opts) {
        return this._client.call("tools.ozone.moderation.queryEvents", params, void 0, opts);
      }
      queryStatuses(params, opts) {
        return this._client.call("tools.ozone.moderation.queryStatuses", params, void 0, opts);
      }
      searchRepos(params, opts) {
        return this._client.call("tools.ozone.moderation.searchRepos", params, void 0, opts);
      }
    }
    client$1.ToolsOzoneModerationNS = ToolsOzoneModerationNS;
    class ToolsOzoneServerNS {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
      }
      getConfig(params, opts) {
        return this._client.call("tools.ozone.server.getConfig", params, void 0, opts);
      }
    }
    client$1.ToolsOzoneServerNS = ToolsOzoneServerNS;
    class ToolsOzoneSetNS {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
      }
      addValues(data, opts) {
        return this._client.call("tools.ozone.set.addValues", opts?.qp, data, opts);
      }
      deleteSet(data, opts) {
        return this._client.call("tools.ozone.set.deleteSet", opts?.qp, data, opts).catch((e) => {
          throw ToolsOzoneSetDeleteSet.toKnownErr(e);
        });
      }
      deleteValues(data, opts) {
        return this._client.call("tools.ozone.set.deleteValues", opts?.qp, data, opts).catch((e) => {
          throw ToolsOzoneSetDeleteValues.toKnownErr(e);
        });
      }
      getValues(params, opts) {
        return this._client.call("tools.ozone.set.getValues", params, void 0, opts).catch((e) => {
          throw ToolsOzoneSetGetValues.toKnownErr(e);
        });
      }
      querySets(params, opts) {
        return this._client.call("tools.ozone.set.querySets", params, void 0, opts);
      }
      upsertSet(data, opts) {
        return this._client.call("tools.ozone.set.upsertSet", opts?.qp, data, opts);
      }
    }
    client$1.ToolsOzoneSetNS = ToolsOzoneSetNS;
    class ToolsOzoneSettingNS {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
      }
      listOptions(params, opts) {
        return this._client.call("tools.ozone.setting.listOptions", params, void 0, opts);
      }
      removeOptions(data, opts) {
        return this._client.call("tools.ozone.setting.removeOptions", opts?.qp, data, opts);
      }
      upsertOption(data, opts) {
        return this._client.call("tools.ozone.setting.upsertOption", opts?.qp, data, opts);
      }
    }
    client$1.ToolsOzoneSettingNS = ToolsOzoneSettingNS;
    class ToolsOzoneSignatureNS {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
      }
      findCorrelation(params, opts) {
        return this._client.call("tools.ozone.signature.findCorrelation", params, void 0, opts);
      }
      findRelatedAccounts(params, opts) {
        return this._client.call("tools.ozone.signature.findRelatedAccounts", params, void 0, opts);
      }
      searchAccounts(params, opts) {
        return this._client.call("tools.ozone.signature.searchAccounts", params, void 0, opts);
      }
    }
    client$1.ToolsOzoneSignatureNS = ToolsOzoneSignatureNS;
    class ToolsOzoneTeamNS {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
      }
      addMember(data, opts) {
        return this._client.call("tools.ozone.team.addMember", opts?.qp, data, opts).catch((e) => {
          throw ToolsOzoneTeamAddMember.toKnownErr(e);
        });
      }
      deleteMember(data, opts) {
        return this._client.call("tools.ozone.team.deleteMember", opts?.qp, data, opts).catch((e) => {
          throw ToolsOzoneTeamDeleteMember.toKnownErr(e);
        });
      }
      listMembers(params, opts) {
        return this._client.call("tools.ozone.team.listMembers", params, void 0, opts);
      }
      updateMember(data, opts) {
        return this._client.call("tools.ozone.team.updateMember", opts?.qp, data, opts).catch((e) => {
          throw ToolsOzoneTeamUpdateMember.toKnownErr(e);
        });
      }
    }
    client$1.ToolsOzoneTeamNS = ToolsOzoneTeamNS;
    return client$1;
  }
  var richText = {};
  var detection = {};
  const require$$0 = /* @__PURE__ */ JSON.parse('["aaa","aarp","abb","abbott","abbvie","abc","able","abogado","abudhabi","ac","academy","accenture","accountant","accountants","aco","actor","ad","ads","adult","ae","aeg","aero","aetna","af","afl","africa","ag","agakhan","agency","ai","aig","airbus","airforce","airtel","akdn","al","alibaba","alipay","allfinanz","allstate","ally","alsace","alstom","am","amazon","americanexpress","americanfamily","amex","amfam","amica","amsterdam","analytics","android","anquan","anz","ao","aol","apartments","app","apple","aq","aquarelle","ar","arab","aramco","archi","army","arpa","art","arte","as","asda","asia","associates","at","athleta","attorney","au","auction","audi","audible","audio","auspost","author","auto","autos","aw","aws","ax","axa","az","azure","ba","baby","baidu","banamex","band","bank","bar","barcelona","barclaycard","barclays","barefoot","bargains","baseball","basketball","bauhaus","bayern","bb","bbc","bbt","bbva","bcg","bcn","bd","be","beats","beauty","beer","bentley","berlin","best","bestbuy","bet","bf","bg","bh","bharti","bi","bible","bid","bike","bing","bingo","bio","biz","bj","black","blackfriday","blockbuster","blog","bloomberg","blue","bm","bms","bmw","bn","bnpparibas","bo","boats","boehringer","bofa","bom","bond","boo","book","booking","bosch","bostik","boston","bot","boutique","box","br","bradesco","bridgestone","broadway","broker","brother","brussels","bs","bt","build","builders","business","buy","buzz","bv","bw","by","bz","bzh","ca","cab","cafe","cal","call","calvinklein","cam","camera","camp","canon","capetown","capital","capitalone","car","caravan","cards","care","career","careers","cars","casa","case","cash","casino","cat","catering","catholic","cba","cbn","cbre","cc","cd","center","ceo","cern","cf","cfa","cfd","cg","ch","chanel","channel","charity","chase","chat","cheap","chintai","christmas","chrome","church","ci","cipriani","circle","cisco","citadel","citi","citic","city","ck","cl","claims","cleaning","click","clinic","clinique","clothing","cloud","club","clubmed","cm","cn","co","coach","codes","coffee","college","cologne","com","commbank","community","company","compare","computer","comsec","condos","construction","consulting","contact","contractors","cooking","cool","coop","corsica","country","coupon","coupons","courses","cpa","cr","credit","creditcard","creditunion","cricket","crown","crs","cruise","cruises","cu","cuisinella","cv","cw","cx","cy","cymru","cyou","cz","dad","dance","data","date","dating","datsun","day","dclk","dds","de","deal","dealer","deals","degree","delivery","dell","deloitte","delta","democrat","dental","dentist","desi","design","dev","dhl","diamonds","diet","digital","direct","directory","discount","discover","dish","diy","dj","dk","dm","dnp","do","docs","doctor","dog","domains","dot","download","drive","dtv","dubai","dunlop","dupont","durban","dvag","dvr","dz","earth","eat","ec","eco","edeka","edu","education","ee","eg","email","emerck","energy","engineer","engineering","enterprises","epson","equipment","er","ericsson","erni","es","esq","estate","et","eu","eurovision","eus","events","exchange","expert","exposed","express","extraspace","fage","fail","fairwinds","faith","family","fan","fans","farm","farmers","fashion","fast","fedex","feedback","ferrari","ferrero","fi","fidelity","fido","film","final","finance","financial","fire","firestone","firmdale","fish","fishing","fit","fitness","fj","fk","flickr","flights","flir","florist","flowers","fly","fm","fo","foo","food","football","ford","forex","forsale","forum","foundation","fox","fr","free","fresenius","frl","frogans","frontier","ftr","fujitsu","fun","fund","furniture","futbol","fyi","ga","gal","gallery","gallo","gallup","game","games","gap","garden","gay","gb","gbiz","gd","gdn","ge","gea","gent","genting","george","gf","gg","ggee","gh","gi","gift","gifts","gives","giving","gl","glass","gle","global","globo","gm","gmail","gmbh","gmo","gmx","gn","godaddy","gold","goldpoint","golf","goo","goodyear","goog","google","gop","got","gov","gp","gq","gr","grainger","graphics","gratis","green","gripe","grocery","group","gs","gt","gu","gucci","guge","guide","guitars","guru","gw","gy","hair","hamburg","hangout","haus","hbo","hdfc","hdfcbank","health","healthcare","help","helsinki","here","hermes","hiphop","hisamitsu","hitachi","hiv","hk","hkt","hm","hn","hockey","holdings","holiday","homedepot","homegoods","homes","homesense","honda","horse","hospital","host","hosting","hot","hotels","hotmail","house","how","hr","hsbc","ht","hu","hughes","hyatt","hyundai","ibm","icbc","ice","icu","id","ie","ieee","ifm","ikano","il","im","imamat","imdb","immo","immobilien","in","inc","industries","infiniti","info","ing","ink","institute","insurance","insure","int","international","intuit","investments","io","ipiranga","iq","ir","irish","is","ismaili","ist","istanbul","it","itau","itv","jaguar","java","jcb","je","jeep","jetzt","jewelry","jio","jll","jm","jmp","jnj","jo","jobs","joburg","jot","joy","jp","jpmorgan","jprs","juegos","juniper","kaufen","kddi","ke","kerryhotels","kerrylogistics","kerryproperties","kfh","kg","kh","ki","kia","kids","kim","kindle","kitchen","kiwi","km","kn","koeln","komatsu","kosher","kp","kpmg","kpn","kr","krd","kred","kuokgroup","kw","ky","kyoto","kz","la","lacaixa","lamborghini","lamer","lancaster","land","landrover","lanxess","lasalle","lat","latino","latrobe","law","lawyer","lb","lc","lds","lease","leclerc","lefrak","legal","lego","lexus","lgbt","li","lidl","life","lifeinsurance","lifestyle","lighting","like","lilly","limited","limo","lincoln","link","lipsy","live","living","lk","llc","llp","loan","loans","locker","locus","lol","london","lotte","lotto","love","lpl","lplfinancial","lr","ls","lt","ltd","ltda","lu","lundbeck","luxe","luxury","lv","ly","ma","madrid","maif","maison","makeup","man","management","mango","map","market","marketing","markets","marriott","marshalls","mattel","mba","mc","mckinsey","md","me","med","media","meet","melbourne","meme","memorial","men","menu","merckmsd","mg","mh","miami","microsoft","mil","mini","mint","mit","mitsubishi","mk","ml","mlb","mls","mm","mma","mn","mo","mobi","mobile","moda","moe","moi","mom","monash","money","monster","mormon","mortgage","moscow","moto","motorcycles","mov","movie","mp","mq","mr","ms","msd","mt","mtn","mtr","mu","museum","music","mv","mw","mx","my","mz","na","nab","nagoya","name","navy","nba","nc","ne","nec","net","netbank","netflix","network","neustar","new","news","next","nextdirect","nexus","nf","nfl","ng","ngo","nhk","ni","nico","nike","nikon","ninja","nissan","nissay","nl","no","nokia","norton","now","nowruz","nowtv","np","nr","nra","nrw","ntt","nu","nyc","nz","obi","observer","office","okinawa","olayan","olayangroup","ollo","om","omega","one","ong","onl","online","ooo","open","oracle","orange","org","organic","origins","osaka","otsuka","ott","ovh","pa","page","panasonic","paris","pars","partners","parts","party","pay","pccw","pe","pet","pf","pfizer","pg","ph","pharmacy","phd","philips","phone","photo","photography","photos","physio","pics","pictet","pictures","pid","pin","ping","pink","pioneer","pizza","pk","pl","place","play","playstation","plumbing","plus","pm","pn","pnc","pohl","poker","politie","porn","post","pr","pramerica","praxi","press","prime","pro","prod","productions","prof","progressive","promo","properties","property","protection","pru","prudential","ps","pt","pub","pw","pwc","py","qa","qpon","quebec","quest","racing","radio","re","read","realestate","realtor","realty","recipes","red","redstone","redumbrella","rehab","reise","reisen","reit","reliance","ren","rent","rentals","repair","report","republican","rest","restaurant","review","reviews","rexroth","rich","richardli","ricoh","ril","rio","rip","ro","rocks","rodeo","rogers","room","rs","rsvp","ru","rugby","ruhr","run","rw","rwe","ryukyu","sa","saarland","safe","safety","sakura","sale","salon","samsclub","samsung","sandvik","sandvikcoromant","sanofi","sap","sarl","sas","save","saxo","sb","sbi","sbs","sc","scb","schaeffler","schmidt","scholarships","school","schule","schwarz","science","scot","sd","se","search","seat","secure","security","seek","select","sener","services","seven","sew","sex","sexy","sfr","sg","sh","shangrila","sharp","shell","shia","shiksha","shoes","shop","shopping","shouji","show","si","silk","sina","singles","site","sj","sk","ski","skin","sky","skype","sl","sling","sm","smart","smile","sn","sncf","so","soccer","social","softbank","software","sohu","solar","solutions","song","sony","soy","spa","space","sport","spot","sr","srl","ss","st","stada","staples","star","statebank","statefarm","stc","stcgroup","stockholm","storage","store","stream","studio","study","style","su","sucks","supplies","supply","support","surf","surgery","suzuki","sv","swatch","swiss","sx","sy","sydney","systems","sz","tab","taipei","talk","taobao","target","tatamotors","tatar","tattoo","tax","taxi","tc","tci","td","tdk","team","tech","technology","tel","temasek","tennis","teva","tf","tg","th","thd","theater","theatre","tiaa","tickets","tienda","tips","tires","tirol","tj","tjmaxx","tjx","tk","tkmaxx","tl","tm","tmall","tn","to","today","tokyo","tools","top","toray","toshiba","total","tours","town","toyota","toys","tr","trade","trading","training","travel","travelers","travelersinsurance","trust","trv","tt","tube","tui","tunes","tushu","tv","tvs","tw","tz","ua","ubank","ubs","ug","uk","unicom","university","uno","uol","ups","us","uy","uz","va","vacations","vana","vanguard","vc","ve","vegas","ventures","verisign","verm\xF6gensberater","verm\xF6gensberatung","versicherung","vet","vg","vi","viajes","video","vig","viking","villas","vin","vip","virgin","visa","vision","viva","vivo","vlaanderen","vn","vodka","volvo","vote","voting","voto","voyage","vu","wales","walmart","walter","wang","wanggou","watch","watches","weather","weatherchannel","webcam","weber","website","wed","wedding","weibo","weir","wf","whoswho","wien","wiki","williamhill","win","windows","wine","winners","wme","wolterskluwer","woodside","work","works","world","wow","ws","wtc","wtf","xbox","xerox","xihuan","xin","xxx","xyz","yachts","yahoo","yamaxun","yandex","ye","yodobashi","yoga","yokohama","you","youtube","yt","yun","za","zappos","zara","zero","zip","zm","zone","zuerich","zw","\u03B5\u03BB","\u03B5\u03C5","\u0431\u0433","\u0431\u0435\u043B","\u0434\u0435\u0442\u0438","\u0435\u044E","\u043A\u0430\u0442\u043E\u043B\u0438\u043A","\u043A\u043E\u043C","\u043C\u043A\u0434","\u043C\u043E\u043D","\u043C\u043E\u0441\u043A\u0432\u0430","\u043E\u043D\u043B\u0430\u0439\u043D","\u043E\u0440\u0433","\u0440\u0443\u0441","\u0440\u0444","\u0441\u0430\u0439\u0442","\u0441\u0440\u0431","\u0443\u043A\u0440","\u049B\u0430\u0437","\u0570\u0561\u0575","\u05D9\u05E9\u05E8\u05D0\u05DC","\u05E7\u05D5\u05DD","\u0627\u0628\u0648\u0638\u0628\u064A","\u0627\u0631\u0627\u0645\u0643\u0648","\u0627\u0644\u0627\u0631\u062F\u0646","\u0627\u0644\u0628\u062D\u0631\u064A\u0646","\u0627\u0644\u062C\u0632\u0627\u0626\u0631","\u0627\u0644\u0633\u0639\u0648\u062F\u064A\u0629","\u0627\u0644\u0639\u0644\u064A\u0627\u0646","\u0627\u0644\u0645\u063A\u0631\u0628","\u0627\u0645\u0627\u0631\u0627\u062A","\u0627\u06CC\u0631\u0627\u0646","\u0628\u0627\u0631\u062A","\u0628\u0627\u0632\u0627\u0631","\u0628\u064A\u062A\u0643","\u0628\u06BE\u0627\u0631\u062A","\u062A\u0648\u0646\u0633","\u0633\u0648\u062F\u0627\u0646","\u0633\u0648\u0631\u064A\u0629","\u0634\u0628\u0643\u0629","\u0639\u0631\u0627\u0642","\u0639\u0631\u0628","\u0639\u0645\u0627\u0646","\u0641\u0644\u0633\u0637\u064A\u0646","\u0642\u0637\u0631","\u0643\u0627\u062B\u0648\u0644\u064A\u0643","\u0643\u0648\u0645","\u0645\u0635\u0631","\u0645\u0644\u064A\u0633\u064A\u0627","\u0645\u0648\u0631\u064A\u062A\u0627\u0646\u064A\u0627","\u0645\u0648\u0642\u0639","\u0647\u0645\u0631\u0627\u0647","\u067E\u0627\u06A9\u0633\u062A\u0627\u0646","\u0680\u0627\u0631\u062A","\u0915\u0949\u092E","\u0928\u0947\u091F","\u092D\u093E\u0930\u0924","\u092D\u093E\u0930\u0924\u092E\u094D","\u092D\u093E\u0930\u094B\u0924","\u0938\u0902\u0917\u0920\u0928","\u09AC\u09BE\u0982\u09B2\u09BE","\u09AD\u09BE\u09B0\u09A4","\u09AD\u09BE\u09F0\u09A4","\u0A2D\u0A3E\u0A30\u0A24","\u0AAD\u0ABE\u0AB0\u0AA4","\u0B2D\u0B3E\u0B30\u0B24","\u0B87\u0BA8\u0BCD\u0BA4\u0BBF\u0BAF\u0BBE","\u0B87\u0BB2\u0B99\u0BCD\u0B95\u0BC8","\u0B9A\u0BBF\u0B99\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0BC2\u0BB0\u0BCD","\u0C2D\u0C3E\u0C30\u0C24\u0C4D","\u0CAD\u0CBE\u0CB0\u0CA4","\u0D2D\u0D3E\u0D30\u0D24\u0D02","\u0DBD\u0D82\u0D9A\u0DCF","\u0E04\u0E2D\u0E21","\u0E44\u0E17\u0E22","\u0EA5\u0EB2\u0EA7","\u10D2\u10D4","\u307F\u3093\u306A","\u30A2\u30DE\u30BE\u30F3","\u30AF\u30E9\u30A6\u30C9","\u30B0\u30FC\u30B0\u30EB","\u30B3\u30E0","\u30B9\u30C8\u30A2","\u30BB\u30FC\u30EB","\u30D5\u30A1\u30C3\u30B7\u30E7\u30F3","\u30DD\u30A4\u30F3\u30C8","\u4E16\u754C","\u4E2D\u4FE1","\u4E2D\u56FD","\u4E2D\u570B","\u4E2D\u6587\u7F51","\u4E9A\u9A6C\u900A","\u4F01\u4E1A","\u4F5B\u5C71","\u4FE1\u606F","\u5065\u5EB7","\u516B\u5366","\u516C\u53F8","\u516C\u76CA","\u53F0\u6E7E","\u53F0\u7063","\u5546\u57CE","\u5546\u5E97","\u5546\u6807","\u5609\u91CC","\u5609\u91CC\u5927\u9152\u5E97","\u5728\u7EBF","\u5927\u62FF","\u5929\u4E3B\u6559","\u5A31\u4E50","\u5BB6\u96FB","\u5E7F\u4E1C","\u5FAE\u535A","\u6148\u5584","\u6211\u7231\u4F60","\u624B\u673A","\u62DB\u8058","\u653F\u52A1","\u653F\u5E9C","\u65B0\u52A0\u5761","\u65B0\u95FB","\u65F6\u5C1A","\u66F8\u7C4D","\u673A\u6784","\u6DE1\u9A6C\u9521","\u6E38\u620F","\u6FB3\u9580","\u70B9\u770B","\u79FB\u52A8","\u7EC4\u7EC7\u673A\u6784","\u7F51\u5740","\u7F51\u5E97","\u7F51\u7AD9","\u7F51\u7EDC","\u8054\u901A","\u8C37\u6B4C","\u8D2D\u7269","\u901A\u8CA9","\u96C6\u56E2","\u96FB\u8A0A\u76C8\u79D1","\u98DE\u5229\u6D66","\u98DF\u54C1","\u9910\u5385","\u9999\u683C\u91CC\u62C9","\u9999\u6E2F","\uB2F7\uB137","\uB2F7\uCEF4","\uC0BC\uC131","\uD55C\uAD6D"]');
  var util$2 = {};
  var hasRequiredUtil$2;
  function requireUtil$2() {
    if (hasRequiredUtil$2) return util$2;
    hasRequiredUtil$2 = 1;
    Object.defineProperty(util$2, "__esModule", { value: true });
    util$2.TAG_REGEX = util$2.TRAILING_PUNCTUATION_REGEX = util$2.URL_REGEX = util$2.MENTION_REGEX = void 0;
    util$2.MENTION_REGEX = /(^|\s|\()(@)([a-zA-Z0-9.-]+)(\b)/g;
    util$2.URL_REGEX = /(^|\s|\()((https?:\/\/[\S]+)|((?<domain>[a-z][a-z0-9]*(\.[a-z0-9]+)+)[\S]*))/gim;
    util$2.TRAILING_PUNCTUATION_REGEX = /\p{P}+$/gu;
    util$2.TAG_REGEX = // eslint-disable-next-line no-misleading-character-class
    /(^|\s)[#＃]((?!\ufe0f)[^\s\u00AD\u2060\u200A\u200B\u200C\u200D\u20e2]*[^\d\s\p{P}\u00AD\u2060\u200A\u200B\u200C\u200D\u20e2]+[^\s\u00AD\u2060\u200A\u200B\u200C\u200D\u20e2]*)?/gu;
    return util$2;
  }
  var hasRequiredDetection;
  function requireDetection() {
    if (hasRequiredDetection) return detection;
    hasRequiredDetection = 1;
    var __importDefault = detection && detection.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(detection, "__esModule", { value: true });
    detection.detectFacets = detectFacets;
    const tlds_1 = __importDefault(require$$0);
    const util_1 = requireUtil$2();
    function detectFacets(text) {
      let match2;
      const facets = [];
      {
        const re = util_1.MENTION_REGEX;
        while (match2 = re.exec(text.utf16)) {
          if (!isValidDomain(match2[3]) && !match2[3].endsWith(".test")) {
            continue;
          }
          const start = text.utf16.indexOf(match2[3], match2.index) - 1;
          facets.push({
            $type: "app.bsky.richtext.facet",
            index: {
              byteStart: text.utf16IndexToUtf8Index(start),
              byteEnd: text.utf16IndexToUtf8Index(start + match2[3].length + 1)
            },
            features: [
              {
                $type: "app.bsky.richtext.facet#mention",
                did: match2[3]
                // must be resolved afterwards
              }
            ]
          });
        }
      }
      {
        const re = util_1.URL_REGEX;
        while (match2 = re.exec(text.utf16)) {
          let uri = match2[2];
          if (!uri.startsWith("http")) {
            const domain = match2.groups?.domain;
            if (!domain || !isValidDomain(domain)) {
              continue;
            }
            uri = `https://${uri}`;
          }
          const start = text.utf16.indexOf(match2[2], match2.index);
          const index = { start, end: start + match2[2].length };
          if (/[.,;:!?]$/.test(uri)) {
            uri = uri.slice(0, -1);
            index.end--;
          }
          if (/[)]$/.test(uri) && !uri.includes("(")) {
            uri = uri.slice(0, -1);
            index.end--;
          }
          facets.push({
            index: {
              byteStart: text.utf16IndexToUtf8Index(index.start),
              byteEnd: text.utf16IndexToUtf8Index(index.end)
            },
            features: [
              {
                $type: "app.bsky.richtext.facet#link",
                uri
              }
            ]
          });
        }
      }
      {
        const re = util_1.TAG_REGEX;
        while (match2 = re.exec(text.utf16)) {
          const leading = match2[1];
          let tag = match2[2];
          if (!tag)
            continue;
          tag = tag.trim().replace(util_1.TRAILING_PUNCTUATION_REGEX, "");
          if (tag.length === 0 || tag.length > 64)
            continue;
          const index = match2.index + leading.length;
          facets.push({
            index: {
              byteStart: text.utf16IndexToUtf8Index(index),
              byteEnd: text.utf16IndexToUtf8Index(index + 1 + tag.length)
            },
            features: [
              {
                $type: "app.bsky.richtext.facet#tag",
                tag
              }
            ]
          });
        }
      }
      return facets.length > 0 ? facets : void 0;
    }
    function isValidDomain(str) {
      return !!tlds_1.default.find((tld) => {
        const i = str.lastIndexOf(tld);
        if (i === -1) {
          return false;
        }
        return str.charAt(i - 1) === "." && i === str.length - tld.length;
      });
    }
    return detection;
  }
  var sanitization = {};
  var unicode = {};
  var hasRequiredUnicode;
  function requireUnicode() {
    if (hasRequiredUnicode) return unicode;
    hasRequiredUnicode = 1;
    Object.defineProperty(unicode, "__esModule", { value: true });
    unicode.UnicodeString = void 0;
    const common_web_1 = requireDist$4();
    const encoder = new TextEncoder();
    const decoder = new TextDecoder();
    class UnicodeString {
      constructor(utf16) {
        Object.defineProperty(this, "utf16", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "utf8", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "_graphemeLen", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.utf16 = utf16;
        this.utf8 = encoder.encode(utf16);
      }
      get length() {
        return this.utf8.byteLength;
      }
      get graphemeLength() {
        if (!this._graphemeLen) {
          this._graphemeLen = (0, common_web_1.graphemeLen)(this.utf16);
        }
        return this._graphemeLen;
      }
      slice(start, end) {
        return decoder.decode(this.utf8.slice(start, end));
      }
      utf16IndexToUtf8Index(i) {
        return encoder.encode(this.utf16.slice(0, i)).byteLength;
      }
      toString() {
        return this.utf16;
      }
    }
    unicode.UnicodeString = UnicodeString;
    return unicode;
  }
  var hasRequiredSanitization;
  function requireSanitization() {
    if (hasRequiredSanitization) return sanitization;
    hasRequiredSanitization = 1;
    Object.defineProperty(sanitization, "__esModule", { value: true });
    sanitization.sanitizeRichText = sanitizeRichText;
    const unicode_1 = requireUnicode();
    const EXCESS_SPACE_RE = /[\r\n]([\u00AD\u2060\u200D\u200C\u200B\s]*[\r\n]){2,}/;
    const REPLACEMENT_STR = "\n\n";
    function sanitizeRichText(richText2, opts) {
      if (opts.cleanNewlines) {
        richText2 = clean(richText2, EXCESS_SPACE_RE, REPLACEMENT_STR);
      }
      return richText2;
    }
    function clean(richText2, targetRegexp, replacementString) {
      richText2 = richText2.clone();
      let match2 = richText2.unicodeText.utf16.match(targetRegexp);
      while (match2 && typeof match2.index !== "undefined") {
        const oldText = richText2.unicodeText;
        const removeStartIndex = richText2.unicodeText.utf16IndexToUtf8Index(match2.index);
        const removeEndIndex = removeStartIndex + new unicode_1.UnicodeString(match2[0]).length;
        richText2.delete(removeStartIndex, removeEndIndex);
        if (richText2.unicodeText.utf16 === oldText.utf16) {
          break;
        }
        richText2.insert(removeStartIndex, replacementString);
        match2 = richText2.unicodeText.utf16.match(targetRegexp);
      }
      return richText2;
    }
    return sanitization;
  }
  var hasRequiredRichText;
  function requireRichText() {
    if (hasRequiredRichText) return richText;
    hasRequiredRichText = 1;
    Object.defineProperty(richText, "__esModule", { value: true });
    richText.RichText = richText.RichTextSegment = void 0;
    const client_1 = requireClient();
    const detection_1 = requireDetection();
    const sanitization_1 = requireSanitization();
    const unicode_1 = requireUnicode();
    class RichTextSegment {
      constructor(text, facet2) {
        Object.defineProperty(this, "text", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: text
        });
        Object.defineProperty(this, "facet", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: facet2
        });
      }
      get link() {
        return this.facet?.features.find(client_1.AppBskyRichtextFacet.isLink);
      }
      isLink() {
        return !!this.link;
      }
      get mention() {
        return this.facet?.features.find(client_1.AppBskyRichtextFacet.isMention);
      }
      isMention() {
        return !!this.mention;
      }
      get tag() {
        return this.facet?.features.find(client_1.AppBskyRichtextFacet.isTag);
      }
      isTag() {
        return !!this.tag;
      }
    }
    richText.RichTextSegment = RichTextSegment;
    class RichText {
      constructor(props, opts) {
        Object.defineProperty(this, "unicodeText", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "facets", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.unicodeText = new unicode_1.UnicodeString(props.text);
        this.facets = props.facets;
        if (!this.facets?.length && props.entities?.length) {
          this.facets = entitiesToFacets(this.unicodeText, props.entities);
        }
        if (this.facets) {
          this.facets = this.facets.filter(facetFilter).sort(facetSort);
        }
        if (opts?.cleanNewlines) {
          (0, sanitization_1.sanitizeRichText)(this, { cleanNewlines: true }).copyInto(this);
        }
      }
      get text() {
        return this.unicodeText.toString();
      }
      get length() {
        return this.unicodeText.length;
      }
      get graphemeLength() {
        return this.unicodeText.graphemeLength;
      }
      clone() {
        return new RichText({
          text: this.unicodeText.utf16,
          facets: cloneDeep(this.facets)
        });
      }
      copyInto(target2) {
        target2.unicodeText = this.unicodeText;
        target2.facets = cloneDeep(this.facets);
      }
      *segments() {
        const facets = this.facets || [];
        if (!facets.length) {
          yield new RichTextSegment(this.unicodeText.utf16);
          return;
        }
        let textCursor = 0;
        let facetCursor = 0;
        do {
          const currFacet = facets[facetCursor];
          if (textCursor < currFacet.index.byteStart) {
            yield new RichTextSegment(this.unicodeText.slice(textCursor, currFacet.index.byteStart));
          } else if (textCursor > currFacet.index.byteStart) {
            facetCursor++;
            continue;
          }
          if (currFacet.index.byteStart < currFacet.index.byteEnd) {
            const subtext = this.unicodeText.slice(currFacet.index.byteStart, currFacet.index.byteEnd);
            if (!subtext.trim()) {
              yield new RichTextSegment(subtext);
            } else {
              yield new RichTextSegment(subtext, currFacet);
            }
          }
          textCursor = currFacet.index.byteEnd;
          facetCursor++;
        } while (facetCursor < facets.length);
        if (textCursor < this.unicodeText.length) {
          yield new RichTextSegment(this.unicodeText.slice(textCursor, this.unicodeText.length));
        }
      }
      insert(insertIndex, insertText) {
        this.unicodeText = new unicode_1.UnicodeString(this.unicodeText.slice(0, insertIndex) + insertText + this.unicodeText.slice(insertIndex));
        if (!this.facets?.length) {
          return this;
        }
        const numCharsAdded = insertText.length;
        for (const ent of this.facets) {
          if (insertIndex <= ent.index.byteStart) {
            ent.index.byteStart += numCharsAdded;
            ent.index.byteEnd += numCharsAdded;
          } else if (insertIndex >= ent.index.byteStart && insertIndex < ent.index.byteEnd) {
            ent.index.byteEnd += numCharsAdded;
          }
        }
        return this;
      }
      delete(removeStartIndex, removeEndIndex) {
        this.unicodeText = new unicode_1.UnicodeString(this.unicodeText.slice(0, removeStartIndex) + this.unicodeText.slice(removeEndIndex));
        if (!this.facets?.length) {
          return this;
        }
        const numCharsRemoved = removeEndIndex - removeStartIndex;
        for (const ent of this.facets) {
          if (removeStartIndex <= ent.index.byteStart && removeEndIndex >= ent.index.byteEnd) {
            ent.index.byteStart = 0;
            ent.index.byteEnd = 0;
          } else if (removeStartIndex > ent.index.byteEnd) ;
          else if (removeStartIndex > ent.index.byteStart && removeStartIndex <= ent.index.byteEnd && removeEndIndex > ent.index.byteEnd) {
            ent.index.byteEnd = removeStartIndex;
          } else if (removeStartIndex >= ent.index.byteStart && removeEndIndex <= ent.index.byteEnd) {
            ent.index.byteEnd -= numCharsRemoved;
          } else if (removeStartIndex < ent.index.byteStart && removeEndIndex >= ent.index.byteStart && removeEndIndex <= ent.index.byteEnd) {
            ent.index.byteStart = removeStartIndex;
            ent.index.byteEnd -= numCharsRemoved;
          } else if (removeEndIndex < ent.index.byteStart) {
            ent.index.byteStart -= numCharsRemoved;
            ent.index.byteEnd -= numCharsRemoved;
          }
        }
        this.facets = this.facets.filter((ent) => ent.index.byteStart < ent.index.byteEnd);
        return this;
      }
      /**
       * Detects facets such as links and mentions
       * Note: Overwrites the existing facets with auto-detected facets
       */
      async detectFacets(agent2) {
        this.facets = (0, detection_1.detectFacets)(this.unicodeText);
        if (this.facets) {
          const promises = [];
          for (const facet2 of this.facets) {
            for (const feature of facet2.features) {
              if (client_1.AppBskyRichtextFacet.isMention(feature)) {
                promises.push(agent2.com.atproto.identity.resolveHandle({ handle: feature.did }).then((res) => res?.data.did).catch((_) => void 0).then((did2) => {
                  feature.did = did2 || "";
                }));
              }
            }
          }
          await Promise.allSettled(promises);
          this.facets.sort(facetSort);
        }
      }
      /**
       * Detects facets such as links and mentions but does not resolve them
       * Will produce invalid facets! For instance, mentions will not have their DIDs set.
       * Note: Overwrites the existing facets with auto-detected facets
       */
      detectFacetsWithoutResolution() {
        this.facets = (0, detection_1.detectFacets)(this.unicodeText);
        if (this.facets) {
          this.facets.sort(facetSort);
        }
      }
    }
    richText.RichText = RichText;
    const facetSort = (a, b) => a.index.byteStart - b.index.byteStart;
    const facetFilter = (facet2) => (
      // discard negative-length facets. zero-length facets are valid
      facet2.index.byteStart <= facet2.index.byteEnd
    );
    function entitiesToFacets(text, entities) {
      const facets = [];
      for (const ent of entities) {
        if (ent.type === "link") {
          facets.push({
            $type: "app.bsky.richtext.facet",
            index: {
              byteStart: text.utf16IndexToUtf8Index(ent.index.start),
              byteEnd: text.utf16IndexToUtf8Index(ent.index.end)
            },
            features: [{ $type: "app.bsky.richtext.facet#link", uri: ent.value }]
          });
        } else if (ent.type === "mention") {
          facets.push({
            $type: "app.bsky.richtext.facet",
            index: {
              byteStart: text.utf16IndexToUtf8Index(ent.index.start),
              byteEnd: text.utf16IndexToUtf8Index(ent.index.end)
            },
            features: [
              { $type: "app.bsky.richtext.facet#mention", did: ent.value }
            ]
          });
        }
      }
      return facets;
    }
    function cloneDeep(v) {
      if (typeof v === "undefined") {
        return v;
      }
      return JSON.parse(JSON.stringify(v));
    }
    return richText;
  }
  var moderation = {};
  var decision = {};
  var labels = {};
  var hasRequiredLabels;
  function requireLabels() {
    if (hasRequiredLabels) return labels;
    hasRequiredLabels = 1;
    Object.defineProperty(labels, "__esModule", { value: true });
    labels.LABELS = labels.DEFAULT_LABEL_SETTINGS = void 0;
    labels.DEFAULT_LABEL_SETTINGS = {
      porn: "hide",
      sexual: "warn",
      nudity: "ignore",
      "graphic-media": "warn"
    };
    labels.LABELS = {
      "!hide": {
        identifier: "!hide",
        configurable: false,
        defaultSetting: "hide",
        flags: ["no-override", "no-self"],
        severity: "alert",
        blurs: "content",
        behaviors: {
          account: {
            profileList: "blur",
            profileView: "blur",
            avatar: "blur",
            banner: "blur",
            displayName: "blur",
            contentList: "blur",
            contentView: "blur"
          },
          profile: {
            avatar: "blur",
            banner: "blur",
            displayName: "blur"
          },
          content: {
            contentList: "blur",
            contentView: "blur"
          }
        },
        locales: []
      },
      "!warn": {
        identifier: "!warn",
        configurable: false,
        defaultSetting: "warn",
        flags: ["no-self"],
        severity: "none",
        blurs: "content",
        behaviors: {
          account: {
            profileList: "blur",
            profileView: "blur",
            avatar: "blur",
            banner: "blur",
            contentList: "blur",
            contentView: "blur"
          },
          profile: {
            avatar: "blur",
            banner: "blur",
            displayName: "blur"
          },
          content: {
            contentList: "blur",
            contentView: "blur"
          }
        },
        locales: []
      },
      "!no-unauthenticated": {
        identifier: "!no-unauthenticated",
        configurable: false,
        defaultSetting: "hide",
        flags: ["no-override", "unauthed"],
        severity: "none",
        blurs: "content",
        behaviors: {
          account: {
            profileList: "blur",
            profileView: "blur",
            avatar: "blur",
            banner: "blur",
            displayName: "blur",
            contentList: "blur",
            contentView: "blur"
          },
          profile: {
            avatar: "blur",
            banner: "blur",
            displayName: "blur"
          },
          content: {
            contentList: "blur",
            contentView: "blur"
          }
        },
        locales: []
      },
      porn: {
        identifier: "porn",
        configurable: true,
        defaultSetting: "hide",
        flags: ["adult"],
        severity: "none",
        blurs: "media",
        behaviors: {
          account: {
            avatar: "blur",
            banner: "blur"
          },
          profile: {
            avatar: "blur",
            banner: "blur"
          },
          content: {
            contentMedia: "blur"
          }
        },
        locales: []
      },
      sexual: {
        identifier: "sexual",
        configurable: true,
        defaultSetting: "warn",
        flags: ["adult"],
        severity: "none",
        blurs: "media",
        behaviors: {
          account: {
            avatar: "blur",
            banner: "blur"
          },
          profile: {
            avatar: "blur",
            banner: "blur"
          },
          content: {
            contentMedia: "blur"
          }
        },
        locales: []
      },
      nudity: {
        identifier: "nudity",
        configurable: true,
        defaultSetting: "ignore",
        flags: [],
        severity: "none",
        blurs: "media",
        behaviors: {
          account: {
            avatar: "blur",
            banner: "blur"
          },
          profile: {
            avatar: "blur",
            banner: "blur"
          },
          content: {
            contentMedia: "blur"
          }
        },
        locales: []
      },
      "graphic-media": {
        identifier: "graphic-media",
        flags: ["adult"],
        configurable: true,
        defaultSetting: "warn",
        severity: "none",
        blurs: "media",
        behaviors: {
          account: {
            avatar: "blur",
            banner: "blur"
          },
          profile: {
            avatar: "blur",
            banner: "blur"
          },
          content: {
            contentMedia: "blur"
          }
        },
        locales: []
      },
      /** @deprecated alias for `graphic-media` */
      gore: {
        identifier: "gore",
        flags: ["adult"],
        configurable: true,
        defaultSetting: "warn",
        severity: "none",
        blurs: "media",
        behaviors: {
          account: {
            avatar: "blur",
            banner: "blur"
          },
          profile: {
            avatar: "blur",
            banner: "blur"
          },
          content: {
            contentMedia: "blur"
          }
        },
        locales: []
      }
    };
    return labels;
  }
  var types = {};
  var hasRequiredTypes;
  function requireTypes() {
    if (hasRequiredTypes) return types;
    hasRequiredTypes = 1;
    Object.defineProperty(types, "__esModule", { value: true });
    types.NOOP_BEHAVIOR = types.HIDE_BEHAVIOR = types.MUTEWORD_BEHAVIOR = types.MUTE_BEHAVIOR = types.BLOCK_BEHAVIOR = types.CUSTOM_LABEL_VALUE_RE = void 0;
    types.CUSTOM_LABEL_VALUE_RE = /^[a-z-]+$/;
    types.BLOCK_BEHAVIOR = {
      profileList: "blur",
      profileView: "alert",
      avatar: "blur",
      banner: "blur",
      contentList: "blur",
      contentView: "blur"
    };
    types.MUTE_BEHAVIOR = {
      profileList: "inform",
      profileView: "alert",
      contentList: "blur",
      contentView: "inform"
    };
    types.MUTEWORD_BEHAVIOR = {
      contentList: "blur",
      contentView: "blur"
    };
    types.HIDE_BEHAVIOR = {
      contentList: "blur",
      contentView: "blur"
    };
    types.NOOP_BEHAVIOR = {};
    return types;
  }
  var ui = {};
  var hasRequiredUi;
  function requireUi() {
    if (hasRequiredUi) return ui;
    hasRequiredUi = 1;
    Object.defineProperty(ui, "__esModule", { value: true });
    ui.ModerationUI = void 0;
    class ModerationUI {
      constructor() {
        Object.defineProperty(this, "noOverride", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: false
        });
        Object.defineProperty(this, "filters", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: []
        });
        Object.defineProperty(this, "blurs", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: []
        });
        Object.defineProperty(this, "alerts", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: []
        });
        Object.defineProperty(this, "informs", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: []
        });
      }
      get filter() {
        return this.filters.length !== 0;
      }
      get blur() {
        return this.blurs.length !== 0;
      }
      get alert() {
        return this.alerts.length !== 0;
      }
      get inform() {
        return this.informs.length !== 0;
      }
    }
    ui.ModerationUI = ModerationUI;
    return ui;
  }
  var hasRequiredDecision;
  function requireDecision() {
    if (hasRequiredDecision) return decision;
    hasRequiredDecision = 1;
    Object.defineProperty(decision, "__esModule", { value: true });
    decision.ModerationDecision = void 0;
    const labels_1 = requireLabels();
    const types_1 = requireTypes();
    const ui_1 = requireUi();
    var ModerationBehaviorSeverity;
    (function(ModerationBehaviorSeverity2) {
      ModerationBehaviorSeverity2[ModerationBehaviorSeverity2["High"] = 0] = "High";
      ModerationBehaviorSeverity2[ModerationBehaviorSeverity2["Medium"] = 1] = "Medium";
      ModerationBehaviorSeverity2[ModerationBehaviorSeverity2["Low"] = 2] = "Low";
    })(ModerationBehaviorSeverity || (ModerationBehaviorSeverity = {}));
    class ModerationDecision {
      constructor() {
        Object.defineProperty(this, "did", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: ""
        });
        Object.defineProperty(this, "isMe", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: false
        });
        Object.defineProperty(this, "causes", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: []
        });
      }
      static merge(...decisions) {
        const decisionsFiltered = decisions.filter((v) => v != null);
        const decision2 = new ModerationDecision();
        if (decisionsFiltered[0]) {
          decision2.did = decisionsFiltered[0].did;
          decision2.isMe = decisionsFiltered[0].isMe;
        }
        decision2.causes = decisionsFiltered.flatMap((d) => d.causes);
        return decision2;
      }
      downgrade() {
        for (const cause of this.causes) {
          cause.downgraded = true;
        }
        return this;
      }
      get blocked() {
        return !!this.blockCause;
      }
      get muted() {
        return !!this.muteCause;
      }
      get blockCause() {
        return this.causes.find((cause) => cause.type === "blocking" || cause.type === "blocked-by" || cause.type === "block-other");
      }
      get muteCause() {
        return this.causes.find((cause) => cause.type === "muted");
      }
      get labelCauses() {
        return this.causes.filter((cause) => cause.type === "label");
      }
      ui(context) {
        const ui2 = new ui_1.ModerationUI();
        for (const cause of this.causes) {
          if (cause.type === "blocking" || cause.type === "blocked-by" || cause.type === "block-other") {
            if (this.isMe) {
              continue;
            }
            if (context === "profileList" || context === "contentList") {
              ui2.filters.push(cause);
            }
            if (!cause.downgraded) {
              if (types_1.BLOCK_BEHAVIOR[context] === "blur") {
                ui2.noOverride = true;
                ui2.blurs.push(cause);
              } else if (types_1.BLOCK_BEHAVIOR[context] === "alert") {
                ui2.alerts.push(cause);
              } else if (types_1.BLOCK_BEHAVIOR[context] === "inform") {
                ui2.informs.push(cause);
              }
            }
          } else if (cause.type === "muted") {
            if (this.isMe) {
              continue;
            }
            if (context === "profileList" || context === "contentList") {
              ui2.filters.push(cause);
            }
            if (!cause.downgraded) {
              if (types_1.MUTE_BEHAVIOR[context] === "blur") {
                ui2.blurs.push(cause);
              } else if (types_1.MUTE_BEHAVIOR[context] === "alert") {
                ui2.alerts.push(cause);
              } else if (types_1.MUTE_BEHAVIOR[context] === "inform") {
                ui2.informs.push(cause);
              }
            }
          } else if (cause.type === "mute-word") {
            if (this.isMe) {
              continue;
            }
            if (context === "contentList") {
              ui2.filters.push(cause);
            }
            if (!cause.downgraded) {
              if (types_1.MUTEWORD_BEHAVIOR[context] === "blur") {
                ui2.blurs.push(cause);
              } else if (types_1.MUTEWORD_BEHAVIOR[context] === "alert") {
                ui2.alerts.push(cause);
              } else if (types_1.MUTEWORD_BEHAVIOR[context] === "inform") {
                ui2.informs.push(cause);
              }
            }
          } else if (cause.type === "hidden") {
            if (context === "profileList" || context === "contentList") {
              ui2.filters.push(cause);
            }
            if (!cause.downgraded) {
              if (types_1.HIDE_BEHAVIOR[context] === "blur") {
                ui2.blurs.push(cause);
              } else if (types_1.HIDE_BEHAVIOR[context] === "alert") {
                ui2.alerts.push(cause);
              } else if (types_1.HIDE_BEHAVIOR[context] === "inform") {
                ui2.informs.push(cause);
              }
            }
          } else if (cause.type === "label") {
            if (context === "profileList" && cause.target === "account") {
              if (cause.setting === "hide" && !this.isMe) {
                ui2.filters.push(cause);
              }
            } else if (context === "contentList" && (cause.target === "account" || cause.target === "content")) {
              if (cause.setting === "hide" && !this.isMe) {
                ui2.filters.push(cause);
              }
            }
            if (!cause.downgraded) {
              if (cause.behavior[context] === "blur") {
                ui2.blurs.push(cause);
                if (cause.noOverride && !this.isMe) {
                  ui2.noOverride = true;
                }
              } else if (cause.behavior[context] === "alert") {
                ui2.alerts.push(cause);
              } else if (cause.behavior[context] === "inform") {
                ui2.informs.push(cause);
              }
            }
          }
        }
        ui2.filters.sort(sortByPriority);
        ui2.blurs.sort(sortByPriority);
        return ui2;
      }
      setDid(did2) {
        this.did = did2;
      }
      setIsMe(isMe) {
        this.isMe = isMe;
      }
      addHidden(hidden2) {
        if (hidden2) {
          this.causes.push({
            type: "hidden",
            source: { type: "user" },
            priority: 6
          });
        }
      }
      addMutedWord(mutedWord) {
        if (mutedWord) {
          this.causes.push({
            type: "mute-word",
            source: { type: "user" },
            priority: 6
          });
        }
      }
      addBlocking(blocking) {
        if (blocking) {
          this.causes.push({
            type: "blocking",
            source: { type: "user" },
            priority: 3
          });
        }
      }
      addBlockingByList(blockingByList) {
        if (blockingByList) {
          this.causes.push({
            type: "blocking",
            source: { type: "list", list: blockingByList },
            priority: 3
          });
        }
      }
      addBlockedBy(blockedBy) {
        if (blockedBy) {
          this.causes.push({
            type: "blocked-by",
            source: { type: "user" },
            priority: 4
          });
        }
      }
      addBlockOther(blockOther) {
        if (blockOther) {
          this.causes.push({
            type: "block-other",
            source: { type: "user" },
            priority: 4
          });
        }
      }
      addLabel(target2, label, opts) {
        const labelDef = types_1.CUSTOM_LABEL_VALUE_RE.test(label.val) ? opts.labelDefs?.[label.src]?.find((def) => def.identifier === label.val) || labels_1.LABELS[label.val] : labels_1.LABELS[label.val];
        if (!labelDef) {
          return;
        }
        const isSelf = label.src === this.did;
        const labeler = isSelf ? void 0 : opts.prefs.labelers.find((s) => s.did === label.src);
        if (!isSelf && !labeler) {
          return;
        }
        if (isSelf && labelDef.flags.includes("no-self")) {
          return;
        }
        let labelPref = labelDef.defaultSetting || "ignore";
        if (!labelDef.configurable) {
          labelPref = labelDef.defaultSetting || "hide";
        } else if (labelDef.flags.includes("adult") && !opts.prefs.adultContentEnabled) {
          labelPref = "hide";
        } else if (labeler?.labels[labelDef.identifier]) {
          labelPref = labeler?.labels[labelDef.identifier];
        } else if (opts.prefs.labels[labelDef.identifier]) {
          labelPref = opts.prefs.labels[labelDef.identifier];
        }
        if (labelPref === "ignore") {
          return;
        }
        if (labelDef.flags.includes("unauthed") && !!opts.userDid) {
          return;
        }
        let priority;
        const severity = measureModerationBehaviorSeverity(labelDef.behaviors[target2]);
        if (labelDef.flags.includes("no-override") || labelDef.flags.includes("adult") && !opts.prefs.adultContentEnabled) {
          priority = 1;
        } else if (labelPref === "hide") {
          priority = 2;
        } else if (severity === ModerationBehaviorSeverity.High) {
          priority = 5;
        } else if (severity === ModerationBehaviorSeverity.Medium) {
          priority = 7;
        } else {
          priority = 8;
        }
        let noOverride = false;
        if (labelDef.flags.includes("no-override")) {
          noOverride = true;
        } else if (labelDef.flags.includes("adult") && !opts.prefs.adultContentEnabled) {
          noOverride = true;
        }
        this.causes.push({
          type: "label",
          source: isSelf || !labeler ? { type: "user" } : { type: "labeler", did: labeler.did },
          label,
          labelDef,
          target: target2,
          setting: labelPref,
          behavior: labelDef.behaviors[target2] || types_1.NOOP_BEHAVIOR,
          noOverride,
          priority
        });
      }
      addMuted(muted) {
        if (muted) {
          this.causes.push({
            type: "muted",
            source: { type: "user" },
            priority: 6
          });
        }
      }
      addMutedByList(mutedByList) {
        if (mutedByList) {
          this.causes.push({
            type: "muted",
            source: { type: "list", list: mutedByList },
            priority: 6
          });
        }
      }
    }
    decision.ModerationDecision = ModerationDecision;
    function measureModerationBehaviorSeverity(beh) {
      if (!beh) {
        return ModerationBehaviorSeverity.Low;
      }
      if (beh.profileView === "blur" || beh.contentView === "blur") {
        return ModerationBehaviorSeverity.High;
      }
      if (beh.contentList === "blur" || beh.contentMedia === "blur") {
        return ModerationBehaviorSeverity.Medium;
      }
      return ModerationBehaviorSeverity.Low;
    }
    function sortByPriority(a, b) {
      return a.priority - b.priority;
    }
    return decision;
  }
  var account = {};
  var hasRequiredAccount;
  function requireAccount() {
    if (hasRequiredAccount) return account;
    hasRequiredAccount = 1;
    Object.defineProperty(account, "__esModule", { value: true });
    account.decideAccount = decideAccount;
    account.filterAccountLabels = filterAccountLabels;
    const decision_1 = requireDecision();
    function decideAccount(subject, opts) {
      const acc = new decision_1.ModerationDecision();
      acc.setDid(subject.did);
      acc.setIsMe(subject.did === opts.userDid);
      if (subject.viewer?.muted) {
        if (subject.viewer?.mutedByList) {
          acc.addMutedByList(subject.viewer?.mutedByList);
        } else {
          acc.addMuted(subject.viewer?.muted);
        }
      }
      if (subject.viewer?.blocking) {
        if (subject.viewer?.blockingByList) {
          acc.addBlockingByList(subject.viewer?.blockingByList);
        } else {
          acc.addBlocking(subject.viewer?.blocking);
        }
      }
      acc.addBlockedBy(subject.viewer?.blockedBy);
      for (const label of filterAccountLabels(subject.labels)) {
        acc.addLabel("account", label, opts);
      }
      return acc;
    }
    function filterAccountLabels(labels2) {
      if (!labels2) {
        return [];
      }
      return labels2.filter((label) => !label.uri.endsWith("/app.bsky.actor.profile/self") || label.val === "!no-unauthenticated");
    }
    return account;
  }
  var feedGenerator = {};
  var profile = {};
  var hasRequiredProfile;
  function requireProfile() {
    if (hasRequiredProfile) return profile;
    hasRequiredProfile = 1;
    Object.defineProperty(profile, "__esModule", { value: true });
    profile.decideProfile = decideProfile;
    profile.filterProfileLabels = filterProfileLabels;
    const decision_1 = requireDecision();
    function decideProfile(subject, opts) {
      const acc = new decision_1.ModerationDecision();
      acc.setDid(subject.did);
      acc.setIsMe(subject.did === opts.userDid);
      for (const label of filterProfileLabels(subject.labels)) {
        acc.addLabel("profile", label, opts);
      }
      return acc;
    }
    function filterProfileLabels(labels2) {
      if (!labels2) {
        return [];
      }
      return labels2.filter((label) => label.uri.endsWith("/app.bsky.actor.profile/self"));
    }
    return profile;
  }
  var hasRequiredFeedGenerator;
  function requireFeedGenerator() {
    if (hasRequiredFeedGenerator) return feedGenerator;
    hasRequiredFeedGenerator = 1;
    Object.defineProperty(feedGenerator, "__esModule", { value: true });
    feedGenerator.decideFeedGenerator = decideFeedGenerator;
    const decision_1 = requireDecision();
    const account_1 = requireAccount();
    const profile_1 = requireProfile();
    function decideFeedGenerator(subject, opts) {
      const acc = new decision_1.ModerationDecision();
      acc.setDid(subject.creator.did);
      acc.setIsMe(subject.creator.did === opts.userDid);
      if (subject.labels?.length) {
        for (const label of subject.labels) {
          acc.addLabel("content", label, opts);
        }
      }
      return decision_1.ModerationDecision.merge(acc, (0, account_1.decideAccount)(subject.creator, opts), (0, profile_1.decideProfile)(subject.creator, opts));
    }
    return feedGenerator;
  }
  var notification = {};
  var hasRequiredNotification;
  function requireNotification() {
    if (hasRequiredNotification) return notification;
    hasRequiredNotification = 1;
    Object.defineProperty(notification, "__esModule", { value: true });
    notification.decideNotification = decideNotification;
    const decision_1 = requireDecision();
    const account_1 = requireAccount();
    const profile_1 = requireProfile();
    function decideNotification(subject, opts) {
      const acc = new decision_1.ModerationDecision();
      acc.setDid(subject.author.did);
      acc.setIsMe(subject.author.did === opts.userDid);
      if (subject.labels?.length) {
        for (const label of subject.labels) {
          acc.addLabel("content", label, opts);
        }
      }
      return decision_1.ModerationDecision.merge(acc, (0, account_1.decideAccount)(subject.author, opts), (0, profile_1.decideProfile)(subject.author, opts));
    }
    return notification;
  }
  var post = {};
  var mutewords = {};
  var hasRequiredMutewords;
  function requireMutewords() {
    if (hasRequiredMutewords) return mutewords;
    hasRequiredMutewords = 1;
    Object.defineProperty(mutewords, "__esModule", { value: true });
    mutewords.hasMutedWord = hasMutedWord;
    const client_1 = requireClient();
    const REGEX = {
      LEADING_TRAILING_PUNCTUATION: /(?:^\p{P}+|\p{P}+$)/gu,
      WORD_BOUNDARY: /[\s\n\t\r\f\v]+?/g
    };
    const LANGUAGE_EXCEPTIONS = [
      "ja",
      // Japanese
      "zh",
      // Chinese
      "ko",
      // Korean
      "th",
      // Thai
      "vi"
      // Vietnamese
    ];
    function hasMutedWord({ mutedWords, text, facets, outlineTags, languages, actor }) {
      const exception2 = LANGUAGE_EXCEPTIONS.includes(languages?.[0] || "");
      const tags = [].concat(outlineTags || []).concat((facets || []).flatMap((facet2) => facet2.features.filter(client_1.AppBskyRichtextFacet.isTag).map((tag) => tag.tag))).map((t) => t.toLowerCase());
      for (const mute of mutedWords) {
        const mutedWord = mute.value.toLowerCase();
        const postText = text.toLowerCase();
        if (mute.expiresAt && mute.expiresAt < (/* @__PURE__ */ new Date()).toISOString())
          continue;
        if (mute.actorTarget === "exclude-following" && Boolean(actor?.viewer?.following))
          continue;
        if (tags.includes(mutedWord))
          return true;
        if (!mute.targets.includes("content"))
          continue;
        if ((mutedWord.length === 1 || exception2) && postText.includes(mutedWord))
          return true;
        if (mutedWord.length > postText.length)
          continue;
        if (mutedWord === postText)
          return true;
        if (/(?:\s|\p{P})+?/u.test(mutedWord) && postText.includes(mutedWord))
          return true;
        const words = postText.split(REGEX.WORD_BOUNDARY);
        for (const word of words) {
          if (word === mutedWord)
            return true;
          const wordTrimmedPunctuation = word.replace(REGEX.LEADING_TRAILING_PUNCTUATION, "");
          if (mutedWord === wordTrimmedPunctuation)
            return true;
          if (mutedWord.length > wordTrimmedPunctuation.length)
            continue;
          if (/\p{P}+/u.test(wordTrimmedPunctuation)) {
            const spacedWord = wordTrimmedPunctuation.replace(/\p{P}+/gu, " ");
            if (spacedWord === mutedWord)
              return true;
            const contiguousWord = spacedWord.replace(/\s/gu, "");
            if (contiguousWord === mutedWord)
              return true;
            const wordParts = wordTrimmedPunctuation.split(/\p{P}+/u);
            for (const wordPart of wordParts) {
              if (wordPart === mutedWord)
                return true;
            }
          }
        }
      }
      return false;
    }
    return mutewords;
  }
  var hasRequiredPost;
  function requirePost() {
    if (hasRequiredPost) return post;
    hasRequiredPost = 1;
    Object.defineProperty(post, "__esModule", { value: true });
    post.decidePost = decidePost;
    const client_1 = requireClient();
    const decision_1 = requireDecision();
    const mutewords_1 = requireMutewords();
    const account_1 = requireAccount();
    const profile_1 = requireProfile();
    function decidePost(subject, opts) {
      return decision_1.ModerationDecision.merge(decideSubject(subject, opts), decideEmbed(subject.embed, opts)?.downgrade(), (0, account_1.decideAccount)(subject.author, opts), (0, profile_1.decideProfile)(subject.author, opts));
    }
    function decideSubject(subject, opts) {
      const acc = new decision_1.ModerationDecision();
      acc.setDid(subject.author.did);
      acc.setIsMe(subject.author.did === opts.userDid);
      if (subject.labels?.length) {
        for (const label of subject.labels) {
          acc.addLabel("content", label, opts);
        }
      }
      acc.addHidden(checkHiddenPost(subject, opts.prefs.hiddenPosts));
      if (!acc.isMe) {
        acc.addMutedWord(checkMutedWords(subject, opts.prefs.mutedWords));
      }
      return acc;
    }
    function decideEmbed(embed, opts) {
      if (embed) {
        if ((client_1.AppBskyEmbedRecord.isView(embed) || client_1.AppBskyEmbedRecordWithMedia.isView(embed)) && client_1.AppBskyEmbedRecord.isViewRecord(embed.record)) {
          return decideQuotedPost(embed.record, opts);
        } else if (client_1.AppBskyEmbedRecordWithMedia.isView(embed) && client_1.AppBskyEmbedRecord.isViewRecord(embed.record.record)) {
          return decideQuotedPost(embed.record.record, opts);
        } else if ((client_1.AppBskyEmbedRecord.isView(embed) || client_1.AppBskyEmbedRecordWithMedia.isView(embed)) && client_1.AppBskyEmbedRecord.isViewBlocked(embed.record)) {
          return decideBlockedQuotedPost(embed.record, opts);
        } else if (client_1.AppBskyEmbedRecordWithMedia.isView(embed) && client_1.AppBskyEmbedRecord.isViewBlocked(embed.record.record)) {
          return decideBlockedQuotedPost(embed.record.record, opts);
        }
      }
      return void 0;
    }
    function decideQuotedPost(subject, opts) {
      const acc = new decision_1.ModerationDecision();
      acc.setDid(subject.author.did);
      acc.setIsMe(subject.author.did === opts.userDid);
      if (subject.labels?.length) {
        for (const label of subject.labels) {
          acc.addLabel("content", label, opts);
        }
      }
      return decision_1.ModerationDecision.merge(acc, (0, account_1.decideAccount)(subject.author, opts), (0, profile_1.decideProfile)(subject.author, opts));
    }
    function decideBlockedQuotedPost(subject, opts) {
      const acc = new decision_1.ModerationDecision();
      acc.setDid(subject.author.did);
      acc.setIsMe(subject.author.did === opts.userDid);
      if (subject.author.viewer?.muted) {
        if (subject.author.viewer?.mutedByList) {
          acc.addMutedByList(subject.author.viewer?.mutedByList);
        } else {
          acc.addMuted(subject.author.viewer?.muted);
        }
      }
      if (subject.author.viewer?.blocking) {
        if (subject.author.viewer?.blockingByList) {
          acc.addBlockingByList(subject.author.viewer?.blockingByList);
        } else {
          acc.addBlocking(subject.author.viewer?.blocking);
        }
      }
      acc.addBlockedBy(subject.author.viewer?.blockedBy);
      return acc;
    }
    function checkHiddenPost(subject, hiddenPosts) {
      if (!hiddenPosts?.length) {
        return false;
      }
      if (hiddenPosts.includes(subject.uri)) {
        return true;
      }
      if (subject.embed) {
        if (client_1.AppBskyEmbedRecord.isView(subject.embed) && client_1.AppBskyEmbedRecord.isViewRecord(subject.embed.record) && hiddenPosts.includes(subject.embed.record.uri)) {
          return true;
        }
        if (client_1.AppBskyEmbedRecordWithMedia.isView(subject.embed) && client_1.AppBskyEmbedRecord.isViewRecord(subject.embed.record.record) && hiddenPosts.includes(subject.embed.record.record.uri)) {
          return true;
        }
      }
      return false;
    }
    function checkMutedWords(subject, mutedWords) {
      if (!mutedWords?.length) {
        return false;
      }
      const postAuthor = subject.author;
      if (client_1.AppBskyFeedPost.isRecord(subject.record)) {
        const post2 = subject.record;
        if ((0, mutewords_1.hasMutedWord)({
          mutedWords,
          text: post2.text,
          facets: post2.facets,
          outlineTags: post2.tags,
          languages: post2.langs,
          actor: postAuthor
        })) {
          return true;
        }
        if (post2.embed && client_1.AppBskyEmbedImages.isMain(post2.embed)) {
          for (const image of post2.embed.images) {
            if ((0, mutewords_1.hasMutedWord)({
              mutedWords,
              text: image.alt,
              languages: post2.langs,
              actor: postAuthor
            })) {
              return true;
            }
          }
        }
      }
      const { embed } = subject;
      if (embed) {
        if ((client_1.AppBskyEmbedRecord.isView(embed) || client_1.AppBskyEmbedRecordWithMedia.isView(embed)) && client_1.AppBskyEmbedRecord.isViewRecord(embed.record)) {
          if (client_1.AppBskyFeedPost.isRecord(embed.record.value)) {
            const embeddedPost = embed.record.value;
            const embedAuthor = embed.record.author;
            if ((0, mutewords_1.hasMutedWord)({
              mutedWords,
              text: embeddedPost.text,
              facets: embeddedPost.facets,
              outlineTags: embeddedPost.tags,
              languages: embeddedPost.langs,
              actor: embedAuthor
            })) {
              return true;
            }
            if (client_1.AppBskyEmbedImages.isMain(embeddedPost.embed)) {
              for (const image of embeddedPost.embed.images) {
                if ((0, mutewords_1.hasMutedWord)({
                  mutedWords,
                  text: image.alt,
                  languages: embeddedPost.langs,
                  actor: embedAuthor
                })) {
                  return true;
                }
              }
            }
            if (client_1.AppBskyEmbedExternal.isMain(embeddedPost.embed)) {
              const { external: external2 } = embeddedPost.embed;
              if ((0, mutewords_1.hasMutedWord)({
                mutedWords,
                text: external2.title + " " + external2.description,
                languages: [],
                actor: embedAuthor
              })) {
                return true;
              }
            }
            if (client_1.AppBskyEmbedRecordWithMedia.isMain(embeddedPost.embed)) {
              if (client_1.AppBskyEmbedExternal.isMain(embeddedPost.embed.media)) {
                const { external: external2 } = embeddedPost.embed.media;
                if ((0, mutewords_1.hasMutedWord)({
                  mutedWords,
                  text: external2.title + " " + external2.description,
                  languages: [],
                  actor: embedAuthor
                })) {
                  return true;
                }
              }
              if (client_1.AppBskyEmbedImages.isMain(embeddedPost.embed.media)) {
                for (const image of embeddedPost.embed.media.images) {
                  if ((0, mutewords_1.hasMutedWord)({
                    mutedWords,
                    text: image.alt,
                    languages: client_1.AppBskyFeedPost.isRecord(embeddedPost.record) ? embeddedPost.langs : [],
                    actor: embedAuthor
                  })) {
                    return true;
                  }
                }
              }
            }
          }
        } else if (client_1.AppBskyEmbedExternal.isView(embed)) {
          const { external: external2 } = embed;
          if ((0, mutewords_1.hasMutedWord)({
            mutedWords,
            text: external2.title + " " + external2.description,
            languages: [],
            actor: postAuthor
          })) {
            return true;
          }
        } else if (client_1.AppBskyEmbedRecordWithMedia.isView(embed) && client_1.AppBskyEmbedRecord.isViewRecord(embed.record.record)) {
          const embedAuthor = embed.record.record.author;
          if (client_1.AppBskyFeedPost.isRecord(embed.record.record.value)) {
            const post2 = embed.record.record.value;
            if ((0, mutewords_1.hasMutedWord)({
              mutedWords,
              text: post2.text,
              facets: post2.facets,
              outlineTags: post2.tags,
              languages: post2.langs,
              actor: embedAuthor
            })) {
              return true;
            }
          }
          if (client_1.AppBskyEmbedImages.isView(embed.media)) {
            for (const image of embed.media.images) {
              if ((0, mutewords_1.hasMutedWord)({
                mutedWords,
                text: image.alt,
                languages: client_1.AppBskyFeedPost.isRecord(subject.record) ? subject.record.langs : [],
                actor: embedAuthor
              })) {
                return true;
              }
            }
          }
          if (client_1.AppBskyEmbedExternal.isView(embed.media)) {
            const { external: external2 } = embed.media;
            if ((0, mutewords_1.hasMutedWord)({
              mutedWords,
              text: external2.title + " " + external2.description,
              languages: [],
              actor: embedAuthor
            })) {
              return true;
            }
          }
        }
      }
      return false;
    }
    return post;
  }
  var userList = {};
  var hasRequiredUserList;
  function requireUserList() {
    if (hasRequiredUserList) return userList;
    hasRequiredUserList = 1;
    Object.defineProperty(userList, "__esModule", { value: true });
    userList.decideUserList = decideUserList;
    const syntax_1 = requireDist$5();
    const decision_1 = requireDecision();
    const account_1 = requireAccount();
    const profile_1 = requireProfile();
    function decideUserList(subject, opts) {
      const acc = new decision_1.ModerationDecision();
      const creator = (
        // Note: ListViewBasic should not contain a creator field, but let's support it anyway
        "creator" in subject && isProfile(subject.creator) ? subject.creator : void 0
      );
      if (creator) {
        acc.setDid(creator.did);
        acc.setIsMe(creator.did === opts.userDid);
        if (subject.labels?.length) {
          for (const label of subject.labels) {
            acc.addLabel("content", label, opts);
          }
        }
        return decision_1.ModerationDecision.merge(acc, (0, account_1.decideAccount)(creator, opts), (0, profile_1.decideProfile)(creator, opts));
      }
      const creatorDid = new syntax_1.AtUri(subject.uri).hostname;
      acc.setDid(creatorDid);
      acc.setIsMe(creatorDid === opts.userDid);
      if (subject.labels?.length) {
        for (const label of subject.labels) {
          acc.addLabel("content", label, opts);
        }
      }
      return acc;
    }
    function isProfile(v) {
      return v && typeof v === "object" && "did" in v;
    }
    return userList;
  }
  var util$1 = {};
  var hasRequiredUtil$1;
  function requireUtil$1() {
    if (hasRequiredUtil$1) return util$1;
    hasRequiredUtil$1 = 1;
    Object.defineProperty(util$1, "__esModule", { value: true });
    util$1.isQuotedPost = isQuotedPost;
    util$1.isQuotedPostWithMedia = isQuotedPostWithMedia;
    util$1.interpretLabelValueDefinition = interpretLabelValueDefinition;
    util$1.interpretLabelValueDefinitions = interpretLabelValueDefinitions;
    const client_1 = requireClient();
    const util_1 = requireUtil$5();
    function isQuotedPost(embed) {
      return Boolean(embed && client_1.AppBskyEmbedRecord.isView(embed));
    }
    function isQuotedPostWithMedia(embed) {
      return Boolean(embed && client_1.AppBskyEmbedRecordWithMedia.isView(embed));
    }
    function interpretLabelValueDefinition(def, definedBy) {
      const behaviors = {
        account: {},
        profile: {},
        content: {}
      };
      const alertOrInform = def.severity === "alert" ? "alert" : def.severity === "inform" ? "inform" : void 0;
      if (def.blurs === "content") {
        behaviors.account.profileList = alertOrInform;
        behaviors.account.profileView = alertOrInform;
        behaviors.account.contentList = "blur";
        behaviors.account.contentView = def.adultOnly ? "blur" : alertOrInform;
        behaviors.profile.profileList = alertOrInform;
        behaviors.profile.profileView = alertOrInform;
        behaviors.content.contentList = "blur";
        behaviors.content.contentView = def.adultOnly ? "blur" : alertOrInform;
      } else if (def.blurs === "media") {
        behaviors.account.profileList = alertOrInform;
        behaviors.account.profileView = alertOrInform;
        behaviors.account.avatar = "blur";
        behaviors.account.banner = "blur";
        behaviors.profile.profileList = alertOrInform;
        behaviors.profile.profileView = alertOrInform;
        behaviors.profile.avatar = "blur";
        behaviors.profile.banner = "blur";
        behaviors.content.contentMedia = "blur";
      } else if (def.blurs === "none") {
        behaviors.account.profileList = alertOrInform;
        behaviors.account.profileView = alertOrInform;
        behaviors.account.contentList = alertOrInform;
        behaviors.account.contentView = alertOrInform;
        behaviors.profile.profileList = alertOrInform;
        behaviors.profile.profileView = alertOrInform;
        behaviors.content.contentList = alertOrInform;
        behaviors.content.contentView = alertOrInform;
      }
      let defaultSetting = "warn";
      if (def.defaultSetting === "hide" || def.defaultSetting === "ignore") {
        defaultSetting = def.defaultSetting;
      }
      const flags = ["no-self"];
      if (def.adultOnly) {
        flags.push("adult");
      }
      return {
        ...def,
        definedBy,
        configurable: true,
        defaultSetting,
        flags,
        behaviors
      };
    }
    function interpretLabelValueDefinitions(labelerView) {
      return (labelerView.policies?.labelValueDefinitions || []).filter((0, util_1.asPredicate)(client_1.ComAtprotoLabelDefs.validateLabelValueDefinition)).map((labelValDef) => interpretLabelValueDefinition(labelValDef, labelerView.creator.did));
    }
    return util$1;
  }
  var hasRequiredModeration;
  function requireModeration() {
    if (hasRequiredModeration) return moderation;
    hasRequiredModeration = 1;
    (function(exports) {
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.interpretLabelValueDefinitions = exports.interpretLabelValueDefinition = exports.hasMutedWord = exports.ModerationDecision = exports.ModerationUI = void 0;
      exports.moderateProfile = moderateProfile;
      exports.moderatePost = moderatePost;
      exports.moderateNotification = moderateNotification;
      exports.moderateFeedGenerator = moderateFeedGenerator;
      exports.moderateUserList = moderateUserList;
      const decision_1 = requireDecision();
      const account_1 = requireAccount();
      const feed_generator_1 = requireFeedGenerator();
      const notification_1 = requireNotification();
      const post_1 = requirePost();
      const profile_1 = requireProfile();
      const user_list_1 = requireUserList();
      var ui_1 = requireUi();
      Object.defineProperty(exports, "ModerationUI", { enumerable: true, get: function() {
        return ui_1.ModerationUI;
      } });
      var decision_2 = requireDecision();
      Object.defineProperty(exports, "ModerationDecision", { enumerable: true, get: function() {
        return decision_2.ModerationDecision;
      } });
      var mutewords_1 = requireMutewords();
      Object.defineProperty(exports, "hasMutedWord", { enumerable: true, get: function() {
        return mutewords_1.hasMutedWord;
      } });
      var util_1 = requireUtil$1();
      Object.defineProperty(exports, "interpretLabelValueDefinition", { enumerable: true, get: function() {
        return util_1.interpretLabelValueDefinition;
      } });
      Object.defineProperty(exports, "interpretLabelValueDefinitions", { enumerable: true, get: function() {
        return util_1.interpretLabelValueDefinitions;
      } });
      function moderateProfile(subject, opts) {
        return decision_1.ModerationDecision.merge((0, account_1.decideAccount)(subject, opts), (0, profile_1.decideProfile)(subject, opts));
      }
      function moderatePost(subject, opts) {
        return (0, post_1.decidePost)(subject, opts);
      }
      function moderateNotification(subject, opts) {
        return (0, notification_1.decideNotification)(subject, opts);
      }
      function moderateFeedGenerator(subject, opts) {
        return (0, feed_generator_1.decideFeedGenerator)(subject, opts);
      }
      function moderateUserList(subject, opts) {
        return (0, user_list_1.decideUserList)(subject, opts);
      }
    })(moderation);
    return moderation;
  }
  var mocker = {};
  var hasRequiredMocker;
  function requireMocker() {
    if (hasRequiredMocker) return mocker;
    hasRequiredMocker = 1;
    Object.defineProperty(mocker, "__esModule", { value: true });
    mocker.mock = void 0;
    const FAKE_CID = "bafyreiclp443lavogvhj3d2ob2cxbfuscni2k5jk7bebjzg7khl3esabwq";
    mocker.mock = {
      post({ text, facets, reply, embed }) {
        return {
          $type: "app.bsky.feed.post",
          text,
          facets,
          reply,
          embed,
          langs: ["en"],
          createdAt: (/* @__PURE__ */ new Date()).toISOString()
        };
      },
      postView({ record: record2, author, embed, replyCount, repostCount, likeCount, viewer, labels: labels2 }) {
        return {
          $type: "app.bsky.feed.defs#postView",
          uri: `at://${author.did}/app.bsky.feed.post/fake`,
          cid: FAKE_CID,
          author,
          record: record2,
          embed,
          replyCount,
          repostCount,
          likeCount,
          indexedAt: (/* @__PURE__ */ new Date()).toISOString(),
          viewer,
          labels: labels2
        };
      },
      embedRecordView({ record: record2, author, labels: labels2 }) {
        return {
          $type: "app.bsky.embed.record#view",
          record: {
            $type: "app.bsky.embed.record#viewRecord",
            uri: `at://${author.did}/app.bsky.feed.post/fake`,
            cid: FAKE_CID,
            author,
            value: record2,
            labels: labels2,
            indexedAt: (/* @__PURE__ */ new Date()).toISOString()
          }
        };
      },
      profileViewBasic({ handle: handle2, displayName, description, viewer, labels: labels2 }) {
        return {
          did: `did:web:${handle2}`,
          handle: handle2,
          displayName,
          // @ts-expect-error technically not in ProfileViewBasic but useful in some cases
          description,
          viewer,
          labels: labels2
        };
      },
      actorViewerState({ muted, mutedByList, blockedBy, blocking, blockingByList, following, followedBy }) {
        return {
          muted,
          mutedByList,
          blockedBy,
          blocking,
          blockingByList,
          following,
          followedBy
        };
      },
      listViewBasic({ name }) {
        return {
          uri: "at://did:plc:fake/app.bsky.graph.list/fake",
          cid: FAKE_CID,
          name,
          purpose: "app.bsky.graph.defs#modlist",
          indexedAt: (/* @__PURE__ */ new Date()).toISOString()
        };
      },
      replyNotification({ author, record: record2, labels: labels2 }) {
        return {
          uri: `at://${author.did}/app.bsky.feed.post/fake`,
          cid: FAKE_CID,
          author,
          reason: "reply",
          reasonSubject: `at://${author.did}/app.bsky.feed.post/fake-parent`,
          record: record2,
          isRead: false,
          indexedAt: (/* @__PURE__ */ new Date()).toISOString(),
          labels: labels2
        };
      },
      followNotification({ author, subjectDid, labels: labels2 }) {
        return {
          uri: `at://${author.did}/app.bsky.graph.follow/fake`,
          cid: FAKE_CID,
          author,
          reason: "follow",
          record: {
            $type: "app.bsky.graph.follow",
            createdAt: (/* @__PURE__ */ new Date()).toISOString(),
            subject: subjectDid
          },
          isRead: false,
          indexedAt: (/* @__PURE__ */ new Date()).toISOString(),
          labels: labels2
        };
      },
      label({ val, uri, src: src2 }) {
        return {
          src: src2 || "did:plc:fake-labeler",
          uri,
          val,
          cts: (/* @__PURE__ */ new Date()).toISOString()
        };
      }
    };
    return mocker;
  }
  var agent = {};
  var AwaitLock = {};
  var hasRequiredAwaitLock;
  function requireAwaitLock() {
    if (hasRequiredAwaitLock) return AwaitLock;
    hasRequiredAwaitLock = 1;
    var __classPrivateFieldGet = AwaitLock && AwaitLock.__classPrivateFieldGet || function(receiver, state2, kind, f) {
      if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
      if (typeof state2 === "function" ? receiver !== state2 || !f : !state2.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state2.get(receiver);
    };
    var __classPrivateFieldSet = AwaitLock && AwaitLock.__classPrivateFieldSet || function(receiver, state2, value, kind, f) {
      if (kind === "m") throw new TypeError("Private method is not writable");
      if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
      if (typeof state2 === "function" ? receiver !== state2 || !f : !state2.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state2.set(receiver, value), value;
    };
    var _AwaitLock_acquired, _AwaitLock_waitingResolvers;
    Object.defineProperty(AwaitLock, "__esModule", { value: true });
    let AwaitLock$1 = class AwaitLock {
      constructor() {
        _AwaitLock_acquired.set(this, false);
        _AwaitLock_waitingResolvers.set(this, /* @__PURE__ */ new Set());
      }
      /**
       * Whether the lock is currently acquired or not. Accessing this property does not affect the
       * status of the lock.
       */
      get acquired() {
        return __classPrivateFieldGet(this, _AwaitLock_acquired, "f");
      }
      /**
       * Acquires the lock, waiting if necessary for it to become free if it is already locked. The
       * returned promise is fulfilled once the lock is acquired.
       *
       * A timeout (in milliseconds) may be optionally provided. If the lock cannot be acquired before
       * the timeout elapses, the returned promise is rejected with an error. The behavior of invalid
       * timeout values depends on how `setTimeout` handles those values.
       *
       * After acquiring the lock, you **must** call `release` when you are done with it.
       */
      acquireAsync({ timeout } = {}) {
        if (!__classPrivateFieldGet(this, _AwaitLock_acquired, "f")) {
          __classPrivateFieldSet(this, _AwaitLock_acquired, true, "f");
          return Promise.resolve();
        }
        if (timeout == null) {
          return new Promise((resolve) => {
            __classPrivateFieldGet(this, _AwaitLock_waitingResolvers, "f").add(resolve);
          });
        }
        let resolver;
        let timer;
        return Promise.race([
          new Promise((resolve) => {
            resolver = () => {
              clearTimeout(timer);
              resolve();
            };
            __classPrivateFieldGet(this, _AwaitLock_waitingResolvers, "f").add(resolver);
          }),
          new Promise((_, reject) => {
            timer = setTimeout(() => {
              __classPrivateFieldGet(this, _AwaitLock_waitingResolvers, "f").delete(resolver);
              reject(new Error(`Timed out waiting for lock`));
            }, timeout);
          })
        ]);
      }
      /**
       * Acquires the lock if it is free and otherwise returns immediately without waiting. Returns
       * `true` if the lock was free and is now acquired, and `false` otherwise.
       *
       * This method differs from calling `acquireAsync` with a zero-millisecond timeout in that it runs
       * synchronously without waiting for the JavaScript task queue.
       */
      tryAcquire() {
        if (!__classPrivateFieldGet(this, _AwaitLock_acquired, "f")) {
          __classPrivateFieldSet(this, _AwaitLock_acquired, true, "f");
          return true;
        }
        return false;
      }
      /**
       * Releases the lock and gives it to the next waiting acquirer, if there is one. Each acquirer
       * must release the lock exactly once.
       */
      release() {
        if (!__classPrivateFieldGet(this, _AwaitLock_acquired, "f")) {
          throw new Error(`Cannot release an unacquired lock`);
        }
        if (__classPrivateFieldGet(this, _AwaitLock_waitingResolvers, "f").size > 0) {
          const [resolve] = __classPrivateFieldGet(this, _AwaitLock_waitingResolvers, "f");
          __classPrivateFieldGet(this, _AwaitLock_waitingResolvers, "f").delete(resolve);
          resolve();
        } else {
          __classPrivateFieldSet(this, _AwaitLock_acquired, false, "f");
        }
      }
    };
    AwaitLock.default = AwaitLock$1;
    _AwaitLock_acquired = /* @__PURE__ */ new WeakMap(), _AwaitLock_waitingResolvers = /* @__PURE__ */ new WeakMap();
    return AwaitLock;
  }
  var predicate = {};
  var hasRequiredPredicate;
  function requirePredicate() {
    if (hasRequiredPredicate) return predicate;
    hasRequiredPredicate = 1;
    Object.defineProperty(predicate, "__esModule", { value: true });
    predicate.isValidThreadViewPref = predicate.isValidSavedFeedsPrefV2 = predicate.isValidSavedFeedsPref = predicate.isValidPostInteractionSettingsPref = predicate.isValidPersonalDetailsPref = predicate.isValidMutedWordsPref = predicate.isValidLabelersPref = predicate.isValidInterestsPref = predicate.isValidHiddenPostsPref = predicate.isValidFeedViewPref = predicate.isValidContentLabelPref = predicate.isValidBskyAppStatePref = predicate.isValidAdultContentPref = predicate.isValidProfile = void 0;
    const index_1 = requireClient();
    const util_1 = requireUtil$5();
    predicate.isValidProfile = (0, util_1.asPredicate)(index_1.AppBskyActorProfile.validateRecord);
    predicate.isValidAdultContentPref = (0, util_1.asPredicate)(index_1.AppBskyActorDefs.validateAdultContentPref);
    predicate.isValidBskyAppStatePref = (0, util_1.asPredicate)(index_1.AppBskyActorDefs.validateBskyAppStatePref);
    predicate.isValidContentLabelPref = (0, util_1.asPredicate)(index_1.AppBskyActorDefs.validateContentLabelPref);
    predicate.isValidFeedViewPref = (0, util_1.asPredicate)(index_1.AppBskyActorDefs.validateFeedViewPref);
    predicate.isValidHiddenPostsPref = (0, util_1.asPredicate)(index_1.AppBskyActorDefs.validateHiddenPostsPref);
    predicate.isValidInterestsPref = (0, util_1.asPredicate)(index_1.AppBskyActorDefs.validateInterestsPref);
    predicate.isValidLabelersPref = (0, util_1.asPredicate)(index_1.AppBskyActorDefs.validateLabelersPref);
    predicate.isValidMutedWordsPref = (0, util_1.asPredicate)(index_1.AppBskyActorDefs.validateMutedWordsPref);
    predicate.isValidPersonalDetailsPref = (0, util_1.asPredicate)(index_1.AppBskyActorDefs.validatePersonalDetailsPref);
    predicate.isValidPostInteractionSettingsPref = (0, util_1.asPredicate)(index_1.AppBskyActorDefs.validatePostInteractionSettingsPref);
    predicate.isValidSavedFeedsPref = (0, util_1.asPredicate)(index_1.AppBskyActorDefs.validateSavedFeedsPref);
    predicate.isValidSavedFeedsPrefV2 = (0, util_1.asPredicate)(index_1.AppBskyActorDefs.validateSavedFeedsPrefV2);
    predicate.isValidThreadViewPref = (0, util_1.asPredicate)(index_1.AppBskyActorDefs.validateThreadViewPref);
    return predicate;
  }
  var hasRequiredAgent;
  function requireAgent() {
    if (hasRequiredAgent) return agent;
    hasRequiredAgent = 1;
    var __createBinding = agent && agent.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = agent && agent.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = agent && agent.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __classPrivateFieldGet = agent && agent.__classPrivateFieldGet || function(receiver, state2, kind, f) {
      if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
      if (typeof state2 === "function" ? receiver !== state2 || !f : !state2.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state2.get(receiver);
    };
    var __importDefault = agent && agent.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var _Agent_prefsLock;
    Object.defineProperty(agent, "__esModule", { value: true });
    agent.Agent = void 0;
    const await_lock_1 = __importDefault(requireAwaitLock());
    const common_web_1 = requireDist$4();
    const syntax_1 = requireDist$5();
    const xrpc_1 = requireDist$1();
    const index_1 = requireClient();
    const lexicons_1 = requireLexicons();
    const const_1 = require_const();
    const moderation_1 = requireModeration();
    const labels_1 = requireLabels();
    const predicate2 = __importStar(requirePredicate());
    const util_1 = requireUtil$4();
    const FEED_VIEW_PREF_DEFAULTS = {
      hideReplies: false,
      hideRepliesByUnfollowed: true,
      hideRepliesByLikeCount: 0,
      hideReposts: false,
      hideQuotePosts: false
    };
    const THREAD_VIEW_PREF_DEFAULTS = {
      sort: "hotness",
      prioritizeFollowedUsers: true
    };
    class Agent extends xrpc_1.XrpcClient {
      /**
       * Configures the Agent (or its sub classes) globally.
       */
      static configure(opts) {
        if (opts.appLabelers) {
          this.appLabelers = opts.appLabelers.map(util_1.asDid);
        }
      }
      /** @deprecated use `this` instead */
      get xrpc() {
        return this;
      }
      constructor(options) {
        const sessionManager = typeof options === "string" || options instanceof URL ? {
          did: void 0,
          fetchHandler: (0, xrpc_1.buildFetchHandler)(options)
        } : options;
        super((url, init) => {
          const headers = new Headers(init?.headers);
          if (this.proxy && !headers.has("atproto-proxy")) {
            headers.set("atproto-proxy", this.proxy);
          }
          headers.set("atproto-accept-labelers", [
            ...this.appLabelers.map((l) => `${l};redact`),
            ...this.labelers,
            headers.get("atproto-accept-labelers")?.trim()
          ].filter(Boolean).join(", "));
          return this.sessionManager.fetchHandler(url, { ...init, headers });
        }, lexicons_1.schemas);
        Object.defineProperty(this, "com", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: new index_1.ComNS(this)
        });
        Object.defineProperty(this, "app", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: new index_1.AppNS(this)
        });
        Object.defineProperty(this, "chat", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: new index_1.ChatNS(this)
        });
        Object.defineProperty(this, "tools", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: new index_1.ToolsNS(this)
        });
        Object.defineProperty(this, "sessionManager", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "labelers", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: []
        });
        Object.defineProperty(this, "proxy", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "uploadBlob", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: (data, opts) => this.com.atproto.repo.uploadBlob(data, opts)
        });
        Object.defineProperty(this, "resolveHandle", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: (params, opts) => this.com.atproto.identity.resolveHandle(params, opts)
        });
        Object.defineProperty(this, "updateHandle", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: (data, opts) => this.com.atproto.identity.updateHandle(data, opts)
        });
        Object.defineProperty(this, "createModerationReport", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: (data, opts) => this.com.atproto.moderation.createReport(data, opts)
        });
        Object.defineProperty(this, "getTimeline", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: (params, opts) => this.app.bsky.feed.getTimeline(params, opts)
        });
        Object.defineProperty(this, "getAuthorFeed", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: (params, opts) => this.app.bsky.feed.getAuthorFeed(params, opts)
        });
        Object.defineProperty(this, "getActorLikes", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: (params, opts) => this.app.bsky.feed.getActorLikes(params, opts)
        });
        Object.defineProperty(this, "getPostThread", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: (params, opts) => this.app.bsky.feed.getPostThread(params, opts)
        });
        Object.defineProperty(this, "getPost", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: (params) => this.app.bsky.feed.post.get(params)
        });
        Object.defineProperty(this, "getPosts", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: (params, opts) => this.app.bsky.feed.getPosts(params, opts)
        });
        Object.defineProperty(this, "getLikes", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: (params, opts) => this.app.bsky.feed.getLikes(params, opts)
        });
        Object.defineProperty(this, "getRepostedBy", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: (params, opts) => this.app.bsky.feed.getRepostedBy(params, opts)
        });
        Object.defineProperty(this, "getFollows", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: (params, opts) => this.app.bsky.graph.getFollows(params, opts)
        });
        Object.defineProperty(this, "getFollowers", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: (params, opts) => this.app.bsky.graph.getFollowers(params, opts)
        });
        Object.defineProperty(this, "getProfile", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: (params, opts) => this.app.bsky.actor.getProfile(params, opts)
        });
        Object.defineProperty(this, "getProfiles", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: (params, opts) => this.app.bsky.actor.getProfiles(params, opts)
        });
        Object.defineProperty(this, "getSuggestions", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: (params, opts) => this.app.bsky.actor.getSuggestions(params, opts)
        });
        Object.defineProperty(this, "searchActors", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: (params, opts) => this.app.bsky.actor.searchActors(params, opts)
        });
        Object.defineProperty(this, "searchActorsTypeahead", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: (params, opts) => this.app.bsky.actor.searchActorsTypeahead(params, opts)
        });
        Object.defineProperty(this, "listNotifications", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: (params, opts) => this.app.bsky.notification.listNotifications(params, opts)
        });
        Object.defineProperty(this, "countUnreadNotifications", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: (params, opts) => this.app.bsky.notification.getUnreadCount(params, opts)
        });
        Object.defineProperty(this, "getLabelers", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: (params, opts) => this.app.bsky.labeler.getServices(params, opts)
        });
        _Agent_prefsLock.set(
          this,
          new await_lock_1.default()
          /**
           * This function updates the preferences of a user and allows for a callback function to be executed
           * before the update.
           * @param cb - cb is a callback function that takes in a single parameter of type
           * AppBskyActorDefs.Preferences and returns either a boolean or void. This callback function is used to
           * update the preferences of the user. The function is called with the current preferences as an
           * argument and if the callback returns false, the preferences are not updated.
           */
        );
        this.sessionManager = sessionManager;
      }
      //#region Cloning utilities
      clone() {
        return this.copyInto(new Agent(this.sessionManager));
      }
      copyInto(inst) {
        inst.configureLabelers(this.labelers);
        inst.configureProxy(this.proxy ?? null);
        inst.clearHeaders();
        for (const [key, value] of this.headers)
          inst.setHeader(key, value);
        return inst;
      }
      withProxy(serviceType, did2) {
        const inst = this.clone();
        inst.configureProxy(`${(0, util_1.asDid)(did2)}#${serviceType}`);
        return inst;
      }
      //#endregion
      //#region ATPROTO labelers configuration utilities
      /**
       * The labelers statically configured on the class of the current instance.
       */
      get appLabelers() {
        return this.constructor.appLabelers;
      }
      configureLabelers(labelerDids) {
        this.labelers = labelerDids.map(util_1.asDid);
      }
      /** @deprecated use {@link configureLabelers} instead */
      configureLabelersHeader(labelerDids) {
        this.configureLabelers(labelerDids.filter(util_1.isDid));
      }
      configureProxy(value) {
        if (value === null)
          this.proxy = void 0;
        else if ((0, util_1.isDid)(value))
          this.proxy = value;
        else
          throw new TypeError("Invalid proxy DID");
      }
      /** @deprecated use {@link configureProxy} instead */
      configureProxyHeader(serviceType, did2) {
        if ((0, util_1.isDid)(did2))
          this.configureProxy(`${did2}#${serviceType}`);
      }
      //#endregion
      //#region Session management
      /**
       * Get the authenticated user's DID, if any.
       */
      get did() {
        return this.sessionManager.did;
      }
      /** @deprecated Use {@link Agent.assertDid} instead */
      get accountDid() {
        return this.assertDid;
      }
      /**
       * Get the authenticated user's DID, or throw an error if not authenticated.
       */
      get assertDid() {
        this.assertAuthenticated();
        return this.did;
      }
      /**
       * Assert that the user is authenticated.
       */
      assertAuthenticated() {
        if (!this.did)
          throw new Error("Not logged in");
      }
      //#endregion
      /** @deprecated use "this" instead */
      get api() {
        return this;
      }
      async getLabelDefinitions(prefs) {
        const dids = [...this.appLabelers];
        if (isBskyPrefs(prefs)) {
          dids.push(...prefs.moderationPrefs.labelers.map((l) => l.did));
        } else if (isModPrefs(prefs)) {
          dids.push(...prefs.labelers.map((l) => l.did));
        } else {
          dids.push(...prefs);
        }
        const labelers = await this.getLabelers({
          dids,
          detailed: true
        });
        const labelDefs = {};
        if (labelers.data) {
          for (const labeler of labelers.data.views) {
            labelDefs[labeler.creator.did] = (0, moderation_1.interpretLabelValueDefinitions)(labeler);
          }
        }
        return labelDefs;
      }
      async post(record2) {
        record2.createdAt || (record2.createdAt = (/* @__PURE__ */ new Date()).toISOString());
        return this.app.bsky.feed.post.create({ repo: this.accountDid }, record2);
      }
      async deletePost(postUri) {
        this.assertAuthenticated();
        const postUrip = new syntax_1.AtUri(postUri);
        return this.app.bsky.feed.post.delete({
          repo: postUrip.hostname,
          rkey: postUrip.rkey
        });
      }
      async like(uri, cid2) {
        return this.app.bsky.feed.like.create({ repo: this.accountDid }, {
          subject: { uri, cid: cid2 },
          createdAt: (/* @__PURE__ */ new Date()).toISOString()
        });
      }
      async deleteLike(likeUri) {
        this.assertAuthenticated();
        const likeUrip = new syntax_1.AtUri(likeUri);
        return this.app.bsky.feed.like.delete({
          repo: likeUrip.hostname,
          rkey: likeUrip.rkey
        });
      }
      async repost(uri, cid2) {
        return this.app.bsky.feed.repost.create({ repo: this.accountDid }, {
          subject: { uri, cid: cid2 },
          createdAt: (/* @__PURE__ */ new Date()).toISOString()
        });
      }
      async deleteRepost(repostUri) {
        this.assertAuthenticated();
        const repostUrip = new syntax_1.AtUri(repostUri);
        return this.app.bsky.feed.repost.delete({
          repo: repostUrip.hostname,
          rkey: repostUrip.rkey
        });
      }
      async follow(subjectDid) {
        return this.app.bsky.graph.follow.create({ repo: this.accountDid }, {
          subject: subjectDid,
          createdAt: (/* @__PURE__ */ new Date()).toISOString()
        });
      }
      async deleteFollow(followUri) {
        this.assertAuthenticated();
        const followUrip = new syntax_1.AtUri(followUri);
        return this.app.bsky.graph.follow.delete({
          repo: followUrip.hostname,
          rkey: followUrip.rkey
        });
      }
      /**
       * @note: Using this method will reset the whole profile record if it
       * previously contained invalid values (wrt to the profile lexicon).
       */
      async upsertProfile(updateFn) {
        const upsert = async () => {
          const repo = this.assertDid;
          const collection = "app.bsky.actor.profile";
          const existing = await this.com.atproto.repo.getRecord({ repo, collection, rkey: "self" }).catch((_) => void 0);
          const existingRecord = existing && predicate2.isValidProfile(existing.data.value) ? existing.data.value : void 0;
          const updated = await updateFn(existingRecord);
          const validation2 = index_1.AppBskyActorProfile.validateRecord({
            $type: collection,
            ...updated
          });
          if (!validation2.success) {
            throw validation2.error;
          }
          await this.com.atproto.repo.putRecord({
            repo,
            collection,
            rkey: "self",
            record: validation2.value,
            swapRecord: existing?.data.cid || null
          });
        };
        return (0, common_web_1.retry)(upsert, {
          maxRetries: 5,
          retryable: (e) => e instanceof index_1.ComAtprotoRepoPutRecord.InvalidSwapError
        });
      }
      async mute(actor) {
        return this.app.bsky.graph.muteActor({ actor });
      }
      async unmute(actor) {
        return this.app.bsky.graph.unmuteActor({ actor });
      }
      async muteModList(uri) {
        return this.app.bsky.graph.muteActorList({ list: uri });
      }
      async unmuteModList(uri) {
        return this.app.bsky.graph.unmuteActorList({ list: uri });
      }
      async blockModList(uri) {
        return this.app.bsky.graph.listblock.create({ repo: this.accountDid }, {
          subject: uri,
          createdAt: (/* @__PURE__ */ new Date()).toISOString()
        });
      }
      async unblockModList(uri) {
        const repo = this.accountDid;
        const listInfo = await this.app.bsky.graph.getList({
          list: uri,
          limit: 1
        });
        const blocked = listInfo.data.list.viewer?.blocked;
        if (blocked) {
          const { rkey } = new syntax_1.AtUri(blocked);
          return this.app.bsky.graph.listblock.delete({
            repo,
            rkey
          });
        }
      }
      async updateSeenNotifications(seenAt = (/* @__PURE__ */ new Date()).toISOString()) {
        return this.app.bsky.notification.updateSeen({ seenAt });
      }
      async getPreferences() {
        const prefs = {
          feeds: {
            saved: void 0,
            pinned: void 0
          },
          // @ts-ignore populating below
          savedFeeds: void 0,
          feedViewPrefs: {
            home: {
              ...FEED_VIEW_PREF_DEFAULTS
            }
          },
          threadViewPrefs: { ...THREAD_VIEW_PREF_DEFAULTS },
          moderationPrefs: {
            adultContentEnabled: false,
            labels: { ...labels_1.DEFAULT_LABEL_SETTINGS },
            labelers: this.appLabelers.map((did2) => ({
              did: did2,
              labels: {}
            })),
            mutedWords: [],
            hiddenPosts: []
          },
          birthDate: void 0,
          interests: {
            tags: []
          },
          bskyAppState: {
            queuedNudges: [],
            activeProgressGuide: void 0,
            nuxs: []
          },
          postInteractionSettings: {
            threadgateAllowRules: void 0,
            postgateEmbeddingRules: void 0
          }
        };
        const res = await this.app.bsky.actor.getPreferences({});
        const labelPrefs = [];
        for (const pref of res.data.preferences) {
          if (predicate2.isValidAdultContentPref(pref)) {
            prefs.moderationPrefs.adultContentEnabled = pref.enabled;
          } else if (predicate2.isValidContentLabelPref(pref)) {
            const adjustedPref = adjustLegacyContentLabelPref(pref);
            labelPrefs.push(adjustedPref);
          } else if (predicate2.isValidLabelersPref(pref)) {
            prefs.moderationPrefs.labelers = this.appLabelers.map((did2) => ({ did: did2, labels: {} })).concat(pref.labelers.map((labeler) => ({
              ...labeler,
              labels: {}
            })));
          } else if (predicate2.isValidSavedFeedsPrefV2(pref)) {
            prefs.savedFeeds = pref.items;
          } else if (predicate2.isValidSavedFeedsPref(pref)) {
            prefs.feeds.saved = pref.saved;
            prefs.feeds.pinned = pref.pinned;
          } else if (predicate2.isValidPersonalDetailsPref(pref)) {
            if (pref.birthDate) {
              prefs.birthDate = new Date(pref.birthDate);
            }
          } else if (predicate2.isValidFeedViewPref(pref)) {
            const { $type: _, feed, ...v } = pref;
            prefs.feedViewPrefs[feed] = { ...FEED_VIEW_PREF_DEFAULTS, ...v };
          } else if (predicate2.isValidThreadViewPref(pref)) {
            const { $type: _, ...v } = pref;
            prefs.threadViewPrefs = { ...prefs.threadViewPrefs, ...v };
          } else if (predicate2.isValidInterestsPref(pref)) {
            const { $type: _, ...v } = pref;
            prefs.interests = { ...prefs.interests, ...v };
          } else if (predicate2.isValidMutedWordsPref(pref)) {
            prefs.moderationPrefs.mutedWords = pref.items;
            if (prefs.moderationPrefs.mutedWords.length) {
              prefs.moderationPrefs.mutedWords = prefs.moderationPrefs.mutedWords.map((word) => {
                word.actorTarget = word.actorTarget || "all";
                return word;
              });
            }
          } else if (predicate2.isValidHiddenPostsPref(pref)) {
            prefs.moderationPrefs.hiddenPosts = pref.items;
          } else if (predicate2.isValidBskyAppStatePref(pref)) {
            prefs.bskyAppState.queuedNudges = pref.queuedNudges || [];
            prefs.bskyAppState.activeProgressGuide = pref.activeProgressGuide;
            prefs.bskyAppState.nuxs = pref.nuxs || [];
          } else if (predicate2.isValidPostInteractionSettingsPref(pref)) {
            prefs.postInteractionSettings.threadgateAllowRules = pref.threadgateAllowRules;
            prefs.postInteractionSettings.postgateEmbeddingRules = pref.postgateEmbeddingRules;
          }
        }
        if (prefs.savedFeeds == null) {
          const { saved, pinned } = prefs.feeds;
          if (saved && pinned) {
            const uniqueMigratedSavedFeeds = /* @__PURE__ */ new Map();
            uniqueMigratedSavedFeeds.set("timeline", {
              id: common_web_1.TID.nextStr(),
              type: "timeline",
              value: "following",
              pinned: true
            });
            for (const uri of pinned) {
              const type = (0, util_1.getSavedFeedType)(uri);
              if (type === "unknown")
                continue;
              uniqueMigratedSavedFeeds.set(uri, {
                id: common_web_1.TID.nextStr(),
                type,
                value: uri,
                pinned: true
              });
            }
            for (const uri of saved) {
              if (!uniqueMigratedSavedFeeds.has(uri)) {
                const type = (0, util_1.getSavedFeedType)(uri);
                if (type === "unknown")
                  continue;
                uniqueMigratedSavedFeeds.set(uri, {
                  id: common_web_1.TID.nextStr(),
                  type,
                  value: uri,
                  pinned: false
                });
              }
            }
            prefs.savedFeeds = Array.from(uniqueMigratedSavedFeeds.values());
          } else {
            prefs.savedFeeds = [
              {
                id: common_web_1.TID.nextStr(),
                type: "timeline",
                value: "following",
                pinned: true
              }
            ];
          }
          await this.overwriteSavedFeeds(prefs.savedFeeds);
        }
        for (const pref of labelPrefs) {
          if (pref.labelerDid) {
            const labeler = prefs.moderationPrefs.labelers.find((labeler2) => labeler2.did === pref.labelerDid);
            if (!labeler)
              continue;
            labeler.labels[pref.label] = pref.visibility;
          } else {
            prefs.moderationPrefs.labels[pref.label] = pref.visibility;
          }
        }
        prefs.moderationPrefs.labels = remapLegacyLabels(prefs.moderationPrefs.labels);
        this.configureLabelers(prefsArrayToLabelerDids(res.data.preferences));
        return prefs;
      }
      async overwriteSavedFeeds(savedFeeds) {
        savedFeeds.forEach(util_1.validateSavedFeed);
        const uniqueSavedFeeds = /* @__PURE__ */ new Map();
        savedFeeds.forEach((feed) => {
          if (uniqueSavedFeeds.has(feed.id)) {
            uniqueSavedFeeds.delete(feed.id);
          }
          uniqueSavedFeeds.set(feed.id, feed);
        });
        return this.updateSavedFeedsV2Preferences(() => Array.from(uniqueSavedFeeds.values()));
      }
      async updateSavedFeeds(savedFeedsToUpdate) {
        savedFeedsToUpdate.map(util_1.validateSavedFeed);
        return this.updateSavedFeedsV2Preferences((savedFeeds) => {
          return savedFeeds.map((savedFeed) => {
            const updatedVersion = savedFeedsToUpdate.find((updated) => savedFeed.id === updated.id);
            if (updatedVersion) {
              return {
                ...savedFeed,
                // only update pinned
                pinned: updatedVersion.pinned
              };
            }
            return savedFeed;
          });
        });
      }
      async addSavedFeeds(savedFeeds) {
        const toSave = savedFeeds.map((f) => ({
          ...f,
          id: common_web_1.TID.nextStr()
        }));
        toSave.forEach(util_1.validateSavedFeed);
        return this.updateSavedFeedsV2Preferences((savedFeeds2) => [
          ...savedFeeds2,
          ...toSave
        ]);
      }
      async removeSavedFeeds(ids) {
        return this.updateSavedFeedsV2Preferences((savedFeeds) => [
          ...savedFeeds.filter((feed) => !ids.find((id) => feed.id === id))
        ]);
      }
      /**
       * @deprecated use `overwriteSavedFeeds`
       */
      async setSavedFeeds(saved, pinned) {
        return this.updateFeedPreferences(() => ({
          saved,
          pinned
        }));
      }
      /**
       * @deprecated use `addSavedFeeds`
       */
      async addSavedFeed(v) {
        return this.updateFeedPreferences((saved, pinned) => ({
          saved: [...saved.filter((uri) => uri !== v), v],
          pinned
        }));
      }
      /**
       * @deprecated use `removeSavedFeeds`
       */
      async removeSavedFeed(v) {
        return this.updateFeedPreferences((saved, pinned) => ({
          saved: saved.filter((uri) => uri !== v),
          pinned: pinned.filter((uri) => uri !== v)
        }));
      }
      /**
       * @deprecated use `addSavedFeeds` or `updateSavedFeeds`
       */
      async addPinnedFeed(v) {
        return this.updateFeedPreferences((saved, pinned) => ({
          saved: [...saved.filter((uri) => uri !== v), v],
          pinned: [...pinned.filter((uri) => uri !== v), v]
        }));
      }
      /**
       * @deprecated use `updateSavedFeeds` or `removeSavedFeeds`
       */
      async removePinnedFeed(v) {
        return this.updateFeedPreferences((saved, pinned) => ({
          saved,
          pinned: pinned.filter((uri) => uri !== v)
        }));
      }
      async setAdultContentEnabled(v) {
        await this.updatePreferences((prefs) => {
          const adultContentPref = prefs.findLast(predicate2.isValidAdultContentPref) || {
            $type: "app.bsky.actor.defs#adultContentPref",
            enabled: v
          };
          adultContentPref.enabled = v;
          return prefs.filter((pref) => !index_1.AppBskyActorDefs.isAdultContentPref(pref)).concat(adultContentPref);
        });
      }
      async setContentLabelPref(key, value, labelerDid) {
        if (labelerDid) {
          (0, syntax_1.ensureValidDid)(labelerDid);
        }
        await this.updatePreferences((prefs) => {
          const labelPref = prefs.filter(predicate2.isValidContentLabelPref).findLast((pref) => pref.label === key && pref.labelerDid === labelerDid) || {
            $type: "app.bsky.actor.defs#contentLabelPref",
            label: key,
            labelerDid,
            visibility: value
          };
          labelPref.visibility = value;
          let legacyLabelPref;
          if (index_1.AppBskyActorDefs.isContentLabelPref(labelPref)) {
            if (!labelPref.labelerDid) {
              const legacyLabelValue = {
                "graphic-media": "gore",
                porn: "nsfw",
                sexual: "suggestive",
                // Protect against using toString, hasOwnProperty, etc. as a label:
                __proto__: null
              }[labelPref.label];
              if (legacyLabelValue) {
                legacyLabelPref = prefs.filter(predicate2.isValidContentLabelPref).findLast((pref) => pref.label === legacyLabelValue && pref.labelerDid === void 0) || {
                  $type: "app.bsky.actor.defs#contentLabelPref",
                  label: legacyLabelValue,
                  labelerDid: void 0,
                  visibility: value
                };
                legacyLabelPref.visibility = value;
              }
            }
          }
          return prefs.filter((pref) => !index_1.AppBskyActorDefs.isContentLabelPref(pref) || !(pref.label === key && pref.labelerDid === labelerDid)).concat(labelPref).filter((pref) => {
            if (!legacyLabelPref)
              return true;
            return !index_1.AppBskyActorDefs.isContentLabelPref(pref) || !(pref.label === legacyLabelPref.label && pref.labelerDid === void 0);
          }).concat(legacyLabelPref ? [legacyLabelPref] : []);
        });
      }
      async addLabeler(did2) {
        const prefs = await this.updatePreferences((prefs2) => {
          const labelersPref = prefs2.findLast(predicate2.isValidLabelersPref) || {
            $type: "app.bsky.actor.defs#labelersPref",
            labelers: []
          };
          if (!labelersPref.labelers.some((labeler) => labeler.did === did2)) {
            labelersPref.labelers.push({ did: did2 });
          }
          return prefs2.filter((pref) => !index_1.AppBskyActorDefs.isLabelersPref(pref)).concat(labelersPref);
        });
        this.configureLabelers(prefsArrayToLabelerDids(prefs));
      }
      async removeLabeler(did2) {
        const prefs = await this.updatePreferences((prefs2) => {
          const labelersPref = prefs2.findLast(predicate2.isValidLabelersPref) || {
            $type: "app.bsky.actor.defs#labelersPref",
            labelers: []
          };
          labelersPref.labelers = labelersPref.labelers.filter((l) => l.did !== did2);
          return prefs2.filter((pref) => !index_1.AppBskyActorDefs.isLabelersPref(pref)).concat(labelersPref);
        });
        this.configureLabelers(prefsArrayToLabelerDids(prefs));
      }
      async setPersonalDetails({ birthDate }) {
        await this.updatePreferences((prefs) => {
          const personalDetailsPref = prefs.findLast(predicate2.isValidPersonalDetailsPref) || {
            $type: "app.bsky.actor.defs#personalDetailsPref"
          };
          personalDetailsPref.birthDate = birthDate instanceof Date ? birthDate.toISOString() : birthDate;
          return prefs.filter((pref) => !index_1.AppBskyActorDefs.isPersonalDetailsPref(pref)).concat(personalDetailsPref);
        });
      }
      async setFeedViewPrefs(feed, pref) {
        await this.updatePreferences((prefs) => {
          const existing = prefs.filter(predicate2.isValidFeedViewPref).findLast((pref2) => pref2.feed === feed);
          return prefs.filter((p) => !index_1.AppBskyActorDefs.isFeedViewPref(p) || p.feed !== feed).concat({
            ...existing,
            ...pref,
            $type: "app.bsky.actor.defs#feedViewPref",
            feed
          });
        });
      }
      async setThreadViewPrefs(pref) {
        await this.updatePreferences((prefs) => {
          const existing = prefs.findLast(predicate2.isValidThreadViewPref);
          return prefs.filter((p) => !index_1.AppBskyActorDefs.isThreadViewPref(p)).concat({
            ...existing,
            ...pref,
            $type: "app.bsky.actor.defs#threadViewPref"
          });
        });
      }
      async setInterestsPref(pref) {
        await this.updatePreferences((prefs) => {
          const existing = prefs.findLast(predicate2.isValidInterestsPref);
          return prefs.filter((p) => !index_1.AppBskyActorDefs.isInterestsPref(p)).concat({
            ...existing,
            ...pref,
            $type: "app.bsky.actor.defs#interestsPref"
          });
        });
      }
      /**
       * Add a muted word to user preferences.
       */
      async addMutedWord(mutedWord) {
        const sanitizedValue = (0, util_1.sanitizeMutedWordValue)(mutedWord.value);
        if (!sanitizedValue)
          return;
        await this.updatePreferences((prefs) => {
          let mutedWordsPref = prefs.findLast(predicate2.isValidMutedWordsPref);
          const newMutedWord = {
            id: common_web_1.TID.nextStr(),
            value: sanitizedValue,
            targets: mutedWord.targets || [],
            actorTarget: mutedWord.actorTarget || "all",
            expiresAt: mutedWord.expiresAt || void 0
          };
          if (mutedWordsPref) {
            mutedWordsPref.items.push(newMutedWord);
            mutedWordsPref.items = migrateLegacyMutedWordsItems(mutedWordsPref.items);
          } else {
            mutedWordsPref = {
              $type: "app.bsky.actor.defs#mutedWordsPref",
              items: [newMutedWord]
            };
          }
          return prefs.filter((p) => !index_1.AppBskyActorDefs.isMutedWordsPref(p)).concat(mutedWordsPref);
        });
      }
      /**
       * Convenience method to add muted words to user preferences
       */
      async addMutedWords(newMutedWords) {
        await Promise.all(newMutedWords.map((word) => this.addMutedWord(word)));
      }
      /**
       * @deprecated use `addMutedWords` or `addMutedWord` instead
       */
      async upsertMutedWords(mutedWords) {
        await this.addMutedWords(mutedWords);
      }
      /**
       * Update a muted word in user preferences.
       */
      async updateMutedWord(mutedWord) {
        await this.updatePreferences((prefs) => {
          const mutedWordsPref = prefs.findLast(predicate2.isValidMutedWordsPref);
          if (mutedWordsPref) {
            mutedWordsPref.items = mutedWordsPref.items.map((existingItem) => {
              const match2 = matchMutedWord(existingItem, mutedWord);
              if (match2) {
                const updated = {
                  ...existingItem,
                  ...mutedWord
                };
                return {
                  id: existingItem.id || common_web_1.TID.nextStr(),
                  value: (0, util_1.sanitizeMutedWordValue)(updated.value) || existingItem.value,
                  targets: updated.targets || [],
                  actorTarget: updated.actorTarget || "all",
                  expiresAt: updated.expiresAt || void 0
                };
              } else {
                return existingItem;
              }
            });
            mutedWordsPref.items = migrateLegacyMutedWordsItems(mutedWordsPref.items);
            return prefs.filter((p) => !index_1.AppBskyActorDefs.isMutedWordsPref(p)).concat(mutedWordsPref);
          }
          return prefs;
        });
      }
      /**
       * Remove a muted word from user preferences.
       */
      async removeMutedWord(mutedWord) {
        await this.updatePreferences((prefs) => {
          const mutedWordsPref = prefs.findLast(predicate2.isValidMutedWordsPref);
          if (mutedWordsPref) {
            for (let i = 0; i < mutedWordsPref.items.length; i++) {
              const match2 = matchMutedWord(mutedWordsPref.items[i], mutedWord);
              if (match2) {
                mutedWordsPref.items.splice(i, 1);
                break;
              }
            }
            mutedWordsPref.items = migrateLegacyMutedWordsItems(mutedWordsPref.items);
            return prefs.filter((p) => !index_1.AppBskyActorDefs.isMutedWordsPref(p)).concat(mutedWordsPref);
          }
          return prefs;
        });
      }
      /**
       * Convenience method to remove muted words from user preferences
       */
      async removeMutedWords(mutedWords) {
        await Promise.all(mutedWords.map((word) => this.removeMutedWord(word)));
      }
      async hidePost(postUri) {
        await this.updateHiddenPost(postUri, "hide");
      }
      async unhidePost(postUri) {
        await this.updateHiddenPost(postUri, "unhide");
      }
      async bskyAppQueueNudges(nudges) {
        await this.updatePreferences((prefs) => {
          const pref = prefs.findLast(predicate2.isValidBskyAppStatePref) || {
            $type: "app.bsky.actor.defs#bskyAppStatePref"
          };
          pref.queuedNudges = (pref.queuedNudges || []).concat(nudges);
          return prefs.filter((p) => !index_1.AppBskyActorDefs.isBskyAppStatePref(p)).concat(pref);
        });
      }
      async bskyAppDismissNudges(nudges) {
        await this.updatePreferences((prefs) => {
          const pref = prefs.findLast(predicate2.isValidBskyAppStatePref) || {
            $type: "app.bsky.actor.defs#bskyAppStatePref"
          };
          nudges = Array.isArray(nudges) ? nudges : [nudges];
          pref.queuedNudges = (pref.queuedNudges || []).filter((nudge) => !nudges.includes(nudge));
          return prefs.filter((p) => !index_1.AppBskyActorDefs.isBskyAppStatePref(p)).concat(pref);
        });
      }
      async bskyAppSetActiveProgressGuide(guide) {
        if (guide) {
          const result = index_1.AppBskyActorDefs.validateBskyAppProgressGuide(guide);
          if (!result.success)
            throw result.error;
        }
        await this.updatePreferences((prefs) => {
          const pref = prefs.findLast(predicate2.isValidBskyAppStatePref) || {
            $type: "app.bsky.actor.defs#bskyAppStatePref"
          };
          pref.activeProgressGuide = guide;
          return prefs.filter((p) => !index_1.AppBskyActorDefs.isBskyAppStatePref(p)).concat(pref);
        });
      }
      /**
       * Insert or update a NUX in user prefs
       */
      async bskyAppUpsertNux(nux) {
        (0, util_1.validateNux)(nux);
        await this.updatePreferences((prefs) => {
          const pref = prefs.findLast(predicate2.isValidBskyAppStatePref) || {
            $type: "app.bsky.actor.defs#bskyAppStatePref"
          };
          pref.nuxs = pref.nuxs || [];
          const existing = pref.nuxs?.find((n) => {
            return n.id === nux.id;
          });
          let next;
          if (existing) {
            next = {
              id: existing.id,
              completed: nux.completed,
              data: nux.data,
              expiresAt: nux.expiresAt
            };
          } else {
            next = nux;
          }
          pref.nuxs = pref.nuxs.filter((n) => n.id !== nux.id).concat(next);
          return prefs.filter((p) => !index_1.AppBskyActorDefs.isBskyAppStatePref(p)).concat(pref);
        });
      }
      /**
       * Removes NUXs from user preferences.
       */
      async bskyAppRemoveNuxs(ids) {
        await this.updatePreferences((prefs) => {
          const pref = prefs.findLast(predicate2.isValidBskyAppStatePref) || {
            $type: "app.bsky.actor.defs#bskyAppStatePref"
          };
          pref.nuxs = (pref.nuxs || []).filter((nux) => !ids.includes(nux.id));
          return prefs.filter((p) => !index_1.AppBskyActorDefs.isBskyAppStatePref(p)).concat(pref);
        });
      }
      async setPostInteractionSettings(settings) {
        const result = index_1.AppBskyActorDefs.validatePostInteractionSettingsPref(settings);
        if (!result.success)
          throw result.error;
        await this.updatePreferences((prefs) => {
          const pref = prefs.findLast(predicate2.isValidPostInteractionSettingsPref) || {
            $type: "app.bsky.actor.defs#postInteractionSettingsPref"
          };
          pref.threadgateAllowRules = settings.threadgateAllowRules;
          pref.postgateEmbeddingRules = settings.postgateEmbeddingRules;
          return prefs.filter((p) => !index_1.AppBskyActorDefs.isPostInteractionSettingsPref(p)).concat(pref);
        });
      }
      /**
       * This function updates the preferences of a user and allows for a callback function to be executed
       * before the update.
       * @param cb - cb is a callback function that takes in a single parameter of type
       * AppBskyActorDefs.Preferences and returns either a boolean or void. This callback function is used to
       * update the preferences of the user. The function is called with the current preferences as an
       * argument and if the callback returns false, the preferences are not updated.
       */
      async updatePreferences(cb) {
        try {
          await __classPrivateFieldGet(this, _Agent_prefsLock, "f").acquireAsync();
          const res = await this.app.bsky.actor.getPreferences({});
          const newPrefs = cb(res.data.preferences);
          if (newPrefs === false) {
            return res.data.preferences;
          }
          await this.app.bsky.actor.putPreferences({
            preferences: newPrefs
          });
          return newPrefs;
        } finally {
          __classPrivateFieldGet(this, _Agent_prefsLock, "f").release();
        }
      }
      async updateHiddenPost(postUri, action) {
        await this.updatePreferences((prefs) => {
          const pref = prefs.findLast(predicate2.isValidHiddenPostsPref) || {
            $type: "app.bsky.actor.defs#hiddenPostsPref",
            items: []
          };
          const hiddenItems = new Set(pref.items);
          if (action === "hide")
            hiddenItems.add(postUri);
          else
            hiddenItems.delete(postUri);
          pref.items = [...hiddenItems];
          return prefs.filter((p) => !index_1.AppBskyActorDefs.isHiddenPostsPref(p)).concat(pref);
        });
      }
      /**
       * A helper specifically for updating feed preferences
       */
      async updateFeedPreferences(cb) {
        let res;
        await this.updatePreferences((prefs) => {
          const feedsPref = prefs.findLast(predicate2.isValidSavedFeedsPref) || {
            $type: "app.bsky.actor.defs#savedFeedsPref",
            saved: [],
            pinned: []
          };
          res = cb(feedsPref.saved, feedsPref.pinned);
          feedsPref.saved = res.saved;
          feedsPref.pinned = res.pinned;
          return prefs.filter((pref) => !index_1.AppBskyActorDefs.isSavedFeedsPref(pref)).concat(feedsPref);
        });
        return res;
      }
      async updateSavedFeedsV2Preferences(cb) {
        let maybeMutatedSavedFeeds = [];
        await this.updatePreferences((prefs) => {
          const existingV2Pref = prefs.findLast(predicate2.isValidSavedFeedsPrefV2) || {
            $type: "app.bsky.actor.defs#savedFeedsPrefV2",
            items: []
          };
          const newSavedFeeds = cb(existingV2Pref.items);
          existingV2Pref.items = [...newSavedFeeds].sort((a, b) => (
            // @NOTE: preserve order of items with the same pinned status
            a.pinned === b.pinned ? 0 : a.pinned ? -1 : 1
          ));
          maybeMutatedSavedFeeds = newSavedFeeds;
          let updatedPrefs = prefs.filter((pref) => !index_1.AppBskyActorDefs.isSavedFeedsPrefV2(pref)).concat(existingV2Pref);
          let existingV1Pref = prefs.findLast(predicate2.isValidSavedFeedsPref);
          if (existingV1Pref) {
            const { saved, pinned } = existingV1Pref;
            const v2Compat = (0, util_1.savedFeedsToUriArrays)(
              // v1 only supports feeds and lists
              existingV2Pref.items.filter((i) => ["feed", "list"].includes(i.type))
            );
            existingV1Pref = {
              ...existingV1Pref,
              saved: Array.from(/* @__PURE__ */ new Set([...saved, ...v2Compat.saved])),
              pinned: Array.from(/* @__PURE__ */ new Set([...pinned, ...v2Compat.pinned]))
            };
            updatedPrefs = updatedPrefs.filter((pref) => !index_1.AppBskyActorDefs.isSavedFeedsPref(pref)).concat(existingV1Pref);
          }
          return updatedPrefs;
        });
        return maybeMutatedSavedFeeds;
      }
    }
    agent.Agent = Agent;
    _Agent_prefsLock = /* @__PURE__ */ new WeakMap();
    Object.defineProperty(Agent, "appLabelers", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: [const_1.BSKY_LABELER_DID]
    });
    function adjustLegacyContentLabelPref(pref) {
      let visibility = pref.visibility;
      if (visibility === "show") {
        visibility = "ignore";
      }
      return { ...pref, visibility };
    }
    function remapLegacyLabels(labels2) {
      const _labels = { ...labels2 };
      const legacyToNewMap = {
        gore: "graphic-media",
        nsfw: "porn",
        suggestive: "sexual"
      };
      for (const labelName in _labels) {
        const newLabelName = legacyToNewMap[labelName];
        if (newLabelName) {
          _labels[newLabelName] = _labels[labelName];
        }
      }
      return _labels;
    }
    function prefsArrayToLabelerDids(prefs) {
      const labelersPref = prefs.findLast(predicate2.isValidLabelersPref);
      let dids = [];
      if (labelersPref) {
        dids = labelersPref.labelers.map((labeler) => labeler.did);
      }
      return dids;
    }
    function isBskyPrefs(v) {
      return v && typeof v === "object" && "moderationPrefs" in v && isModPrefs(v.moderationPrefs);
    }
    function isModPrefs(v) {
      return v && typeof v === "object" && "labelers" in v;
    }
    function migrateLegacyMutedWordsItems(items) {
      return items.map((item) => ({
        ...item,
        id: item.id || common_web_1.TID.nextStr()
      }));
    }
    function matchMutedWord(existingWord, newWord) {
      const existingId = existingWord.id;
      const matchById = existingId && existingId === newWord.id;
      const legacyMatchByValue = !existingId && existingWord.value === newWord.value;
      return matchById || legacyMatchByValue;
    }
    return agent;
  }
  var atpAgent = {};
  var hasRequiredAtpAgent;
  function requireAtpAgent() {
    if (hasRequiredAtpAgent) return atpAgent;
    hasRequiredAtpAgent = 1;
    Object.defineProperty(atpAgent, "__esModule", { value: true });
    atpAgent.CredentialSession = atpAgent.AtpAgent = void 0;
    const common_web_1 = requireDist$4();
    const xrpc_1 = requireDist$1();
    const agent_1 = requireAgent();
    const client_1 = requireClient();
    const lexicons_1 = requireLexicons();
    const ReadableStream = globalThis.ReadableStream;
    class AtpAgent extends agent_1.Agent {
      constructor(options) {
        const sessionManager = options instanceof CredentialSession ? options : new CredentialSession(new URL(options.service), options.fetch, options.persistSession);
        super(sessionManager);
        Object.defineProperty(this, "sessionManager", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.sessionManager = sessionManager;
        if (!(options instanceof CredentialSession) && options.headers) {
          for (const [key, value] of options.headers) {
            this.setHeader(key, value);
          }
        }
      }
      clone() {
        return this.copyInto(new AtpAgent(this.sessionManager));
      }
      get session() {
        return this.sessionManager.session;
      }
      get hasSession() {
        return this.sessionManager.hasSession;
      }
      get did() {
        return this.sessionManager.did;
      }
      get serviceUrl() {
        return this.sessionManager.serviceUrl;
      }
      get pdsUrl() {
        return this.sessionManager.pdsUrl;
      }
      get dispatchUrl() {
        return this.sessionManager.dispatchUrl;
      }
      /** @deprecated use {@link serviceUrl} instead */
      get service() {
        return this.serviceUrl;
      }
      get persistSession() {
        throw new Error('Cannot set persistSession directly. "persistSession" is defined through the constructor and will be invoked automatically when session data changes.');
      }
      set persistSession(v) {
        throw new Error('Cannot set persistSession directly. "persistSession" must be defined in the constructor and can no longer be changed.');
      }
      /** @deprecated use {@link AtpAgent.serviceUrl} instead */
      getServiceUrl() {
        return this.serviceUrl;
      }
      async resumeSession(session) {
        return this.sessionManager.resumeSession(session);
      }
      async createAccount(data, opts) {
        return this.sessionManager.createAccount(data, opts);
      }
      async login(opts) {
        return this.sessionManager.login(opts);
      }
      async logout() {
        return this.sessionManager.logout();
      }
    }
    atpAgent.AtpAgent = AtpAgent;
    class CredentialSession {
      constructor(serviceUrl, fetch2 = globalThis.fetch, persistSession) {
        Object.defineProperty(this, "serviceUrl", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: serviceUrl
        });
        Object.defineProperty(this, "fetch", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: fetch2
        });
        Object.defineProperty(this, "persistSession", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: persistSession
        });
        Object.defineProperty(this, "pdsUrl", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "session", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "refreshSessionPromise", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "server", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: new client_1.ComAtprotoServerNS(
            // Note that the use of the codegen "schemas" (to instantiate `this.api`),
            // as well as the use of `ComAtprotoServerNS` will cause this class to
            // reference (way) more code than it actually needs. It is not possible,
            // with the current state of the codegen, to generate a client that only
            // includes the methods that are actually used by this class. This is a
            // known limitation that should be addressed in a future version of the
            // codegen.
            new xrpc_1.XrpcClient((url, init) => {
              return (0, this.fetch)(new URL(url, this.serviceUrl), init);
            }, lexicons_1.schemas)
          )
        });
      }
      get did() {
        return this.session?.did;
      }
      get dispatchUrl() {
        return this.pdsUrl || this.serviceUrl;
      }
      get hasSession() {
        return !!this.session;
      }
      /**
       * Sets a WhatWG "fetch()" function to be used for making HTTP requests.
       */
      setFetch(fetch2 = globalThis.fetch) {
        this.fetch = fetch2;
      }
      async fetchHandler(url, init) {
        await this.refreshSessionPromise;
        const initialUri = new URL(url, this.dispatchUrl);
        const initialReq = new Request(initialUri, init);
        const initialToken = this.session?.accessJwt;
        if (!initialToken || initialReq.headers.has("authorization")) {
          return (0, this.fetch)(initialReq);
        }
        initialReq.headers.set("authorization", `Bearer ${initialToken}`);
        const initialRes = await (0, this.fetch)(initialReq);
        if (!this.session?.refreshJwt) {
          return initialRes;
        }
        const isExpiredToken = await isErrorResponse(initialRes, [400], ["ExpiredToken"]);
        if (!isExpiredToken) {
          return initialRes;
        }
        try {
          await this.refreshSession();
        } catch {
          return initialRes;
        }
        if (init?.signal?.aborted) {
          return initialRes;
        }
        if (ReadableStream && init?.body instanceof ReadableStream) {
          return initialRes;
        }
        const updatedToken = this.session?.accessJwt;
        if (!updatedToken || updatedToken === initialToken) {
          return initialRes;
        }
        await initialRes.body?.cancel();
        const updatedUri = new URL(url, this.dispatchUrl);
        const updatedReq = new Request(updatedUri, init);
        updatedReq.headers.set("authorization", `Bearer ${updatedToken}`);
        return await (0, this.fetch)(updatedReq);
      }
      /**
       * Create a new account and hydrate its session in this agent.
       */
      async createAccount(data, opts) {
        try {
          const res = await this.server.createAccount(data, opts);
          this.session = {
            accessJwt: res.data.accessJwt,
            refreshJwt: res.data.refreshJwt,
            handle: res.data.handle,
            did: res.data.did,
            email: data.email,
            emailConfirmed: false,
            emailAuthFactor: false,
            active: true
          };
          this.persistSession?.("create", this.session);
          this._updateApiEndpoint(res.data.didDoc);
          return res;
        } catch (e) {
          this.session = void 0;
          this.persistSession?.("create-failed", void 0);
          throw e;
        }
      }
      /**
       * Start a new session with this agent.
       */
      async login(opts) {
        try {
          const res = await this.server.createSession({
            identifier: opts.identifier,
            password: opts.password,
            authFactorToken: opts.authFactorToken,
            allowTakendown: opts.allowTakendown
          });
          this.session = {
            accessJwt: res.data.accessJwt,
            refreshJwt: res.data.refreshJwt,
            handle: res.data.handle,
            did: res.data.did,
            email: res.data.email,
            emailConfirmed: res.data.emailConfirmed,
            emailAuthFactor: res.data.emailAuthFactor,
            active: res.data.active ?? true,
            status: res.data.status
          };
          this._updateApiEndpoint(res.data.didDoc);
          this.persistSession?.("create", this.session);
          return res;
        } catch (e) {
          this.session = void 0;
          this.persistSession?.("create-failed", void 0);
          throw e;
        }
      }
      async logout() {
        if (this.session) {
          try {
            await this.server.deleteSession(void 0, {
              headers: {
                authorization: `Bearer ${this.session.refreshJwt}`
              }
            });
          } catch {
          } finally {
            this.session = void 0;
            this.persistSession?.("expired", void 0);
          }
        }
      }
      /**
       * Resume a pre-existing session with this agent.
       */
      async resumeSession(session) {
        this.session = session;
        try {
          const res = await this.server.getSession(void 0, {
            headers: { authorization: `Bearer ${session.accessJwt}` }
          }).catch(async (err) => {
            if (err instanceof xrpc_1.XRPCError && ["ExpiredToken", "InvalidToken"].includes(err.error) && session.refreshJwt) {
              try {
                const res2 = await this.server.refreshSession(void 0, {
                  headers: { authorization: `Bearer ${session.refreshJwt}` }
                });
                session.accessJwt = res2.data.accessJwt;
                session.refreshJwt = res2.data.refreshJwt;
                return this.server.getSession(void 0, {
                  headers: { authorization: `Bearer ${session.accessJwt}` }
                });
              } catch {
              }
            }
            throw err;
          });
          if (res.data.did !== session.did) {
            throw new xrpc_1.XRPCError(xrpc_1.ResponseType.InvalidRequest, "Invalid session", "InvalidDID");
          }
          session.email = res.data.email;
          session.handle = res.data.handle;
          session.emailConfirmed = res.data.emailConfirmed;
          session.emailAuthFactor = res.data.emailAuthFactor;
          session.active = res.data.active ?? true;
          session.status = res.data.status;
          if (this.session === session) {
            this._updateApiEndpoint(res.data.didDoc);
            this.persistSession?.("update", session);
          }
          return res;
        } catch (err) {
          if (this.session === session) {
            this.session = void 0;
            this.persistSession?.(err instanceof xrpc_1.XRPCError && ["ExpiredToken", "InvalidToken"].includes(err.error) ? "expired" : "network-error", void 0);
          }
          throw err;
        }
      }
      /**
       * Internal helper to refresh sessions
       * - Wraps the actual implementation in a promise-guard to ensure only
       *   one refresh is attempted at a time.
       */
      async refreshSession() {
        return this.refreshSessionPromise || (this.refreshSessionPromise = this._refreshSessionInner().finally(() => {
          this.refreshSessionPromise = void 0;
        }));
      }
      /**
       * Internal helper to refresh sessions (actual behavior)
       */
      async _refreshSessionInner() {
        if (!this.session?.refreshJwt) {
          return;
        }
        try {
          const res = await this.server.refreshSession(void 0, {
            headers: { authorization: `Bearer ${this.session.refreshJwt}` }
          });
          this.session = {
            ...this.session,
            accessJwt: res.data.accessJwt,
            refreshJwt: res.data.refreshJwt,
            handle: res.data.handle,
            did: res.data.did
          };
          this._updateApiEndpoint(res.data.didDoc);
          this.persistSession?.("update", this.session);
        } catch (err) {
          if (err instanceof xrpc_1.XRPCError && err.error && ["ExpiredToken", "InvalidToken"].includes(err.error)) {
            this.session = void 0;
            this.persistSession?.("expired", void 0);
          }
        }
      }
      /**
       * Helper to update the pds endpoint dynamically.
       *
       * The session methods (create, resume, refresh) may respond with the user's
       * did document which contains the user's canonical PDS endpoint. That endpoint
       * may differ from the endpoint used to contact the server. We capture that
       * PDS endpoint and update the client to use that given endpoint for future
       * requests. (This helps ensure smooth migrations between PDSes, especially
       * when the PDSes are operated by a single org.)
       */
      _updateApiEndpoint(didDoc2) {
        if ((0, common_web_1.isValidDidDoc)(didDoc2)) {
          const endpoint = (0, common_web_1.getPdsEndpoint)(didDoc2);
          this.pdsUrl = endpoint ? new URL(endpoint) : void 0;
        } else {
          this.pdsUrl = void 0;
        }
      }
    }
    atpAgent.CredentialSession = CredentialSession;
    function isErrorObject(v) {
      return xrpc_1.errorResponseBody.safeParse(v).success;
    }
    async function isErrorResponse(response, status, errorNames) {
      if (!status.includes(response.status))
        return false;
      try {
        const json = await peekJson(response, 10 * 1024);
        return isErrorObject(json) && errorNames.includes(json.error);
      } catch (err) {
        return false;
      }
    }
    async function peekJson(response, maxSize = Infinity) {
      if (extractType(response) !== "application/json")
        throw new Error("Not JSON");
      if (extractLength(response) > maxSize)
        throw new Error("Response too large");
      return response.clone().json();
    }
    function extractLength({ headers }) {
      return headers.get("Content-Length") ? Number(headers.get("Content-Length")) : NaN;
    }
    function extractType({ headers }) {
      return headers.get("Content-Type")?.split(";")[0]?.trim();
    }
    return atpAgent;
  }
  var bskyAgent = {};
  var hasRequiredBskyAgent;
  function requireBskyAgent() {
    if (hasRequiredBskyAgent) return bskyAgent;
    hasRequiredBskyAgent = 1;
    Object.defineProperty(bskyAgent, "__esModule", { value: true });
    bskyAgent.BskyAgent = void 0;
    const atp_agent_1 = requireAtpAgent();
    class BskyAgent extends atp_agent_1.AtpAgent {
      clone() {
        if (this.constructor === BskyAgent) {
          const agent2 = new BskyAgent(this.sessionManager);
          return this.copyInto(agent2);
        }
        throw new TypeError("Cannot clone a subclass of BskyAgent");
      }
    }
    bskyAgent.BskyAgent = BskyAgent;
    return bskyAgent;
  }
  var hasRequiredDist;
  function requireDist() {
    if (hasRequiredDist) return dist$5;
    hasRequiredDist = 1;
    (function(exports) {
      var __createBinding = dist$5 && dist$5.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      });
      var __exportStar = dist$5 && dist$5.__exportStar || function(m, exports2) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.lexicons = exports.default = exports.BskyAgent = exports.CredentialSession = exports.AtpAgent = exports.Agent = exports.LABELS = exports.DEFAULT_LABEL_SETTINGS = exports.asPredicate = exports.schemas = exports.parseLanguage = exports.stringifyLex = exports.lexToJson = exports.jsonToLex = exports.jsonStringToLex = exports.BlobRef = exports.AtUri = void 0;
      const lexicon_1 = requireDist$2();
      const lexicons_1 = requireLexicons();
      var syntax_1 = requireDist$5();
      Object.defineProperty(exports, "AtUri", { enumerable: true, get: function() {
        return syntax_1.AtUri;
      } });
      var lexicon_2 = requireDist$2();
      Object.defineProperty(exports, "BlobRef", { enumerable: true, get: function() {
        return lexicon_2.BlobRef;
      } });
      Object.defineProperty(exports, "jsonStringToLex", { enumerable: true, get: function() {
        return lexicon_2.jsonStringToLex;
      } });
      Object.defineProperty(exports, "jsonToLex", { enumerable: true, get: function() {
        return lexicon_2.jsonToLex;
      } });
      Object.defineProperty(exports, "lexToJson", { enumerable: true, get: function() {
        return lexicon_2.lexToJson;
      } });
      Object.defineProperty(exports, "stringifyLex", { enumerable: true, get: function() {
        return lexicon_2.stringifyLex;
      } });
      var common_web_1 = requireDist$4();
      Object.defineProperty(exports, "parseLanguage", { enumerable: true, get: function() {
        return common_web_1.parseLanguage;
      } });
      __exportStar(requireTypes$2(), exports);
      __exportStar(require_const(), exports);
      __exportStar(requireUtil$4(), exports);
      __exportStar(requireClient(), exports);
      var lexicons_2 = requireLexicons();
      Object.defineProperty(exports, "schemas", { enumerable: true, get: function() {
        return lexicons_2.schemas;
      } });
      var util_1 = requireUtil$5();
      Object.defineProperty(exports, "asPredicate", { enumerable: true, get: function() {
        return util_1.asPredicate;
      } });
      __exportStar(requireRichText(), exports);
      __exportStar(requireSanitization(), exports);
      __exportStar(requireUnicode(), exports);
      __exportStar(requireUtil$2(), exports);
      __exportStar(requireModeration(), exports);
      __exportStar(requireTypes(), exports);
      __exportStar(requireMocker(), exports);
      var labels_1 = requireLabels();
      Object.defineProperty(exports, "DEFAULT_LABEL_SETTINGS", { enumerable: true, get: function() {
        return labels_1.DEFAULT_LABEL_SETTINGS;
      } });
      Object.defineProperty(exports, "LABELS", { enumerable: true, get: function() {
        return labels_1.LABELS;
      } });
      var agent_1 = requireAgent();
      Object.defineProperty(exports, "Agent", { enumerable: true, get: function() {
        return agent_1.Agent;
      } });
      var atp_agent_1 = requireAtpAgent();
      Object.defineProperty(exports, "AtpAgent", { enumerable: true, get: function() {
        return atp_agent_1.AtpAgent;
      } });
      var atp_agent_2 = requireAtpAgent();
      Object.defineProperty(exports, "CredentialSession", { enumerable: true, get: function() {
        return atp_agent_2.CredentialSession;
      } });
      var bsky_agent_1 = requireBskyAgent();
      Object.defineProperty(exports, "BskyAgent", { enumerable: true, get: function() {
        return bsky_agent_1.BskyAgent;
      } });
      var atp_agent_3 = requireAtpAgent();
      Object.defineProperty(exports, "default", { enumerable: true, get: function() {
        return atp_agent_3.AtpAgent;
      } });
      exports.lexicons = new lexicon_1.Lexicons(lexicons_1.lexicons);
    })(dist$5);
    return dist$5;
  }
  var distExports = requireDist();
  class BlueskyAPI {
    constructor(service2 = "https://bsky.social", identifier, password) {
      this.service = service2;
      this.identifier = identifier;
      this.password = password;
      this.agent = new distExports.BskyAgent({ service: this.service });
    }
    async login() {
      return this.agent.login({
        identifier: this.identifier,
        password: this.password
      });
    }
    async getPost(uri) {
      await this.agent.getPostThread({ uri: "at://..." });
    }
    async getTimeline() {
      const { data } = await this.agent.getTimeline({
        // cursor: '',
        limit: 30
      });
      console.log(data);
    }
    async getAtprotoUri(postUrl) {
      const match2 = postUrl.match(/bsky\.app\/profile\/([^\/]+)\/post\/([^\/]+)/);
      if (!match2) {
        console.error("Invalid Bluesky post URL format.");
        return null;
      }
      const handle2 = match2[1];
      const postId = match2[2];
      if (handle2.startsWith("did:")) {
        return null;
      }
      try {
        const { data } = await this.agent.resolveHandle({ handle: handle2 });
        const did2 = data.did;
        const atprotoUri = `at://${did2}/app.bsky.feed.post/${postId}`;
        return atprotoUri;
      } catch (error) {
        console.error("Failed to resolve handle:", error);
        return null;
      }
    }
    async getThread(uri) {
      const res = await this.agent.getPostThread({ uri });
      const { thread } = res.data;
      return thread;
    }
    async getReplies(uri) {
      const thread = this.getThread(uri);
      return thread.replies.map(
        (i, reply) => {
          return reply.post.record.text;
        }
      );
    }
    async unrollThread(thread) {
      const originalAuthor = thread.post.author.did;
      async function collectPosts(threadNode, parentAuthorDid, posts = []) {
        if (!threadNode.post) {
          return [];
        }
        if (threadNode.post.author.did === originalAuthor && parentAuthorDid === originalAuthor) {
          posts.push(threadNode.post);
        }
        if (threadNode.post.replyCount && !threadNode.replies) {
          threadNode.replies = (await this.getThread(threadNode.post.uri)).replies;
        }
        if (threadNode.replies) {
          for (const reply of threadNode.replies) {
            await collectPosts(reply, threadNode.post.author.did, posts);
          }
        }
        return posts;
      }
      collectPosts = collectPosts.bind(this);
      const allPosts = await collectPosts(thread, originalAuthor);
      console.log(allPosts.length);
      return allPosts;
    }
  }
  let debounceTimeout;
  function debounce(func, delay) {
    return function(...args) {
      clearTimeout(debounceTimeout);
      debounceTimeout = setTimeout(() => func.apply(this, args), delay);
    };
  }
  function waitForElement$2(selector, onAdd, onRemove, onChange, ignoreExisting) {
    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        if (onAdd) {
          mutation.addedNodes.forEach((node) => {
            if (node.matches && node.matches(selector)) onAdd(node);
            node.querySelectorAll?.(selector).forEach((el) => onAdd(el, observer));
          });
        }
        if (onRemove) {
          mutation.removedNodes.forEach((node) => {
            if (node.matches && node.matches(selector)) onRemove(node);
            node.querySelectorAll?.(selector).forEach((el) => onRemove(el, observer));
          });
        }
        if (onChange) {
          if (mutation.type === "attributes") {
            const attributeName = mutation.attributeName;
            const oldValue = mutation.oldValue;
            const newValue = mutation.target.getAttribute(attributeName);
            if (oldValue !== newValue) {
              onChange(attributeName, oldValue, newValue, mutation.target, observer);
            }
          }
        }
      });
    });
    const processExistingElements = () => {
      const elements = document.querySelectorAll(selector);
      elements.forEach((el) => onAdd(el, observer));
    };
    if (onAdd && !ignoreExisting) {
      processExistingElements();
    }
    observer.observe(document.body, { childList: true, subtree: true, attributes: !!onChange });
    return observer;
  }
  function observeChanges$1(target2, callback, subtree) {
    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        if (mutation.type === "attributes") {
          const attributeName = mutation.attributeName;
          const oldValue = mutation.oldValue;
          const newValue = mutation.target.getAttribute(attributeName);
          if (oldValue !== newValue) {
            callback(attributeName, oldValue, newValue, mutation.target);
          }
        }
      });
    });
    observer.observe(target2, {
      attributes: true,
      attributeOldValue: true,
      subtree: !!subtree
    });
    return observer;
  }
  function observeVisibilityChange$1($element, callback) {
    const target2 = $element[0];
    const observer = new MutationObserver(() => {
      const isVisible = $element.is(":visible");
      callback(isVisible);
    });
    observer.observe(target2, {
      attributes: true,
      childList: true,
      subtree: false
      // Only observe the target element
    });
    return () => observer.disconnect();
  }
  function splitTerms(input) {
    return input.split(/\s+/).filter((term) => term.length > 0);
  }
  function extractLastTerm(input) {
    let terms = splitTerms(input);
    return terms.length > 0 ? terms[terms.length - 1] : "";
  }
  const utils$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    debounce,
    extractLastTerm,
    observeChanges: observeChanges$1,
    observeVisibilityChange: observeVisibilityChange$1,
    splitTerms,
    waitForElement: waitForElement$2
  }, Symbol.toStringTag, { value: "Module" }));
  const CONFIG_FIELDS = {
    "displaySection": {
      "section": [GM_config.create("Display Preferences"), "Customize how items are displayed"],
      "type": "hidden"
    },
    "postWidthDesktop": {
      "label": "Maximum width of posts in pixels when in desktop mode",
      "type": "integer",
      "default": "600"
    },
    "postActionButtonPosition": {
      "label": "Post action button position",
      "title": "Where to position reply, repost, like, etc. buttons",
      "type": "select",
      "options": ["Bottom", "Left"],
      "default": "Bottom"
    },
    "postTimestampFormat": {
      "label": "Post timestamp format",
      "title": "A format string specifying how post timestamps are displayed",
      "type": "textarea",
      "default": "'$age' '('yyyy-MM-dd hh:mmaaa')'"
    },
    "postTimestampFormatMobile": {
      "label": "Post timestamp format (mobile)",
      "title": "A format string specifying how post timestamps are displayed on small screens",
      "type": "textarea",
      "default": "'$age'"
    },
    "videoPreviewPlayback": {
      "label": "Video Preview Playback",
      "title": "Control playback of video previews",
      "type": "select",
      "options": ["Play all", "Play selected", "Pause all"]
    },
    "showReplyContext": {
      "label": "Show Reply Context",
      "title": "If checked, the post being replied to will be shown even if it was previously marked as read.",
      "type": "checkbox",
      "default": false
    },
    "unrollThreads": {
      "label": "Unroll Threads",
      "title": 'If checked, threads with one or more replies from the original author will be "unrolled" into the first post.',
      "type": "checkbox",
      "default": false
    },
    "unrolledPostSelection": {
      "label": "Unrolled Post Selection",
      "title": "If checked, navigation between/selection of individual unrolled posts will be enabled.",
      "type": "checkbox",
      "default": false
    },
    "showReplySidecar": {
      "label": "Show Replies Sidecar",
      "title": "If checked, replies to the selected post (and, where applicable, the post being replied to) will be displayed in a sidecar next to each post (requires atproto settings below).",
      "type": "checkbox",
      "default": false
    },
    "showReplySidecarMinimumWidth": {
      "label": "Show Replies Sidecar Minimum Width",
      "title": "Set a minimum post width in pixels for showing the reply sidecar",
      "type": "int",
      "default": 600
    },
    "sidecarReplySortOrder": {
      "label": "Reply Sidecar Sort Order",
      "title": "Select an option to determine how replies are sorted in the sidecar",
      "type": "select",
      "options": ["Default", "Oldest First", "Newest First", "Most Liked First", "Most Reposted First"]
    },
    "hideRightSidebar": {
      "label": "Hide Right Sidebar",
      "title": "If checked, the right sidebar with the search box, following/trending displays, etc. will be hidden (useful when overriding max width above).",
      "type": "checkbox",
      "default": false
    },
    "hideLoadNewButton": {
      "label": "Hide Load New Button",
      "title": "If checked, the floating button to load new items will be hidden.",
      "type": "checkbox",
      "default": false
    },
    "showPostCounts": {
      "label": "Show Post Counts",
      "title": "Specify whether post counts are displayed in all, selected, or no posts.",
      "type": "select",
      "options": ["All", "Selection", "None"],
      "default": "All"
    },
    "enableSmoothScrolling": {
      "label": "Enable Smooth Scrolling",
      "title": "If checked, scrolling using keyboard navigation will be smooth \u{1F6E5}\uFE0F \u{1F3B7}",
      "type": "checkbox",
      "default": false
    },
    "posts": {
      "label": "CSS Style: All Posts",
      "type": "textarea",
      "default": "padding 1px;"
    },
    "unreadPosts": {
      "label": "CSS Style: Unread Posts",
      "type": "textarea",
      "default": "opacity: 100% !important;"
    },
    "unreadPostsLightMode": {
      "label": "CSS Style: Unread Posts (Light Mode)",
      "type": "textarea",
      "default": "background-color: white;"
    },
    "unreadPostsDarkMode": {
      "label": "CSS Style: Unread Posts (Dark Mode)",
      "type": "textarea",
      "default": "background-color: #202020;"
    },
    "readPosts": {
      "label": "CSS Style: Read Posts",
      "type": "textarea",
      "default": "opacity: 75% !important;"
    },
    "readPostsLightMode": {
      "label": "CSS Style: Read Posts (Light Mode)",
      "type": "textarea",
      "default": "background-color: #f0f0f0;"
    },
    "readPostsDarkMode": {
      "label": "CSS Style: Read Posts (Dark Mode)",
      "type": "textarea",
      "default": "background-color: black;"
    },
    "selectionActive": {
      "label": "CSS Style: Selected Post",
      "type": "textarea",
      "default": "outline: 3px rgba(255, 0, 0, .6) solid !important;"
    },
    "selectionChildFocused": {
      "label": "CSS Style: Selected Child Post Focused",
      "type": "textarea",
      "default": "outline: 3px rgba(128, 0, 0, .2) solid !important;"
    },
    "selectionInactive": {
      "label": "CSS Style: Unselected Post",
      "type": "textarea",
      "default": "outline: 3px solid transparent;"
    },
    "replySelectionActive": {
      "label": "CSS Style: Selected Reply",
      "type": "textarea",
      "default": "outline: 1px rgba(255, 0, 0, .8) solid !important;"
    },
    "replySelectionInactive": {
      "label": "CSS Style: Unselected Replies",
      "type": "textarea",
      "default": "outline: 1px rgb(212, 219, 226) solid"
    },
    "threadIndicatorWidth": {
      "label": "Thread Indicator Width in pixels",
      "type": "integer",
      "default": "4"
    },
    "threadIndicatorColor": {
      "label": "Thread Indicator Color",
      "type": "textarea",
      "default": "rgb(212, 219, 226)"
    },
    "threadMargin": {
      "label": "Thread Margin",
      "type": "textarea",
      "default": "10px"
    },
    "atprotoSection": {
      "section": [GM_config.create("AT Protocol Agent"), "Enables additional functionality"],
      "type": "hidden"
    },
    "atprotoService": {
      "label": "Service",
      "title": "AT Protocol Service",
      "type": "textarea",
      "default": "https://bsky.social"
    },
    "atprotoIdentifier": {
      "label": "Identifier (Handle)",
      "title": "AT Protocol Identifier (Handle)",
      "type": "textarea"
    },
    "atprotoPassword": {
      "label": "Password",
      "title": "AT Protocol Password",
      "type": "textarea"
    },
    "stateSyncSection": {
      "section": [GM_config.create("State Sync"), 'Sync state between different browsers via cloud storage -- see <a href="https://github.com/tonycpsu/bluesky-navigator/blob/main/doc/remote_state.md" target="_blank">here</a> for details.'],
      "type": "hidden"
    },
    "stateSyncEnabled": {
      "label": "Enable State Sync",
      "title": "If checked, synchronize state to/from the cloud",
      "type": "checkbox",
      "default": false
    },
    "stateSyncConfig": {
      "label": "State Sync Configuration (JSON)",
      "title": "JSON object containing state information",
      "type": "textarea"
    },
    "stateSyncTimeout": {
      "label": "State Sync Timeout",
      "title": "Number of milliseconds of idle time before syncing state",
      "type": "int",
      "default": 5e3
    },
    "rulesSection": {
      "section": [GM_config.create("Rules"), "Post Rules"],
      "type": "hidden"
    },
    "rulesConfig": {
      "label": "Filters Configuration",
      "type": "textarea"
    },
    "miscellaneousSection": {
      "section": [GM_config.create("Miscellaneous"), "Other settings"],
      "type": "hidden"
    },
    "markReadOnScroll": {
      "label": "Mark Read on Scroll",
      "title": "If checked, items will be marked read while scrolling",
      "type": "checkbox",
      "default": false
    },
    "disableLoadMoreOnScroll": {
      "label": "Disable Load More on Scroll",
      "title": 'If checked, the default behavior of loading more items when scrolling will be disabled. You can still press "U" to load more manually.',
      "type": "checkbox",
      "default": false
    },
    "savePostState": {
      "label": "Save Post State",
      "title": "If checked, read/unread state is kept for post items in addition to feed items",
      "type": "checkbox",
      "default": false
    },
    "stateSaveTimeout": {
      "label": "State Save Timeout",
      "title": "Number of milliseconds of idle time before saving state locally",
      "type": "int",
      "default": 1e3
    },
    "historyMax": {
      "label": "History Max Size",
      "title": "Maximum number of posts to remember for saving read state",
      "type": "int",
      "default": constants$1.DEFAULT_HISTORY_MAX
    },
    "showDebuggingInfo": {
      "label": "Enable Debugging",
      "title": "If checked, some debugging info will be shown in posts",
      "type": "checkbox",
      "default": false
    }
  };
  const style = '/* style.css */\n\ndiv[style^="position: fixed; inset: 0px 0px 0px 50%;"] {\n    border: none;\n}\n\ndiv#logContainer {\n    width: 100%;\n    bottom: 0;\n    pointer-events: none;\n    height: 25%;\n    position: fixed;\n    background: rgba(0, 0, 0, 0.2);\n    color: #e0e0e0;\n    font-family: monospace;\n    font-size: 12px;\n    z-index: 10000;\n    padding: 10px;\n    padding-top: 30px;\n}\n\n#logHeader {\n    position: relative;\n    width: 100%;\n    background: #333;\n    color: white;\n    padding: 5px 10px;\n    box-sizing: border-box;\n    pointer-events: auto;\n}\n\nbutton#clearLogs {\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100px;\n    background: red;\n    color: white;\n    border: none;\n    padding: 2px 5px;\n    cursor: pointer;\n}\n\n#logContent {\n    overflow-y: auto;\n    max-height: calc(70% - 30px);\n    padding: 10px;\n    box-sizing: border-box;\n}\n\ndiv#bsky-navigator-toolbar {\n    display: flex;\n    flex-direction: row;\n    position: sticky;\n    top: 0;\n    align-items: center;\n    width: 100%;\n    height: 32px;\n    background-color: inherit;\n    border-bottom: 1px solid rgb(192, 192, 192);\n}\n\n@media (prefers-color-scheme: dark) {\n    div#bsky-navigator-toolbar {\n        background-color: #29333d\n    }\n}\n\n.toolbar-icon {\n    margin: 0px;\n    width: 24px;\n    height: 24px;\n    padding: 0px 8px;\n    flex: 1;\n}\n\n\n.toolbar-icon-pending {\n    animation: fadeInOut 1s infinite !important;\n}\n\n.indicator-image {\n    width: 24px;\n    height: 24px;\n}\n\n@media (prefers-color-scheme: dark) {\n    .indicator-image {\n        filter: invert(1) brightness(2);\n    }\n}\n\ndiv#infoIndicator {\n    flex: 3;\n}\n\ndiv#infoIndicatorText {\n    font-size: 0.8em;\n}\n\ndiv#itemTimestampStats {\n    font-size: 0.7em;\n}\n\n#bsky-navigator-search {\n    flex: 1;\n    margin: 0px 8px;\n    z-index: 10;\n    font: 14px "DejaVu Sans Mono", "Lucida Console", "Courier New", monospace;\n}\n\n.ui-autocomplete {\n    position: absolute !important;\n    background-color: white !important;\n    border: 1px solid #ccc !important;\n    z-index: 1000 !important;\n    max-height: 200px !important;\n    overflow-y: auto !important;\n    list-style-type: none !important;\n    font: 14px "DejaVu Sans Mono", "Lucida Console", "Courier New", monospace;\n    padding: 2px !important;\n}\n\n.ui-menu-item {\n    padding: 2px !important;\n    font-size: 14px !important;\n    color: black !important;\n}\n\n/* Highlight hovered item */\n.ui-state-active {\n    background-color: #007bff !important;\n    color: white !important;\n}\n\n@media only screen and not (max-width: 800px) {\n    div#statusBar {\n        display: flex;\n        width: 100%;\n        height: 32px;\n        margin-left: auto;\n        margin-right: auto;\n        position: sticky;\n        z-index: 10;\n        align-items: center;\n        background-color: #ffffff;\n        bottom: 0;\n        font-size: 1em;\n        padding: 1px;\n        border-top: 1px solid rgb(192, 192, 192);\n        overflow: clip;\n    }\n}\n\n@media only screen and (max-width: 800px) {\n    div#statusBar {\n        display: flex;\n        width: 100%;\n        height: 32px;\n        margin-left: auto;\n        margin-right: auto;\n        position: sticky;\n        z-index: 10;\n        align-items: center;\n        background-color: #ffffff;\n        bottom: 58px;\n        font-size: 1em;\n        padding: 1px;\n        overflow: clip;\n    }\n}\n\n@media (prefers-color-scheme: dark) {\n    div#statusBar {\n        background-color: #29333d;\n    }\n}\n\ndiv#statusBarLeft {\n    display: flex;\n    flex: 1;\n    text-align: left;\n    padding: 1px;\n}\n\ndiv#statusBarCenter {\n    display: flex;\n    flex: 1 1 auto;\n    text-align: center;\n    padding: 1px;\n}\n\ndiv#statusBarRight {\n    display: flex;\n    flex: 1;\n    text-align: right;\n    padding: 1px;\n}\n\n#prevButton {\n    z-index: 1000;\n    position: absolute;\n    top: 30%;\n    right: -10px;\n    opacity: 20%;\n}\n\n#prevButton.mobile {\n    position: fixed;\n    left: 1%;\n    top: 25%;\n}\n\n#nextButton {\n    z-index: 1000;\n    position: absolute;\n    bottom: 30%;\n    right: -10px;\n    opacity: 20%;\n}\n\n#nextButton.mobile {\n    position: fixed;\n    left: 1%;\n    bottom: 20%;\n}\n\nnav.r-1wyvozj {\n    overflow: inherit;\n}\n\n@keyframes oscillateBorderBottom {\n    0% {\n        border-bottom-color: rgba(0, 128, 0, 1);\n    }\n    50% {\n        border-bottom-color: rgba(0, 128, 0, 0.3);\n    }\n    100% {\n        border-bottom-color: rgba(0, 128, 0, 1);\n    }\n}\n\n@keyframes oscillateBorderTop {\n    0% {\n        border-top-color: rgba(0, 128, 0, 1);\n    }\n    50% {\n        border-top-color: rgba(0, 128, 0, 0.3);\n    }\n    100% {\n        border-top-color: rgba(0, 128, 0, 1);\n    }\n}\n\n@keyframes fadeInOut {\n    0% {\n        opacity: 0.2;\n    }\n    50% {\n        opacity: 1;\n    }\n    100% {\n        opacity: 0.2;\n    }\n}\n\ndiv.loading-indicator-reverse {\n    border-bottom: 10px solid;\n    animation: oscillateBorderBottom 0.2s infinite;\n}\n\ndiv.loading-indicator-forward {\n    border-top: 10px solid;\n    animation: oscillateBorderTop 0.2s infinite;\n}\n\n.filtered {\n    display: none !important;\n}\n\n#messageContainer {\n    inset: 5%;\n    padding: 10px;\n}\n\n.messageTitle {\n    font-size: 1.5em;\n    text-align: center;\n}\n\n.messageBody {\n    font-size: 1.2em;\n}\n\n#messageActions a {\n    color: #8040c0;\n}\n\n#messageActions a:hover {\n    text-decoration: underline;\n    cursor: pointer;\n}\n\n.preferences-icon-overlay {\n    background-color: #cccccc;\n    cursor: pointer;\n    justify-content: center;\n    z-index: 1000;\n}\n\n.preferences-icon-overlay-sync-ready {\n    background-color: #d5f5e3;\n}\n\n.preferences-icon-overlay-sync-pending {\n    animation: fadeInOut 1s infinite;\n    background-color: #f9e79f;\n}\n\n.preferences-icon-overlay-sync-success {\n    background-color: #2ecc71;\n}\n\n.preferences-icon-overlay-sync-failure {\n    background-color: #ec7063 ;\n}\n\n.preferences-icon-overlay span {\n    color: white;\n    font-size: 16px;\n}\n\ndiv.item-banner {\n    position: absolute;\n    top: 0;\n    left: 0;\n    font-family: "Lucida Console", "Courier New", monospace;\n    font-size: 0.7em;\n    z-index: 10;\n    color: black;\n    text-shadow: 1px 1px rgba(255, 255, 255,0.8);\n    background: rgba(128, 192, 192, 0.3);\n    padding: 3px;\n    border-radius: 4px;\n}\n\n.image-highlight {\n    filter: invert(36%) sepia(28%) saturate(5764%) hue-rotate(194deg) brightness(102%) contrast(105%);\n}\n\n.load-time-icon {\n    position: absolute;\n    bottom: 2px;\n    width: 24px;\n    height: 24px;\n    opacity: 0.8;\n    filter: invert(93%) sepia(49%) saturate(2805%) hue-rotate(328deg) brightness(99%) contrast(96%) drop-shadow( 0.2px  0px 0px black)\n        drop-shadow(-0.2px  0px 0px black)\n        drop-shadow( 0px  0.2px 0px black)\n        drop-shadow( 0px -0.2px 0px black);\n}\n\n.image-flip-x {\n    transform: scaleX(-1);\n    -webkit-transform: scaleX(-1);\n}\n\n.popup {\n    display: none;\n    position: fixed;\n    max-height: 80vH;\n    top: 50%;\n    left: 50%;\n    transform: translate(-50%, -50%);\n    /* transform: scale(0.25); /\\* Scale down to 75% *\\/ */\n    background: white;\n    padding: 15px;\n    border-radius: 12px;\n    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);\n    width: 400px;\n    z-index: 1000;\n}\n\nnav + div {\n    display: none;\n}\n\ndiv:has(>div.item) {\n    display: flex;\n    flex-direction: row;\n    align-items: stretch;\n}\n\n.item {\n    display: flex;\n    flex: 2;\n    max-height: 100%;\n}\n\n.item > div:first-of-type {\n    flex: 1;\n    align-items: stretch;\n\n}\n\n.item > div:first-of-type > div:last-of-type {\n    flex: 1;\n}\n\n.unrolled-banner {\n    position: absolute;\n    top: -0.5em;\n    left: 10px;\n    padding: 0px 5px;\n    backdrop-filter: blur(10px);\n    color: #888;\n}\n\n.unrolled-divider {\n    margin-top: 1em;\n    border: 1px solid #eee;\n    color: white;\n}\n\n.unrolled-reply {\n    /* border: 1px transparent; */\n    margin: 1px;\n    border: 1px solid transparent;\n    box-sizing: border-box;\n}\n\n.sidecar-replies {\n    flex: 1 1 0;\n    min-height: 0;\n    overflow-y: auto;\n    font-size: 0.8em;\n    padding-left: 10px;\n    display: flex;\n    flex-direction: column;\n    max-height: 50vH;\n}\n\n.sidecar-parent-indicator {\n    position: absolute;\n}\n\n.sidecar-post {\n    display: flex;\n    flex-direction: column;\n    padding: 5px;\n    flex-shrink: 0;\n    font-family: InterVariable, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji";\n}\n\n.sidecar-post a {\n    text-decoration: none;\n}\n\n.sidecar-post a:hover {\n    text-decoration: underline;\n}\n\n.sidecar-post-user-info {\n    display: flex;\n    flex-direction: row;\n    font-size: 0.9em;\n}\n\n.sidecar-post-avatar {\n    width: 24px;\n    height: 24px;\n    padding: 2px;\n}\n\n.sidecar-post-username {\n    font-weight: 600;\n    color: rgb(11, 15, 20);\n}\n\n.sidecar-post-handle {\n    color: rgb(66, 87, 108);\n    font-variant: no-contextual;\n}\n\n.sidecar-post-content {\n    padding: 5px 0px;\n}\n\n.sidecar-post-content a {\n    color: rgb(16, 131, 254);\n}\n\n.sidecar-post-footer {\n    color: rgb(66, 87, 108);\n    display: flex;\n    flex-direction: row;\n    font-size: 11px;\n}\n\n.sidecar-post-footer svg, .sidecar-post-footer span {\n    display: inline-flex;\n    vertical-align: middle;\n    /* flex: 1; */\n    color: rgb(111, 134, 159);\n}\n\n.sidecar-post-timestamp {\n    display: inline-flex;\n    vertical-align: middle;\n    flex: 3;\n}\n\n.sidecar-parent .sidecar-post {\n    border: 3px dashed rgb(111, 134, 159);\n    padding: 5px;\n}\n\n.sidecar-post-counts {\n    display: flex;\n    flex: 2;\n}\n\n.sidecar-count {\n    display: flex;\n    flex: 1;\n    justify-content: right;\n    align-items: center;\n}\n\n.sidecar-count-icon > svg {\n  height: 1em;\n}\n';
  const configCss = "h1 {\n    font-size: 18pt;\n}\n\nh2 {\n    font-size: 14pt;\n}\n.config_var textarea {\n    width: 100%;\n    height: 1.5em;\n}\n\n#GM_config_rulesConfig_var textarea {\n    height: 10em;\n}\n\n#GM_config_stateSyncConfig_var textarea {\n    height: 10em;\n}\n\n\n\n#GM_config_header {\n    position: fixed;\n    background-color: inherit;\n    top: -10px;\n    width: 100%;\n}\n\n@media (prefers-color-scheme: light) {\n    #GM_config_header {\n        background-color: #ffffff;\n    }\n}\n\n@media (prefers-color-scheme: dark) {\n    #GM_config_header {\n        background-color: #29333d;\n    }\n}\n\n#GM_config_section_0 {\n    padding-top: 100px;\n}\n\n#GM_config_buttons_holder {\n    position: fixed;\n    top: 0;\n    right: 0;\n}\n";
  const sidecarTemplatesHtml = '<script id="sidecar-replies-template" type="text/x-handlebars-template">\n  {{#if this.postId}}\n  <div id="sidecar-replies-{{postId}}" class="sidecar-replies">\n  {{#if parent}}\n  <div class="sidecar-parent">\n  <div class="sidecar-parent-indicator">\u2199\uFE0F</div>\n  {{> postTemplate parent}}\n  </div>\n  {{/if}}\n  {{#each replies}}\n  {{> postTemplate this}}\n  {{/each}}\n  </div>\n  {{else}}\n  <div class="sidecar-replies-empty sidecar-replies">\n  </div>    \n  {{/if}}\n<\/script>\n\n<script id="sidecar-post-template" type="text/x-handlebars-template">\n  {{#if postId}}\n  <div id="sidecar-post-{{postId}}" class="sidecar-post">\n  <div class="sidecar-post-user-info">\n  <img id="avatar-{{postId}}" class="sidecar-post-avatar" src="{{avatar}}" alt="User Avatar" loading="lazy">\n  <div class="sidecar-post-author">\n  <a href="https://bsky.app/profile/{{handle}}">\n  <div class="sidecar-post-username">{{displayName}}</div>\n  </a>\n  <a href="https://bsky.app/profile/{{handle}}">\n  <div class="sidecar-post-handle">@{{handle}}</div>\n  </a>\n  </div>\n  </div>\n  {{> bodyTemplate this}}\n  <div class="sidecar-post-footer">\n  <div class="sidecar-post-timestamp">\n  <a href="{{postUrl}}">\n  {{timestamp}}\n  </a>\n  </div>\n  <div class="sidecar-post-counts">\n  <div class="sidecar-count">\n  <div class="sidecar-count-icon sidecar-reply-button">{{{replySvg}}}</div>\n  <div class="sidecar-count-label">{{replyCount}}</div>\n  </div>\n\n  <div class="sidecar-count">\n  <div class="sidecar-count-icon sidecar-repost-button">{{{repostSvg}}}</div>\n  <div class="sidecar-count-label">{{repostCount}}</div>\n  </div>\n\n  <div class="sidecar-count">\n  <div class="sidecar-count-icon sidecar-like-button">{{{likeSvg}}}</div>\n  <div class="sidecar-count-label">{{likeCount}}</div>\n  </div>\n\n  </div>\n  </div>\n  </div>\n  {{else}}\n  <div class="sidecar-post-empty" class="sidecar-post">\n  </div>\n  {{/if}}\n<\/script>\n\n\n<script id="sidecar-body-template" type="text/x-handlebars-template">\n<div class="sidecar-post-body">\n<div class="sidecar-post-content">{{{content}}}</div>\n  {{#if embed}}\n  {{#each embed.images}}\n  {{> imageTemplate this}}\n  {{/each}}\n  {{/if}}\n</div>\n<\/script>\n\n<script id="sidecar-embed-image-template" type="text/x-handlebars-template">\n        <button aria-label="alt text" role="button" tabindex="0" class="css-175oi2r r-1loqt21 r-1otgn73" style="flex: 1 1 0%; overflow: hidden; background-color: rgb(241, 243, 245);" type="button"><div data-expoimage="true" class="css-175oi2r" style="overflow: hidden; flex: 1 1 0%;"><div><img alt="alt text" src="{{thumb}}" loading="lazy" style="object-position: left 50% top 50%; width: 100%; height: 100%; object-fit: cover; transition-duration: 0ms; transition-timing-function: linear;" fetchpriority="auto" title=""></div></div><div class="css-175oi2r" style="position: absolute; inset: 0px; border-radius: 12px 0px 0px 12px; border-width: 1px; border-color: rgb(212, 219, 226); opacity: 0.6; pointer-events: none;"></div></button>\n<\/script>\n';
  const millisecondsInWeek = 6048e5;
  const millisecondsInDay = 864e5;
  const constructFromSymbol = Symbol.for("constructDateFrom");
  function constructFrom(date, value) {
    if (typeof date === "function") return date(value);
    if (date && typeof date === "object" && constructFromSymbol in date)
      return date[constructFromSymbol](value);
    if (date instanceof Date) return new date.constructor(value);
    return new Date(value);
  }
  function toDate(argument, context) {
    return constructFrom(context || argument, argument);
  }
  let defaultOptions = {};
  function getDefaultOptions() {
    return defaultOptions;
  }
  function startOfWeek(date, options) {
    const defaultOptions2 = getDefaultOptions();
    const weekStartsOn = options?.weekStartsOn ?? options?.locale?.options?.weekStartsOn ?? defaultOptions2.weekStartsOn ?? defaultOptions2.locale?.options?.weekStartsOn ?? 0;
    const _date = toDate(date, options?.in);
    const day = _date.getDay();
    const diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
    _date.setDate(_date.getDate() - diff);
    _date.setHours(0, 0, 0, 0);
    return _date;
  }
  function startOfISOWeek(date, options) {
    return startOfWeek(date, { ...options, weekStartsOn: 1 });
  }
  function getISOWeekYear(date, options) {
    const _date = toDate(date, options?.in);
    const year = _date.getFullYear();
    const fourthOfJanuaryOfNextYear = constructFrom(_date, 0);
    fourthOfJanuaryOfNextYear.setFullYear(year + 1, 0, 4);
    fourthOfJanuaryOfNextYear.setHours(0, 0, 0, 0);
    const startOfNextYear = startOfISOWeek(fourthOfJanuaryOfNextYear);
    const fourthOfJanuaryOfThisYear = constructFrom(_date, 0);
    fourthOfJanuaryOfThisYear.setFullYear(year, 0, 4);
    fourthOfJanuaryOfThisYear.setHours(0, 0, 0, 0);
    const startOfThisYear = startOfISOWeek(fourthOfJanuaryOfThisYear);
    if (_date.getTime() >= startOfNextYear.getTime()) {
      return year + 1;
    } else if (_date.getTime() >= startOfThisYear.getTime()) {
      return year;
    } else {
      return year - 1;
    }
  }
  function getTimezoneOffsetInMilliseconds(date) {
    const _date = toDate(date);
    const utcDate = new Date(
      Date.UTC(
        _date.getFullYear(),
        _date.getMonth(),
        _date.getDate(),
        _date.getHours(),
        _date.getMinutes(),
        _date.getSeconds(),
        _date.getMilliseconds()
      )
    );
    utcDate.setUTCFullYear(_date.getFullYear());
    return +date - +utcDate;
  }
  function normalizeDates(context, ...dates) {
    const normalize = constructFrom.bind(
      null,
      dates.find((date) => typeof date === "object")
    );
    return dates.map(normalize);
  }
  function startOfDay(date, options) {
    const _date = toDate(date, options?.in);
    _date.setHours(0, 0, 0, 0);
    return _date;
  }
  function differenceInCalendarDays(laterDate, earlierDate, options) {
    const [laterDate_, earlierDate_] = normalizeDates(
      options?.in,
      laterDate,
      earlierDate
    );
    const laterStartOfDay = startOfDay(laterDate_);
    const earlierStartOfDay = startOfDay(earlierDate_);
    const laterTimestamp = +laterStartOfDay - getTimezoneOffsetInMilliseconds(laterStartOfDay);
    const earlierTimestamp = +earlierStartOfDay - getTimezoneOffsetInMilliseconds(earlierStartOfDay);
    return Math.round((laterTimestamp - earlierTimestamp) / millisecondsInDay);
  }
  function startOfISOWeekYear(date, options) {
    const year = getISOWeekYear(date, options);
    const fourthOfJanuary = constructFrom(date, 0);
    fourthOfJanuary.setFullYear(year, 0, 4);
    fourthOfJanuary.setHours(0, 0, 0, 0);
    return startOfISOWeek(fourthOfJanuary);
  }
  function isDate(value) {
    return value instanceof Date || typeof value === "object" && Object.prototype.toString.call(value) === "[object Date]";
  }
  function isValid(date) {
    return !(!isDate(date) && typeof date !== "number" || isNaN(+toDate(date)));
  }
  function startOfYear(date, options) {
    const date_ = toDate(date, options?.in);
    date_.setFullYear(date_.getFullYear(), 0, 1);
    date_.setHours(0, 0, 0, 0);
    return date_;
  }
  const formatDistanceLocale = {
    lessThanXSeconds: {
      one: "less than a second",
      other: "less than {{count}} seconds"
    },
    xSeconds: {
      one: "1 second",
      other: "{{count}} seconds"
    },
    halfAMinute: "half a minute",
    lessThanXMinutes: {
      one: "less than a minute",
      other: "less than {{count}} minutes"
    },
    xMinutes: {
      one: "1 minute",
      other: "{{count}} minutes"
    },
    aboutXHours: {
      one: "about 1 hour",
      other: "about {{count}} hours"
    },
    xHours: {
      one: "1 hour",
      other: "{{count}} hours"
    },
    xDays: {
      one: "1 day",
      other: "{{count}} days"
    },
    aboutXWeeks: {
      one: "about 1 week",
      other: "about {{count}} weeks"
    },
    xWeeks: {
      one: "1 week",
      other: "{{count}} weeks"
    },
    aboutXMonths: {
      one: "about 1 month",
      other: "about {{count}} months"
    },
    xMonths: {
      one: "1 month",
      other: "{{count}} months"
    },
    aboutXYears: {
      one: "about 1 year",
      other: "about {{count}} years"
    },
    xYears: {
      one: "1 year",
      other: "{{count}} years"
    },
    overXYears: {
      one: "over 1 year",
      other: "over {{count}} years"
    },
    almostXYears: {
      one: "almost 1 year",
      other: "almost {{count}} years"
    }
  };
  const formatDistance = (token, count, options) => {
    let result;
    const tokenValue = formatDistanceLocale[token];
    if (typeof tokenValue === "string") {
      result = tokenValue;
    } else if (count === 1) {
      result = tokenValue.one;
    } else {
      result = tokenValue.other.replace("{{count}}", count.toString());
    }
    if (options?.addSuffix) {
      if (options.comparison && options.comparison > 0) {
        return "in " + result;
      } else {
        return result + " ago";
      }
    }
    return result;
  };
  function buildFormatLongFn(args) {
    return (options = {}) => {
      const width = options.width ? String(options.width) : args.defaultWidth;
      const format2 = args.formats[width] || args.formats[args.defaultWidth];
      return format2;
    };
  }
  const dateFormats = {
    full: "EEEE, MMMM do, y",
    long: "MMMM do, y",
    medium: "MMM d, y",
    short: "MM/dd/yyyy"
  };
  const timeFormats = {
    full: "h:mm:ss a zzzz",
    long: "h:mm:ss a z",
    medium: "h:mm:ss a",
    short: "h:mm a"
  };
  const dateTimeFormats = {
    full: "{{date}} 'at' {{time}}",
    long: "{{date}} 'at' {{time}}",
    medium: "{{date}}, {{time}}",
    short: "{{date}}, {{time}}"
  };
  const formatLong = {
    date: buildFormatLongFn({
      formats: dateFormats,
      defaultWidth: "full"
    }),
    time: buildFormatLongFn({
      formats: timeFormats,
      defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
      formats: dateTimeFormats,
      defaultWidth: "full"
    })
  };
  const formatRelativeLocale = {
    lastWeek: "'last' eeee 'at' p",
    yesterday: "'yesterday at' p",
    today: "'today at' p",
    tomorrow: "'tomorrow at' p",
    nextWeek: "eeee 'at' p",
    other: "P"
  };
  const formatRelative = (token, _date, _baseDate, _options) => formatRelativeLocale[token];
  function buildLocalizeFn(args) {
    return (value, options) => {
      const context = options?.context ? String(options.context) : "standalone";
      let valuesArray;
      if (context === "formatting" && args.formattingValues) {
        const defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
        const width = options?.width ? String(options.width) : defaultWidth;
        valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
      } else {
        const defaultWidth = args.defaultWidth;
        const width = options?.width ? String(options.width) : args.defaultWidth;
        valuesArray = args.values[width] || args.values[defaultWidth];
      }
      const index = args.argumentCallback ? args.argumentCallback(value) : value;
      return valuesArray[index];
    };
  }
  const eraValues = {
    narrow: ["B", "A"],
    abbreviated: ["BC", "AD"],
    wide: ["Before Christ", "Anno Domini"]
  };
  const quarterValues = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["Q1", "Q2", "Q3", "Q4"],
    wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
  };
  const monthValues = {
    narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
    abbreviated: [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ],
    wide: [
      "January",
      "February",
      "March",
      "April",
      "May",
      "June",
      "July",
      "August",
      "September",
      "October",
      "November",
      "December"
    ]
  };
  const dayValues = {
    narrow: ["S", "M", "T", "W", "T", "F", "S"],
    short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
    abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    wide: [
      "Sunday",
      "Monday",
      "Tuesday",
      "Wednesday",
      "Thursday",
      "Friday",
      "Saturday"
    ]
  };
  const dayPeriodValues = {
    narrow: {
      am: "a",
      pm: "p",
      midnight: "mi",
      noon: "n",
      morning: "morning",
      afternoon: "afternoon",
      evening: "evening",
      night: "night"
    },
    abbreviated: {
      am: "AM",
      pm: "PM",
      midnight: "midnight",
      noon: "noon",
      morning: "morning",
      afternoon: "afternoon",
      evening: "evening",
      night: "night"
    },
    wide: {
      am: "a.m.",
      pm: "p.m.",
      midnight: "midnight",
      noon: "noon",
      morning: "morning",
      afternoon: "afternoon",
      evening: "evening",
      night: "night"
    }
  };
  const formattingDayPeriodValues = {
    narrow: {
      am: "a",
      pm: "p",
      midnight: "mi",
      noon: "n",
      morning: "in the morning",
      afternoon: "in the afternoon",
      evening: "in the evening",
      night: "at night"
    },
    abbreviated: {
      am: "AM",
      pm: "PM",
      midnight: "midnight",
      noon: "noon",
      morning: "in the morning",
      afternoon: "in the afternoon",
      evening: "in the evening",
      night: "at night"
    },
    wide: {
      am: "a.m.",
      pm: "p.m.",
      midnight: "midnight",
      noon: "noon",
      morning: "in the morning",
      afternoon: "in the afternoon",
      evening: "in the evening",
      night: "at night"
    }
  };
  const ordinalNumber = (dirtyNumber, _options) => {
    const number = Number(dirtyNumber);
    const rem100 = number % 100;
    if (rem100 > 20 || rem100 < 10) {
      switch (rem100 % 10) {
        case 1:
          return number + "st";
        case 2:
          return number + "nd";
        case 3:
          return number + "rd";
      }
    }
    return number + "th";
  };
  const localize = {
    ordinalNumber,
    era: buildLocalizeFn({
      values: eraValues,
      defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
      values: quarterValues,
      defaultWidth: "wide",
      argumentCallback: (quarter) => quarter - 1
    }),
    month: buildLocalizeFn({
      values: monthValues,
      defaultWidth: "wide"
    }),
    day: buildLocalizeFn({
      values: dayValues,
      defaultWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
      values: dayPeriodValues,
      defaultWidth: "wide",
      formattingValues: formattingDayPeriodValues,
      defaultFormattingWidth: "wide"
    })
  };
  function buildMatchFn(args) {
    return (string2, options = {}) => {
      const width = options.width;
      const matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
      const matchResult = string2.match(matchPattern);
      if (!matchResult) {
        return null;
      }
      const matchedString = matchResult[0];
      const parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
      const key = Array.isArray(parsePatterns) ? findIndex(parsePatterns, (pattern) => pattern.test(matchedString)) : (
        // [TODO] -- I challenge you to fix the type
        findKey(parsePatterns, (pattern) => pattern.test(matchedString))
      );
      let value;
      value = args.valueCallback ? args.valueCallback(key) : key;
      value = options.valueCallback ? (
        // [TODO] -- I challenge you to fix the type
        options.valueCallback(value)
      ) : value;
      const rest = string2.slice(matchedString.length);
      return { value, rest };
    };
  }
  function findKey(object, predicate2) {
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key) && predicate2(object[key])) {
        return key;
      }
    }
    return void 0;
  }
  function findIndex(array, predicate2) {
    for (let key = 0; key < array.length; key++) {
      if (predicate2(array[key])) {
        return key;
      }
    }
    return void 0;
  }
  function buildMatchPatternFn(args) {
    return (string2, options = {}) => {
      const matchResult = string2.match(args.matchPattern);
      if (!matchResult) return null;
      const matchedString = matchResult[0];
      const parseResult = string2.match(args.parsePattern);
      if (!parseResult) return null;
      let value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
      value = options.valueCallback ? options.valueCallback(value) : value;
      const rest = string2.slice(matchedString.length);
      return { value, rest };
    };
  }
  const matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
  const parseOrdinalNumberPattern = /\d+/i;
  const matchEraPatterns = {
    narrow: /^(b|a)/i,
    abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
    wide: /^(before christ|before common era|anno domini|common era)/i
  };
  const parseEraPatterns = {
    any: [/^b/i, /^(a|c)/i]
  };
  const matchQuarterPatterns = {
    narrow: /^[1234]/i,
    abbreviated: /^q[1234]/i,
    wide: /^[1234](th|st|nd|rd)? quarter/i
  };
  const parseQuarterPatterns = {
    any: [/1/i, /2/i, /3/i, /4/i]
  };
  const matchMonthPatterns = {
    narrow: /^[jfmasond]/i,
    abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
    wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
  };
  const parseMonthPatterns = {
    narrow: [
      /^j/i,
      /^f/i,
      /^m/i,
      /^a/i,
      /^m/i,
      /^j/i,
      /^j/i,
      /^a/i,
      /^s/i,
      /^o/i,
      /^n/i,
      /^d/i
    ],
    any: [
      /^ja/i,
      /^f/i,
      /^mar/i,
      /^ap/i,
      /^may/i,
      /^jun/i,
      /^jul/i,
      /^au/i,
      /^s/i,
      /^o/i,
      /^n/i,
      /^d/i
    ]
  };
  const matchDayPatterns = {
    narrow: /^[smtwf]/i,
    short: /^(su|mo|tu|we|th|fr|sa)/i,
    abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
    wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
  };
  const parseDayPatterns = {
    narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
    any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
  };
  const matchDayPeriodPatterns = {
    narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
    any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
  };
  const parseDayPeriodPatterns = {
    any: {
      am: /^a/i,
      pm: /^p/i,
      midnight: /^mi/i,
      noon: /^no/i,
      morning: /morning/i,
      afternoon: /afternoon/i,
      evening: /evening/i,
      night: /night/i
    }
  };
  const match = {
    ordinalNumber: buildMatchPatternFn({
      matchPattern: matchOrdinalNumberPattern,
      parsePattern: parseOrdinalNumberPattern,
      valueCallback: (value) => parseInt(value, 10)
    }),
    era: buildMatchFn({
      matchPatterns: matchEraPatterns,
      defaultMatchWidth: "wide",
      parsePatterns: parseEraPatterns,
      defaultParseWidth: "any"
    }),
    quarter: buildMatchFn({
      matchPatterns: matchQuarterPatterns,
      defaultMatchWidth: "wide",
      parsePatterns: parseQuarterPatterns,
      defaultParseWidth: "any",
      valueCallback: (index) => index + 1
    }),
    month: buildMatchFn({
      matchPatterns: matchMonthPatterns,
      defaultMatchWidth: "wide",
      parsePatterns: parseMonthPatterns,
      defaultParseWidth: "any"
    }),
    day: buildMatchFn({
      matchPatterns: matchDayPatterns,
      defaultMatchWidth: "wide",
      parsePatterns: parseDayPatterns,
      defaultParseWidth: "any"
    }),
    dayPeriod: buildMatchFn({
      matchPatterns: matchDayPeriodPatterns,
      defaultMatchWidth: "any",
      parsePatterns: parseDayPeriodPatterns,
      defaultParseWidth: "any"
    })
  };
  const enUS = {
    code: "en-US",
    formatDistance,
    formatLong,
    formatRelative,
    localize,
    match,
    options: {
      weekStartsOn: 0,
      firstWeekContainsDate: 1
    }
  };
  function getDayOfYear(date, options) {
    const _date = toDate(date, options?.in);
    const diff = differenceInCalendarDays(_date, startOfYear(_date));
    const dayOfYear = diff + 1;
    return dayOfYear;
  }
  function getISOWeek(date, options) {
    const _date = toDate(date, options?.in);
    const diff = +startOfISOWeek(_date) - +startOfISOWeekYear(_date);
    return Math.round(diff / millisecondsInWeek) + 1;
  }
  function getWeekYear(date, options) {
    const _date = toDate(date, options?.in);
    const year = _date.getFullYear();
    const defaultOptions2 = getDefaultOptions();
    const firstWeekContainsDate = options?.firstWeekContainsDate ?? options?.locale?.options?.firstWeekContainsDate ?? defaultOptions2.firstWeekContainsDate ?? defaultOptions2.locale?.options?.firstWeekContainsDate ?? 1;
    const firstWeekOfNextYear = constructFrom(options?.in || date, 0);
    firstWeekOfNextYear.setFullYear(year + 1, 0, firstWeekContainsDate);
    firstWeekOfNextYear.setHours(0, 0, 0, 0);
    const startOfNextYear = startOfWeek(firstWeekOfNextYear, options);
    const firstWeekOfThisYear = constructFrom(options?.in || date, 0);
    firstWeekOfThisYear.setFullYear(year, 0, firstWeekContainsDate);
    firstWeekOfThisYear.setHours(0, 0, 0, 0);
    const startOfThisYear = startOfWeek(firstWeekOfThisYear, options);
    if (+_date >= +startOfNextYear) {
      return year + 1;
    } else if (+_date >= +startOfThisYear) {
      return year;
    } else {
      return year - 1;
    }
  }
  function startOfWeekYear(date, options) {
    const defaultOptions2 = getDefaultOptions();
    const firstWeekContainsDate = options?.firstWeekContainsDate ?? options?.locale?.options?.firstWeekContainsDate ?? defaultOptions2.firstWeekContainsDate ?? defaultOptions2.locale?.options?.firstWeekContainsDate ?? 1;
    const year = getWeekYear(date, options);
    const firstWeek = constructFrom(options?.in || date, 0);
    firstWeek.setFullYear(year, 0, firstWeekContainsDate);
    firstWeek.setHours(0, 0, 0, 0);
    const _date = startOfWeek(firstWeek, options);
    return _date;
  }
  function getWeek(date, options) {
    const _date = toDate(date, options?.in);
    const diff = +startOfWeek(_date, options) - +startOfWeekYear(_date, options);
    return Math.round(diff / millisecondsInWeek) + 1;
  }
  function addLeadingZeros(number, targetLength) {
    const sign = number < 0 ? "-" : "";
    const output = Math.abs(number).toString().padStart(targetLength, "0");
    return sign + output;
  }
  const lightFormatters = {
    // Year
    y(date, token) {
      const signedYear = date.getFullYear();
      const year = signedYear > 0 ? signedYear : 1 - signedYear;
      return addLeadingZeros(token === "yy" ? year % 100 : year, token.length);
    },
    // Month
    M(date, token) {
      const month = date.getMonth();
      return token === "M" ? String(month + 1) : addLeadingZeros(month + 1, 2);
    },
    // Day of the month
    d(date, token) {
      return addLeadingZeros(date.getDate(), token.length);
    },
    // AM or PM
    a(date, token) {
      const dayPeriodEnumValue = date.getHours() / 12 >= 1 ? "pm" : "am";
      switch (token) {
        case "a":
        case "aa":
          return dayPeriodEnumValue.toUpperCase();
        case "aaa":
          return dayPeriodEnumValue;
        case "aaaaa":
          return dayPeriodEnumValue[0];
        case "aaaa":
        default:
          return dayPeriodEnumValue === "am" ? "a.m." : "p.m.";
      }
    },
    // Hour [1-12]
    h(date, token) {
      return addLeadingZeros(date.getHours() % 12 || 12, token.length);
    },
    // Hour [0-23]
    H(date, token) {
      return addLeadingZeros(date.getHours(), token.length);
    },
    // Minute
    m(date, token) {
      return addLeadingZeros(date.getMinutes(), token.length);
    },
    // Second
    s(date, token) {
      return addLeadingZeros(date.getSeconds(), token.length);
    },
    // Fraction of second
    S(date, token) {
      const numberOfDigits = token.length;
      const milliseconds = date.getMilliseconds();
      const fractionalSeconds = Math.trunc(
        milliseconds * Math.pow(10, numberOfDigits - 3)
      );
      return addLeadingZeros(fractionalSeconds, token.length);
    }
  };
  const dayPeriodEnum = {
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  };
  const formatters = {
    // Era
    G: function(date, token, localize2) {
      const era = date.getFullYear() > 0 ? 1 : 0;
      switch (token) {
        // AD, BC
        case "G":
        case "GG":
        case "GGG":
          return localize2.era(era, { width: "abbreviated" });
        // A, B
        case "GGGGG":
          return localize2.era(era, { width: "narrow" });
        // Anno Domini, Before Christ
        case "GGGG":
        default:
          return localize2.era(era, { width: "wide" });
      }
    },
    // Year
    y: function(date, token, localize2) {
      if (token === "yo") {
        const signedYear = date.getFullYear();
        const year = signedYear > 0 ? signedYear : 1 - signedYear;
        return localize2.ordinalNumber(year, { unit: "year" });
      }
      return lightFormatters.y(date, token);
    },
    // Local week-numbering year
    Y: function(date, token, localize2, options) {
      const signedWeekYear = getWeekYear(date, options);
      const weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear;
      if (token === "YY") {
        const twoDigitYear = weekYear % 100;
        return addLeadingZeros(twoDigitYear, 2);
      }
      if (token === "Yo") {
        return localize2.ordinalNumber(weekYear, { unit: "year" });
      }
      return addLeadingZeros(weekYear, token.length);
    },
    // ISO week-numbering year
    R: function(date, token) {
      const isoWeekYear = getISOWeekYear(date);
      return addLeadingZeros(isoWeekYear, token.length);
    },
    // Extended year. This is a single number designating the year of this calendar system.
    // The main difference between `y` and `u` localizers are B.C. years:
    // | Year | `y` | `u` |
    // |------|-----|-----|
    // | AC 1 |   1 |   1 |
    // | BC 1 |   1 |   0 |
    // | BC 2 |   2 |  -1 |
    // Also `yy` always returns the last two digits of a year,
    // while `uu` pads single digit years to 2 characters and returns other years unchanged.
    u: function(date, token) {
      const year = date.getFullYear();
      return addLeadingZeros(year, token.length);
    },
    // Quarter
    Q: function(date, token, localize2) {
      const quarter = Math.ceil((date.getMonth() + 1) / 3);
      switch (token) {
        // 1, 2, 3, 4
        case "Q":
          return String(quarter);
        // 01, 02, 03, 04
        case "QQ":
          return addLeadingZeros(quarter, 2);
        // 1st, 2nd, 3rd, 4th
        case "Qo":
          return localize2.ordinalNumber(quarter, { unit: "quarter" });
        // Q1, Q2, Q3, Q4
        case "QQQ":
          return localize2.quarter(quarter, {
            width: "abbreviated",
            context: "formatting"
          });
        // 1, 2, 3, 4 (narrow quarter; could be not numerical)
        case "QQQQQ":
          return localize2.quarter(quarter, {
            width: "narrow",
            context: "formatting"
          });
        // 1st quarter, 2nd quarter, ...
        case "QQQQ":
        default:
          return localize2.quarter(quarter, {
            width: "wide",
            context: "formatting"
          });
      }
    },
    // Stand-alone quarter
    q: function(date, token, localize2) {
      const quarter = Math.ceil((date.getMonth() + 1) / 3);
      switch (token) {
        // 1, 2, 3, 4
        case "q":
          return String(quarter);
        // 01, 02, 03, 04
        case "qq":
          return addLeadingZeros(quarter, 2);
        // 1st, 2nd, 3rd, 4th
        case "qo":
          return localize2.ordinalNumber(quarter, { unit: "quarter" });
        // Q1, Q2, Q3, Q4
        case "qqq":
          return localize2.quarter(quarter, {
            width: "abbreviated",
            context: "standalone"
          });
        // 1, 2, 3, 4 (narrow quarter; could be not numerical)
        case "qqqqq":
          return localize2.quarter(quarter, {
            width: "narrow",
            context: "standalone"
          });
        // 1st quarter, 2nd quarter, ...
        case "qqqq":
        default:
          return localize2.quarter(quarter, {
            width: "wide",
            context: "standalone"
          });
      }
    },
    // Month
    M: function(date, token, localize2) {
      const month = date.getMonth();
      switch (token) {
        case "M":
        case "MM":
          return lightFormatters.M(date, token);
        // 1st, 2nd, ..., 12th
        case "Mo":
          return localize2.ordinalNumber(month + 1, { unit: "month" });
        // Jan, Feb, ..., Dec
        case "MMM":
          return localize2.month(month, {
            width: "abbreviated",
            context: "formatting"
          });
        // J, F, ..., D
        case "MMMMM":
          return localize2.month(month, {
            width: "narrow",
            context: "formatting"
          });
        // January, February, ..., December
        case "MMMM":
        default:
          return localize2.month(month, { width: "wide", context: "formatting" });
      }
    },
    // Stand-alone month
    L: function(date, token, localize2) {
      const month = date.getMonth();
      switch (token) {
        // 1, 2, ..., 12
        case "L":
          return String(month + 1);
        // 01, 02, ..., 12
        case "LL":
          return addLeadingZeros(month + 1, 2);
        // 1st, 2nd, ..., 12th
        case "Lo":
          return localize2.ordinalNumber(month + 1, { unit: "month" });
        // Jan, Feb, ..., Dec
        case "LLL":
          return localize2.month(month, {
            width: "abbreviated",
            context: "standalone"
          });
        // J, F, ..., D
        case "LLLLL":
          return localize2.month(month, {
            width: "narrow",
            context: "standalone"
          });
        // January, February, ..., December
        case "LLLL":
        default:
          return localize2.month(month, { width: "wide", context: "standalone" });
      }
    },
    // Local week of year
    w: function(date, token, localize2, options) {
      const week = getWeek(date, options);
      if (token === "wo") {
        return localize2.ordinalNumber(week, { unit: "week" });
      }
      return addLeadingZeros(week, token.length);
    },
    // ISO week of year
    I: function(date, token, localize2) {
      const isoWeek = getISOWeek(date);
      if (token === "Io") {
        return localize2.ordinalNumber(isoWeek, { unit: "week" });
      }
      return addLeadingZeros(isoWeek, token.length);
    },
    // Day of the month
    d: function(date, token, localize2) {
      if (token === "do") {
        return localize2.ordinalNumber(date.getDate(), { unit: "date" });
      }
      return lightFormatters.d(date, token);
    },
    // Day of year
    D: function(date, token, localize2) {
      const dayOfYear = getDayOfYear(date);
      if (token === "Do") {
        return localize2.ordinalNumber(dayOfYear, { unit: "dayOfYear" });
      }
      return addLeadingZeros(dayOfYear, token.length);
    },
    // Day of week
    E: function(date, token, localize2) {
      const dayOfWeek = date.getDay();
      switch (token) {
        // Tue
        case "E":
        case "EE":
        case "EEE":
          return localize2.day(dayOfWeek, {
            width: "abbreviated",
            context: "formatting"
          });
        // T
        case "EEEEE":
          return localize2.day(dayOfWeek, {
            width: "narrow",
            context: "formatting"
          });
        // Tu
        case "EEEEEE":
          return localize2.day(dayOfWeek, {
            width: "short",
            context: "formatting"
          });
        // Tuesday
        case "EEEE":
        default:
          return localize2.day(dayOfWeek, {
            width: "wide",
            context: "formatting"
          });
      }
    },
    // Local day of week
    e: function(date, token, localize2, options) {
      const dayOfWeek = date.getDay();
      const localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
      switch (token) {
        // Numerical value (Nth day of week with current locale or weekStartsOn)
        case "e":
          return String(localDayOfWeek);
        // Padded numerical value
        case "ee":
          return addLeadingZeros(localDayOfWeek, 2);
        // 1st, 2nd, ..., 7th
        case "eo":
          return localize2.ordinalNumber(localDayOfWeek, { unit: "day" });
        case "eee":
          return localize2.day(dayOfWeek, {
            width: "abbreviated",
            context: "formatting"
          });
        // T
        case "eeeee":
          return localize2.day(dayOfWeek, {
            width: "narrow",
            context: "formatting"
          });
        // Tu
        case "eeeeee":
          return localize2.day(dayOfWeek, {
            width: "short",
            context: "formatting"
          });
        // Tuesday
        case "eeee":
        default:
          return localize2.day(dayOfWeek, {
            width: "wide",
            context: "formatting"
          });
      }
    },
    // Stand-alone local day of week
    c: function(date, token, localize2, options) {
      const dayOfWeek = date.getDay();
      const localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
      switch (token) {
        // Numerical value (same as in `e`)
        case "c":
          return String(localDayOfWeek);
        // Padded numerical value
        case "cc":
          return addLeadingZeros(localDayOfWeek, token.length);
        // 1st, 2nd, ..., 7th
        case "co":
          return localize2.ordinalNumber(localDayOfWeek, { unit: "day" });
        case "ccc":
          return localize2.day(dayOfWeek, {
            width: "abbreviated",
            context: "standalone"
          });
        // T
        case "ccccc":
          return localize2.day(dayOfWeek, {
            width: "narrow",
            context: "standalone"
          });
        // Tu
        case "cccccc":
          return localize2.day(dayOfWeek, {
            width: "short",
            context: "standalone"
          });
        // Tuesday
        case "cccc":
        default:
          return localize2.day(dayOfWeek, {
            width: "wide",
            context: "standalone"
          });
      }
    },
    // ISO day of week
    i: function(date, token, localize2) {
      const dayOfWeek = date.getDay();
      const isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;
      switch (token) {
        // 2
        case "i":
          return String(isoDayOfWeek);
        // 02
        case "ii":
          return addLeadingZeros(isoDayOfWeek, token.length);
        // 2nd
        case "io":
          return localize2.ordinalNumber(isoDayOfWeek, { unit: "day" });
        // Tue
        case "iii":
          return localize2.day(dayOfWeek, {
            width: "abbreviated",
            context: "formatting"
          });
        // T
        case "iiiii":
          return localize2.day(dayOfWeek, {
            width: "narrow",
            context: "formatting"
          });
        // Tu
        case "iiiiii":
          return localize2.day(dayOfWeek, {
            width: "short",
            context: "formatting"
          });
        // Tuesday
        case "iiii":
        default:
          return localize2.day(dayOfWeek, {
            width: "wide",
            context: "formatting"
          });
      }
    },
    // AM or PM
    a: function(date, token, localize2) {
      const hours = date.getHours();
      const dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
      switch (token) {
        case "a":
        case "aa":
          return localize2.dayPeriod(dayPeriodEnumValue, {
            width: "abbreviated",
            context: "formatting"
          });
        case "aaa":
          return localize2.dayPeriod(dayPeriodEnumValue, {
            width: "abbreviated",
            context: "formatting"
          }).toLowerCase();
        case "aaaaa":
          return localize2.dayPeriod(dayPeriodEnumValue, {
            width: "narrow",
            context: "formatting"
          });
        case "aaaa":
        default:
          return localize2.dayPeriod(dayPeriodEnumValue, {
            width: "wide",
            context: "formatting"
          });
      }
    },
    // AM, PM, midnight, noon
    b: function(date, token, localize2) {
      const hours = date.getHours();
      let dayPeriodEnumValue;
      if (hours === 12) {
        dayPeriodEnumValue = dayPeriodEnum.noon;
      } else if (hours === 0) {
        dayPeriodEnumValue = dayPeriodEnum.midnight;
      } else {
        dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
      }
      switch (token) {
        case "b":
        case "bb":
          return localize2.dayPeriod(dayPeriodEnumValue, {
            width: "abbreviated",
            context: "formatting"
          });
        case "bbb":
          return localize2.dayPeriod(dayPeriodEnumValue, {
            width: "abbreviated",
            context: "formatting"
          }).toLowerCase();
        case "bbbbb":
          return localize2.dayPeriod(dayPeriodEnumValue, {
            width: "narrow",
            context: "formatting"
          });
        case "bbbb":
        default:
          return localize2.dayPeriod(dayPeriodEnumValue, {
            width: "wide",
            context: "formatting"
          });
      }
    },
    // in the morning, in the afternoon, in the evening, at night
    B: function(date, token, localize2) {
      const hours = date.getHours();
      let dayPeriodEnumValue;
      if (hours >= 17) {
        dayPeriodEnumValue = dayPeriodEnum.evening;
      } else if (hours >= 12) {
        dayPeriodEnumValue = dayPeriodEnum.afternoon;
      } else if (hours >= 4) {
        dayPeriodEnumValue = dayPeriodEnum.morning;
      } else {
        dayPeriodEnumValue = dayPeriodEnum.night;
      }
      switch (token) {
        case "B":
        case "BB":
        case "BBB":
          return localize2.dayPeriod(dayPeriodEnumValue, {
            width: "abbreviated",
            context: "formatting"
          });
        case "BBBBB":
          return localize2.dayPeriod(dayPeriodEnumValue, {
            width: "narrow",
            context: "formatting"
          });
        case "BBBB":
        default:
          return localize2.dayPeriod(dayPeriodEnumValue, {
            width: "wide",
            context: "formatting"
          });
      }
    },
    // Hour [1-12]
    h: function(date, token, localize2) {
      if (token === "ho") {
        let hours = date.getHours() % 12;
        if (hours === 0) hours = 12;
        return localize2.ordinalNumber(hours, { unit: "hour" });
      }
      return lightFormatters.h(date, token);
    },
    // Hour [0-23]
    H: function(date, token, localize2) {
      if (token === "Ho") {
        return localize2.ordinalNumber(date.getHours(), { unit: "hour" });
      }
      return lightFormatters.H(date, token);
    },
    // Hour [0-11]
    K: function(date, token, localize2) {
      const hours = date.getHours() % 12;
      if (token === "Ko") {
        return localize2.ordinalNumber(hours, { unit: "hour" });
      }
      return addLeadingZeros(hours, token.length);
    },
    // Hour [1-24]
    k: function(date, token, localize2) {
      let hours = date.getHours();
      if (hours === 0) hours = 24;
      if (token === "ko") {
        return localize2.ordinalNumber(hours, { unit: "hour" });
      }
      return addLeadingZeros(hours, token.length);
    },
    // Minute
    m: function(date, token, localize2) {
      if (token === "mo") {
        return localize2.ordinalNumber(date.getMinutes(), { unit: "minute" });
      }
      return lightFormatters.m(date, token);
    },
    // Second
    s: function(date, token, localize2) {
      if (token === "so") {
        return localize2.ordinalNumber(date.getSeconds(), { unit: "second" });
      }
      return lightFormatters.s(date, token);
    },
    // Fraction of second
    S: function(date, token) {
      return lightFormatters.S(date, token);
    },
    // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
    X: function(date, token, _localize) {
      const timezoneOffset = date.getTimezoneOffset();
      if (timezoneOffset === 0) {
        return "Z";
      }
      switch (token) {
        // Hours and optional minutes
        case "X":
          return formatTimezoneWithOptionalMinutes(timezoneOffset);
        // Hours, minutes and optional seconds without `:` delimiter
        // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
        // so this token always has the same output as `XX`
        case "XXXX":
        case "XX":
          return formatTimezone(timezoneOffset);
        // Hours, minutes and optional seconds with `:` delimiter
        // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
        // so this token always has the same output as `XXX`
        case "XXXXX":
        case "XXX":
        // Hours and minutes with `:` delimiter
        default:
          return formatTimezone(timezoneOffset, ":");
      }
    },
    // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
    x: function(date, token, _localize) {
      const timezoneOffset = date.getTimezoneOffset();
      switch (token) {
        // Hours and optional minutes
        case "x":
          return formatTimezoneWithOptionalMinutes(timezoneOffset);
        // Hours, minutes and optional seconds without `:` delimiter
        // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
        // so this token always has the same output as `xx`
        case "xxxx":
        case "xx":
          return formatTimezone(timezoneOffset);
        // Hours, minutes and optional seconds with `:` delimiter
        // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
        // so this token always has the same output as `xxx`
        case "xxxxx":
        case "xxx":
        // Hours and minutes with `:` delimiter
        default:
          return formatTimezone(timezoneOffset, ":");
      }
    },
    // Timezone (GMT)
    O: function(date, token, _localize) {
      const timezoneOffset = date.getTimezoneOffset();
      switch (token) {
        // Short
        case "O":
        case "OO":
        case "OOO":
          return "GMT" + formatTimezoneShort(timezoneOffset, ":");
        // Long
        case "OOOO":
        default:
          return "GMT" + formatTimezone(timezoneOffset, ":");
      }
    },
    // Timezone (specific non-location)
    z: function(date, token, _localize) {
      const timezoneOffset = date.getTimezoneOffset();
      switch (token) {
        // Short
        case "z":
        case "zz":
        case "zzz":
          return "GMT" + formatTimezoneShort(timezoneOffset, ":");
        // Long
        case "zzzz":
        default:
          return "GMT" + formatTimezone(timezoneOffset, ":");
      }
    },
    // Seconds timestamp
    t: function(date, token, _localize) {
      const timestamp = Math.trunc(+date / 1e3);
      return addLeadingZeros(timestamp, token.length);
    },
    // Milliseconds timestamp
    T: function(date, token, _localize) {
      return addLeadingZeros(+date, token.length);
    }
  };
  function formatTimezoneShort(offset, delimiter = "") {
    const sign = offset > 0 ? "-" : "+";
    const absOffset = Math.abs(offset);
    const hours = Math.trunc(absOffset / 60);
    const minutes = absOffset % 60;
    if (minutes === 0) {
      return sign + String(hours);
    }
    return sign + String(hours) + delimiter + addLeadingZeros(minutes, 2);
  }
  function formatTimezoneWithOptionalMinutes(offset, delimiter) {
    if (offset % 60 === 0) {
      const sign = offset > 0 ? "-" : "+";
      return sign + addLeadingZeros(Math.abs(offset) / 60, 2);
    }
    return formatTimezone(offset, delimiter);
  }
  function formatTimezone(offset, delimiter = "") {
    const sign = offset > 0 ? "-" : "+";
    const absOffset = Math.abs(offset);
    const hours = addLeadingZeros(Math.trunc(absOffset / 60), 2);
    const minutes = addLeadingZeros(absOffset % 60, 2);
    return sign + hours + delimiter + minutes;
  }
  const dateLongFormatter = (pattern, formatLong2) => {
    switch (pattern) {
      case "P":
        return formatLong2.date({ width: "short" });
      case "PP":
        return formatLong2.date({ width: "medium" });
      case "PPP":
        return formatLong2.date({ width: "long" });
      case "PPPP":
      default:
        return formatLong2.date({ width: "full" });
    }
  };
  const timeLongFormatter = (pattern, formatLong2) => {
    switch (pattern) {
      case "p":
        return formatLong2.time({ width: "short" });
      case "pp":
        return formatLong2.time({ width: "medium" });
      case "ppp":
        return formatLong2.time({ width: "long" });
      case "pppp":
      default:
        return formatLong2.time({ width: "full" });
    }
  };
  const dateTimeLongFormatter = (pattern, formatLong2) => {
    const matchResult = pattern.match(/(P+)(p+)?/) || [];
    const datePattern = matchResult[1];
    const timePattern = matchResult[2];
    if (!timePattern) {
      return dateLongFormatter(pattern, formatLong2);
    }
    let dateTimeFormat;
    switch (datePattern) {
      case "P":
        dateTimeFormat = formatLong2.dateTime({ width: "short" });
        break;
      case "PP":
        dateTimeFormat = formatLong2.dateTime({ width: "medium" });
        break;
      case "PPP":
        dateTimeFormat = formatLong2.dateTime({ width: "long" });
        break;
      case "PPPP":
      default:
        dateTimeFormat = formatLong2.dateTime({ width: "full" });
        break;
    }
    return dateTimeFormat.replace("{{date}}", dateLongFormatter(datePattern, formatLong2)).replace("{{time}}", timeLongFormatter(timePattern, formatLong2));
  };
  const longFormatters = {
    p: timeLongFormatter,
    P: dateTimeLongFormatter
  };
  const dayOfYearTokenRE = /^D+$/;
  const weekYearTokenRE = /^Y+$/;
  const throwTokens = ["D", "DD", "YY", "YYYY"];
  function isProtectedDayOfYearToken(token) {
    return dayOfYearTokenRE.test(token);
  }
  function isProtectedWeekYearToken(token) {
    return weekYearTokenRE.test(token);
  }
  function warnOrThrowProtectedError(token, format2, input) {
    const _message = message(token, format2, input);
    console.warn(_message);
    if (throwTokens.includes(token)) throw new RangeError(_message);
  }
  function message(token, format2, input) {
    const subject = token[0] === "Y" ? "years" : "days of the month";
    return `Use \`${token.toLowerCase()}\` instead of \`${token}\` (in \`${format2}\`) for formatting ${subject} to the input \`${input}\`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md`;
  }
  const formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
  const longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
  const escapedStringRegExp = /^'([^]*?)'?$/;
  const doubleQuoteRegExp = /''/g;
  const unescapedLatinCharacterRegExp = /[a-zA-Z]/;
  function format(date, formatStr, options) {
    const defaultOptions2 = getDefaultOptions();
    const locale = defaultOptions2.locale ?? enUS;
    const firstWeekContainsDate = defaultOptions2.firstWeekContainsDate ?? defaultOptions2.locale?.options?.firstWeekContainsDate ?? 1;
    const weekStartsOn = defaultOptions2.weekStartsOn ?? defaultOptions2.locale?.options?.weekStartsOn ?? 0;
    const originalDate = toDate(date, options?.in);
    if (!isValid(originalDate)) {
      throw new RangeError("Invalid time value");
    }
    let parts = formatStr.match(longFormattingTokensRegExp).map((substring) => {
      const firstCharacter = substring[0];
      if (firstCharacter === "p" || firstCharacter === "P") {
        const longFormatter = longFormatters[firstCharacter];
        return longFormatter(substring, locale.formatLong);
      }
      return substring;
    }).join("").match(formattingTokensRegExp).map((substring) => {
      if (substring === "''") {
        return { isToken: false, value: "'" };
      }
      const firstCharacter = substring[0];
      if (firstCharacter === "'") {
        return { isToken: false, value: cleanEscapedString(substring) };
      }
      if (formatters[firstCharacter]) {
        return { isToken: true, value: substring };
      }
      if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
        throw new RangeError(
          "Format string contains an unescaped latin alphabet character `" + firstCharacter + "`"
        );
      }
      return { isToken: false, value: substring };
    });
    if (locale.localize.preprocessor) {
      parts = locale.localize.preprocessor(originalDate, parts);
    }
    const formatterOptions = {
      firstWeekContainsDate,
      weekStartsOn,
      locale
    };
    return parts.map((part) => {
      if (!part.isToken) return part.value;
      const token = part.value;
      if (isProtectedWeekYearToken(token) || isProtectedDayOfYearToken(token)) {
        warnOrThrowProtectedError(token, formatStr, String(date));
      }
      const formatter = formatters[token[0]];
      return formatter(originalDate, token, locale.localize, formatterOptions);
    }).join("");
  }
  function cleanEscapedString(input) {
    const matched = input.match(escapedStringRegExp);
    if (!matched) {
      return input;
    }
    return matched[1].replace(doubleQuoteRegExp, "'");
  }
  var handlebars = { exports: {} };
  var handlebars_runtime = { exports: {} };
  var base$1 = {};
  var utils = {};
  var hasRequiredUtils;
  function requireUtils() {
    if (hasRequiredUtils) return utils;
    hasRequiredUtils = 1;
    utils.__esModule = true;
    utils.extend = extend;
    utils.indexOf = indexOf;
    utils.escapeExpression = escapeExpression;
    utils.isEmpty = isEmpty;
    utils.createFrame = createFrame;
    utils.blockParams = blockParams;
    utils.appendContextPath = appendContextPath;
    var escape = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#x27;",
      "`": "&#x60;",
      "=": "&#x3D;"
    };
    var badChars = /[&<>"'`=]/g, possible = /[&<>"'`=]/;
    function escapeChar(chr) {
      return escape[chr];
    }
    function extend(obj) {
      for (var i = 1; i < arguments.length; i++) {
        for (var key in arguments[i]) {
          if (Object.prototype.hasOwnProperty.call(arguments[i], key)) {
            obj[key] = arguments[i][key];
          }
        }
      }
      return obj;
    }
    var toString2 = Object.prototype.toString;
    utils.toString = toString2;
    var isFunction = function isFunction2(value) {
      return typeof value === "function";
    };
    if (isFunction(/x/)) {
      utils.isFunction = isFunction = function(value) {
        return typeof value === "function" && toString2.call(value) === "[object Function]";
      };
    }
    utils.isFunction = isFunction;
    var isArray = Array.isArray || function(value) {
      return value && typeof value === "object" ? toString2.call(value) === "[object Array]" : false;
    };
    utils.isArray = isArray;
    function indexOf(array, value) {
      for (var i = 0, len = array.length; i < len; i++) {
        if (array[i] === value) {
          return i;
        }
      }
      return -1;
    }
    function escapeExpression(string2) {
      if (typeof string2 !== "string") {
        if (string2 && string2.toHTML) {
          return string2.toHTML();
        } else if (string2 == null) {
          return "";
        } else if (!string2) {
          return string2 + "";
        }
        string2 = "" + string2;
      }
      if (!possible.test(string2)) {
        return string2;
      }
      return string2.replace(badChars, escapeChar);
    }
    function isEmpty(value) {
      if (!value && value !== 0) {
        return true;
      } else if (isArray(value) && value.length === 0) {
        return true;
      } else {
        return false;
      }
    }
    function createFrame(object) {
      var frame = extend({}, object);
      frame._parent = object;
      return frame;
    }
    function blockParams(params, ids) {
      params.path = ids;
      return params;
    }
    function appendContextPath(contextPath, id) {
      return (contextPath ? contextPath + "." : "") + id;
    }
    return utils;
  }
  var exception = { exports: {} };
  var hasRequiredException;
  function requireException() {
    if (hasRequiredException) return exception.exports;
    hasRequiredException = 1;
    (function(module, exports) {
      exports.__esModule = true;
      var errorProps = ["description", "fileName", "lineNumber", "endLineNumber", "message", "name", "number", "stack"];
      function Exception(message2, node) {
        var loc = node && node.loc, line = void 0, endLineNumber = void 0, column = void 0, endColumn = void 0;
        if (loc) {
          line = loc.start.line;
          endLineNumber = loc.end.line;
          column = loc.start.column;
          endColumn = loc.end.column;
          message2 += " - " + line + ":" + column;
        }
        var tmp = Error.prototype.constructor.call(this, message2);
        for (var idx = 0; idx < errorProps.length; idx++) {
          this[errorProps[idx]] = tmp[errorProps[idx]];
        }
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, Exception);
        }
        try {
          if (loc) {
            this.lineNumber = line;
            this.endLineNumber = endLineNumber;
            if (Object.defineProperty) {
              Object.defineProperty(this, "column", {
                value: column,
                enumerable: true
              });
              Object.defineProperty(this, "endColumn", {
                value: endColumn,
                enumerable: true
              });
            } else {
              this.column = column;
              this.endColumn = endColumn;
            }
          }
        } catch (nop) {
        }
      }
      Exception.prototype = new Error();
      exports["default"] = Exception;
      module.exports = exports["default"];
    })(exception, exception.exports);
    return exception.exports;
  }
  var helpers$1 = {};
  var blockHelperMissing = { exports: {} };
  var hasRequiredBlockHelperMissing;
  function requireBlockHelperMissing() {
    if (hasRequiredBlockHelperMissing) return blockHelperMissing.exports;
    hasRequiredBlockHelperMissing = 1;
    (function(module, exports) {
      exports.__esModule = true;
      var _utils = requireUtils();
      exports["default"] = function(instance) {
        instance.registerHelper("blockHelperMissing", function(context, options) {
          var inverse = options.inverse, fn = options.fn;
          if (context === true) {
            return fn(this);
          } else if (context === false || context == null) {
            return inverse(this);
          } else if (_utils.isArray(context)) {
            if (context.length > 0) {
              if (options.ids) {
                options.ids = [options.name];
              }
              return instance.helpers.each(context, options);
            } else {
              return inverse(this);
            }
          } else {
            if (options.data && options.ids) {
              var data = _utils.createFrame(options.data);
              data.contextPath = _utils.appendContextPath(options.data.contextPath, options.name);
              options = { data };
            }
            return fn(context, options);
          }
        });
      };
      module.exports = exports["default"];
    })(blockHelperMissing, blockHelperMissing.exports);
    return blockHelperMissing.exports;
  }
  var each = { exports: {} };
  var hasRequiredEach;
  function requireEach() {
    if (hasRequiredEach) return each.exports;
    hasRequiredEach = 1;
    (function(module, exports) {
      exports.__esModule = true;
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var _utils = requireUtils();
      var _exception = requireException();
      var _exception2 = _interopRequireDefault(_exception);
      exports["default"] = function(instance) {
        instance.registerHelper("each", function(context, options) {
          if (!options) {
            throw new _exception2["default"]("Must pass iterator to #each");
          }
          var fn = options.fn, inverse = options.inverse, i = 0, ret = "", data = void 0, contextPath = void 0;
          if (options.data && options.ids) {
            contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]) + ".";
          }
          if (_utils.isFunction(context)) {
            context = context.call(this);
          }
          if (options.data) {
            data = _utils.createFrame(options.data);
          }
          function execIteration(field, index, last) {
            if (data) {
              data.key = field;
              data.index = index;
              data.first = index === 0;
              data.last = !!last;
              if (contextPath) {
                data.contextPath = contextPath + field;
              }
            }
            ret = ret + fn(context[field], {
              data,
              blockParams: _utils.blockParams([context[field], field], [contextPath + field, null])
            });
          }
          if (context && typeof context === "object") {
            if (_utils.isArray(context)) {
              for (var j = context.length; i < j; i++) {
                if (i in context) {
                  execIteration(i, i, i === context.length - 1);
                }
              }
            } else if (typeof Symbol === "function" && context[Symbol.iterator]) {
              var newContext = [];
              var iterator = context[Symbol.iterator]();
              for (var it = iterator.next(); !it.done; it = iterator.next()) {
                newContext.push(it.value);
              }
              context = newContext;
              for (var j = context.length; i < j; i++) {
                execIteration(i, i, i === context.length - 1);
              }
            } else {
              (function() {
                var priorKey = void 0;
                Object.keys(context).forEach(function(key) {
                  if (priorKey !== void 0) {
                    execIteration(priorKey, i - 1);
                  }
                  priorKey = key;
                  i++;
                });
                if (priorKey !== void 0) {
                  execIteration(priorKey, i - 1, true);
                }
              })();
            }
          }
          if (i === 0) {
            ret = inverse(this);
          }
          return ret;
        });
      };
      module.exports = exports["default"];
    })(each, each.exports);
    return each.exports;
  }
  var helperMissing = { exports: {} };
  var hasRequiredHelperMissing;
  function requireHelperMissing() {
    if (hasRequiredHelperMissing) return helperMissing.exports;
    hasRequiredHelperMissing = 1;
    (function(module, exports) {
      exports.__esModule = true;
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var _exception = requireException();
      var _exception2 = _interopRequireDefault(_exception);
      exports["default"] = function(instance) {
        instance.registerHelper("helperMissing", function() {
          if (arguments.length === 1) {
            return void 0;
          } else {
            throw new _exception2["default"]('Missing helper: "' + arguments[arguments.length - 1].name + '"');
          }
        });
      };
      module.exports = exports["default"];
    })(helperMissing, helperMissing.exports);
    return helperMissing.exports;
  }
  var _if = { exports: {} };
  var hasRequired_if;
  function require_if() {
    if (hasRequired_if) return _if.exports;
    hasRequired_if = 1;
    (function(module, exports) {
      exports.__esModule = true;
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var _utils = requireUtils();
      var _exception = requireException();
      var _exception2 = _interopRequireDefault(_exception);
      exports["default"] = function(instance) {
        instance.registerHelper("if", function(conditional, options) {
          if (arguments.length != 2) {
            throw new _exception2["default"]("#if requires exactly one argument");
          }
          if (_utils.isFunction(conditional)) {
            conditional = conditional.call(this);
          }
          if (!options.hash.includeZero && !conditional || _utils.isEmpty(conditional)) {
            return options.inverse(this);
          } else {
            return options.fn(this);
          }
        });
        instance.registerHelper("unless", function(conditional, options) {
          if (arguments.length != 2) {
            throw new _exception2["default"]("#unless requires exactly one argument");
          }
          return instance.helpers["if"].call(this, conditional, {
            fn: options.inverse,
            inverse: options.fn,
            hash: options.hash
          });
        });
      };
      module.exports = exports["default"];
    })(_if, _if.exports);
    return _if.exports;
  }
  var log = { exports: {} };
  var hasRequiredLog;
  function requireLog() {
    if (hasRequiredLog) return log.exports;
    hasRequiredLog = 1;
    (function(module, exports) {
      exports.__esModule = true;
      exports["default"] = function(instance) {
        instance.registerHelper("log", function() {
          var args = [void 0], options = arguments[arguments.length - 1];
          for (var i = 0; i < arguments.length - 1; i++) {
            args.push(arguments[i]);
          }
          var level = 1;
          if (options.hash.level != null) {
            level = options.hash.level;
          } else if (options.data && options.data.level != null) {
            level = options.data.level;
          }
          args[0] = level;
          instance.log.apply(instance, args);
        });
      };
      module.exports = exports["default"];
    })(log, log.exports);
    return log.exports;
  }
  var lookup = { exports: {} };
  var hasRequiredLookup;
  function requireLookup() {
    if (hasRequiredLookup) return lookup.exports;
    hasRequiredLookup = 1;
    (function(module, exports) {
      exports.__esModule = true;
      exports["default"] = function(instance) {
        instance.registerHelper("lookup", function(obj, field, options) {
          if (!obj) {
            return obj;
          }
          return options.lookupProperty(obj, field);
        });
      };
      module.exports = exports["default"];
    })(lookup, lookup.exports);
    return lookup.exports;
  }
  var _with = { exports: {} };
  var hasRequired_with;
  function require_with() {
    if (hasRequired_with) return _with.exports;
    hasRequired_with = 1;
    (function(module, exports) {
      exports.__esModule = true;
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var _utils = requireUtils();
      var _exception = requireException();
      var _exception2 = _interopRequireDefault(_exception);
      exports["default"] = function(instance) {
        instance.registerHelper("with", function(context, options) {
          if (arguments.length != 2) {
            throw new _exception2["default"]("#with requires exactly one argument");
          }
          if (_utils.isFunction(context)) {
            context = context.call(this);
          }
          var fn = options.fn;
          if (!_utils.isEmpty(context)) {
            var data = options.data;
            if (options.data && options.ids) {
              data = _utils.createFrame(options.data);
              data.contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]);
            }
            return fn(context, {
              data,
              blockParams: _utils.blockParams([context], [data && data.contextPath])
            });
          } else {
            return options.inverse(this);
          }
        });
      };
      module.exports = exports["default"];
    })(_with, _with.exports);
    return _with.exports;
  }
  var hasRequiredHelpers$1;
  function requireHelpers$1() {
    if (hasRequiredHelpers$1) return helpers$1;
    hasRequiredHelpers$1 = 1;
    helpers$1.__esModule = true;
    helpers$1.registerDefaultHelpers = registerDefaultHelpers;
    helpers$1.moveHelperToHooks = moveHelperToHooks;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var _helpersBlockHelperMissing = requireBlockHelperMissing();
    var _helpersBlockHelperMissing2 = _interopRequireDefault(_helpersBlockHelperMissing);
    var _helpersEach = requireEach();
    var _helpersEach2 = _interopRequireDefault(_helpersEach);
    var _helpersHelperMissing = requireHelperMissing();
    var _helpersHelperMissing2 = _interopRequireDefault(_helpersHelperMissing);
    var _helpersIf = require_if();
    var _helpersIf2 = _interopRequireDefault(_helpersIf);
    var _helpersLog = requireLog();
    var _helpersLog2 = _interopRequireDefault(_helpersLog);
    var _helpersLookup = requireLookup();
    var _helpersLookup2 = _interopRequireDefault(_helpersLookup);
    var _helpersWith = require_with();
    var _helpersWith2 = _interopRequireDefault(_helpersWith);
    function registerDefaultHelpers(instance) {
      _helpersBlockHelperMissing2["default"](instance);
      _helpersEach2["default"](instance);
      _helpersHelperMissing2["default"](instance);
      _helpersIf2["default"](instance);
      _helpersLog2["default"](instance);
      _helpersLookup2["default"](instance);
      _helpersWith2["default"](instance);
    }
    function moveHelperToHooks(instance, helperName, keepHelper) {
      if (instance.helpers[helperName]) {
        instance.hooks[helperName] = instance.helpers[helperName];
        if (!keepHelper) {
          delete instance.helpers[helperName];
        }
      }
    }
    return helpers$1;
  }
  var decorators = {};
  var inline = { exports: {} };
  var hasRequiredInline;
  function requireInline() {
    if (hasRequiredInline) return inline.exports;
    hasRequiredInline = 1;
    (function(module, exports) {
      exports.__esModule = true;
      var _utils = requireUtils();
      exports["default"] = function(instance) {
        instance.registerDecorator("inline", function(fn, props, container, options) {
          var ret = fn;
          if (!props.partials) {
            props.partials = {};
            ret = function(context, options2) {
              var original = container.partials;
              container.partials = _utils.extend({}, original, props.partials);
              var ret2 = fn(context, options2);
              container.partials = original;
              return ret2;
            };
          }
          props.partials[options.args[0]] = options.fn;
          return ret;
        });
      };
      module.exports = exports["default"];
    })(inline, inline.exports);
    return inline.exports;
  }
  var hasRequiredDecorators;
  function requireDecorators() {
    if (hasRequiredDecorators) return decorators;
    hasRequiredDecorators = 1;
    decorators.__esModule = true;
    decorators.registerDefaultDecorators = registerDefaultDecorators;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var _decoratorsInline = requireInline();
    var _decoratorsInline2 = _interopRequireDefault(_decoratorsInline);
    function registerDefaultDecorators(instance) {
      _decoratorsInline2["default"](instance);
    }
    return decorators;
  }
  var logger = { exports: {} };
  var hasRequiredLogger;
  function requireLogger() {
    if (hasRequiredLogger) return logger.exports;
    hasRequiredLogger = 1;
    (function(module, exports) {
      exports.__esModule = true;
      var _utils = requireUtils();
      var logger2 = {
        methodMap: ["debug", "info", "warn", "error"],
        level: "info",
        // Maps a given level value to the `methodMap` indexes above.
        lookupLevel: function lookupLevel(level) {
          if (typeof level === "string") {
            var levelMap = _utils.indexOf(logger2.methodMap, level.toLowerCase());
            if (levelMap >= 0) {
              level = levelMap;
            } else {
              level = parseInt(level, 10);
            }
          }
          return level;
        },
        // Can be overridden in the host environment
        log: function log2(level) {
          level = logger2.lookupLevel(level);
          if (typeof console !== "undefined" && logger2.lookupLevel(logger2.level) <= level) {
            var method = logger2.methodMap[level];
            if (!console[method]) {
              method = "log";
            }
            for (var _len = arguments.length, message2 = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              message2[_key - 1] = arguments[_key];
            }
            console[method].apply(console, message2);
          }
        }
      };
      exports["default"] = logger2;
      module.exports = exports["default"];
    })(logger, logger.exports);
    return logger.exports;
  }
  var protoAccess = {};
  var createNewLookupObject = {};
  var hasRequiredCreateNewLookupObject;
  function requireCreateNewLookupObject() {
    if (hasRequiredCreateNewLookupObject) return createNewLookupObject;
    hasRequiredCreateNewLookupObject = 1;
    createNewLookupObject.__esModule = true;
    createNewLookupObject.createNewLookupObject = createNewLookupObject$1;
    var _utils = requireUtils();
    function createNewLookupObject$1() {
      for (var _len = arguments.length, sources = Array(_len), _key = 0; _key < _len; _key++) {
        sources[_key] = arguments[_key];
      }
      return _utils.extend.apply(void 0, [/* @__PURE__ */ Object.create(null)].concat(sources));
    }
    return createNewLookupObject;
  }
  var hasRequiredProtoAccess;
  function requireProtoAccess() {
    if (hasRequiredProtoAccess) return protoAccess;
    hasRequiredProtoAccess = 1;
    protoAccess.__esModule = true;
    protoAccess.createProtoAccessControl = createProtoAccessControl;
    protoAccess.resultIsAllowed = resultIsAllowed;
    protoAccess.resetLoggedProperties = resetLoggedProperties;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var _createNewLookupObject = requireCreateNewLookupObject();
    var _logger = requireLogger();
    var _logger2 = _interopRequireDefault(_logger);
    var loggedProperties = /* @__PURE__ */ Object.create(null);
    function createProtoAccessControl(runtimeOptions) {
      var defaultMethodWhiteList = /* @__PURE__ */ Object.create(null);
      defaultMethodWhiteList["constructor"] = false;
      defaultMethodWhiteList["__defineGetter__"] = false;
      defaultMethodWhiteList["__defineSetter__"] = false;
      defaultMethodWhiteList["__lookupGetter__"] = false;
      var defaultPropertyWhiteList = /* @__PURE__ */ Object.create(null);
      defaultPropertyWhiteList["__proto__"] = false;
      return {
        properties: {
          whitelist: _createNewLookupObject.createNewLookupObject(defaultPropertyWhiteList, runtimeOptions.allowedProtoProperties),
          defaultValue: runtimeOptions.allowProtoPropertiesByDefault
        },
        methods: {
          whitelist: _createNewLookupObject.createNewLookupObject(defaultMethodWhiteList, runtimeOptions.allowedProtoMethods),
          defaultValue: runtimeOptions.allowProtoMethodsByDefault
        }
      };
    }
    function resultIsAllowed(result, protoAccessControl, propertyName) {
      if (typeof result === "function") {
        return checkWhiteList(protoAccessControl.methods, propertyName);
      } else {
        return checkWhiteList(protoAccessControl.properties, propertyName);
      }
    }
    function checkWhiteList(protoAccessControlForType, propertyName) {
      if (protoAccessControlForType.whitelist[propertyName] !== void 0) {
        return protoAccessControlForType.whitelist[propertyName] === true;
      }
      if (protoAccessControlForType.defaultValue !== void 0) {
        return protoAccessControlForType.defaultValue;
      }
      logUnexpecedPropertyAccessOnce(propertyName);
      return false;
    }
    function logUnexpecedPropertyAccessOnce(propertyName) {
      if (loggedProperties[propertyName] !== true) {
        loggedProperties[propertyName] = true;
        _logger2["default"].log("error", 'Handlebars: Access has been denied to resolve the property "' + propertyName + '" because it is not an "own property" of its parent.\nYou can add a runtime option to disable the check or this warning:\nSee https://handlebarsjs.com/api-reference/runtime-options.html#options-to-control-prototype-access for details');
      }
    }
    function resetLoggedProperties() {
      Object.keys(loggedProperties).forEach(function(propertyName) {
        delete loggedProperties[propertyName];
      });
    }
    return protoAccess;
  }
  var hasRequiredBase$1;
  function requireBase$1() {
    if (hasRequiredBase$1) return base$1;
    hasRequiredBase$1 = 1;
    base$1.__esModule = true;
    base$1.HandlebarsEnvironment = HandlebarsEnvironment;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var _utils = requireUtils();
    var _exception = requireException();
    var _exception2 = _interopRequireDefault(_exception);
    var _helpers = requireHelpers$1();
    var _decorators = requireDecorators();
    var _logger = requireLogger();
    var _logger2 = _interopRequireDefault(_logger);
    var _internalProtoAccess = requireProtoAccess();
    var VERSION = "4.7.8";
    base$1.VERSION = VERSION;
    var COMPILER_REVISION = 8;
    base$1.COMPILER_REVISION = COMPILER_REVISION;
    var LAST_COMPATIBLE_COMPILER_REVISION = 7;
    base$1.LAST_COMPATIBLE_COMPILER_REVISION = LAST_COMPATIBLE_COMPILER_REVISION;
    var REVISION_CHANGES = {
      1: "<= 1.0.rc.2",
      // 1.0.rc.2 is actually rev2 but doesn't report it
      2: "== 1.0.0-rc.3",
      3: "== 1.0.0-rc.4",
      4: "== 1.x.x",
      5: "== 2.0.0-alpha.x",
      6: ">= 2.0.0-beta.1",
      7: ">= 4.0.0 <4.3.0",
      8: ">= 4.3.0"
    };
    base$1.REVISION_CHANGES = REVISION_CHANGES;
    var objectType = "[object Object]";
    function HandlebarsEnvironment(helpers2, partials, decorators2) {
      this.helpers = helpers2 || {};
      this.partials = partials || {};
      this.decorators = decorators2 || {};
      _helpers.registerDefaultHelpers(this);
      _decorators.registerDefaultDecorators(this);
    }
    HandlebarsEnvironment.prototype = {
      constructor: HandlebarsEnvironment,
      logger: _logger2["default"],
      log: _logger2["default"].log,
      registerHelper: function registerHelper(name, fn) {
        if (_utils.toString.call(name) === objectType) {
          if (fn) {
            throw new _exception2["default"]("Arg not supported with multiple helpers");
          }
          _utils.extend(this.helpers, name);
        } else {
          this.helpers[name] = fn;
        }
      },
      unregisterHelper: function unregisterHelper(name) {
        delete this.helpers[name];
      },
      registerPartial: function registerPartial(name, partial) {
        if (_utils.toString.call(name) === objectType) {
          _utils.extend(this.partials, name);
        } else {
          if (typeof partial === "undefined") {
            throw new _exception2["default"]('Attempting to register a partial called "' + name + '" as undefined');
          }
          this.partials[name] = partial;
        }
      },
      unregisterPartial: function unregisterPartial(name) {
        delete this.partials[name];
      },
      registerDecorator: function registerDecorator(name, fn) {
        if (_utils.toString.call(name) === objectType) {
          if (fn) {
            throw new _exception2["default"]("Arg not supported with multiple decorators");
          }
          _utils.extend(this.decorators, name);
        } else {
          this.decorators[name] = fn;
        }
      },
      unregisterDecorator: function unregisterDecorator(name) {
        delete this.decorators[name];
      },
      /**
       * Reset the memory of illegal property accesses that have already been logged.
       * @deprecated should only be used in handlebars test-cases
       */
      resetLoggedPropertyAccesses: function resetLoggedPropertyAccesses() {
        _internalProtoAccess.resetLoggedProperties();
      }
    };
    var log2 = _logger2["default"].log;
    base$1.log = log2;
    base$1.createFrame = _utils.createFrame;
    base$1.logger = _logger2["default"];
    return base$1;
  }
  var safeString = { exports: {} };
  var hasRequiredSafeString;
  function requireSafeString() {
    if (hasRequiredSafeString) return safeString.exports;
    hasRequiredSafeString = 1;
    (function(module, exports) {
      exports.__esModule = true;
      function SafeString(string2) {
        this.string = string2;
      }
      SafeString.prototype.toString = SafeString.prototype.toHTML = function() {
        return "" + this.string;
      };
      exports["default"] = SafeString;
      module.exports = exports["default"];
    })(safeString, safeString.exports);
    return safeString.exports;
  }
  var runtime = {};
  var wrapHelper = {};
  var hasRequiredWrapHelper;
  function requireWrapHelper() {
    if (hasRequiredWrapHelper) return wrapHelper;
    hasRequiredWrapHelper = 1;
    wrapHelper.__esModule = true;
    wrapHelper.wrapHelper = wrapHelper$1;
    function wrapHelper$1(helper, transformOptionsFn) {
      if (typeof helper !== "function") {
        return helper;
      }
      var wrapper = function wrapper2() {
        var options = arguments[arguments.length - 1];
        arguments[arguments.length - 1] = transformOptionsFn(options);
        return helper.apply(this, arguments);
      };
      return wrapper;
    }
    return wrapHelper;
  }
  var hasRequiredRuntime;
  function requireRuntime() {
    if (hasRequiredRuntime) return runtime;
    hasRequiredRuntime = 1;
    runtime.__esModule = true;
    runtime.checkRevision = checkRevision;
    runtime.template = template;
    runtime.wrapProgram = wrapProgram;
    runtime.resolvePartial = resolvePartial;
    runtime.invokePartial = invokePartial;
    runtime.noop = noop;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
          }
        }
        newObj["default"] = obj;
        return newObj;
      }
    }
    var _utils = requireUtils();
    var Utils = _interopRequireWildcard(_utils);
    var _exception = requireException();
    var _exception2 = _interopRequireDefault(_exception);
    var _base = requireBase$1();
    var _helpers = requireHelpers$1();
    var _internalWrapHelper = requireWrapHelper();
    var _internalProtoAccess = requireProtoAccess();
    function checkRevision(compilerInfo) {
      var compilerRevision = compilerInfo && compilerInfo[0] || 1, currentRevision = _base.COMPILER_REVISION;
      if (compilerRevision >= _base.LAST_COMPATIBLE_COMPILER_REVISION && compilerRevision <= _base.COMPILER_REVISION) {
        return;
      }
      if (compilerRevision < _base.LAST_COMPATIBLE_COMPILER_REVISION) {
        var runtimeVersions = _base.REVISION_CHANGES[currentRevision], compilerVersions = _base.REVISION_CHANGES[compilerRevision];
        throw new _exception2["default"]("Template was precompiled with an older version of Handlebars than the current runtime. Please update your precompiler to a newer version (" + runtimeVersions + ") or downgrade your runtime to an older version (" + compilerVersions + ").");
      } else {
        throw new _exception2["default"]("Template was precompiled with a newer version of Handlebars than the current runtime. Please update your runtime to a newer version (" + compilerInfo[1] + ").");
      }
    }
    function template(templateSpec, env) {
      if (!env) {
        throw new _exception2["default"]("No environment passed to template");
      }
      if (!templateSpec || !templateSpec.main) {
        throw new _exception2["default"]("Unknown template object: " + typeof templateSpec);
      }
      templateSpec.main.decorator = templateSpec.main_d;
      env.VM.checkRevision(templateSpec.compiler);
      var templateWasPrecompiledWithCompilerV7 = templateSpec.compiler && templateSpec.compiler[0] === 7;
      function invokePartialWrapper(partial, context, options) {
        if (options.hash) {
          context = Utils.extend({}, context, options.hash);
          if (options.ids) {
            options.ids[0] = true;
          }
        }
        partial = env.VM.resolvePartial.call(this, partial, context, options);
        var extendedOptions = Utils.extend({}, options, {
          hooks: this.hooks,
          protoAccessControl: this.protoAccessControl
        });
        var result = env.VM.invokePartial.call(this, partial, context, extendedOptions);
        if (result == null && env.compile) {
          options.partials[options.name] = env.compile(partial, templateSpec.compilerOptions, env);
          result = options.partials[options.name](context, extendedOptions);
        }
        if (result != null) {
          if (options.indent) {
            var lines = result.split("\n");
            for (var i = 0, l = lines.length; i < l; i++) {
              if (!lines[i] && i + 1 === l) {
                break;
              }
              lines[i] = options.indent + lines[i];
            }
            result = lines.join("\n");
          }
          return result;
        } else {
          throw new _exception2["default"]("The partial " + options.name + " could not be compiled when running in runtime-only mode");
        }
      }
      var container = {
        strict: function strict(obj, name, loc) {
          if (!obj || !(name in obj)) {
            throw new _exception2["default"]('"' + name + '" not defined in ' + obj, {
              loc
            });
          }
          return container.lookupProperty(obj, name);
        },
        lookupProperty: function lookupProperty(parent, propertyName) {
          var result = parent[propertyName];
          if (result == null) {
            return result;
          }
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return result;
          }
          if (_internalProtoAccess.resultIsAllowed(result, container.protoAccessControl, propertyName)) {
            return result;
          }
          return void 0;
        },
        lookup: function lookup2(depths, name) {
          var len = depths.length;
          for (var i = 0; i < len; i++) {
            var result = depths[i] && container.lookupProperty(depths[i], name);
            if (result != null) {
              return depths[i][name];
            }
          }
        },
        lambda: function lambda(current, context) {
          return typeof current === "function" ? current.call(context) : current;
        },
        escapeExpression: Utils.escapeExpression,
        invokePartial: invokePartialWrapper,
        fn: function fn(i) {
          var ret2 = templateSpec[i];
          ret2.decorator = templateSpec[i + "_d"];
          return ret2;
        },
        programs: [],
        program: function program(i, data, declaredBlockParams, blockParams, depths) {
          var programWrapper = this.programs[i], fn = this.fn(i);
          if (data || depths || blockParams || declaredBlockParams) {
            programWrapper = wrapProgram(this, i, fn, data, declaredBlockParams, blockParams, depths);
          } else if (!programWrapper) {
            programWrapper = this.programs[i] = wrapProgram(this, i, fn);
          }
          return programWrapper;
        },
        data: function data(value, depth) {
          while (value && depth--) {
            value = value._parent;
          }
          return value;
        },
        mergeIfNeeded: function mergeIfNeeded(param, common) {
          var obj = param || common;
          if (param && common && param !== common) {
            obj = Utils.extend({}, common, param);
          }
          return obj;
        },
        // An empty object to use as replacement for null-contexts
        nullContext: Object.seal({}),
        noop: env.VM.noop,
        compilerInfo: templateSpec.compiler
      };
      function ret(context) {
        var options = arguments.length <= 1 || arguments[1] === void 0 ? {} : arguments[1];
        var data = options.data;
        ret._setup(options);
        if (!options.partial && templateSpec.useData) {
          data = initData(context, data);
        }
        var depths = void 0, blockParams = templateSpec.useBlockParams ? [] : void 0;
        if (templateSpec.useDepths) {
          if (options.depths) {
            depths = context != options.depths[0] ? [context].concat(options.depths) : options.depths;
          } else {
            depths = [context];
          }
        }
        function main(context2) {
          return "" + templateSpec.main(container, context2, container.helpers, container.partials, data, blockParams, depths);
        }
        main = executeDecorators(templateSpec.main, main, container, options.depths || [], data, blockParams);
        return main(context, options);
      }
      ret.isTop = true;
      ret._setup = function(options) {
        if (!options.partial) {
          var mergedHelpers = Utils.extend({}, env.helpers, options.helpers);
          wrapHelpersToPassLookupProperty(mergedHelpers, container);
          container.helpers = mergedHelpers;
          if (templateSpec.usePartial) {
            container.partials = container.mergeIfNeeded(options.partials, env.partials);
          }
          if (templateSpec.usePartial || templateSpec.useDecorators) {
            container.decorators = Utils.extend({}, env.decorators, options.decorators);
          }
          container.hooks = {};
          container.protoAccessControl = _internalProtoAccess.createProtoAccessControl(options);
          var keepHelperInHelpers = options.allowCallsToHelperMissing || templateWasPrecompiledWithCompilerV7;
          _helpers.moveHelperToHooks(container, "helperMissing", keepHelperInHelpers);
          _helpers.moveHelperToHooks(container, "blockHelperMissing", keepHelperInHelpers);
        } else {
          container.protoAccessControl = options.protoAccessControl;
          container.helpers = options.helpers;
          container.partials = options.partials;
          container.decorators = options.decorators;
          container.hooks = options.hooks;
        }
      };
      ret._child = function(i, data, blockParams, depths) {
        if (templateSpec.useBlockParams && !blockParams) {
          throw new _exception2["default"]("must pass block params");
        }
        if (templateSpec.useDepths && !depths) {
          throw new _exception2["default"]("must pass parent depths");
        }
        return wrapProgram(container, i, templateSpec[i], data, 0, blockParams, depths);
      };
      return ret;
    }
    function wrapProgram(container, i, fn, data, declaredBlockParams, blockParams, depths) {
      function prog(context) {
        var options = arguments.length <= 1 || arguments[1] === void 0 ? {} : arguments[1];
        var currentDepths = depths;
        if (depths && context != depths[0] && !(context === container.nullContext && depths[0] === null)) {
          currentDepths = [context].concat(depths);
        }
        return fn(container, context, container.helpers, container.partials, options.data || data, blockParams && [options.blockParams].concat(blockParams), currentDepths);
      }
      prog = executeDecorators(fn, prog, container, depths, data, blockParams);
      prog.program = i;
      prog.depth = depths ? depths.length : 0;
      prog.blockParams = declaredBlockParams || 0;
      return prog;
    }
    function resolvePartial(partial, context, options) {
      if (!partial) {
        if (options.name === "@partial-block") {
          partial = options.data["partial-block"];
        } else {
          partial = options.partials[options.name];
        }
      } else if (!partial.call && !options.name) {
        options.name = partial;
        partial = options.partials[partial];
      }
      return partial;
    }
    function invokePartial(partial, context, options) {
      var currentPartialBlock = options.data && options.data["partial-block"];
      options.partial = true;
      if (options.ids) {
        options.data.contextPath = options.ids[0] || options.data.contextPath;
      }
      var partialBlock = void 0;
      if (options.fn && options.fn !== noop) {
        (function() {
          options.data = _base.createFrame(options.data);
          var fn = options.fn;
          partialBlock = options.data["partial-block"] = function partialBlockWrapper(context2) {
            var options2 = arguments.length <= 1 || arguments[1] === void 0 ? {} : arguments[1];
            options2.data = _base.createFrame(options2.data);
            options2.data["partial-block"] = currentPartialBlock;
            return fn(context2, options2);
          };
          if (fn.partials) {
            options.partials = Utils.extend({}, options.partials, fn.partials);
          }
        })();
      }
      if (partial === void 0 && partialBlock) {
        partial = partialBlock;
      }
      if (partial === void 0) {
        throw new _exception2["default"]("The partial " + options.name + " could not be found");
      } else if (partial instanceof Function) {
        return partial(context, options);
      }
    }
    function noop() {
      return "";
    }
    function initData(context, data) {
      if (!data || !("root" in data)) {
        data = data ? _base.createFrame(data) : {};
        data.root = context;
      }
      return data;
    }
    function executeDecorators(fn, prog, container, depths, data, blockParams) {
      if (fn.decorator) {
        var props = {};
        prog = fn.decorator(prog, props, container, depths && depths[0], data, blockParams, depths);
        Utils.extend(prog, props);
      }
      return prog;
    }
    function wrapHelpersToPassLookupProperty(mergedHelpers, container) {
      Object.keys(mergedHelpers).forEach(function(helperName) {
        var helper = mergedHelpers[helperName];
        mergedHelpers[helperName] = passLookupPropertyOption(helper, container);
      });
    }
    function passLookupPropertyOption(helper, container) {
      var lookupProperty = container.lookupProperty;
      return _internalWrapHelper.wrapHelper(helper, function(options) {
        return Utils.extend({ lookupProperty }, options);
      });
    }
    return runtime;
  }
  var noConflict = { exports: {} };
  var hasRequiredNoConflict;
  function requireNoConflict() {
    if (hasRequiredNoConflict) return noConflict.exports;
    hasRequiredNoConflict = 1;
    (function(module, exports) {
      exports.__esModule = true;
      exports["default"] = function(Handlebars2) {
        (function() {
          if (typeof globalThis === "object") return;
          Object.prototype.__defineGetter__("__magic__", function() {
            return this;
          });
          __magic__.globalThis = __magic__;
          delete Object.prototype.__magic__;
        })();
        var $Handlebars = globalThis.Handlebars;
        Handlebars2.noConflict = function() {
          if (globalThis.Handlebars === Handlebars2) {
            globalThis.Handlebars = $Handlebars;
          }
          return Handlebars2;
        };
      };
      module.exports = exports["default"];
    })(noConflict, noConflict.exports);
    return noConflict.exports;
  }
  var hasRequiredHandlebars_runtime;
  function requireHandlebars_runtime() {
    if (hasRequiredHandlebars_runtime) return handlebars_runtime.exports;
    hasRequiredHandlebars_runtime = 1;
    (function(module, exports) {
      exports.__esModule = true;
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _interopRequireWildcard(obj) {
        if (obj && obj.__esModule) {
          return obj;
        } else {
          var newObj = {};
          if (obj != null) {
            for (var key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
          }
          newObj["default"] = obj;
          return newObj;
        }
      }
      var _handlebarsBase = requireBase$1();
      var base3 = _interopRequireWildcard(_handlebarsBase);
      var _handlebarsSafeString = requireSafeString();
      var _handlebarsSafeString2 = _interopRequireDefault(_handlebarsSafeString);
      var _handlebarsException = requireException();
      var _handlebarsException2 = _interopRequireDefault(_handlebarsException);
      var _handlebarsUtils = requireUtils();
      var Utils = _interopRequireWildcard(_handlebarsUtils);
      var _handlebarsRuntime = requireRuntime();
      var runtime2 = _interopRequireWildcard(_handlebarsRuntime);
      var _handlebarsNoConflict = requireNoConflict();
      var _handlebarsNoConflict2 = _interopRequireDefault(_handlebarsNoConflict);
      function create2() {
        var hb = new base3.HandlebarsEnvironment();
        Utils.extend(hb, base3);
        hb.SafeString = _handlebarsSafeString2["default"];
        hb.Exception = _handlebarsException2["default"];
        hb.Utils = Utils;
        hb.escapeExpression = Utils.escapeExpression;
        hb.VM = runtime2;
        hb.template = function(spec) {
          return runtime2.template(spec, hb);
        };
        return hb;
      }
      var inst = create2();
      inst.create = create2;
      _handlebarsNoConflict2["default"](inst);
      inst["default"] = inst;
      exports["default"] = inst;
      module.exports = exports["default"];
    })(handlebars_runtime, handlebars_runtime.exports);
    return handlebars_runtime.exports;
  }
  var ast = { exports: {} };
  var hasRequiredAst;
  function requireAst() {
    if (hasRequiredAst) return ast.exports;
    hasRequiredAst = 1;
    (function(module, exports) {
      exports.__esModule = true;
      var AST = {
        // Public API used to evaluate derived attributes regarding AST nodes
        helpers: {
          // a mustache is definitely a helper if:
          // * it is an eligible helper, and
          // * it has at least one parameter or hash segment
          helperExpression: function helperExpression(node) {
            return node.type === "SubExpression" || (node.type === "MustacheStatement" || node.type === "BlockStatement") && !!(node.params && node.params.length || node.hash);
          },
          scopedId: function scopedId(path) {
            return /^\.|this\b/.test(path.original);
          },
          // an ID is simple if it only has one part, and that part is not
          // `..` or `this`.
          simpleId: function simpleId(path) {
            return path.parts.length === 1 && !AST.helpers.scopedId(path) && !path.depth;
          }
        }
      };
      exports["default"] = AST;
      module.exports = exports["default"];
    })(ast, ast.exports);
    return ast.exports;
  }
  var base = {};
  var parser = { exports: {} };
  var hasRequiredParser;
  function requireParser() {
    if (hasRequiredParser) return parser.exports;
    hasRequiredParser = 1;
    (function(module, exports) {
      exports.__esModule = true;
      var handlebars2 = function() {
        var parser2 = {
          trace: function trace() {
          },
          yy: {},
          symbols_: { "error": 2, "root": 3, "program": 4, "EOF": 5, "program_repetition0": 6, "statement": 7, "mustache": 8, "block": 9, "rawBlock": 10, "partial": 11, "partialBlock": 12, "content": 13, "COMMENT": 14, "CONTENT": 15, "openRawBlock": 16, "rawBlock_repetition0": 17, "END_RAW_BLOCK": 18, "OPEN_RAW_BLOCK": 19, "helperName": 20, "openRawBlock_repetition0": 21, "openRawBlock_option0": 22, "CLOSE_RAW_BLOCK": 23, "openBlock": 24, "block_option0": 25, "closeBlock": 26, "openInverse": 27, "block_option1": 28, "OPEN_BLOCK": 29, "openBlock_repetition0": 30, "openBlock_option0": 31, "openBlock_option1": 32, "CLOSE": 33, "OPEN_INVERSE": 34, "openInverse_repetition0": 35, "openInverse_option0": 36, "openInverse_option1": 37, "openInverseChain": 38, "OPEN_INVERSE_CHAIN": 39, "openInverseChain_repetition0": 40, "openInverseChain_option0": 41, "openInverseChain_option1": 42, "inverseAndProgram": 43, "INVERSE": 44, "inverseChain": 45, "inverseChain_option0": 46, "OPEN_ENDBLOCK": 47, "OPEN": 48, "mustache_repetition0": 49, "mustache_option0": 50, "OPEN_UNESCAPED": 51, "mustache_repetition1": 52, "mustache_option1": 53, "CLOSE_UNESCAPED": 54, "OPEN_PARTIAL": 55, "partialName": 56, "partial_repetition0": 57, "partial_option0": 58, "openPartialBlock": 59, "OPEN_PARTIAL_BLOCK": 60, "openPartialBlock_repetition0": 61, "openPartialBlock_option0": 62, "param": 63, "sexpr": 64, "OPEN_SEXPR": 65, "sexpr_repetition0": 66, "sexpr_option0": 67, "CLOSE_SEXPR": 68, "hash": 69, "hash_repetition_plus0": 70, "hashSegment": 71, "ID": 72, "EQUALS": 73, "blockParams": 74, "OPEN_BLOCK_PARAMS": 75, "blockParams_repetition_plus0": 76, "CLOSE_BLOCK_PARAMS": 77, "path": 78, "dataName": 79, "STRING": 80, "NUMBER": 81, "BOOLEAN": 82, "UNDEFINED": 83, "NULL": 84, "DATA": 85, "pathSegments": 86, "SEP": 87, "$accept": 0, "$end": 1 },
          terminals_: { 2: "error", 5: "EOF", 14: "COMMENT", 15: "CONTENT", 18: "END_RAW_BLOCK", 19: "OPEN_RAW_BLOCK", 23: "CLOSE_RAW_BLOCK", 29: "OPEN_BLOCK", 33: "CLOSE", 34: "OPEN_INVERSE", 39: "OPEN_INVERSE_CHAIN", 44: "INVERSE", 47: "OPEN_ENDBLOCK", 48: "OPEN", 51: "OPEN_UNESCAPED", 54: "CLOSE_UNESCAPED", 55: "OPEN_PARTIAL", 60: "OPEN_PARTIAL_BLOCK", 65: "OPEN_SEXPR", 68: "CLOSE_SEXPR", 72: "ID", 73: "EQUALS", 75: "OPEN_BLOCK_PARAMS", 77: "CLOSE_BLOCK_PARAMS", 80: "STRING", 81: "NUMBER", 82: "BOOLEAN", 83: "UNDEFINED", 84: "NULL", 85: "DATA", 87: "SEP" },
          productions_: [0, [3, 2], [4, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [13, 1], [10, 3], [16, 5], [9, 4], [9, 4], [24, 6], [27, 6], [38, 6], [43, 2], [45, 3], [45, 1], [26, 3], [8, 5], [8, 5], [11, 5], [12, 3], [59, 5], [63, 1], [63, 1], [64, 5], [69, 1], [71, 3], [74, 3], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [56, 1], [56, 1], [79, 2], [78, 1], [86, 3], [86, 1], [6, 0], [6, 2], [17, 0], [17, 2], [21, 0], [21, 2], [22, 0], [22, 1], [25, 0], [25, 1], [28, 0], [28, 1], [30, 0], [30, 2], [31, 0], [31, 1], [32, 0], [32, 1], [35, 0], [35, 2], [36, 0], [36, 1], [37, 0], [37, 1], [40, 0], [40, 2], [41, 0], [41, 1], [42, 0], [42, 1], [46, 0], [46, 1], [49, 0], [49, 2], [50, 0], [50, 1], [52, 0], [52, 2], [53, 0], [53, 1], [57, 0], [57, 2], [58, 0], [58, 1], [61, 0], [61, 2], [62, 0], [62, 1], [66, 0], [66, 2], [67, 0], [67, 1], [70, 1], [70, 2], [76, 1], [76, 2]],
          performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {
            var $0 = $$.length - 1;
            switch (yystate) {
              case 1:
                return $$[$0 - 1];
              case 2:
                this.$ = yy.prepareProgram($$[$0]);
                break;
              case 3:
                this.$ = $$[$0];
                break;
              case 4:
                this.$ = $$[$0];
                break;
              case 5:
                this.$ = $$[$0];
                break;
              case 6:
                this.$ = $$[$0];
                break;
              case 7:
                this.$ = $$[$0];
                break;
              case 8:
                this.$ = $$[$0];
                break;
              case 9:
                this.$ = {
                  type: "CommentStatement",
                  value: yy.stripComment($$[$0]),
                  strip: yy.stripFlags($$[$0], $$[$0]),
                  loc: yy.locInfo(this._$)
                };
                break;
              case 10:
                this.$ = {
                  type: "ContentStatement",
                  original: $$[$0],
                  value: $$[$0],
                  loc: yy.locInfo(this._$)
                };
                break;
              case 11:
                this.$ = yy.prepareRawBlock($$[$0 - 2], $$[$0 - 1], $$[$0], this._$);
                break;
              case 12:
                this.$ = { path: $$[$0 - 3], params: $$[$0 - 2], hash: $$[$0 - 1] };
                break;
              case 13:
                this.$ = yy.prepareBlock($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0], false, this._$);
                break;
              case 14:
                this.$ = yy.prepareBlock($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0], true, this._$);
                break;
              case 15:
                this.$ = { open: $$[$0 - 5], path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };
                break;
              case 16:
                this.$ = { path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };
                break;
              case 17:
                this.$ = { path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };
                break;
              case 18:
                this.$ = { strip: yy.stripFlags($$[$0 - 1], $$[$0 - 1]), program: $$[$0] };
                break;
              case 19:
                var inverse = yy.prepareBlock($$[$0 - 2], $$[$0 - 1], $$[$0], $$[$0], false, this._$), program = yy.prepareProgram([inverse], $$[$0 - 1].loc);
                program.chained = true;
                this.$ = { strip: $$[$0 - 2].strip, program, chain: true };
                break;
              case 20:
                this.$ = $$[$0];
                break;
              case 21:
                this.$ = { path: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 2], $$[$0]) };
                break;
              case 22:
                this.$ = yy.prepareMustache($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0 - 4], yy.stripFlags($$[$0 - 4], $$[$0]), this._$);
                break;
              case 23:
                this.$ = yy.prepareMustache($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0 - 4], yy.stripFlags($$[$0 - 4], $$[$0]), this._$);
                break;
              case 24:
                this.$ = {
                  type: "PartialStatement",
                  name: $$[$0 - 3],
                  params: $$[$0 - 2],
                  hash: $$[$0 - 1],
                  indent: "",
                  strip: yy.stripFlags($$[$0 - 4], $$[$0]),
                  loc: yy.locInfo(this._$)
                };
                break;
              case 25:
                this.$ = yy.preparePartialBlock($$[$0 - 2], $$[$0 - 1], $$[$0], this._$);
                break;
              case 26:
                this.$ = { path: $$[$0 - 3], params: $$[$0 - 2], hash: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 4], $$[$0]) };
                break;
              case 27:
                this.$ = $$[$0];
                break;
              case 28:
                this.$ = $$[$0];
                break;
              case 29:
                this.$ = {
                  type: "SubExpression",
                  path: $$[$0 - 3],
                  params: $$[$0 - 2],
                  hash: $$[$0 - 1],
                  loc: yy.locInfo(this._$)
                };
                break;
              case 30:
                this.$ = { type: "Hash", pairs: $$[$0], loc: yy.locInfo(this._$) };
                break;
              case 31:
                this.$ = { type: "HashPair", key: yy.id($$[$0 - 2]), value: $$[$0], loc: yy.locInfo(this._$) };
                break;
              case 32:
                this.$ = yy.id($$[$0 - 1]);
                break;
              case 33:
                this.$ = $$[$0];
                break;
              case 34:
                this.$ = $$[$0];
                break;
              case 35:
                this.$ = { type: "StringLiteral", value: $$[$0], original: $$[$0], loc: yy.locInfo(this._$) };
                break;
              case 36:
                this.$ = { type: "NumberLiteral", value: Number($$[$0]), original: Number($$[$0]), loc: yy.locInfo(this._$) };
                break;
              case 37:
                this.$ = { type: "BooleanLiteral", value: $$[$0] === "true", original: $$[$0] === "true", loc: yy.locInfo(this._$) };
                break;
              case 38:
                this.$ = { type: "UndefinedLiteral", original: void 0, value: void 0, loc: yy.locInfo(this._$) };
                break;
              case 39:
                this.$ = { type: "NullLiteral", original: null, value: null, loc: yy.locInfo(this._$) };
                break;
              case 40:
                this.$ = $$[$0];
                break;
              case 41:
                this.$ = $$[$0];
                break;
              case 42:
                this.$ = yy.preparePath(true, $$[$0], this._$);
                break;
              case 43:
                this.$ = yy.preparePath(false, $$[$0], this._$);
                break;
              case 44:
                $$[$0 - 2].push({ part: yy.id($$[$0]), original: $$[$0], separator: $$[$0 - 1] });
                this.$ = $$[$0 - 2];
                break;
              case 45:
                this.$ = [{ part: yy.id($$[$0]), original: $$[$0] }];
                break;
              case 46:
                this.$ = [];
                break;
              case 47:
                $$[$0 - 1].push($$[$0]);
                break;
              case 48:
                this.$ = [];
                break;
              case 49:
                $$[$0 - 1].push($$[$0]);
                break;
              case 50:
                this.$ = [];
                break;
              case 51:
                $$[$0 - 1].push($$[$0]);
                break;
              case 58:
                this.$ = [];
                break;
              case 59:
                $$[$0 - 1].push($$[$0]);
                break;
              case 64:
                this.$ = [];
                break;
              case 65:
                $$[$0 - 1].push($$[$0]);
                break;
              case 70:
                this.$ = [];
                break;
              case 71:
                $$[$0 - 1].push($$[$0]);
                break;
              case 78:
                this.$ = [];
                break;
              case 79:
                $$[$0 - 1].push($$[$0]);
                break;
              case 82:
                this.$ = [];
                break;
              case 83:
                $$[$0 - 1].push($$[$0]);
                break;
              case 86:
                this.$ = [];
                break;
              case 87:
                $$[$0 - 1].push($$[$0]);
                break;
              case 90:
                this.$ = [];
                break;
              case 91:
                $$[$0 - 1].push($$[$0]);
                break;
              case 94:
                this.$ = [];
                break;
              case 95:
                $$[$0 - 1].push($$[$0]);
                break;
              case 98:
                this.$ = [$$[$0]];
                break;
              case 99:
                $$[$0 - 1].push($$[$0]);
                break;
              case 100:
                this.$ = [$$[$0]];
                break;
              case 101:
                $$[$0 - 1].push($$[$0]);
                break;
            }
          },
          table: [{ 3: 1, 4: 2, 5: [2, 46], 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 1: [3] }, { 5: [1, 4] }, { 5: [2, 2], 7: 5, 8: 6, 9: 7, 10: 8, 11: 9, 12: 10, 13: 11, 14: [1, 12], 15: [1, 20], 16: 17, 19: [1, 23], 24: 15, 27: 16, 29: [1, 21], 34: [1, 22], 39: [2, 2], 44: [2, 2], 47: [2, 2], 48: [1, 13], 51: [1, 14], 55: [1, 18], 59: 19, 60: [1, 24] }, { 1: [2, 1] }, { 5: [2, 47], 14: [2, 47], 15: [2, 47], 19: [2, 47], 29: [2, 47], 34: [2, 47], 39: [2, 47], 44: [2, 47], 47: [2, 47], 48: [2, 47], 51: [2, 47], 55: [2, 47], 60: [2, 47] }, { 5: [2, 3], 14: [2, 3], 15: [2, 3], 19: [2, 3], 29: [2, 3], 34: [2, 3], 39: [2, 3], 44: [2, 3], 47: [2, 3], 48: [2, 3], 51: [2, 3], 55: [2, 3], 60: [2, 3] }, { 5: [2, 4], 14: [2, 4], 15: [2, 4], 19: [2, 4], 29: [2, 4], 34: [2, 4], 39: [2, 4], 44: [2, 4], 47: [2, 4], 48: [2, 4], 51: [2, 4], 55: [2, 4], 60: [2, 4] }, { 5: [2, 5], 14: [2, 5], 15: [2, 5], 19: [2, 5], 29: [2, 5], 34: [2, 5], 39: [2, 5], 44: [2, 5], 47: [2, 5], 48: [2, 5], 51: [2, 5], 55: [2, 5], 60: [2, 5] }, { 5: [2, 6], 14: [2, 6], 15: [2, 6], 19: [2, 6], 29: [2, 6], 34: [2, 6], 39: [2, 6], 44: [2, 6], 47: [2, 6], 48: [2, 6], 51: [2, 6], 55: [2, 6], 60: [2, 6] }, { 5: [2, 7], 14: [2, 7], 15: [2, 7], 19: [2, 7], 29: [2, 7], 34: [2, 7], 39: [2, 7], 44: [2, 7], 47: [2, 7], 48: [2, 7], 51: [2, 7], 55: [2, 7], 60: [2, 7] }, { 5: [2, 8], 14: [2, 8], 15: [2, 8], 19: [2, 8], 29: [2, 8], 34: [2, 8], 39: [2, 8], 44: [2, 8], 47: [2, 8], 48: [2, 8], 51: [2, 8], 55: [2, 8], 60: [2, 8] }, { 5: [2, 9], 14: [2, 9], 15: [2, 9], 19: [2, 9], 29: [2, 9], 34: [2, 9], 39: [2, 9], 44: [2, 9], 47: [2, 9], 48: [2, 9], 51: [2, 9], 55: [2, 9], 60: [2, 9] }, { 20: 25, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 36, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 37, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 39: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 4: 38, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 15: [2, 48], 17: 39, 18: [2, 48] }, { 20: 41, 56: 40, 64: 42, 65: [1, 43], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 44, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 5: [2, 10], 14: [2, 10], 15: [2, 10], 18: [2, 10], 19: [2, 10], 29: [2, 10], 34: [2, 10], 39: [2, 10], 44: [2, 10], 47: [2, 10], 48: [2, 10], 51: [2, 10], 55: [2, 10], 60: [2, 10] }, { 20: 45, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 46, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 47, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 41, 56: 48, 64: 42, 65: [1, 43], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [2, 78], 49: 49, 65: [2, 78], 72: [2, 78], 80: [2, 78], 81: [2, 78], 82: [2, 78], 83: [2, 78], 84: [2, 78], 85: [2, 78] }, { 23: [2, 33], 33: [2, 33], 54: [2, 33], 65: [2, 33], 68: [2, 33], 72: [2, 33], 75: [2, 33], 80: [2, 33], 81: [2, 33], 82: [2, 33], 83: [2, 33], 84: [2, 33], 85: [2, 33] }, { 23: [2, 34], 33: [2, 34], 54: [2, 34], 65: [2, 34], 68: [2, 34], 72: [2, 34], 75: [2, 34], 80: [2, 34], 81: [2, 34], 82: [2, 34], 83: [2, 34], 84: [2, 34], 85: [2, 34] }, { 23: [2, 35], 33: [2, 35], 54: [2, 35], 65: [2, 35], 68: [2, 35], 72: [2, 35], 75: [2, 35], 80: [2, 35], 81: [2, 35], 82: [2, 35], 83: [2, 35], 84: [2, 35], 85: [2, 35] }, { 23: [2, 36], 33: [2, 36], 54: [2, 36], 65: [2, 36], 68: [2, 36], 72: [2, 36], 75: [2, 36], 80: [2, 36], 81: [2, 36], 82: [2, 36], 83: [2, 36], 84: [2, 36], 85: [2, 36] }, { 23: [2, 37], 33: [2, 37], 54: [2, 37], 65: [2, 37], 68: [2, 37], 72: [2, 37], 75: [2, 37], 80: [2, 37], 81: [2, 37], 82: [2, 37], 83: [2, 37], 84: [2, 37], 85: [2, 37] }, { 23: [2, 38], 33: [2, 38], 54: [2, 38], 65: [2, 38], 68: [2, 38], 72: [2, 38], 75: [2, 38], 80: [2, 38], 81: [2, 38], 82: [2, 38], 83: [2, 38], 84: [2, 38], 85: [2, 38] }, { 23: [2, 39], 33: [2, 39], 54: [2, 39], 65: [2, 39], 68: [2, 39], 72: [2, 39], 75: [2, 39], 80: [2, 39], 81: [2, 39], 82: [2, 39], 83: [2, 39], 84: [2, 39], 85: [2, 39] }, { 23: [2, 43], 33: [2, 43], 54: [2, 43], 65: [2, 43], 68: [2, 43], 72: [2, 43], 75: [2, 43], 80: [2, 43], 81: [2, 43], 82: [2, 43], 83: [2, 43], 84: [2, 43], 85: [2, 43], 87: [1, 50] }, { 72: [1, 35], 86: 51 }, { 23: [2, 45], 33: [2, 45], 54: [2, 45], 65: [2, 45], 68: [2, 45], 72: [2, 45], 75: [2, 45], 80: [2, 45], 81: [2, 45], 82: [2, 45], 83: [2, 45], 84: [2, 45], 85: [2, 45], 87: [2, 45] }, { 52: 52, 54: [2, 82], 65: [2, 82], 72: [2, 82], 80: [2, 82], 81: [2, 82], 82: [2, 82], 83: [2, 82], 84: [2, 82], 85: [2, 82] }, { 25: 53, 38: 55, 39: [1, 57], 43: 56, 44: [1, 58], 45: 54, 47: [2, 54] }, { 28: 59, 43: 60, 44: [1, 58], 47: [2, 56] }, { 13: 62, 15: [1, 20], 18: [1, 61] }, { 33: [2, 86], 57: 63, 65: [2, 86], 72: [2, 86], 80: [2, 86], 81: [2, 86], 82: [2, 86], 83: [2, 86], 84: [2, 86], 85: [2, 86] }, { 33: [2, 40], 65: [2, 40], 72: [2, 40], 80: [2, 40], 81: [2, 40], 82: [2, 40], 83: [2, 40], 84: [2, 40], 85: [2, 40] }, { 33: [2, 41], 65: [2, 41], 72: [2, 41], 80: [2, 41], 81: [2, 41], 82: [2, 41], 83: [2, 41], 84: [2, 41], 85: [2, 41] }, { 20: 64, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 26: 65, 47: [1, 66] }, { 30: 67, 33: [2, 58], 65: [2, 58], 72: [2, 58], 75: [2, 58], 80: [2, 58], 81: [2, 58], 82: [2, 58], 83: [2, 58], 84: [2, 58], 85: [2, 58] }, { 33: [2, 64], 35: 68, 65: [2, 64], 72: [2, 64], 75: [2, 64], 80: [2, 64], 81: [2, 64], 82: [2, 64], 83: [2, 64], 84: [2, 64], 85: [2, 64] }, { 21: 69, 23: [2, 50], 65: [2, 50], 72: [2, 50], 80: [2, 50], 81: [2, 50], 82: [2, 50], 83: [2, 50], 84: [2, 50], 85: [2, 50] }, { 33: [2, 90], 61: 70, 65: [2, 90], 72: [2, 90], 80: [2, 90], 81: [2, 90], 82: [2, 90], 83: [2, 90], 84: [2, 90], 85: [2, 90] }, { 20: 74, 33: [2, 80], 50: 71, 63: 72, 64: 75, 65: [1, 43], 69: 73, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 72: [1, 79] }, { 23: [2, 42], 33: [2, 42], 54: [2, 42], 65: [2, 42], 68: [2, 42], 72: [2, 42], 75: [2, 42], 80: [2, 42], 81: [2, 42], 82: [2, 42], 83: [2, 42], 84: [2, 42], 85: [2, 42], 87: [1, 50] }, { 20: 74, 53: 80, 54: [2, 84], 63: 81, 64: 75, 65: [1, 43], 69: 82, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 26: 83, 47: [1, 66] }, { 47: [2, 55] }, { 4: 84, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 39: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 47: [2, 20] }, { 20: 85, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 86, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 26: 87, 47: [1, 66] }, { 47: [2, 57] }, { 5: [2, 11], 14: [2, 11], 15: [2, 11], 19: [2, 11], 29: [2, 11], 34: [2, 11], 39: [2, 11], 44: [2, 11], 47: [2, 11], 48: [2, 11], 51: [2, 11], 55: [2, 11], 60: [2, 11] }, { 15: [2, 49], 18: [2, 49] }, { 20: 74, 33: [2, 88], 58: 88, 63: 89, 64: 75, 65: [1, 43], 69: 90, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 65: [2, 94], 66: 91, 68: [2, 94], 72: [2, 94], 80: [2, 94], 81: [2, 94], 82: [2, 94], 83: [2, 94], 84: [2, 94], 85: [2, 94] }, { 5: [2, 25], 14: [2, 25], 15: [2, 25], 19: [2, 25], 29: [2, 25], 34: [2, 25], 39: [2, 25], 44: [2, 25], 47: [2, 25], 48: [2, 25], 51: [2, 25], 55: [2, 25], 60: [2, 25] }, { 20: 92, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 74, 31: 93, 33: [2, 60], 63: 94, 64: 75, 65: [1, 43], 69: 95, 70: 76, 71: 77, 72: [1, 78], 75: [2, 60], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 74, 33: [2, 66], 36: 96, 63: 97, 64: 75, 65: [1, 43], 69: 98, 70: 76, 71: 77, 72: [1, 78], 75: [2, 66], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 74, 22: 99, 23: [2, 52], 63: 100, 64: 75, 65: [1, 43], 69: 101, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 74, 33: [2, 92], 62: 102, 63: 103, 64: 75, 65: [1, 43], 69: 104, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [1, 105] }, { 33: [2, 79], 65: [2, 79], 72: [2, 79], 80: [2, 79], 81: [2, 79], 82: [2, 79], 83: [2, 79], 84: [2, 79], 85: [2, 79] }, { 33: [2, 81] }, { 23: [2, 27], 33: [2, 27], 54: [2, 27], 65: [2, 27], 68: [2, 27], 72: [2, 27], 75: [2, 27], 80: [2, 27], 81: [2, 27], 82: [2, 27], 83: [2, 27], 84: [2, 27], 85: [2, 27] }, { 23: [2, 28], 33: [2, 28], 54: [2, 28], 65: [2, 28], 68: [2, 28], 72: [2, 28], 75: [2, 28], 80: [2, 28], 81: [2, 28], 82: [2, 28], 83: [2, 28], 84: [2, 28], 85: [2, 28] }, { 23: [2, 30], 33: [2, 30], 54: [2, 30], 68: [2, 30], 71: 106, 72: [1, 107], 75: [2, 30] }, { 23: [2, 98], 33: [2, 98], 54: [2, 98], 68: [2, 98], 72: [2, 98], 75: [2, 98] }, { 23: [2, 45], 33: [2, 45], 54: [2, 45], 65: [2, 45], 68: [2, 45], 72: [2, 45], 73: [1, 108], 75: [2, 45], 80: [2, 45], 81: [2, 45], 82: [2, 45], 83: [2, 45], 84: [2, 45], 85: [2, 45], 87: [2, 45] }, { 23: [2, 44], 33: [2, 44], 54: [2, 44], 65: [2, 44], 68: [2, 44], 72: [2, 44], 75: [2, 44], 80: [2, 44], 81: [2, 44], 82: [2, 44], 83: [2, 44], 84: [2, 44], 85: [2, 44], 87: [2, 44] }, { 54: [1, 109] }, { 54: [2, 83], 65: [2, 83], 72: [2, 83], 80: [2, 83], 81: [2, 83], 82: [2, 83], 83: [2, 83], 84: [2, 83], 85: [2, 83] }, { 54: [2, 85] }, { 5: [2, 13], 14: [2, 13], 15: [2, 13], 19: [2, 13], 29: [2, 13], 34: [2, 13], 39: [2, 13], 44: [2, 13], 47: [2, 13], 48: [2, 13], 51: [2, 13], 55: [2, 13], 60: [2, 13] }, { 38: 55, 39: [1, 57], 43: 56, 44: [1, 58], 45: 111, 46: 110, 47: [2, 76] }, { 33: [2, 70], 40: 112, 65: [2, 70], 72: [2, 70], 75: [2, 70], 80: [2, 70], 81: [2, 70], 82: [2, 70], 83: [2, 70], 84: [2, 70], 85: [2, 70] }, { 47: [2, 18] }, { 5: [2, 14], 14: [2, 14], 15: [2, 14], 19: [2, 14], 29: [2, 14], 34: [2, 14], 39: [2, 14], 44: [2, 14], 47: [2, 14], 48: [2, 14], 51: [2, 14], 55: [2, 14], 60: [2, 14] }, { 33: [1, 113] }, { 33: [2, 87], 65: [2, 87], 72: [2, 87], 80: [2, 87], 81: [2, 87], 82: [2, 87], 83: [2, 87], 84: [2, 87], 85: [2, 87] }, { 33: [2, 89] }, { 20: 74, 63: 115, 64: 75, 65: [1, 43], 67: 114, 68: [2, 96], 69: 116, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [1, 117] }, { 32: 118, 33: [2, 62], 74: 119, 75: [1, 120] }, { 33: [2, 59], 65: [2, 59], 72: [2, 59], 75: [2, 59], 80: [2, 59], 81: [2, 59], 82: [2, 59], 83: [2, 59], 84: [2, 59], 85: [2, 59] }, { 33: [2, 61], 75: [2, 61] }, { 33: [2, 68], 37: 121, 74: 122, 75: [1, 120] }, { 33: [2, 65], 65: [2, 65], 72: [2, 65], 75: [2, 65], 80: [2, 65], 81: [2, 65], 82: [2, 65], 83: [2, 65], 84: [2, 65], 85: [2, 65] }, { 33: [2, 67], 75: [2, 67] }, { 23: [1, 123] }, { 23: [2, 51], 65: [2, 51], 72: [2, 51], 80: [2, 51], 81: [2, 51], 82: [2, 51], 83: [2, 51], 84: [2, 51], 85: [2, 51] }, { 23: [2, 53] }, { 33: [1, 124] }, { 33: [2, 91], 65: [2, 91], 72: [2, 91], 80: [2, 91], 81: [2, 91], 82: [2, 91], 83: [2, 91], 84: [2, 91], 85: [2, 91] }, { 33: [2, 93] }, { 5: [2, 22], 14: [2, 22], 15: [2, 22], 19: [2, 22], 29: [2, 22], 34: [2, 22], 39: [2, 22], 44: [2, 22], 47: [2, 22], 48: [2, 22], 51: [2, 22], 55: [2, 22], 60: [2, 22] }, { 23: [2, 99], 33: [2, 99], 54: [2, 99], 68: [2, 99], 72: [2, 99], 75: [2, 99] }, { 73: [1, 108] }, { 20: 74, 63: 125, 64: 75, 65: [1, 43], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 5: [2, 23], 14: [2, 23], 15: [2, 23], 19: [2, 23], 29: [2, 23], 34: [2, 23], 39: [2, 23], 44: [2, 23], 47: [2, 23], 48: [2, 23], 51: [2, 23], 55: [2, 23], 60: [2, 23] }, { 47: [2, 19] }, { 47: [2, 77] }, { 20: 74, 33: [2, 72], 41: 126, 63: 127, 64: 75, 65: [1, 43], 69: 128, 70: 76, 71: 77, 72: [1, 78], 75: [2, 72], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 5: [2, 24], 14: [2, 24], 15: [2, 24], 19: [2, 24], 29: [2, 24], 34: [2, 24], 39: [2, 24], 44: [2, 24], 47: [2, 24], 48: [2, 24], 51: [2, 24], 55: [2, 24], 60: [2, 24] }, { 68: [1, 129] }, { 65: [2, 95], 68: [2, 95], 72: [2, 95], 80: [2, 95], 81: [2, 95], 82: [2, 95], 83: [2, 95], 84: [2, 95], 85: [2, 95] }, { 68: [2, 97] }, { 5: [2, 21], 14: [2, 21], 15: [2, 21], 19: [2, 21], 29: [2, 21], 34: [2, 21], 39: [2, 21], 44: [2, 21], 47: [2, 21], 48: [2, 21], 51: [2, 21], 55: [2, 21], 60: [2, 21] }, { 33: [1, 130] }, { 33: [2, 63] }, { 72: [1, 132], 76: 131 }, { 33: [1, 133] }, { 33: [2, 69] }, { 15: [2, 12], 18: [2, 12] }, { 14: [2, 26], 15: [2, 26], 19: [2, 26], 29: [2, 26], 34: [2, 26], 47: [2, 26], 48: [2, 26], 51: [2, 26], 55: [2, 26], 60: [2, 26] }, { 23: [2, 31], 33: [2, 31], 54: [2, 31], 68: [2, 31], 72: [2, 31], 75: [2, 31] }, { 33: [2, 74], 42: 134, 74: 135, 75: [1, 120] }, { 33: [2, 71], 65: [2, 71], 72: [2, 71], 75: [2, 71], 80: [2, 71], 81: [2, 71], 82: [2, 71], 83: [2, 71], 84: [2, 71], 85: [2, 71] }, { 33: [2, 73], 75: [2, 73] }, { 23: [2, 29], 33: [2, 29], 54: [2, 29], 65: [2, 29], 68: [2, 29], 72: [2, 29], 75: [2, 29], 80: [2, 29], 81: [2, 29], 82: [2, 29], 83: [2, 29], 84: [2, 29], 85: [2, 29] }, { 14: [2, 15], 15: [2, 15], 19: [2, 15], 29: [2, 15], 34: [2, 15], 39: [2, 15], 44: [2, 15], 47: [2, 15], 48: [2, 15], 51: [2, 15], 55: [2, 15], 60: [2, 15] }, { 72: [1, 137], 77: [1, 136] }, { 72: [2, 100], 77: [2, 100] }, { 14: [2, 16], 15: [2, 16], 19: [2, 16], 29: [2, 16], 34: [2, 16], 44: [2, 16], 47: [2, 16], 48: [2, 16], 51: [2, 16], 55: [2, 16], 60: [2, 16] }, { 33: [1, 138] }, { 33: [2, 75] }, { 33: [2, 32] }, { 72: [2, 101], 77: [2, 101] }, { 14: [2, 17], 15: [2, 17], 19: [2, 17], 29: [2, 17], 34: [2, 17], 39: [2, 17], 44: [2, 17], 47: [2, 17], 48: [2, 17], 51: [2, 17], 55: [2, 17], 60: [2, 17] }],
          defaultActions: { 4: [2, 1], 54: [2, 55], 56: [2, 20], 60: [2, 57], 73: [2, 81], 82: [2, 85], 86: [2, 18], 90: [2, 89], 101: [2, 53], 104: [2, 93], 110: [2, 19], 111: [2, 77], 116: [2, 97], 119: [2, 63], 122: [2, 69], 135: [2, 75], 136: [2, 32] },
          parseError: function parseError(str, hash) {
            throw new Error(str);
          },
          parse: function parse(input) {
            var self = this, stack = [0], vstack = [null], lstack = [], table = this.table, yytext = "", yylineno = 0, yyleng = 0;
            this.lexer.setInput(input);
            this.lexer.yy = this.yy;
            this.yy.lexer = this.lexer;
            this.yy.parser = this;
            if (typeof this.lexer.yylloc == "undefined") this.lexer.yylloc = {};
            var yyloc = this.lexer.yylloc;
            lstack.push(yyloc);
            var ranges = this.lexer.options && this.lexer.options.ranges;
            if (typeof this.yy.parseError === "function") this.parseError = this.yy.parseError;
            function lex() {
              var token;
              token = self.lexer.lex() || 1;
              if (typeof token !== "number") {
                token = self.symbols_[token] || token;
              }
              return token;
            }
            var symbol, state2, action, r, yyval = {}, p, len, newState, expected;
            while (true) {
              state2 = stack[stack.length - 1];
              if (this.defaultActions[state2]) {
                action = this.defaultActions[state2];
              } else {
                if (symbol === null || typeof symbol == "undefined") {
                  symbol = lex();
                }
                action = table[state2] && table[state2][symbol];
              }
              if (typeof action === "undefined" || !action.length || !action[0]) {
                var errStr = "";
                {
                  expected = [];
                  for (p in table[state2]) if (this.terminals_[p] && p > 2) {
                    expected.push("'" + this.terminals_[p] + "'");
                  }
                  if (this.lexer.showPosition) {
                    errStr = "Parse error on line " + (yylineno + 1) + ":\n" + this.lexer.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol] || symbol) + "'";
                  } else {
                    errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol == 1 ? "end of input" : "'" + (this.terminals_[symbol] || symbol) + "'");
                  }
                  this.parseError(errStr, { text: this.lexer.match, token: this.terminals_[symbol] || symbol, line: this.lexer.yylineno, loc: yyloc, expected });
                }
              }
              if (action[0] instanceof Array && action.length > 1) {
                throw new Error("Parse Error: multiple actions possible at state: " + state2 + ", token: " + symbol);
              }
              switch (action[0]) {
                case 1:
                  stack.push(symbol);
                  vstack.push(this.lexer.yytext);
                  lstack.push(this.lexer.yylloc);
                  stack.push(action[1]);
                  symbol = null;
                  {
                    yyleng = this.lexer.yyleng;
                    yytext = this.lexer.yytext;
                    yylineno = this.lexer.yylineno;
                    yyloc = this.lexer.yylloc;
                  }
                  break;
                case 2:
                  len = this.productions_[action[1]][1];
                  yyval.$ = vstack[vstack.length - len];
                  yyval._$ = { first_line: lstack[lstack.length - (len || 1)].first_line, last_line: lstack[lstack.length - 1].last_line, first_column: lstack[lstack.length - (len || 1)].first_column, last_column: lstack[lstack.length - 1].last_column };
                  if (ranges) {
                    yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];
                  }
                  r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);
                  if (typeof r !== "undefined") {
                    return r;
                  }
                  if (len) {
                    stack = stack.slice(0, -1 * len * 2);
                    vstack = vstack.slice(0, -1 * len);
                    lstack = lstack.slice(0, -1 * len);
                  }
                  stack.push(this.productions_[action[1]][0]);
                  vstack.push(yyval.$);
                  lstack.push(yyval._$);
                  newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
                  stack.push(newState);
                  break;
                case 3:
                  return true;
              }
            }
            return true;
          }
        };
        var lexer = function() {
          var lexer2 = {
            EOF: 1,
            parseError: function parseError(str, hash) {
              if (this.yy.parser) {
                this.yy.parser.parseError(str, hash);
              } else {
                throw new Error(str);
              }
            },
            setInput: function setInput(input) {
              this._input = input;
              this._more = this._less = this.done = false;
              this.yylineno = this.yyleng = 0;
              this.yytext = this.matched = this.match = "";
              this.conditionStack = ["INITIAL"];
              this.yylloc = { first_line: 1, first_column: 0, last_line: 1, last_column: 0 };
              if (this.options.ranges) this.yylloc.range = [0, 0];
              this.offset = 0;
              return this;
            },
            input: function input() {
              var ch = this._input[0];
              this.yytext += ch;
              this.yyleng++;
              this.offset++;
              this.match += ch;
              this.matched += ch;
              var lines = ch.match(/(?:\r\n?|\n).*/g);
              if (lines) {
                this.yylineno++;
                this.yylloc.last_line++;
              } else {
                this.yylloc.last_column++;
              }
              if (this.options.ranges) this.yylloc.range[1]++;
              this._input = this._input.slice(1);
              return ch;
            },
            unput: function unput(ch) {
              var len = ch.length;
              var lines = ch.split(/(?:\r\n?|\n)/g);
              this._input = ch + this._input;
              this.yytext = this.yytext.substr(0, this.yytext.length - len - 1);
              this.offset -= len;
              var oldLines = this.match.split(/(?:\r\n?|\n)/g);
              this.match = this.match.substr(0, this.match.length - 1);
              this.matched = this.matched.substr(0, this.matched.length - 1);
              if (lines.length - 1) this.yylineno -= lines.length - 1;
              var r = this.yylloc.range;
              this.yylloc = {
                first_line: this.yylloc.first_line,
                last_line: this.yylineno + 1,
                first_column: this.yylloc.first_column,
                last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
              };
              if (this.options.ranges) {
                this.yylloc.range = [r[0], r[0] + this.yyleng - len];
              }
              return this;
            },
            more: function more() {
              this._more = true;
              return this;
            },
            less: function less(n) {
              this.unput(this.match.slice(n));
            },
            pastInput: function pastInput() {
              var past = this.matched.substr(0, this.matched.length - this.match.length);
              return (past.length > 20 ? "..." : "") + past.substr(-20).replace(/\n/g, "");
            },
            upcomingInput: function upcomingInput() {
              var next = this.match;
              if (next.length < 20) {
                next += this._input.substr(0, 20 - next.length);
              }
              return (next.substr(0, 20) + (next.length > 20 ? "..." : "")).replace(/\n/g, "");
            },
            showPosition: function showPosition() {
              var pre = this.pastInput();
              var c = new Array(pre.length + 1).join("-");
              return pre + this.upcomingInput() + "\n" + c + "^";
            },
            next: function next() {
              if (this.done) {
                return this.EOF;
              }
              if (!this._input) this.done = true;
              var token, match2, tempMatch, index, lines;
              if (!this._more) {
                this.yytext = "";
                this.match = "";
              }
              var rules = this._currentRules();
              for (var i = 0; i < rules.length; i++) {
                tempMatch = this._input.match(this.rules[rules[i]]);
                if (tempMatch && (!match2 || tempMatch[0].length > match2[0].length)) {
                  match2 = tempMatch;
                  index = i;
                  if (!this.options.flex) break;
                }
              }
              if (match2) {
                lines = match2[0].match(/(?:\r\n?|\n).*/g);
                if (lines) this.yylineno += lines.length;
                this.yylloc = {
                  first_line: this.yylloc.last_line,
                  last_line: this.yylineno + 1,
                  first_column: this.yylloc.last_column,
                  last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match2[0].length
                };
                this.yytext += match2[0];
                this.match += match2[0];
                this.matches = match2;
                this.yyleng = this.yytext.length;
                if (this.options.ranges) {
                  this.yylloc.range = [this.offset, this.offset += this.yyleng];
                }
                this._more = false;
                this._input = this._input.slice(match2[0].length);
                this.matched += match2[0];
                token = this.performAction.call(this, this.yy, this, rules[index], this.conditionStack[this.conditionStack.length - 1]);
                if (this.done && this._input) this.done = false;
                if (token) return token;
                else return;
              }
              if (this._input === "") {
                return this.EOF;
              } else {
                return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". Unrecognized text.\n" + this.showPosition(), { text: "", token: null, line: this.yylineno });
              }
            },
            lex: function lex() {
              var r = this.next();
              if (typeof r !== "undefined") {
                return r;
              } else {
                return this.lex();
              }
            },
            begin: function begin(condition) {
              this.conditionStack.push(condition);
            },
            popState: function popState() {
              return this.conditionStack.pop();
            },
            _currentRules: function _currentRules() {
              return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
            },
            topState: function topState() {
              return this.conditionStack[this.conditionStack.length - 2];
            },
            pushState: function begin(condition) {
              this.begin(condition);
            }
          };
          lexer2.options = {};
          lexer2.performAction = function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
            function strip(start, end) {
              return yy_.yytext = yy_.yytext.substring(start, yy_.yyleng - end + start);
            }
            switch ($avoiding_name_collisions) {
              case 0:
                if (yy_.yytext.slice(-2) === "\\\\") {
                  strip(0, 1);
                  this.begin("mu");
                } else if (yy_.yytext.slice(-1) === "\\") {
                  strip(0, 1);
                  this.begin("emu");
                } else {
                  this.begin("mu");
                }
                if (yy_.yytext) return 15;
                break;
              case 1:
                return 15;
              case 2:
                this.popState();
                return 15;
              case 3:
                this.begin("raw");
                return 15;
              case 4:
                this.popState();
                if (this.conditionStack[this.conditionStack.length - 1] === "raw") {
                  return 15;
                } else {
                  strip(5, 9);
                  return "END_RAW_BLOCK";
                }
              case 5:
                return 15;
              case 6:
                this.popState();
                return 14;
              case 7:
                return 65;
              case 8:
                return 68;
              case 9:
                return 19;
              case 10:
                this.popState();
                this.begin("raw");
                return 23;
              case 11:
                return 55;
              case 12:
                return 60;
              case 13:
                return 29;
              case 14:
                return 47;
              case 15:
                this.popState();
                return 44;
              case 16:
                this.popState();
                return 44;
              case 17:
                return 34;
              case 18:
                return 39;
              case 19:
                return 51;
              case 20:
                return 48;
              case 21:
                this.unput(yy_.yytext);
                this.popState();
                this.begin("com");
                break;
              case 22:
                this.popState();
                return 14;
              case 23:
                return 48;
              case 24:
                return 73;
              case 25:
                return 72;
              case 26:
                return 72;
              case 27:
                return 87;
              case 28:
                break;
              case 29:
                this.popState();
                return 54;
              case 30:
                this.popState();
                return 33;
              case 31:
                yy_.yytext = strip(1, 2).replace(/\\"/g, '"');
                return 80;
              case 32:
                yy_.yytext = strip(1, 2).replace(/\\'/g, "'");
                return 80;
              case 33:
                return 85;
              case 34:
                return 82;
              case 35:
                return 82;
              case 36:
                return 83;
              case 37:
                return 84;
              case 38:
                return 81;
              case 39:
                return 75;
              case 40:
                return 77;
              case 41:
                return 72;
              case 42:
                yy_.yytext = yy_.yytext.replace(/\\([\\\]])/g, "$1");
                return 72;
              case 43:
                return "INVALID";
              case 44:
                return 5;
            }
          };
          lexer2.rules = [/^(?:[^\x00]*?(?=(\{\{)))/, /^(?:[^\x00]+)/, /^(?:[^\x00]{2,}?(?=(\{\{|\\\{\{|\\\\\{\{|$)))/, /^(?:\{\{\{\{(?=[^/]))/, /^(?:\{\{\{\{\/[^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=[=}\s\/.])\}\}\}\})/, /^(?:[^\x00]+?(?=(\{\{\{\{)))/, /^(?:[\s\S]*?--(~)?\}\})/, /^(?:\()/, /^(?:\))/, /^(?:\{\{\{\{)/, /^(?:\}\}\}\})/, /^(?:\{\{(~)?>)/, /^(?:\{\{(~)?#>)/, /^(?:\{\{(~)?#\*?)/, /^(?:\{\{(~)?\/)/, /^(?:\{\{(~)?\^\s*(~)?\}\})/, /^(?:\{\{(~)?\s*else\s*(~)?\}\})/, /^(?:\{\{(~)?\^)/, /^(?:\{\{(~)?\s*else\b)/, /^(?:\{\{(~)?\{)/, /^(?:\{\{(~)?&)/, /^(?:\{\{(~)?!--)/, /^(?:\{\{(~)?![\s\S]*?\}\})/, /^(?:\{\{(~)?\*?)/, /^(?:=)/, /^(?:\.\.)/, /^(?:\.(?=([=~}\s\/.)|])))/, /^(?:[\/.])/, /^(?:\s+)/, /^(?:\}(~)?\}\})/, /^(?:(~)?\}\})/, /^(?:"(\\["]|[^"])*")/, /^(?:'(\\[']|[^'])*')/, /^(?:@)/, /^(?:true(?=([~}\s)])))/, /^(?:false(?=([~}\s)])))/, /^(?:undefined(?=([~}\s)])))/, /^(?:null(?=([~}\s)])))/, /^(?:-?[0-9]+(?:\.[0-9]+)?(?=([~}\s)])))/, /^(?:as\s+\|)/, /^(?:\|)/, /^(?:([^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=([=~}\s\/.)|]))))/, /^(?:\[(\\\]|[^\]])*\])/, /^(?:.)/, /^(?:$)/];
          lexer2.conditions = { "mu": { "rules": [7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44], "inclusive": false }, "emu": { "rules": [2], "inclusive": false }, "com": { "rules": [6], "inclusive": false }, "raw": { "rules": [3, 4, 5], "inclusive": false }, "INITIAL": { "rules": [0, 1, 44], "inclusive": true } };
          return lexer2;
        }();
        parser2.lexer = lexer;
        function Parser() {
          this.yy = {};
        }
        Parser.prototype = parser2;
        parser2.Parser = Parser;
        return new Parser();
      }();
      exports["default"] = handlebars2;
      module.exports = exports["default"];
    })(parser, parser.exports);
    return parser.exports;
  }
  var whitespaceControl = { exports: {} };
  var visitor = { exports: {} };
  var hasRequiredVisitor;
  function requireVisitor() {
    if (hasRequiredVisitor) return visitor.exports;
    hasRequiredVisitor = 1;
    (function(module, exports) {
      exports.__esModule = true;
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var _exception = requireException();
      var _exception2 = _interopRequireDefault(_exception);
      function Visitor() {
        this.parents = [];
      }
      Visitor.prototype = {
        constructor: Visitor,
        mutating: false,
        // Visits a given value. If mutating, will replace the value if necessary.
        acceptKey: function acceptKey(node, name) {
          var value = this.accept(node[name]);
          if (this.mutating) {
            if (value && !Visitor.prototype[value.type]) {
              throw new _exception2["default"]('Unexpected node type "' + value.type + '" found when accepting ' + name + " on " + node.type);
            }
            node[name] = value;
          }
        },
        // Performs an accept operation with added sanity check to ensure
        // required keys are not removed.
        acceptRequired: function acceptRequired(node, name) {
          this.acceptKey(node, name);
          if (!node[name]) {
            throw new _exception2["default"](node.type + " requires " + name);
          }
        },
        // Traverses a given array. If mutating, empty respnses will be removed
        // for child elements.
        acceptArray: function acceptArray(array) {
          for (var i = 0, l = array.length; i < l; i++) {
            this.acceptKey(array, i);
            if (!array[i]) {
              array.splice(i, 1);
              i--;
              l--;
            }
          }
        },
        accept: function accept(object) {
          if (!object) {
            return;
          }
          if (!this[object.type]) {
            throw new _exception2["default"]("Unknown type: " + object.type, object);
          }
          if (this.current) {
            this.parents.unshift(this.current);
          }
          this.current = object;
          var ret = this[object.type](object);
          this.current = this.parents.shift();
          if (!this.mutating || ret) {
            return ret;
          } else if (ret !== false) {
            return object;
          }
        },
        Program: function Program(program) {
          this.acceptArray(program.body);
        },
        MustacheStatement: visitSubExpression,
        Decorator: visitSubExpression,
        BlockStatement: visitBlock,
        DecoratorBlock: visitBlock,
        PartialStatement: visitPartial,
        PartialBlockStatement: function PartialBlockStatement(partial) {
          visitPartial.call(this, partial);
          this.acceptKey(partial, "program");
        },
        ContentStatement: function ContentStatement() {
        },
        CommentStatement: function CommentStatement() {
        },
        SubExpression: visitSubExpression,
        PathExpression: function PathExpression() {
        },
        StringLiteral: function StringLiteral() {
        },
        NumberLiteral: function NumberLiteral() {
        },
        BooleanLiteral: function BooleanLiteral() {
        },
        UndefinedLiteral: function UndefinedLiteral() {
        },
        NullLiteral: function NullLiteral() {
        },
        Hash: function Hash(hash) {
          this.acceptArray(hash.pairs);
        },
        HashPair: function HashPair(pair) {
          this.acceptRequired(pair, "value");
        }
      };
      function visitSubExpression(mustache) {
        this.acceptRequired(mustache, "path");
        this.acceptArray(mustache.params);
        this.acceptKey(mustache, "hash");
      }
      function visitBlock(block2) {
        visitSubExpression.call(this, block2);
        this.acceptKey(block2, "program");
        this.acceptKey(block2, "inverse");
      }
      function visitPartial(partial) {
        this.acceptRequired(partial, "name");
        this.acceptArray(partial.params);
        this.acceptKey(partial, "hash");
      }
      exports["default"] = Visitor;
      module.exports = exports["default"];
    })(visitor, visitor.exports);
    return visitor.exports;
  }
  var hasRequiredWhitespaceControl;
  function requireWhitespaceControl() {
    if (hasRequiredWhitespaceControl) return whitespaceControl.exports;
    hasRequiredWhitespaceControl = 1;
    (function(module, exports) {
      exports.__esModule = true;
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var _visitor = requireVisitor();
      var _visitor2 = _interopRequireDefault(_visitor);
      function WhitespaceControl() {
        var options = arguments.length <= 0 || arguments[0] === void 0 ? {} : arguments[0];
        this.options = options;
      }
      WhitespaceControl.prototype = new _visitor2["default"]();
      WhitespaceControl.prototype.Program = function(program) {
        var doStandalone = !this.options.ignoreStandalone;
        var isRoot = !this.isRootSeen;
        this.isRootSeen = true;
        var body = program.body;
        for (var i = 0, l = body.length; i < l; i++) {
          var current = body[i], strip = this.accept(current);
          if (!strip) {
            continue;
          }
          var _isPrevWhitespace = isPrevWhitespace(body, i, isRoot), _isNextWhitespace = isNextWhitespace(body, i, isRoot), openStandalone = strip.openStandalone && _isPrevWhitespace, closeStandalone = strip.closeStandalone && _isNextWhitespace, inlineStandalone = strip.inlineStandalone && _isPrevWhitespace && _isNextWhitespace;
          if (strip.close) {
            omitRight(body, i, true);
          }
          if (strip.open) {
            omitLeft(body, i, true);
          }
          if (doStandalone && inlineStandalone) {
            omitRight(body, i);
            if (omitLeft(body, i)) {
              if (current.type === "PartialStatement") {
                current.indent = /([ \t]+$)/.exec(body[i - 1].original)[1];
              }
            }
          }
          if (doStandalone && openStandalone) {
            omitRight((current.program || current.inverse).body);
            omitLeft(body, i);
          }
          if (doStandalone && closeStandalone) {
            omitRight(body, i);
            omitLeft((current.inverse || current.program).body);
          }
        }
        return program;
      };
      WhitespaceControl.prototype.BlockStatement = WhitespaceControl.prototype.DecoratorBlock = WhitespaceControl.prototype.PartialBlockStatement = function(block2) {
        this.accept(block2.program);
        this.accept(block2.inverse);
        var program = block2.program || block2.inverse, inverse = block2.program && block2.inverse, firstInverse = inverse, lastInverse = inverse;
        if (inverse && inverse.chained) {
          firstInverse = inverse.body[0].program;
          while (lastInverse.chained) {
            lastInverse = lastInverse.body[lastInverse.body.length - 1].program;
          }
        }
        var strip = {
          open: block2.openStrip.open,
          close: block2.closeStrip.close,
          // Determine the standalone candiacy. Basically flag our content as being possibly standalone
          // so our parent can determine if we actually are standalone
          openStandalone: isNextWhitespace(program.body),
          closeStandalone: isPrevWhitespace((firstInverse || program).body)
        };
        if (block2.openStrip.close) {
          omitRight(program.body, null, true);
        }
        if (inverse) {
          var inverseStrip = block2.inverseStrip;
          if (inverseStrip.open) {
            omitLeft(program.body, null, true);
          }
          if (inverseStrip.close) {
            omitRight(firstInverse.body, null, true);
          }
          if (block2.closeStrip.open) {
            omitLeft(lastInverse.body, null, true);
          }
          if (!this.options.ignoreStandalone && isPrevWhitespace(program.body) && isNextWhitespace(firstInverse.body)) {
            omitLeft(program.body);
            omitRight(firstInverse.body);
          }
        } else if (block2.closeStrip.open) {
          omitLeft(program.body, null, true);
        }
        return strip;
      };
      WhitespaceControl.prototype.Decorator = WhitespaceControl.prototype.MustacheStatement = function(mustache) {
        return mustache.strip;
      };
      WhitespaceControl.prototype.PartialStatement = WhitespaceControl.prototype.CommentStatement = function(node) {
        var strip = node.strip || {};
        return {
          inlineStandalone: true,
          open: strip.open,
          close: strip.close
        };
      };
      function isPrevWhitespace(body, i, isRoot) {
        if (i === void 0) {
          i = body.length;
        }
        var prev = body[i - 1], sibling = body[i - 2];
        if (!prev) {
          return isRoot;
        }
        if (prev.type === "ContentStatement") {
          return (sibling || !isRoot ? /\r?\n\s*?$/ : /(^|\r?\n)\s*?$/).test(prev.original);
        }
      }
      function isNextWhitespace(body, i, isRoot) {
        if (i === void 0) {
          i = -1;
        }
        var next = body[i + 1], sibling = body[i + 2];
        if (!next) {
          return isRoot;
        }
        if (next.type === "ContentStatement") {
          return (sibling || !isRoot ? /^\s*?\r?\n/ : /^\s*?(\r?\n|$)/).test(next.original);
        }
      }
      function omitRight(body, i, multiple) {
        var current = body[i == null ? 0 : i + 1];
        if (!current || current.type !== "ContentStatement" || !multiple && current.rightStripped) {
          return;
        }
        var original = current.value;
        current.value = current.value.replace(multiple ? /^\s+/ : /^[ \t]*\r?\n?/, "");
        current.rightStripped = current.value !== original;
      }
      function omitLeft(body, i, multiple) {
        var current = body[i == null ? body.length - 1 : i - 1];
        if (!current || current.type !== "ContentStatement" || !multiple && current.leftStripped) {
          return;
        }
        var original = current.value;
        current.value = current.value.replace(multiple ? /\s+$/ : /[ \t]+$/, "");
        current.leftStripped = current.value !== original;
        return current.leftStripped;
      }
      exports["default"] = WhitespaceControl;
      module.exports = exports["default"];
    })(whitespaceControl, whitespaceControl.exports);
    return whitespaceControl.exports;
  }
  var helpers = {};
  var hasRequiredHelpers;
  function requireHelpers() {
    if (hasRequiredHelpers) return helpers;
    hasRequiredHelpers = 1;
    helpers.__esModule = true;
    helpers.SourceLocation = SourceLocation;
    helpers.id = id;
    helpers.stripFlags = stripFlags;
    helpers.stripComment = stripComment;
    helpers.preparePath = preparePath;
    helpers.prepareMustache = prepareMustache;
    helpers.prepareRawBlock = prepareRawBlock;
    helpers.prepareBlock = prepareBlock;
    helpers.prepareProgram = prepareProgram;
    helpers.preparePartialBlock = preparePartialBlock;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var _exception = requireException();
    var _exception2 = _interopRequireDefault(_exception);
    function validateClose(open, close) {
      close = close.path ? close.path.original : close;
      if (open.path.original !== close) {
        var errorNode = { loc: open.path.loc };
        throw new _exception2["default"](open.path.original + " doesn't match " + close, errorNode);
      }
    }
    function SourceLocation(source, locInfo) {
      this.source = source;
      this.start = {
        line: locInfo.first_line,
        column: locInfo.first_column
      };
      this.end = {
        line: locInfo.last_line,
        column: locInfo.last_column
      };
    }
    function id(token) {
      if (/^\[.*\]$/.test(token)) {
        return token.substring(1, token.length - 1);
      } else {
        return token;
      }
    }
    function stripFlags(open, close) {
      return {
        open: open.charAt(2) === "~",
        close: close.charAt(close.length - 3) === "~"
      };
    }
    function stripComment(comment) {
      return comment.replace(/^\{\{~?!-?-?/, "").replace(/-?-?~?\}\}$/, "");
    }
    function preparePath(data, parts, loc) {
      loc = this.locInfo(loc);
      var original = data ? "@" : "", dig = [], depth = 0;
      for (var i = 0, l = parts.length; i < l; i++) {
        var part = parts[i].part, isLiteral = parts[i].original !== part;
        original += (parts[i].separator || "") + part;
        if (!isLiteral && (part === ".." || part === "." || part === "this")) {
          if (dig.length > 0) {
            throw new _exception2["default"]("Invalid path: " + original, { loc });
          } else if (part === "..") {
            depth++;
          }
        } else {
          dig.push(part);
        }
      }
      return {
        type: "PathExpression",
        data,
        depth,
        parts: dig,
        original,
        loc
      };
    }
    function prepareMustache(path, params, hash, open, strip, locInfo) {
      var escapeFlag = open.charAt(3) || open.charAt(2), escaped = escapeFlag !== "{" && escapeFlag !== "&";
      var decorator = /\*/.test(open);
      return {
        type: decorator ? "Decorator" : "MustacheStatement",
        path,
        params,
        hash,
        escaped,
        strip,
        loc: this.locInfo(locInfo)
      };
    }
    function prepareRawBlock(openRawBlock, contents, close, locInfo) {
      validateClose(openRawBlock, close);
      locInfo = this.locInfo(locInfo);
      var program = {
        type: "Program",
        body: contents,
        strip: {},
        loc: locInfo
      };
      return {
        type: "BlockStatement",
        path: openRawBlock.path,
        params: openRawBlock.params,
        hash: openRawBlock.hash,
        program,
        openStrip: {},
        inverseStrip: {},
        closeStrip: {},
        loc: locInfo
      };
    }
    function prepareBlock(openBlock, program, inverseAndProgram, close, inverted, locInfo) {
      if (close && close.path) {
        validateClose(openBlock, close);
      }
      var decorator = /\*/.test(openBlock.open);
      program.blockParams = openBlock.blockParams;
      var inverse = void 0, inverseStrip = void 0;
      if (inverseAndProgram) {
        if (decorator) {
          throw new _exception2["default"]("Unexpected inverse block on decorator", inverseAndProgram);
        }
        if (inverseAndProgram.chain) {
          inverseAndProgram.program.body[0].closeStrip = close.strip;
        }
        inverseStrip = inverseAndProgram.strip;
        inverse = inverseAndProgram.program;
      }
      if (inverted) {
        inverted = inverse;
        inverse = program;
        program = inverted;
      }
      return {
        type: decorator ? "DecoratorBlock" : "BlockStatement",
        path: openBlock.path,
        params: openBlock.params,
        hash: openBlock.hash,
        program,
        inverse,
        openStrip: openBlock.strip,
        inverseStrip,
        closeStrip: close && close.strip,
        loc: this.locInfo(locInfo)
      };
    }
    function prepareProgram(statements, loc) {
      if (!loc && statements.length) {
        var firstLoc = statements[0].loc, lastLoc = statements[statements.length - 1].loc;
        if (firstLoc && lastLoc) {
          loc = {
            source: firstLoc.source,
            start: {
              line: firstLoc.start.line,
              column: firstLoc.start.column
            },
            end: {
              line: lastLoc.end.line,
              column: lastLoc.end.column
            }
          };
        }
      }
      return {
        type: "Program",
        body: statements,
        strip: {},
        loc
      };
    }
    function preparePartialBlock(open, program, close, locInfo) {
      validateClose(open, close);
      return {
        type: "PartialBlockStatement",
        name: open.path,
        params: open.params,
        hash: open.hash,
        program,
        openStrip: open.strip,
        closeStrip: close && close.strip,
        loc: this.locInfo(locInfo)
      };
    }
    return helpers;
  }
  var hasRequiredBase;
  function requireBase() {
    if (hasRequiredBase) return base;
    hasRequiredBase = 1;
    base.__esModule = true;
    base.parseWithoutProcessing = parseWithoutProcessing;
    base.parse = parse;
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
          }
        }
        newObj["default"] = obj;
        return newObj;
      }
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var _parser = requireParser();
    var _parser2 = _interopRequireDefault(_parser);
    var _whitespaceControl = requireWhitespaceControl();
    var _whitespaceControl2 = _interopRequireDefault(_whitespaceControl);
    var _helpers = requireHelpers();
    var Helpers = _interopRequireWildcard(_helpers);
    var _utils = requireUtils();
    base.parser = _parser2["default"];
    var yy = {};
    _utils.extend(yy, Helpers);
    function parseWithoutProcessing(input, options) {
      if (input.type === "Program") {
        return input;
      }
      _parser2["default"].yy = yy;
      yy.locInfo = function(locInfo) {
        return new yy.SourceLocation(options && options.srcName, locInfo);
      };
      var ast2 = _parser2["default"].parse(input);
      return ast2;
    }
    function parse(input, options) {
      var ast2 = parseWithoutProcessing(input, options);
      var strip = new _whitespaceControl2["default"](options);
      return strip.accept(ast2);
    }
    return base;
  }
  var compiler = {};
  var hasRequiredCompiler;
  function requireCompiler() {
    if (hasRequiredCompiler) return compiler;
    hasRequiredCompiler = 1;
    compiler.__esModule = true;
    compiler.Compiler = Compiler;
    compiler.precompile = precompile;
    compiler.compile = compile;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var _exception = requireException();
    var _exception2 = _interopRequireDefault(_exception);
    var _utils = requireUtils();
    var _ast = requireAst();
    var _ast2 = _interopRequireDefault(_ast);
    var slice = [].slice;
    function Compiler() {
    }
    Compiler.prototype = {
      compiler: Compiler,
      equals: function equals2(other) {
        var len = this.opcodes.length;
        if (other.opcodes.length !== len) {
          return false;
        }
        for (var i = 0; i < len; i++) {
          var opcode = this.opcodes[i], otherOpcode = other.opcodes[i];
          if (opcode.opcode !== otherOpcode.opcode || !argEquals(opcode.args, otherOpcode.args)) {
            return false;
          }
        }
        len = this.children.length;
        for (var i = 0; i < len; i++) {
          if (!this.children[i].equals(other.children[i])) {
            return false;
          }
        }
        return true;
      },
      guid: 0,
      compile: function compile2(program, options) {
        this.sourceNode = [];
        this.opcodes = [];
        this.children = [];
        this.options = options;
        this.stringParams = options.stringParams;
        this.trackIds = options.trackIds;
        options.blockParams = options.blockParams || [];
        options.knownHelpers = _utils.extend(/* @__PURE__ */ Object.create(null), {
          helperMissing: true,
          blockHelperMissing: true,
          each: true,
          "if": true,
          unless: true,
          "with": true,
          log: true,
          lookup: true
        }, options.knownHelpers);
        return this.accept(program);
      },
      compileProgram: function compileProgram(program) {
        var childCompiler = new this.compiler(), result = childCompiler.compile(program, this.options), guid = this.guid++;
        this.usePartial = this.usePartial || result.usePartial;
        this.children[guid] = result;
        this.useDepths = this.useDepths || result.useDepths;
        return guid;
      },
      accept: function accept(node) {
        if (!this[node.type]) {
          throw new _exception2["default"]("Unknown type: " + node.type, node);
        }
        this.sourceNode.unshift(node);
        var ret = this[node.type](node);
        this.sourceNode.shift();
        return ret;
      },
      Program: function Program(program) {
        this.options.blockParams.unshift(program.blockParams);
        var body = program.body, bodyLength = body.length;
        for (var i = 0; i < bodyLength; i++) {
          this.accept(body[i]);
        }
        this.options.blockParams.shift();
        this.isSimple = bodyLength === 1;
        this.blockParams = program.blockParams ? program.blockParams.length : 0;
        return this;
      },
      BlockStatement: function BlockStatement(block2) {
        transformLiteralToPath(block2);
        var program = block2.program, inverse = block2.inverse;
        program = program && this.compileProgram(program);
        inverse = inverse && this.compileProgram(inverse);
        var type = this.classifySexpr(block2);
        if (type === "helper") {
          this.helperSexpr(block2, program, inverse);
        } else if (type === "simple") {
          this.simpleSexpr(block2);
          this.opcode("pushProgram", program);
          this.opcode("pushProgram", inverse);
          this.opcode("emptyHash");
          this.opcode("blockValue", block2.path.original);
        } else {
          this.ambiguousSexpr(block2, program, inverse);
          this.opcode("pushProgram", program);
          this.opcode("pushProgram", inverse);
          this.opcode("emptyHash");
          this.opcode("ambiguousBlockValue");
        }
        this.opcode("append");
      },
      DecoratorBlock: function DecoratorBlock(decorator) {
        var program = decorator.program && this.compileProgram(decorator.program);
        var params = this.setupFullMustacheParams(decorator, program, void 0), path = decorator.path;
        this.useDecorators = true;
        this.opcode("registerDecorator", params.length, path.original);
      },
      PartialStatement: function PartialStatement(partial) {
        this.usePartial = true;
        var program = partial.program;
        if (program) {
          program = this.compileProgram(partial.program);
        }
        var params = partial.params;
        if (params.length > 1) {
          throw new _exception2["default"]("Unsupported number of partial arguments: " + params.length, partial);
        } else if (!params.length) {
          if (this.options.explicitPartialContext) {
            this.opcode("pushLiteral", "undefined");
          } else {
            params.push({ type: "PathExpression", parts: [], depth: 0 });
          }
        }
        var partialName = partial.name.original, isDynamic = partial.name.type === "SubExpression";
        if (isDynamic) {
          this.accept(partial.name);
        }
        this.setupFullMustacheParams(partial, program, void 0, true);
        var indent = partial.indent || "";
        if (this.options.preventIndent && indent) {
          this.opcode("appendContent", indent);
          indent = "";
        }
        this.opcode("invokePartial", isDynamic, partialName, indent);
        this.opcode("append");
      },
      PartialBlockStatement: function PartialBlockStatement(partialBlock) {
        this.PartialStatement(partialBlock);
      },
      MustacheStatement: function MustacheStatement(mustache) {
        this.SubExpression(mustache);
        if (mustache.escaped && !this.options.noEscape) {
          this.opcode("appendEscaped");
        } else {
          this.opcode("append");
        }
      },
      Decorator: function Decorator(decorator) {
        this.DecoratorBlock(decorator);
      },
      ContentStatement: function ContentStatement(content) {
        if (content.value) {
          this.opcode("appendContent", content.value);
        }
      },
      CommentStatement: function CommentStatement() {
      },
      SubExpression: function SubExpression(sexpr) {
        transformLiteralToPath(sexpr);
        var type = this.classifySexpr(sexpr);
        if (type === "simple") {
          this.simpleSexpr(sexpr);
        } else if (type === "helper") {
          this.helperSexpr(sexpr);
        } else {
          this.ambiguousSexpr(sexpr);
        }
      },
      ambiguousSexpr: function ambiguousSexpr(sexpr, program, inverse) {
        var path = sexpr.path, name = path.parts[0], isBlock = program != null || inverse != null;
        this.opcode("getContext", path.depth);
        this.opcode("pushProgram", program);
        this.opcode("pushProgram", inverse);
        path.strict = true;
        this.accept(path);
        this.opcode("invokeAmbiguous", name, isBlock);
      },
      simpleSexpr: function simpleSexpr(sexpr) {
        var path = sexpr.path;
        path.strict = true;
        this.accept(path);
        this.opcode("resolvePossibleLambda");
      },
      helperSexpr: function helperSexpr(sexpr, program, inverse) {
        var params = this.setupFullMustacheParams(sexpr, program, inverse), path = sexpr.path, name = path.parts[0];
        if (this.options.knownHelpers[name]) {
          this.opcode("invokeKnownHelper", params.length, name);
        } else if (this.options.knownHelpersOnly) {
          throw new _exception2["default"]("You specified knownHelpersOnly, but used the unknown helper " + name, sexpr);
        } else {
          path.strict = true;
          path.falsy = true;
          this.accept(path);
          this.opcode("invokeHelper", params.length, path.original, _ast2["default"].helpers.simpleId(path));
        }
      },
      PathExpression: function PathExpression(path) {
        this.addDepth(path.depth);
        this.opcode("getContext", path.depth);
        var name = path.parts[0], scoped = _ast2["default"].helpers.scopedId(path), blockParamId = !path.depth && !scoped && this.blockParamIndex(name);
        if (blockParamId) {
          this.opcode("lookupBlockParam", blockParamId, path.parts);
        } else if (!name) {
          this.opcode("pushContext");
        } else if (path.data) {
          this.options.data = true;
          this.opcode("lookupData", path.depth, path.parts, path.strict);
        } else {
          this.opcode("lookupOnContext", path.parts, path.falsy, path.strict, scoped);
        }
      },
      StringLiteral: function StringLiteral(string2) {
        this.opcode("pushString", string2.value);
      },
      NumberLiteral: function NumberLiteral(number) {
        this.opcode("pushLiteral", number.value);
      },
      BooleanLiteral: function BooleanLiteral(bool) {
        this.opcode("pushLiteral", bool.value);
      },
      UndefinedLiteral: function UndefinedLiteral() {
        this.opcode("pushLiteral", "undefined");
      },
      NullLiteral: function NullLiteral() {
        this.opcode("pushLiteral", "null");
      },
      Hash: function Hash(hash) {
        var pairs = hash.pairs, i = 0, l = pairs.length;
        this.opcode("pushHash");
        for (; i < l; i++) {
          this.pushParam(pairs[i].value);
        }
        while (i--) {
          this.opcode("assignToHash", pairs[i].key);
        }
        this.opcode("popHash");
      },
      // HELPERS
      opcode: function opcode(name) {
        this.opcodes.push({
          opcode: name,
          args: slice.call(arguments, 1),
          loc: this.sourceNode[0].loc
        });
      },
      addDepth: function addDepth(depth) {
        if (!depth) {
          return;
        }
        this.useDepths = true;
      },
      classifySexpr: function classifySexpr(sexpr) {
        var isSimple = _ast2["default"].helpers.simpleId(sexpr.path);
        var isBlockParam = isSimple && !!this.blockParamIndex(sexpr.path.parts[0]);
        var isHelper = !isBlockParam && _ast2["default"].helpers.helperExpression(sexpr);
        var isEligible = !isBlockParam && (isHelper || isSimple);
        if (isEligible && !isHelper) {
          var _name = sexpr.path.parts[0], options = this.options;
          if (options.knownHelpers[_name]) {
            isHelper = true;
          } else if (options.knownHelpersOnly) {
            isEligible = false;
          }
        }
        if (isHelper) {
          return "helper";
        } else if (isEligible) {
          return "ambiguous";
        } else {
          return "simple";
        }
      },
      pushParams: function pushParams(params) {
        for (var i = 0, l = params.length; i < l; i++) {
          this.pushParam(params[i]);
        }
      },
      pushParam: function pushParam(val) {
        var value = val.value != null ? val.value : val.original || "";
        if (this.stringParams) {
          if (value.replace) {
            value = value.replace(/^(\.?\.\/)*/g, "").replace(/\//g, ".");
          }
          if (val.depth) {
            this.addDepth(val.depth);
          }
          this.opcode("getContext", val.depth || 0);
          this.opcode("pushStringParam", value, val.type);
          if (val.type === "SubExpression") {
            this.accept(val);
          }
        } else {
          if (this.trackIds) {
            var blockParamIndex = void 0;
            if (val.parts && !_ast2["default"].helpers.scopedId(val) && !val.depth) {
              blockParamIndex = this.blockParamIndex(val.parts[0]);
            }
            if (blockParamIndex) {
              var blockParamChild = val.parts.slice(1).join(".");
              this.opcode("pushId", "BlockParam", blockParamIndex, blockParamChild);
            } else {
              value = val.original || value;
              if (value.replace) {
                value = value.replace(/^this(?:\.|$)/, "").replace(/^\.\//, "").replace(/^\.$/, "");
              }
              this.opcode("pushId", val.type, value);
            }
          }
          this.accept(val);
        }
      },
      setupFullMustacheParams: function setupFullMustacheParams(sexpr, program, inverse, omitEmpty) {
        var params = sexpr.params;
        this.pushParams(params);
        this.opcode("pushProgram", program);
        this.opcode("pushProgram", inverse);
        if (sexpr.hash) {
          this.accept(sexpr.hash);
        } else {
          this.opcode("emptyHash", omitEmpty);
        }
        return params;
      },
      blockParamIndex: function blockParamIndex(name) {
        for (var depth = 0, len = this.options.blockParams.length; depth < len; depth++) {
          var blockParams = this.options.blockParams[depth], param = blockParams && _utils.indexOf(blockParams, name);
          if (blockParams && param >= 0) {
            return [depth, param];
          }
        }
      }
    };
    function precompile(input, options, env) {
      if (input == null || typeof input !== "string" && input.type !== "Program") {
        throw new _exception2["default"]("You must pass a string or Handlebars AST to Handlebars.precompile. You passed " + input);
      }
      options = options || {};
      if (!("data" in options)) {
        options.data = true;
      }
      if (options.compat) {
        options.useDepths = true;
      }
      var ast2 = env.parse(input, options), environment = new env.Compiler().compile(ast2, options);
      return new env.JavaScriptCompiler().compile(environment, options);
    }
    function compile(input, options, env) {
      if (options === void 0) options = {};
      if (input == null || typeof input !== "string" && input.type !== "Program") {
        throw new _exception2["default"]("You must pass a string or Handlebars AST to Handlebars.compile. You passed " + input);
      }
      options = _utils.extend({}, options);
      if (!("data" in options)) {
        options.data = true;
      }
      if (options.compat) {
        options.useDepths = true;
      }
      var compiled = void 0;
      function compileInput() {
        var ast2 = env.parse(input, options), environment = new env.Compiler().compile(ast2, options), templateSpec = new env.JavaScriptCompiler().compile(environment, options, void 0, true);
        return env.template(templateSpec);
      }
      function ret(context, execOptions) {
        if (!compiled) {
          compiled = compileInput();
        }
        return compiled.call(this, context, execOptions);
      }
      ret._setup = function(setupOptions) {
        if (!compiled) {
          compiled = compileInput();
        }
        return compiled._setup(setupOptions);
      };
      ret._child = function(i, data, blockParams, depths) {
        if (!compiled) {
          compiled = compileInput();
        }
        return compiled._child(i, data, blockParams, depths);
      };
      return ret;
    }
    function argEquals(a, b) {
      if (a === b) {
        return true;
      }
      if (_utils.isArray(a) && _utils.isArray(b) && a.length === b.length) {
        for (var i = 0; i < a.length; i++) {
          if (!argEquals(a[i], b[i])) {
            return false;
          }
        }
        return true;
      }
    }
    function transformLiteralToPath(sexpr) {
      if (!sexpr.path.parts) {
        var literal = sexpr.path;
        sexpr.path = {
          type: "PathExpression",
          data: false,
          depth: 0,
          parts: [literal.original + ""],
          original: literal.original + "",
          loc: literal.loc
        };
      }
    }
    return compiler;
  }
  var javascriptCompiler = { exports: {} };
  var codeGen = { exports: {} };
  var sourceMap = {};
  var sourceMapGenerator = {};
  var base64Vlq = {};
  var base64 = {};
  var hasRequiredBase64;
  function requireBase64() {
    if (hasRequiredBase64) return base64;
    hasRequiredBase64 = 1;
    var intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
    base64.encode = function(number) {
      if (0 <= number && number < intToCharMap.length) {
        return intToCharMap[number];
      }
      throw new TypeError("Must be between 0 and 63: " + number);
    };
    base64.decode = function(charCode) {
      var bigA = 65;
      var bigZ = 90;
      var littleA = 97;
      var littleZ = 122;
      var zero = 48;
      var nine = 57;
      var plus = 43;
      var slash = 47;
      var littleOffset = 26;
      var numberOffset = 52;
      if (bigA <= charCode && charCode <= bigZ) {
        return charCode - bigA;
      }
      if (littleA <= charCode && charCode <= littleZ) {
        return charCode - littleA + littleOffset;
      }
      if (zero <= charCode && charCode <= nine) {
        return charCode - zero + numberOffset;
      }
      if (charCode == plus) {
        return 62;
      }
      if (charCode == slash) {
        return 63;
      }
      return -1;
    };
    return base64;
  }
  var hasRequiredBase64Vlq;
  function requireBase64Vlq() {
    if (hasRequiredBase64Vlq) return base64Vlq;
    hasRequiredBase64Vlq = 1;
    var base642 = requireBase64();
    var VLQ_BASE_SHIFT = 5;
    var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
    var VLQ_BASE_MASK = VLQ_BASE - 1;
    var VLQ_CONTINUATION_BIT = VLQ_BASE;
    function toVLQSigned(aValue) {
      return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
    }
    function fromVLQSigned(aValue) {
      var isNegative = (aValue & 1) === 1;
      var shifted = aValue >> 1;
      return isNegative ? -shifted : shifted;
    }
    base64Vlq.encode = function base64VLQ_encode(aValue) {
      var encoded = "";
      var digit;
      var vlq = toVLQSigned(aValue);
      do {
        digit = vlq & VLQ_BASE_MASK;
        vlq >>>= VLQ_BASE_SHIFT;
        if (vlq > 0) {
          digit |= VLQ_CONTINUATION_BIT;
        }
        encoded += base642.encode(digit);
      } while (vlq > 0);
      return encoded;
    };
    base64Vlq.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
      var strLen = aStr.length;
      var result = 0;
      var shift = 0;
      var continuation, digit;
      do {
        if (aIndex >= strLen) {
          throw new Error("Expected more digits in base 64 VLQ value.");
        }
        digit = base642.decode(aStr.charCodeAt(aIndex++));
        if (digit === -1) {
          throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
        }
        continuation = !!(digit & VLQ_CONTINUATION_BIT);
        digit &= VLQ_BASE_MASK;
        result = result + (digit << shift);
        shift += VLQ_BASE_SHIFT;
      } while (continuation);
      aOutParam.value = fromVLQSigned(result);
      aOutParam.rest = aIndex;
    };
    return base64Vlq;
  }
  var util = {};
  var hasRequiredUtil;
  function requireUtil() {
    if (hasRequiredUtil) return util;
    hasRequiredUtil = 1;
    (function(exports) {
      function getArg(aArgs, aName, aDefaultValue) {
        if (aName in aArgs) {
          return aArgs[aName];
        } else if (arguments.length === 3) {
          return aDefaultValue;
        } else {
          throw new Error('"' + aName + '" is a required argument.');
        }
      }
      exports.getArg = getArg;
      var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
      var dataUrlRegexp = /^data:.+\,.+$/;
      function urlParse(aUrl) {
        var match2 = aUrl.match(urlRegexp);
        if (!match2) {
          return null;
        }
        return {
          scheme: match2[1],
          auth: match2[2],
          host: match2[3],
          port: match2[4],
          path: match2[5]
        };
      }
      exports.urlParse = urlParse;
      function urlGenerate(aParsedUrl) {
        var url = "";
        if (aParsedUrl.scheme) {
          url += aParsedUrl.scheme + ":";
        }
        url += "//";
        if (aParsedUrl.auth) {
          url += aParsedUrl.auth + "@";
        }
        if (aParsedUrl.host) {
          url += aParsedUrl.host;
        }
        if (aParsedUrl.port) {
          url += ":" + aParsedUrl.port;
        }
        if (aParsedUrl.path) {
          url += aParsedUrl.path;
        }
        return url;
      }
      exports.urlGenerate = urlGenerate;
      function normalize(aPath) {
        var path = aPath;
        var url = urlParse(aPath);
        if (url) {
          if (!url.path) {
            return aPath;
          }
          path = url.path;
        }
        var isAbsolute = exports.isAbsolute(path);
        var parts = path.split(/\/+/);
        for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
          part = parts[i];
          if (part === ".") {
            parts.splice(i, 1);
          } else if (part === "..") {
            up++;
          } else if (up > 0) {
            if (part === "") {
              parts.splice(i + 1, up);
              up = 0;
            } else {
              parts.splice(i, 2);
              up--;
            }
          }
        }
        path = parts.join("/");
        if (path === "") {
          path = isAbsolute ? "/" : ".";
        }
        if (url) {
          url.path = path;
          return urlGenerate(url);
        }
        return path;
      }
      exports.normalize = normalize;
      function join(aRoot, aPath) {
        if (aRoot === "") {
          aRoot = ".";
        }
        if (aPath === "") {
          aPath = ".";
        }
        var aPathUrl = urlParse(aPath);
        var aRootUrl = urlParse(aRoot);
        if (aRootUrl) {
          aRoot = aRootUrl.path || "/";
        }
        if (aPathUrl && !aPathUrl.scheme) {
          if (aRootUrl) {
            aPathUrl.scheme = aRootUrl.scheme;
          }
          return urlGenerate(aPathUrl);
        }
        if (aPathUrl || aPath.match(dataUrlRegexp)) {
          return aPath;
        }
        if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
          aRootUrl.host = aPath;
          return urlGenerate(aRootUrl);
        }
        var joined = aPath.charAt(0) === "/" ? aPath : normalize(aRoot.replace(/\/+$/, "") + "/" + aPath);
        if (aRootUrl) {
          aRootUrl.path = joined;
          return urlGenerate(aRootUrl);
        }
        return joined;
      }
      exports.join = join;
      exports.isAbsolute = function(aPath) {
        return aPath.charAt(0) === "/" || urlRegexp.test(aPath);
      };
      function relative(aRoot, aPath) {
        if (aRoot === "") {
          aRoot = ".";
        }
        aRoot = aRoot.replace(/\/$/, "");
        var level = 0;
        while (aPath.indexOf(aRoot + "/") !== 0) {
          var index = aRoot.lastIndexOf("/");
          if (index < 0) {
            return aPath;
          }
          aRoot = aRoot.slice(0, index);
          if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
            return aPath;
          }
          ++level;
        }
        return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
      }
      exports.relative = relative;
      var supportsNullProto = function() {
        var obj = /* @__PURE__ */ Object.create(null);
        return !("__proto__" in obj);
      }();
      function identity2(s) {
        return s;
      }
      function toSetString(aStr) {
        if (isProtoString(aStr)) {
          return "$" + aStr;
        }
        return aStr;
      }
      exports.toSetString = supportsNullProto ? identity2 : toSetString;
      function fromSetString(aStr) {
        if (isProtoString(aStr)) {
          return aStr.slice(1);
        }
        return aStr;
      }
      exports.fromSetString = supportsNullProto ? identity2 : fromSetString;
      function isProtoString(s) {
        if (!s) {
          return false;
        }
        var length2 = s.length;
        if (length2 < 9) {
          return false;
        }
        if (s.charCodeAt(length2 - 1) !== 95 || s.charCodeAt(length2 - 2) !== 95 || s.charCodeAt(length2 - 3) !== 111 || s.charCodeAt(length2 - 4) !== 116 || s.charCodeAt(length2 - 5) !== 111 || s.charCodeAt(length2 - 6) !== 114 || s.charCodeAt(length2 - 7) !== 112 || s.charCodeAt(length2 - 8) !== 95 || s.charCodeAt(length2 - 9) !== 95) {
          return false;
        }
        for (var i = length2 - 10; i >= 0; i--) {
          if (s.charCodeAt(i) !== 36) {
            return false;
          }
        }
        return true;
      }
      function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
        var cmp = strcmp(mappingA.source, mappingB.source);
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalLine - mappingB.originalLine;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalColumn - mappingB.originalColumn;
        if (cmp !== 0 || onlyCompareOriginal) {
          return cmp;
        }
        cmp = mappingA.generatedColumn - mappingB.generatedColumn;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.generatedLine - mappingB.generatedLine;
        if (cmp !== 0) {
          return cmp;
        }
        return strcmp(mappingA.name, mappingB.name);
      }
      exports.compareByOriginalPositions = compareByOriginalPositions;
      function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
        var cmp = mappingA.generatedLine - mappingB.generatedLine;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.generatedColumn - mappingB.generatedColumn;
        if (cmp !== 0 || onlyCompareGenerated) {
          return cmp;
        }
        cmp = strcmp(mappingA.source, mappingB.source);
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalLine - mappingB.originalLine;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalColumn - mappingB.originalColumn;
        if (cmp !== 0) {
          return cmp;
        }
        return strcmp(mappingA.name, mappingB.name);
      }
      exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
      function strcmp(aStr1, aStr2) {
        if (aStr1 === aStr2) {
          return 0;
        }
        if (aStr1 === null) {
          return 1;
        }
        if (aStr2 === null) {
          return -1;
        }
        if (aStr1 > aStr2) {
          return 1;
        }
        return -1;
      }
      function compareByGeneratedPositionsInflated(mappingA, mappingB) {
        var cmp = mappingA.generatedLine - mappingB.generatedLine;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.generatedColumn - mappingB.generatedColumn;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = strcmp(mappingA.source, mappingB.source);
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalLine - mappingB.originalLine;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalColumn - mappingB.originalColumn;
        if (cmp !== 0) {
          return cmp;
        }
        return strcmp(mappingA.name, mappingB.name);
      }
      exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
      function parseSourceMapInput(str) {
        return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ""));
      }
      exports.parseSourceMapInput = parseSourceMapInput;
      function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
        sourceURL = sourceURL || "";
        if (sourceRoot) {
          if (sourceRoot[sourceRoot.length - 1] !== "/" && sourceURL[0] !== "/") {
            sourceRoot += "/";
          }
          sourceURL = sourceRoot + sourceURL;
        }
        if (sourceMapURL) {
          var parsed = urlParse(sourceMapURL);
          if (!parsed) {
            throw new Error("sourceMapURL could not be parsed");
          }
          if (parsed.path) {
            var index = parsed.path.lastIndexOf("/");
            if (index >= 0) {
              parsed.path = parsed.path.substring(0, index + 1);
            }
          }
          sourceURL = join(urlGenerate(parsed), sourceURL);
        }
        return normalize(sourceURL);
      }
      exports.computeSourceURL = computeSourceURL;
    })(util);
    return util;
  }
  var arraySet = {};
  var hasRequiredArraySet;
  function requireArraySet() {
    if (hasRequiredArraySet) return arraySet;
    hasRequiredArraySet = 1;
    var util2 = requireUtil();
    var has = Object.prototype.hasOwnProperty;
    var hasNativeMap = typeof Map !== "undefined";
    function ArraySet() {
      this._array = [];
      this._set = hasNativeMap ? /* @__PURE__ */ new Map() : /* @__PURE__ */ Object.create(null);
    }
    ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
      var set = new ArraySet();
      for (var i = 0, len = aArray.length; i < len; i++) {
        set.add(aArray[i], aAllowDuplicates);
      }
      return set;
    };
    ArraySet.prototype.size = function ArraySet_size() {
      return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
    };
    ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
      var sStr = hasNativeMap ? aStr : util2.toSetString(aStr);
      var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
      var idx = this._array.length;
      if (!isDuplicate || aAllowDuplicates) {
        this._array.push(aStr);
      }
      if (!isDuplicate) {
        if (hasNativeMap) {
          this._set.set(aStr, idx);
        } else {
          this._set[sStr] = idx;
        }
      }
    };
    ArraySet.prototype.has = function ArraySet_has(aStr) {
      if (hasNativeMap) {
        return this._set.has(aStr);
      } else {
        var sStr = util2.toSetString(aStr);
        return has.call(this._set, sStr);
      }
    };
    ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
      if (hasNativeMap) {
        var idx = this._set.get(aStr);
        if (idx >= 0) {
          return idx;
        }
      } else {
        var sStr = util2.toSetString(aStr);
        if (has.call(this._set, sStr)) {
          return this._set[sStr];
        }
      }
      throw new Error('"' + aStr + '" is not in the set.');
    };
    ArraySet.prototype.at = function ArraySet_at(aIdx) {
      if (aIdx >= 0 && aIdx < this._array.length) {
        return this._array[aIdx];
      }
      throw new Error("No element indexed by " + aIdx);
    };
    ArraySet.prototype.toArray = function ArraySet_toArray() {
      return this._array.slice();
    };
    arraySet.ArraySet = ArraySet;
    return arraySet;
  }
  var mappingList = {};
  var hasRequiredMappingList;
  function requireMappingList() {
    if (hasRequiredMappingList) return mappingList;
    hasRequiredMappingList = 1;
    var util2 = requireUtil();
    function generatedPositionAfter(mappingA, mappingB) {
      var lineA = mappingA.generatedLine;
      var lineB = mappingB.generatedLine;
      var columnA = mappingA.generatedColumn;
      var columnB = mappingB.generatedColumn;
      return lineB > lineA || lineB == lineA && columnB >= columnA || util2.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
    }
    function MappingList() {
      this._array = [];
      this._sorted = true;
      this._last = { generatedLine: -1, generatedColumn: 0 };
    }
    MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
      this._array.forEach(aCallback, aThisArg);
    };
    MappingList.prototype.add = function MappingList_add(aMapping) {
      if (generatedPositionAfter(this._last, aMapping)) {
        this._last = aMapping;
        this._array.push(aMapping);
      } else {
        this._sorted = false;
        this._array.push(aMapping);
      }
    };
    MappingList.prototype.toArray = function MappingList_toArray() {
      if (!this._sorted) {
        this._array.sort(util2.compareByGeneratedPositionsInflated);
        this._sorted = true;
      }
      return this._array;
    };
    mappingList.MappingList = MappingList;
    return mappingList;
  }
  var hasRequiredSourceMapGenerator;
  function requireSourceMapGenerator() {
    if (hasRequiredSourceMapGenerator) return sourceMapGenerator;
    hasRequiredSourceMapGenerator = 1;
    var base64VLQ = requireBase64Vlq();
    var util2 = requireUtil();
    var ArraySet = requireArraySet().ArraySet;
    var MappingList = requireMappingList().MappingList;
    function SourceMapGenerator(aArgs) {
      if (!aArgs) {
        aArgs = {};
      }
      this._file = util2.getArg(aArgs, "file", null);
      this._sourceRoot = util2.getArg(aArgs, "sourceRoot", null);
      this._skipValidation = util2.getArg(aArgs, "skipValidation", false);
      this._sources = new ArraySet();
      this._names = new ArraySet();
      this._mappings = new MappingList();
      this._sourcesContents = null;
    }
    SourceMapGenerator.prototype._version = 3;
    SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
      var sourceRoot = aSourceMapConsumer.sourceRoot;
      var generator2 = new SourceMapGenerator({
        file: aSourceMapConsumer.file,
        sourceRoot
      });
      aSourceMapConsumer.eachMapping(function(mapping) {
        var newMapping = {
          generated: {
            line: mapping.generatedLine,
            column: mapping.generatedColumn
          }
        };
        if (mapping.source != null) {
          newMapping.source = mapping.source;
          if (sourceRoot != null) {
            newMapping.source = util2.relative(sourceRoot, newMapping.source);
          }
          newMapping.original = {
            line: mapping.originalLine,
            column: mapping.originalColumn
          };
          if (mapping.name != null) {
            newMapping.name = mapping.name;
          }
        }
        generator2.addMapping(newMapping);
      });
      aSourceMapConsumer.sources.forEach(function(sourceFile) {
        var sourceRelative = sourceFile;
        if (sourceRoot !== null) {
          sourceRelative = util2.relative(sourceRoot, sourceFile);
        }
        if (!generator2._sources.has(sourceRelative)) {
          generator2._sources.add(sourceRelative);
        }
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          generator2.setSourceContent(sourceFile, content);
        }
      });
      return generator2;
    };
    SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
      var generated = util2.getArg(aArgs, "generated");
      var original = util2.getArg(aArgs, "original", null);
      var source = util2.getArg(aArgs, "source", null);
      var name = util2.getArg(aArgs, "name", null);
      if (!this._skipValidation) {
        this._validateMapping(generated, original, source, name);
      }
      if (source != null) {
        source = String(source);
        if (!this._sources.has(source)) {
          this._sources.add(source);
        }
      }
      if (name != null) {
        name = String(name);
        if (!this._names.has(name)) {
          this._names.add(name);
        }
      }
      this._mappings.add({
        generatedLine: generated.line,
        generatedColumn: generated.column,
        originalLine: original != null && original.line,
        originalColumn: original != null && original.column,
        source,
        name
      });
    };
    SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
      var source = aSourceFile;
      if (this._sourceRoot != null) {
        source = util2.relative(this._sourceRoot, source);
      }
      if (aSourceContent != null) {
        if (!this._sourcesContents) {
          this._sourcesContents = /* @__PURE__ */ Object.create(null);
        }
        this._sourcesContents[util2.toSetString(source)] = aSourceContent;
      } else if (this._sourcesContents) {
        delete this._sourcesContents[util2.toSetString(source)];
        if (Object.keys(this._sourcesContents).length === 0) {
          this._sourcesContents = null;
        }
      }
    };
    SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
      var sourceFile = aSourceFile;
      if (aSourceFile == null) {
        if (aSourceMapConsumer.file == null) {
          throw new Error(
            `SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`
          );
        }
        sourceFile = aSourceMapConsumer.file;
      }
      var sourceRoot = this._sourceRoot;
      if (sourceRoot != null) {
        sourceFile = util2.relative(sourceRoot, sourceFile);
      }
      var newSources = new ArraySet();
      var newNames = new ArraySet();
      this._mappings.unsortedForEach(function(mapping) {
        if (mapping.source === sourceFile && mapping.originalLine != null) {
          var original = aSourceMapConsumer.originalPositionFor({
            line: mapping.originalLine,
            column: mapping.originalColumn
          });
          if (original.source != null) {
            mapping.source = original.source;
            if (aSourceMapPath != null) {
              mapping.source = util2.join(aSourceMapPath, mapping.source);
            }
            if (sourceRoot != null) {
              mapping.source = util2.relative(sourceRoot, mapping.source);
            }
            mapping.originalLine = original.line;
            mapping.originalColumn = original.column;
            if (original.name != null) {
              mapping.name = original.name;
            }
          }
        }
        var source = mapping.source;
        if (source != null && !newSources.has(source)) {
          newSources.add(source);
        }
        var name = mapping.name;
        if (name != null && !newNames.has(name)) {
          newNames.add(name);
        }
      }, this);
      this._sources = newSources;
      this._names = newNames;
      aSourceMapConsumer.sources.forEach(function(sourceFile2) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile2);
        if (content != null) {
          if (aSourceMapPath != null) {
            sourceFile2 = util2.join(aSourceMapPath, sourceFile2);
          }
          if (sourceRoot != null) {
            sourceFile2 = util2.relative(sourceRoot, sourceFile2);
          }
          this.setSourceContent(sourceFile2, content);
        }
      }, this);
    };
    SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
      if (aOriginal && typeof aOriginal.line !== "number" && typeof aOriginal.column !== "number") {
        throw new Error(
          "original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values."
        );
      }
      if (aGenerated && "line" in aGenerated && "column" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
        return;
      } else if (aGenerated && "line" in aGenerated && "column" in aGenerated && aOriginal && "line" in aOriginal && "column" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
        return;
      } else {
        throw new Error("Invalid mapping: " + JSON.stringify({
          generated: aGenerated,
          source: aSource,
          original: aOriginal,
          name: aName
        }));
      }
    };
    SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
      var previousGeneratedColumn = 0;
      var previousGeneratedLine = 1;
      var previousOriginalColumn = 0;
      var previousOriginalLine = 0;
      var previousName = 0;
      var previousSource = 0;
      var result = "";
      var next;
      var mapping;
      var nameIdx;
      var sourceIdx;
      var mappings = this._mappings.toArray();
      for (var i = 0, len = mappings.length; i < len; i++) {
        mapping = mappings[i];
        next = "";
        if (mapping.generatedLine !== previousGeneratedLine) {
          previousGeneratedColumn = 0;
          while (mapping.generatedLine !== previousGeneratedLine) {
            next += ";";
            previousGeneratedLine++;
          }
        } else {
          if (i > 0) {
            if (!util2.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
              continue;
            }
            next += ",";
          }
        }
        next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
        previousGeneratedColumn = mapping.generatedColumn;
        if (mapping.source != null) {
          sourceIdx = this._sources.indexOf(mapping.source);
          next += base64VLQ.encode(sourceIdx - previousSource);
          previousSource = sourceIdx;
          next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
          previousOriginalLine = mapping.originalLine - 1;
          next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
          previousOriginalColumn = mapping.originalColumn;
          if (mapping.name != null) {
            nameIdx = this._names.indexOf(mapping.name);
            next += base64VLQ.encode(nameIdx - previousName);
            previousName = nameIdx;
          }
        }
        result += next;
      }
      return result;
    };
    SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
      return aSources.map(function(source) {
        if (!this._sourcesContents) {
          return null;
        }
        if (aSourceRoot != null) {
          source = util2.relative(aSourceRoot, source);
        }
        var key = util2.toSetString(source);
        return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
      }, this);
    };
    SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
      var map = {
        version: this._version,
        sources: this._sources.toArray(),
        names: this._names.toArray(),
        mappings: this._serializeMappings()
      };
      if (this._file != null) {
        map.file = this._file;
      }
      if (this._sourceRoot != null) {
        map.sourceRoot = this._sourceRoot;
      }
      if (this._sourcesContents) {
        map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
      }
      return map;
    };
    SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
      return JSON.stringify(this.toJSON());
    };
    sourceMapGenerator.SourceMapGenerator = SourceMapGenerator;
    return sourceMapGenerator;
  }
  var sourceMapConsumer = {};
  var binarySearch = {};
  var hasRequiredBinarySearch;
  function requireBinarySearch() {
    if (hasRequiredBinarySearch) return binarySearch;
    hasRequiredBinarySearch = 1;
    (function(exports) {
      exports.GREATEST_LOWER_BOUND = 1;
      exports.LEAST_UPPER_BOUND = 2;
      function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
        var mid = Math.floor((aHigh - aLow) / 2) + aLow;
        var cmp = aCompare(aNeedle, aHaystack[mid], true);
        if (cmp === 0) {
          return mid;
        } else if (cmp > 0) {
          if (aHigh - mid > 1) {
            return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
          }
          if (aBias == exports.LEAST_UPPER_BOUND) {
            return aHigh < aHaystack.length ? aHigh : -1;
          } else {
            return mid;
          }
        } else {
          if (mid - aLow > 1) {
            return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
          }
          if (aBias == exports.LEAST_UPPER_BOUND) {
            return mid;
          } else {
            return aLow < 0 ? -1 : aLow;
          }
        }
      }
      exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
        if (aHaystack.length === 0) {
          return -1;
        }
        var index = recursiveSearch(
          -1,
          aHaystack.length,
          aNeedle,
          aHaystack,
          aCompare,
          aBias || exports.GREATEST_LOWER_BOUND
        );
        if (index < 0) {
          return -1;
        }
        while (index - 1 >= 0) {
          if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
            break;
          }
          --index;
        }
        return index;
      };
    })(binarySearch);
    return binarySearch;
  }
  var quickSort = {};
  var hasRequiredQuickSort;
  function requireQuickSort() {
    if (hasRequiredQuickSort) return quickSort;
    hasRequiredQuickSort = 1;
    function swap(ary, x, y) {
      var temp = ary[x];
      ary[x] = ary[y];
      ary[y] = temp;
    }
    function randomIntInRange(low, high) {
      return Math.round(low + Math.random() * (high - low));
    }
    function doQuickSort(ary, comparator, p, r) {
      if (p < r) {
        var pivotIndex = randomIntInRange(p, r);
        var i = p - 1;
        swap(ary, pivotIndex, r);
        var pivot = ary[r];
        for (var j = p; j < r; j++) {
          if (comparator(ary[j], pivot) <= 0) {
            i += 1;
            swap(ary, i, j);
          }
        }
        swap(ary, i + 1, j);
        var q = i + 1;
        doQuickSort(ary, comparator, p, q - 1);
        doQuickSort(ary, comparator, q + 1, r);
      }
    }
    quickSort.quickSort = function(ary, comparator) {
      doQuickSort(ary, comparator, 0, ary.length - 1);
    };
    return quickSort;
  }
  var hasRequiredSourceMapConsumer;
  function requireSourceMapConsumer() {
    if (hasRequiredSourceMapConsumer) return sourceMapConsumer;
    hasRequiredSourceMapConsumer = 1;
    var util2 = requireUtil();
    var binarySearch2 = requireBinarySearch();
    var ArraySet = requireArraySet().ArraySet;
    var base64VLQ = requireBase64Vlq();
    var quickSort2 = requireQuickSort().quickSort;
    function SourceMapConsumer(aSourceMap, aSourceMapURL) {
      var sourceMap2 = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap2 = util2.parseSourceMapInput(aSourceMap);
      }
      return sourceMap2.sections != null ? new IndexedSourceMapConsumer(sourceMap2, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap2, aSourceMapURL);
    }
    SourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {
      return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
    };
    SourceMapConsumer.prototype._version = 3;
    SourceMapConsumer.prototype.__generatedMappings = null;
    Object.defineProperty(SourceMapConsumer.prototype, "_generatedMappings", {
      configurable: true,
      enumerable: true,
      get: function() {
        if (!this.__generatedMappings) {
          this._parseMappings(this._mappings, this.sourceRoot);
        }
        return this.__generatedMappings;
      }
    });
    SourceMapConsumer.prototype.__originalMappings = null;
    Object.defineProperty(SourceMapConsumer.prototype, "_originalMappings", {
      configurable: true,
      enumerable: true,
      get: function() {
        if (!this.__originalMappings) {
          this._parseMappings(this._mappings, this.sourceRoot);
        }
        return this.__originalMappings;
      }
    });
    SourceMapConsumer.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
      var c = aStr.charAt(index);
      return c === ";" || c === ",";
    };
    SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      throw new Error("Subclasses must implement _parseMappings");
    };
    SourceMapConsumer.GENERATED_ORDER = 1;
    SourceMapConsumer.ORIGINAL_ORDER = 2;
    SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
    SourceMapConsumer.LEAST_UPPER_BOUND = 2;
    SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
      var context = aContext || null;
      var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
      var mappings;
      switch (order) {
        case SourceMapConsumer.GENERATED_ORDER:
          mappings = this._generatedMappings;
          break;
        case SourceMapConsumer.ORIGINAL_ORDER:
          mappings = this._originalMappings;
          break;
        default:
          throw new Error("Unknown order of iteration.");
      }
      var sourceRoot = this.sourceRoot;
      mappings.map(function(mapping) {
        var source = mapping.source === null ? null : this._sources.at(mapping.source);
        source = util2.computeSourceURL(sourceRoot, source, this._sourceMapURL);
        return {
          source,
          generatedLine: mapping.generatedLine,
          generatedColumn: mapping.generatedColumn,
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: mapping.name === null ? null : this._names.at(mapping.name)
        };
      }, this).forEach(aCallback, context);
    };
    SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
      var line = util2.getArg(aArgs, "line");
      var needle = {
        source: util2.getArg(aArgs, "source"),
        originalLine: line,
        originalColumn: util2.getArg(aArgs, "column", 0)
      };
      needle.source = this._findSourceIndex(needle.source);
      if (needle.source < 0) {
        return [];
      }
      var mappings = [];
      var index = this._findMapping(
        needle,
        this._originalMappings,
        "originalLine",
        "originalColumn",
        util2.compareByOriginalPositions,
        binarySearch2.LEAST_UPPER_BOUND
      );
      if (index >= 0) {
        var mapping = this._originalMappings[index];
        if (aArgs.column === void 0) {
          var originalLine = mapping.originalLine;
          while (mapping && mapping.originalLine === originalLine) {
            mappings.push({
              line: util2.getArg(mapping, "generatedLine", null),
              column: util2.getArg(mapping, "generatedColumn", null),
              lastColumn: util2.getArg(mapping, "lastGeneratedColumn", null)
            });
            mapping = this._originalMappings[++index];
          }
        } else {
          var originalColumn = mapping.originalColumn;
          while (mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn) {
            mappings.push({
              line: util2.getArg(mapping, "generatedLine", null),
              column: util2.getArg(mapping, "generatedColumn", null),
              lastColumn: util2.getArg(mapping, "lastGeneratedColumn", null)
            });
            mapping = this._originalMappings[++index];
          }
        }
      }
      return mappings;
    };
    sourceMapConsumer.SourceMapConsumer = SourceMapConsumer;
    function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
      var sourceMap2 = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap2 = util2.parseSourceMapInput(aSourceMap);
      }
      var version2 = util2.getArg(sourceMap2, "version");
      var sources = util2.getArg(sourceMap2, "sources");
      var names = util2.getArg(sourceMap2, "names", []);
      var sourceRoot = util2.getArg(sourceMap2, "sourceRoot", null);
      var sourcesContent = util2.getArg(sourceMap2, "sourcesContent", null);
      var mappings = util2.getArg(sourceMap2, "mappings");
      var file = util2.getArg(sourceMap2, "file", null);
      if (version2 != this._version) {
        throw new Error("Unsupported version: " + version2);
      }
      if (sourceRoot) {
        sourceRoot = util2.normalize(sourceRoot);
      }
      sources = sources.map(String).map(util2.normalize).map(function(source) {
        return sourceRoot && util2.isAbsolute(sourceRoot) && util2.isAbsolute(source) ? util2.relative(sourceRoot, source) : source;
      });
      this._names = ArraySet.fromArray(names.map(String), true);
      this._sources = ArraySet.fromArray(sources, true);
      this._absoluteSources = this._sources.toArray().map(function(s) {
        return util2.computeSourceURL(sourceRoot, s, aSourceMapURL);
      });
      this.sourceRoot = sourceRoot;
      this.sourcesContent = sourcesContent;
      this._mappings = mappings;
      this._sourceMapURL = aSourceMapURL;
      this.file = file;
    }
    BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
    BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
    BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
      var relativeSource = aSource;
      if (this.sourceRoot != null) {
        relativeSource = util2.relative(this.sourceRoot, relativeSource);
      }
      if (this._sources.has(relativeSource)) {
        return this._sources.indexOf(relativeSource);
      }
      var i;
      for (i = 0; i < this._absoluteSources.length; ++i) {
        if (this._absoluteSources[i] == aSource) {
          return i;
        }
      }
      return -1;
    };
    BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
      var smc = Object.create(BasicSourceMapConsumer.prototype);
      var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
      var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
      smc.sourceRoot = aSourceMap._sourceRoot;
      smc.sourcesContent = aSourceMap._generateSourcesContent(
        smc._sources.toArray(),
        smc.sourceRoot
      );
      smc.file = aSourceMap._file;
      smc._sourceMapURL = aSourceMapURL;
      smc._absoluteSources = smc._sources.toArray().map(function(s) {
        return util2.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
      });
      var generatedMappings = aSourceMap._mappings.toArray().slice();
      var destGeneratedMappings = smc.__generatedMappings = [];
      var destOriginalMappings = smc.__originalMappings = [];
      for (var i = 0, length2 = generatedMappings.length; i < length2; i++) {
        var srcMapping = generatedMappings[i];
        var destMapping = new Mapping();
        destMapping.generatedLine = srcMapping.generatedLine;
        destMapping.generatedColumn = srcMapping.generatedColumn;
        if (srcMapping.source) {
          destMapping.source = sources.indexOf(srcMapping.source);
          destMapping.originalLine = srcMapping.originalLine;
          destMapping.originalColumn = srcMapping.originalColumn;
          if (srcMapping.name) {
            destMapping.name = names.indexOf(srcMapping.name);
          }
          destOriginalMappings.push(destMapping);
        }
        destGeneratedMappings.push(destMapping);
      }
      quickSort2(smc.__originalMappings, util2.compareByOriginalPositions);
      return smc;
    };
    BasicSourceMapConsumer.prototype._version = 3;
    Object.defineProperty(BasicSourceMapConsumer.prototype, "sources", {
      get: function() {
        return this._absoluteSources.slice();
      }
    });
    function Mapping() {
      this.generatedLine = 0;
      this.generatedColumn = 0;
      this.source = null;
      this.originalLine = null;
      this.originalColumn = null;
      this.name = null;
    }
    BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      var generatedLine = 1;
      var previousGeneratedColumn = 0;
      var previousOriginalLine = 0;
      var previousOriginalColumn = 0;
      var previousSource = 0;
      var previousName = 0;
      var length2 = aStr.length;
      var index = 0;
      var cachedSegments = {};
      var temp = {};
      var originalMappings = [];
      var generatedMappings = [];
      var mapping, str, segment, end, value;
      while (index < length2) {
        if (aStr.charAt(index) === ";") {
          generatedLine++;
          index++;
          previousGeneratedColumn = 0;
        } else if (aStr.charAt(index) === ",") {
          index++;
        } else {
          mapping = new Mapping();
          mapping.generatedLine = generatedLine;
          for (end = index; end < length2; end++) {
            if (this._charIsMappingSeparator(aStr, end)) {
              break;
            }
          }
          str = aStr.slice(index, end);
          segment = cachedSegments[str];
          if (segment) {
            index += str.length;
          } else {
            segment = [];
            while (index < end) {
              base64VLQ.decode(aStr, index, temp);
              value = temp.value;
              index = temp.rest;
              segment.push(value);
            }
            if (segment.length === 2) {
              throw new Error("Found a source, but no line and column");
            }
            if (segment.length === 3) {
              throw new Error("Found a source and line, but no column");
            }
            cachedSegments[str] = segment;
          }
          mapping.generatedColumn = previousGeneratedColumn + segment[0];
          previousGeneratedColumn = mapping.generatedColumn;
          if (segment.length > 1) {
            mapping.source = previousSource + segment[1];
            previousSource += segment[1];
            mapping.originalLine = previousOriginalLine + segment[2];
            previousOriginalLine = mapping.originalLine;
            mapping.originalLine += 1;
            mapping.originalColumn = previousOriginalColumn + segment[3];
            previousOriginalColumn = mapping.originalColumn;
            if (segment.length > 4) {
              mapping.name = previousName + segment[4];
              previousName += segment[4];
            }
          }
          generatedMappings.push(mapping);
          if (typeof mapping.originalLine === "number") {
            originalMappings.push(mapping);
          }
        }
      }
      quickSort2(generatedMappings, util2.compareByGeneratedPositionsDeflated);
      this.__generatedMappings = generatedMappings;
      quickSort2(originalMappings, util2.compareByOriginalPositions);
      this.__originalMappings = originalMappings;
    };
    BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
      if (aNeedle[aLineName] <= 0) {
        throw new TypeError("Line must be greater than or equal to 1, got " + aNeedle[aLineName]);
      }
      if (aNeedle[aColumnName] < 0) {
        throw new TypeError("Column must be greater than or equal to 0, got " + aNeedle[aColumnName]);
      }
      return binarySearch2.search(aNeedle, aMappings, aComparator, aBias);
    };
    BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
      for (var index = 0; index < this._generatedMappings.length; ++index) {
        var mapping = this._generatedMappings[index];
        if (index + 1 < this._generatedMappings.length) {
          var nextMapping = this._generatedMappings[index + 1];
          if (mapping.generatedLine === nextMapping.generatedLine) {
            mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
            continue;
          }
        }
        mapping.lastGeneratedColumn = Infinity;
      }
    };
    BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util2.getArg(aArgs, "line"),
        generatedColumn: util2.getArg(aArgs, "column")
      };
      var index = this._findMapping(
        needle,
        this._generatedMappings,
        "generatedLine",
        "generatedColumn",
        util2.compareByGeneratedPositionsDeflated,
        util2.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND)
      );
      if (index >= 0) {
        var mapping = this._generatedMappings[index];
        if (mapping.generatedLine === needle.generatedLine) {
          var source = util2.getArg(mapping, "source", null);
          if (source !== null) {
            source = this._sources.at(source);
            source = util2.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
          }
          var name = util2.getArg(mapping, "name", null);
          if (name !== null) {
            name = this._names.at(name);
          }
          return {
            source,
            line: util2.getArg(mapping, "originalLine", null),
            column: util2.getArg(mapping, "originalColumn", null),
            name
          };
        }
      }
      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    };
    BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
      if (!this.sourcesContent) {
        return false;
      }
      return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(sc) {
        return sc == null;
      });
    };
    BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
      if (!this.sourcesContent) {
        return null;
      }
      var index = this._findSourceIndex(aSource);
      if (index >= 0) {
        return this.sourcesContent[index];
      }
      var relativeSource = aSource;
      if (this.sourceRoot != null) {
        relativeSource = util2.relative(this.sourceRoot, relativeSource);
      }
      var url;
      if (this.sourceRoot != null && (url = util2.urlParse(this.sourceRoot))) {
        var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
        if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) {
          return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
        }
        if ((!url.path || url.path == "/") && this._sources.has("/" + relativeSource)) {
          return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
        }
      }
      if (nullOnMissing) {
        return null;
      } else {
        throw new Error('"' + relativeSource + '" is not in the SourceMap.');
      }
    };
    BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
      var source = util2.getArg(aArgs, "source");
      source = this._findSourceIndex(source);
      if (source < 0) {
        return {
          line: null,
          column: null,
          lastColumn: null
        };
      }
      var needle = {
        source,
        originalLine: util2.getArg(aArgs, "line"),
        originalColumn: util2.getArg(aArgs, "column")
      };
      var index = this._findMapping(
        needle,
        this._originalMappings,
        "originalLine",
        "originalColumn",
        util2.compareByOriginalPositions,
        util2.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND)
      );
      if (index >= 0) {
        var mapping = this._originalMappings[index];
        if (mapping.source === needle.source) {
          return {
            line: util2.getArg(mapping, "generatedLine", null),
            column: util2.getArg(mapping, "generatedColumn", null),
            lastColumn: util2.getArg(mapping, "lastGeneratedColumn", null)
          };
        }
      }
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    };
    sourceMapConsumer.BasicSourceMapConsumer = BasicSourceMapConsumer;
    function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
      var sourceMap2 = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap2 = util2.parseSourceMapInput(aSourceMap);
      }
      var version2 = util2.getArg(sourceMap2, "version");
      var sections = util2.getArg(sourceMap2, "sections");
      if (version2 != this._version) {
        throw new Error("Unsupported version: " + version2);
      }
      this._sources = new ArraySet();
      this._names = new ArraySet();
      var lastOffset = {
        line: -1,
        column: 0
      };
      this._sections = sections.map(function(s) {
        if (s.url) {
          throw new Error("Support for url field in sections not implemented.");
        }
        var offset = util2.getArg(s, "offset");
        var offsetLine = util2.getArg(offset, "line");
        var offsetColumn = util2.getArg(offset, "column");
        if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {
          throw new Error("Section offsets must be ordered and non-overlapping.");
        }
        lastOffset = offset;
        return {
          generatedOffset: {
            // The offset fields are 0-based, but we use 1-based indices when
            // encoding/decoding from VLQ.
            generatedLine: offsetLine + 1,
            generatedColumn: offsetColumn + 1
          },
          consumer: new SourceMapConsumer(util2.getArg(s, "map"), aSourceMapURL)
        };
      });
    }
    IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
    IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
    IndexedSourceMapConsumer.prototype._version = 3;
    Object.defineProperty(IndexedSourceMapConsumer.prototype, "sources", {
      get: function() {
        var sources = [];
        for (var i = 0; i < this._sections.length; i++) {
          for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
            sources.push(this._sections[i].consumer.sources[j]);
          }
        }
        return sources;
      }
    });
    IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util2.getArg(aArgs, "line"),
        generatedColumn: util2.getArg(aArgs, "column")
      };
      var sectionIndex = binarySearch2.search(
        needle,
        this._sections,
        function(needle2, section2) {
          var cmp = needle2.generatedLine - section2.generatedOffset.generatedLine;
          if (cmp) {
            return cmp;
          }
          return needle2.generatedColumn - section2.generatedOffset.generatedColumn;
        }
      );
      var section = this._sections[sectionIndex];
      if (!section) {
        return {
          source: null,
          line: null,
          column: null,
          name: null
        };
      }
      return section.consumer.originalPositionFor({
        line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
        column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
        bias: aArgs.bias
      });
    };
    IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
      return this._sections.every(function(s) {
        return s.consumer.hasContentsOfAllSources();
      });
    };
    IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];
        var content = section.consumer.sourceContentFor(aSource, true);
        if (content) {
          return content;
        }
      }
      if (nullOnMissing) {
        return null;
      } else {
        throw new Error('"' + aSource + '" is not in the SourceMap.');
      }
    };
    IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];
        if (section.consumer._findSourceIndex(util2.getArg(aArgs, "source")) === -1) {
          continue;
        }
        var generatedPosition = section.consumer.generatedPositionFor(aArgs);
        if (generatedPosition) {
          var ret = {
            line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
            column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
          };
          return ret;
        }
      }
      return {
        line: null,
        column: null
      };
    };
    IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      this.__generatedMappings = [];
      this.__originalMappings = [];
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];
        var sectionMappings = section.consumer._generatedMappings;
        for (var j = 0; j < sectionMappings.length; j++) {
          var mapping = sectionMappings[j];
          var source = section.consumer._sources.at(mapping.source);
          source = util2.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
          this._sources.add(source);
          source = this._sources.indexOf(source);
          var name = null;
          if (mapping.name) {
            name = section.consumer._names.at(mapping.name);
            this._names.add(name);
            name = this._names.indexOf(name);
          }
          var adjustedMapping = {
            source,
            generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
            generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
            originalLine: mapping.originalLine,
            originalColumn: mapping.originalColumn,
            name
          };
          this.__generatedMappings.push(adjustedMapping);
          if (typeof adjustedMapping.originalLine === "number") {
            this.__originalMappings.push(adjustedMapping);
          }
        }
      }
      quickSort2(this.__generatedMappings, util2.compareByGeneratedPositionsDeflated);
      quickSort2(this.__originalMappings, util2.compareByOriginalPositions);
    };
    sourceMapConsumer.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
    return sourceMapConsumer;
  }
  var sourceNode = {};
  var hasRequiredSourceNode;
  function requireSourceNode() {
    if (hasRequiredSourceNode) return sourceNode;
    hasRequiredSourceNode = 1;
    var SourceMapGenerator = requireSourceMapGenerator().SourceMapGenerator;
    var util2 = requireUtil();
    var REGEX_NEWLINE = /(\r?\n)/;
    var NEWLINE_CODE = 10;
    var isSourceNode = "$$$isSourceNode$$$";
    function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
      this.children = [];
      this.sourceContents = {};
      this.line = aLine == null ? null : aLine;
      this.column = aColumn == null ? null : aColumn;
      this.source = aSource == null ? null : aSource;
      this.name = aName == null ? null : aName;
      this[isSourceNode] = true;
      if (aChunks != null) this.add(aChunks);
    }
    SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
      var node = new SourceNode();
      var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
      var remainingLinesIndex = 0;
      var shiftNextLine = function() {
        var lineContents = getNextLine();
        var newLine = getNextLine() || "";
        return lineContents + newLine;
        function getNextLine() {
          return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : void 0;
        }
      };
      var lastGeneratedLine = 1, lastGeneratedColumn = 0;
      var lastMapping = null;
      aSourceMapConsumer.eachMapping(function(mapping) {
        if (lastMapping !== null) {
          if (lastGeneratedLine < mapping.generatedLine) {
            addMappingWithCode(lastMapping, shiftNextLine());
            lastGeneratedLine++;
            lastGeneratedColumn = 0;
          } else {
            var nextLine = remainingLines[remainingLinesIndex] || "";
            var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
            remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
            lastGeneratedColumn = mapping.generatedColumn;
            addMappingWithCode(lastMapping, code);
            lastMapping = mapping;
            return;
          }
        }
        while (lastGeneratedLine < mapping.generatedLine) {
          node.add(shiftNextLine());
          lastGeneratedLine++;
        }
        if (lastGeneratedColumn < mapping.generatedColumn) {
          var nextLine = remainingLines[remainingLinesIndex] || "";
          node.add(nextLine.substr(0, mapping.generatedColumn));
          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
        }
        lastMapping = mapping;
      }, this);
      if (remainingLinesIndex < remainingLines.length) {
        if (lastMapping) {
          addMappingWithCode(lastMapping, shiftNextLine());
        }
        node.add(remainingLines.splice(remainingLinesIndex).join(""));
      }
      aSourceMapConsumer.sources.forEach(function(sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          if (aRelativePath != null) {
            sourceFile = util2.join(aRelativePath, sourceFile);
          }
          node.setSourceContent(sourceFile, content);
        }
      });
      return node;
      function addMappingWithCode(mapping, code) {
        if (mapping === null || mapping.source === void 0) {
          node.add(code);
        } else {
          var source = aRelativePath ? util2.join(aRelativePath, mapping.source) : mapping.source;
          node.add(new SourceNode(
            mapping.originalLine,
            mapping.originalColumn,
            source,
            code,
            mapping.name
          ));
        }
      }
    };
    SourceNode.prototype.add = function SourceNode_add(aChunk) {
      if (Array.isArray(aChunk)) {
        aChunk.forEach(function(chunk) {
          this.add(chunk);
        }, this);
      } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
        if (aChunk) {
          this.children.push(aChunk);
        }
      } else {
        throw new TypeError(
          "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
        );
      }
      return this;
    };
    SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
      if (Array.isArray(aChunk)) {
        for (var i = aChunk.length - 1; i >= 0; i--) {
          this.prepend(aChunk[i]);
        }
      } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
        this.children.unshift(aChunk);
      } else {
        throw new TypeError(
          "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
        );
      }
      return this;
    };
    SourceNode.prototype.walk = function SourceNode_walk(aFn) {
      var chunk;
      for (var i = 0, len = this.children.length; i < len; i++) {
        chunk = this.children[i];
        if (chunk[isSourceNode]) {
          chunk.walk(aFn);
        } else {
          if (chunk !== "") {
            aFn(chunk, {
              source: this.source,
              line: this.line,
              column: this.column,
              name: this.name
            });
          }
        }
      }
    };
    SourceNode.prototype.join = function SourceNode_join(aSep) {
      var newChildren;
      var i;
      var len = this.children.length;
      if (len > 0) {
        newChildren = [];
        for (i = 0; i < len - 1; i++) {
          newChildren.push(this.children[i]);
          newChildren.push(aSep);
        }
        newChildren.push(this.children[i]);
        this.children = newChildren;
      }
      return this;
    };
    SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
      var lastChild = this.children[this.children.length - 1];
      if (lastChild[isSourceNode]) {
        lastChild.replaceRight(aPattern, aReplacement);
      } else if (typeof lastChild === "string") {
        this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
      } else {
        this.children.push("".replace(aPattern, aReplacement));
      }
      return this;
    };
    SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
      this.sourceContents[util2.toSetString(aSourceFile)] = aSourceContent;
    };
    SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
      for (var i = 0, len = this.children.length; i < len; i++) {
        if (this.children[i][isSourceNode]) {
          this.children[i].walkSourceContents(aFn);
        }
      }
      var sources = Object.keys(this.sourceContents);
      for (var i = 0, len = sources.length; i < len; i++) {
        aFn(util2.fromSetString(sources[i]), this.sourceContents[sources[i]]);
      }
    };
    SourceNode.prototype.toString = function SourceNode_toString() {
      var str = "";
      this.walk(function(chunk) {
        str += chunk;
      });
      return str;
    };
    SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
      var generated = {
        code: "",
        line: 1,
        column: 0
      };
      var map = new SourceMapGenerator(aArgs);
      var sourceMappingActive = false;
      var lastOriginalSource = null;
      var lastOriginalLine = null;
      var lastOriginalColumn = null;
      var lastOriginalName = null;
      this.walk(function(chunk, original) {
        generated.code += chunk;
        if (original.source !== null && original.line !== null && original.column !== null) {
          if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
            map.addMapping({
              source: original.source,
              original: {
                line: original.line,
                column: original.column
              },
              generated: {
                line: generated.line,
                column: generated.column
              },
              name: original.name
            });
          }
          lastOriginalSource = original.source;
          lastOriginalLine = original.line;
          lastOriginalColumn = original.column;
          lastOriginalName = original.name;
          sourceMappingActive = true;
        } else if (sourceMappingActive) {
          map.addMapping({
            generated: {
              line: generated.line,
              column: generated.column
            }
          });
          lastOriginalSource = null;
          sourceMappingActive = false;
        }
        for (var idx = 0, length2 = chunk.length; idx < length2; idx++) {
          if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
            generated.line++;
            generated.column = 0;
            if (idx + 1 === length2) {
              lastOriginalSource = null;
              sourceMappingActive = false;
            } else if (sourceMappingActive) {
              map.addMapping({
                source: original.source,
                original: {
                  line: original.line,
                  column: original.column
                },
                generated: {
                  line: generated.line,
                  column: generated.column
                },
                name: original.name
              });
            }
          } else {
            generated.column++;
          }
        }
      });
      this.walkSourceContents(function(sourceFile, sourceContent) {
        map.setSourceContent(sourceFile, sourceContent);
      });
      return { code: generated.code, map };
    };
    sourceNode.SourceNode = SourceNode;
    return sourceNode;
  }
  var hasRequiredSourceMap;
  function requireSourceMap() {
    if (hasRequiredSourceMap) return sourceMap;
    hasRequiredSourceMap = 1;
    sourceMap.SourceMapGenerator = requireSourceMapGenerator().SourceMapGenerator;
    sourceMap.SourceMapConsumer = requireSourceMapConsumer().SourceMapConsumer;
    sourceMap.SourceNode = requireSourceNode().SourceNode;
    return sourceMap;
  }
  var hasRequiredCodeGen;
  function requireCodeGen() {
    if (hasRequiredCodeGen) return codeGen.exports;
    hasRequiredCodeGen = 1;
    (function(module, exports) {
      exports.__esModule = true;
      var _utils = requireUtils();
      var SourceNode = void 0;
      try {
        if (true) {
          var SourceMap = requireSourceMap();
          SourceNode = SourceMap.SourceNode;
        }
      } catch (err) {
      }
      if (!SourceNode) {
        SourceNode = function(line, column, srcFile, chunks) {
          this.src = "";
          if (chunks) {
            this.add(chunks);
          }
        };
        SourceNode.prototype = {
          add: function add(chunks) {
            if (_utils.isArray(chunks)) {
              chunks = chunks.join("");
            }
            this.src += chunks;
          },
          prepend: function prepend(chunks) {
            if (_utils.isArray(chunks)) {
              chunks = chunks.join("");
            }
            this.src = chunks + this.src;
          },
          toStringWithSourceMap: function toStringWithSourceMap() {
            return { code: this.toString() };
          },
          toString: function toString2() {
            return this.src;
          }
        };
      }
      function castChunk(chunk, codeGen2, loc) {
        if (_utils.isArray(chunk)) {
          var ret = [];
          for (var i = 0, len = chunk.length; i < len; i++) {
            ret.push(codeGen2.wrap(chunk[i], loc));
          }
          return ret;
        } else if (typeof chunk === "boolean" || typeof chunk === "number") {
          return chunk + "";
        }
        return chunk;
      }
      function CodeGen(srcFile) {
        this.srcFile = srcFile;
        this.source = [];
      }
      CodeGen.prototype = {
        isEmpty: function isEmpty() {
          return !this.source.length;
        },
        prepend: function prepend(source, loc) {
          this.source.unshift(this.wrap(source, loc));
        },
        push: function push(source, loc) {
          this.source.push(this.wrap(source, loc));
        },
        merge: function merge() {
          var source = this.empty();
          this.each(function(line) {
            source.add(["  ", line, "\n"]);
          });
          return source;
        },
        each: function each2(iter) {
          for (var i = 0, len = this.source.length; i < len; i++) {
            iter(this.source[i]);
          }
        },
        empty: function empty() {
          var loc = this.currentLocation || { start: {} };
          return new SourceNode(loc.start.line, loc.start.column, this.srcFile);
        },
        wrap: function wrap(chunk) {
          var loc = arguments.length <= 1 || arguments[1] === void 0 ? this.currentLocation || { start: {} } : arguments[1];
          if (chunk instanceof SourceNode) {
            return chunk;
          }
          chunk = castChunk(chunk, this, loc);
          return new SourceNode(loc.start.line, loc.start.column, this.srcFile, chunk);
        },
        functionCall: function functionCall(fn, type, params) {
          params = this.generateList(params);
          return this.wrap([fn, type ? "." + type + "(" : "(", params, ")"]);
        },
        quotedString: function quotedString(str) {
          return '"' + (str + "").replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029") + '"';
        },
        objectLiteral: function objectLiteral(obj) {
          var _this = this;
          var pairs = [];
          Object.keys(obj).forEach(function(key) {
            var value = castChunk(obj[key], _this);
            if (value !== "undefined") {
              pairs.push([_this.quotedString(key), ":", value]);
            }
          });
          var ret = this.generateList(pairs);
          ret.prepend("{");
          ret.add("}");
          return ret;
        },
        generateList: function generateList(entries) {
          var ret = this.empty();
          for (var i = 0, len = entries.length; i < len; i++) {
            if (i) {
              ret.add(",");
            }
            ret.add(castChunk(entries[i], this));
          }
          return ret;
        },
        generateArray: function generateArray(entries) {
          var ret = this.generateList(entries);
          ret.prepend("[");
          ret.add("]");
          return ret;
        }
      };
      exports["default"] = CodeGen;
      module.exports = exports["default"];
    })(codeGen, codeGen.exports);
    return codeGen.exports;
  }
  var hasRequiredJavascriptCompiler;
  function requireJavascriptCompiler() {
    if (hasRequiredJavascriptCompiler) return javascriptCompiler.exports;
    hasRequiredJavascriptCompiler = 1;
    (function(module, exports) {
      exports.__esModule = true;
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var _base = requireBase$1();
      var _exception = requireException();
      var _exception2 = _interopRequireDefault(_exception);
      var _utils = requireUtils();
      var _codeGen = requireCodeGen();
      var _codeGen2 = _interopRequireDefault(_codeGen);
      function Literal(value) {
        this.value = value;
      }
      function JavaScriptCompiler() {
      }
      JavaScriptCompiler.prototype = {
        // PUBLIC API: You can override these methods in a subclass to provide
        // alternative compiled forms for name lookup and buffering semantics
        nameLookup: function nameLookup(parent, name) {
          return this.internalNameLookup(parent, name);
        },
        depthedLookup: function depthedLookup(name) {
          return [this.aliasable("container.lookup"), "(depths, ", JSON.stringify(name), ")"];
        },
        compilerInfo: function compilerInfo() {
          var revision = _base.COMPILER_REVISION, versions = _base.REVISION_CHANGES[revision];
          return [revision, versions];
        },
        appendToBuffer: function appendToBuffer(source, location, explicit) {
          if (!_utils.isArray(source)) {
            source = [source];
          }
          source = this.source.wrap(source, location);
          if (this.environment.isSimple) {
            return ["return ", source, ";"];
          } else if (explicit) {
            return ["buffer += ", source, ";"];
          } else {
            source.appendToBuffer = true;
            return source;
          }
        },
        initializeBuffer: function initializeBuffer() {
          return this.quotedString("");
        },
        // END PUBLIC API
        internalNameLookup: function internalNameLookup(parent, name) {
          this.lookupPropertyFunctionIsUsed = true;
          return ["lookupProperty(", parent, ",", JSON.stringify(name), ")"];
        },
        lookupPropertyFunctionIsUsed: false,
        compile: function compile(environment, options, context, asObject) {
          this.environment = environment;
          this.options = options;
          this.stringParams = this.options.stringParams;
          this.trackIds = this.options.trackIds;
          this.precompile = !asObject;
          this.name = this.environment.name;
          this.isChild = !!context;
          this.context = context || {
            decorators: [],
            programs: [],
            environments: []
          };
          this.preamble();
          this.stackSlot = 0;
          this.stackVars = [];
          this.aliases = {};
          this.registers = { list: [] };
          this.hashes = [];
          this.compileStack = [];
          this.inlineStack = [];
          this.blockParams = [];
          this.compileChildren(environment, options);
          this.useDepths = this.useDepths || environment.useDepths || environment.useDecorators || this.options.compat;
          this.useBlockParams = this.useBlockParams || environment.useBlockParams;
          var opcodes = environment.opcodes, opcode = void 0, firstLoc = void 0, i = void 0, l = void 0;
          for (i = 0, l = opcodes.length; i < l; i++) {
            opcode = opcodes[i];
            this.source.currentLocation = opcode.loc;
            firstLoc = firstLoc || opcode.loc;
            this[opcode.opcode].apply(this, opcode.args);
          }
          this.source.currentLocation = firstLoc;
          this.pushSource("");
          if (this.stackSlot || this.inlineStack.length || this.compileStack.length) {
            throw new _exception2["default"]("Compile completed with content left on stack");
          }
          if (!this.decorators.isEmpty()) {
            this.useDecorators = true;
            this.decorators.prepend(["var decorators = container.decorators, ", this.lookupPropertyFunctionVarDeclaration(), ";\n"]);
            this.decorators.push("return fn;");
            if (asObject) {
              this.decorators = Function.apply(this, ["fn", "props", "container", "depth0", "data", "blockParams", "depths", this.decorators.merge()]);
            } else {
              this.decorators.prepend("function(fn, props, container, depth0, data, blockParams, depths) {\n");
              this.decorators.push("}\n");
              this.decorators = this.decorators.merge();
            }
          } else {
            this.decorators = void 0;
          }
          var fn = this.createFunctionContext(asObject);
          if (!this.isChild) {
            var ret = {
              compiler: this.compilerInfo(),
              main: fn
            };
            if (this.decorators) {
              ret.main_d = this.decorators;
              ret.useDecorators = true;
            }
            var _context = this.context;
            var programs = _context.programs;
            var decorators2 = _context.decorators;
            for (i = 0, l = programs.length; i < l; i++) {
              if (programs[i]) {
                ret[i] = programs[i];
                if (decorators2[i]) {
                  ret[i + "_d"] = decorators2[i];
                  ret.useDecorators = true;
                }
              }
            }
            if (this.environment.usePartial) {
              ret.usePartial = true;
            }
            if (this.options.data) {
              ret.useData = true;
            }
            if (this.useDepths) {
              ret.useDepths = true;
            }
            if (this.useBlockParams) {
              ret.useBlockParams = true;
            }
            if (this.options.compat) {
              ret.compat = true;
            }
            if (!asObject) {
              ret.compiler = JSON.stringify(ret.compiler);
              this.source.currentLocation = { start: { line: 1, column: 0 } };
              ret = this.objectLiteral(ret);
              if (options.srcName) {
                ret = ret.toStringWithSourceMap({ file: options.destName });
                ret.map = ret.map && ret.map.toString();
              } else {
                ret = ret.toString();
              }
            } else {
              ret.compilerOptions = this.options;
            }
            return ret;
          } else {
            return fn;
          }
        },
        preamble: function preamble() {
          this.lastContext = 0;
          this.source = new _codeGen2["default"](this.options.srcName);
          this.decorators = new _codeGen2["default"](this.options.srcName);
        },
        createFunctionContext: function createFunctionContext(asObject) {
          var _this = this;
          var varDeclarations = "";
          var locals = this.stackVars.concat(this.registers.list);
          if (locals.length > 0) {
            varDeclarations += ", " + locals.join(", ");
          }
          var aliasCount = 0;
          Object.keys(this.aliases).forEach(function(alias) {
            var node = _this.aliases[alias];
            if (node.children && node.referenceCount > 1) {
              varDeclarations += ", alias" + ++aliasCount + "=" + alias;
              node.children[0] = "alias" + aliasCount;
            }
          });
          if (this.lookupPropertyFunctionIsUsed) {
            varDeclarations += ", " + this.lookupPropertyFunctionVarDeclaration();
          }
          var params = ["container", "depth0", "helpers", "partials", "data"];
          if (this.useBlockParams || this.useDepths) {
            params.push("blockParams");
          }
          if (this.useDepths) {
            params.push("depths");
          }
          var source = this.mergeSource(varDeclarations);
          if (asObject) {
            params.push(source);
            return Function.apply(this, params);
          } else {
            return this.source.wrap(["function(", params.join(","), ") {\n  ", source, "}"]);
          }
        },
        mergeSource: function mergeSource(varDeclarations) {
          var isSimple = this.environment.isSimple, appendOnly = !this.forceBuffer, appendFirst = void 0, sourceSeen = void 0, bufferStart = void 0, bufferEnd = void 0;
          this.source.each(function(line) {
            if (line.appendToBuffer) {
              if (bufferStart) {
                line.prepend("  + ");
              } else {
                bufferStart = line;
              }
              bufferEnd = line;
            } else {
              if (bufferStart) {
                if (!sourceSeen) {
                  appendFirst = true;
                } else {
                  bufferStart.prepend("buffer += ");
                }
                bufferEnd.add(";");
                bufferStart = bufferEnd = void 0;
              }
              sourceSeen = true;
              if (!isSimple) {
                appendOnly = false;
              }
            }
          });
          if (appendOnly) {
            if (bufferStart) {
              bufferStart.prepend("return ");
              bufferEnd.add(";");
            } else if (!sourceSeen) {
              this.source.push('return "";');
            }
          } else {
            varDeclarations += ", buffer = " + (appendFirst ? "" : this.initializeBuffer());
            if (bufferStart) {
              bufferStart.prepend("return buffer + ");
              bufferEnd.add(";");
            } else {
              this.source.push("return buffer;");
            }
          }
          if (varDeclarations) {
            this.source.prepend("var " + varDeclarations.substring(2) + (appendFirst ? "" : ";\n"));
          }
          return this.source.merge();
        },
        lookupPropertyFunctionVarDeclaration: function lookupPropertyFunctionVarDeclaration() {
          return "\n      lookupProperty = container.lookupProperty || function(parent, propertyName) {\n        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {\n          return parent[propertyName];\n        }\n        return undefined\n    }\n    ".trim();
        },
        // [blockValue]
        //
        // On stack, before: hash, inverse, program, value
        // On stack, after: return value of blockHelperMissing
        //
        // The purpose of this opcode is to take a block of the form
        // `{{#this.foo}}...{{/this.foo}}`, resolve the value of `foo`, and
        // replace it on the stack with the result of properly
        // invoking blockHelperMissing.
        blockValue: function blockValue(name) {
          var blockHelperMissing2 = this.aliasable("container.hooks.blockHelperMissing"), params = [this.contextName(0)];
          this.setupHelperArgs(name, 0, params);
          var blockName = this.popStack();
          params.splice(1, 0, blockName);
          this.push(this.source.functionCall(blockHelperMissing2, "call", params));
        },
        // [ambiguousBlockValue]
        //
        // On stack, before: hash, inverse, program, value
        // Compiler value, before: lastHelper=value of last found helper, if any
        // On stack, after, if no lastHelper: same as [blockValue]
        // On stack, after, if lastHelper: value
        ambiguousBlockValue: function ambiguousBlockValue() {
          var blockHelperMissing2 = this.aliasable("container.hooks.blockHelperMissing"), params = [this.contextName(0)];
          this.setupHelperArgs("", 0, params, true);
          this.flushInline();
          var current = this.topStack();
          params.splice(1, 0, current);
          this.pushSource(["if (!", this.lastHelper, ") { ", current, " = ", this.source.functionCall(blockHelperMissing2, "call", params), "}"]);
        },
        // [appendContent]
        //
        // On stack, before: ...
        // On stack, after: ...
        //
        // Appends the string value of `content` to the current buffer
        appendContent: function appendContent(content) {
          if (this.pendingContent) {
            content = this.pendingContent + content;
          } else {
            this.pendingLocation = this.source.currentLocation;
          }
          this.pendingContent = content;
        },
        // [append]
        //
        // On stack, before: value, ...
        // On stack, after: ...
        //
        // Coerces `value` to a String and appends it to the current buffer.
        //
        // If `value` is truthy, or 0, it is coerced into a string and appended
        // Otherwise, the empty string is appended
        append: function append() {
          if (this.isInline()) {
            this.replaceStack(function(current) {
              return [" != null ? ", current, ' : ""'];
            });
            this.pushSource(this.appendToBuffer(this.popStack()));
          } else {
            var local = this.popStack();
            this.pushSource(["if (", local, " != null) { ", this.appendToBuffer(local, void 0, true), " }"]);
            if (this.environment.isSimple) {
              this.pushSource(["else { ", this.appendToBuffer("''", void 0, true), " }"]);
            }
          }
        },
        // [appendEscaped]
        //
        // On stack, before: value, ...
        // On stack, after: ...
        //
        // Escape `value` and append it to the buffer
        appendEscaped: function appendEscaped() {
          this.pushSource(this.appendToBuffer([this.aliasable("container.escapeExpression"), "(", this.popStack(), ")"]));
        },
        // [getContext]
        //
        // On stack, before: ...
        // On stack, after: ...
        // Compiler value, after: lastContext=depth
        //
        // Set the value of the `lastContext` compiler value to the depth
        getContext: function getContext(depth) {
          this.lastContext = depth;
        },
        // [pushContext]
        //
        // On stack, before: ...
        // On stack, after: currentContext, ...
        //
        // Pushes the value of the current context onto the stack.
        pushContext: function pushContext() {
          this.pushStackLiteral(this.contextName(this.lastContext));
        },
        // [lookupOnContext]
        //
        // On stack, before: ...
        // On stack, after: currentContext[name], ...
        //
        // Looks up the value of `name` on the current context and pushes
        // it onto the stack.
        lookupOnContext: function lookupOnContext(parts, falsy, strict, scoped) {
          var i = 0;
          if (!scoped && this.options.compat && !this.lastContext) {
            this.push(this.depthedLookup(parts[i++]));
          } else {
            this.pushContext();
          }
          this.resolvePath("context", parts, i, falsy, strict);
        },
        // [lookupBlockParam]
        //
        // On stack, before: ...
        // On stack, after: blockParam[name], ...
        //
        // Looks up the value of `parts` on the given block param and pushes
        // it onto the stack.
        lookupBlockParam: function lookupBlockParam(blockParamId, parts) {
          this.useBlockParams = true;
          this.push(["blockParams[", blockParamId[0], "][", blockParamId[1], "]"]);
          this.resolvePath("context", parts, 1);
        },
        // [lookupData]
        //
        // On stack, before: ...
        // On stack, after: data, ...
        //
        // Push the data lookup operator
        lookupData: function lookupData(depth, parts, strict) {
          if (!depth) {
            this.pushStackLiteral("data");
          } else {
            this.pushStackLiteral("container.data(data, " + depth + ")");
          }
          this.resolvePath("data", parts, 0, true, strict);
        },
        resolvePath: function resolvePath(type, parts, i, falsy, strict) {
          var _this2 = this;
          if (this.options.strict || this.options.assumeObjects) {
            this.push(strictLookup(this.options.strict && strict, this, parts, i, type));
            return;
          }
          var len = parts.length;
          for (; i < len; i++) {
            this.replaceStack(function(current) {
              var lookup2 = _this2.nameLookup(current, parts[i], type);
              if (!falsy) {
                return [" != null ? ", lookup2, " : ", current];
              } else {
                return [" && ", lookup2];
              }
            });
          }
        },
        // [resolvePossibleLambda]
        //
        // On stack, before: value, ...
        // On stack, after: resolved value, ...
        //
        // If the `value` is a lambda, replace it on the stack by
        // the return value of the lambda
        resolvePossibleLambda: function resolvePossibleLambda() {
          this.push([this.aliasable("container.lambda"), "(", this.popStack(), ", ", this.contextName(0), ")"]);
        },
        // [pushStringParam]
        //
        // On stack, before: ...
        // On stack, after: string, currentContext, ...
        //
        // This opcode is designed for use in string mode, which
        // provides the string value of a parameter along with its
        // depth rather than resolving it immediately.
        pushStringParam: function pushStringParam(string2, type) {
          this.pushContext();
          this.pushString(type);
          if (type !== "SubExpression") {
            if (typeof string2 === "string") {
              this.pushString(string2);
            } else {
              this.pushStackLiteral(string2);
            }
          }
        },
        emptyHash: function emptyHash(omitEmpty) {
          if (this.trackIds) {
            this.push("{}");
          }
          if (this.stringParams) {
            this.push("{}");
            this.push("{}");
          }
          this.pushStackLiteral(omitEmpty ? "undefined" : "{}");
        },
        pushHash: function pushHash() {
          if (this.hash) {
            this.hashes.push(this.hash);
          }
          this.hash = { values: {}, types: [], contexts: [], ids: [] };
        },
        popHash: function popHash() {
          var hash = this.hash;
          this.hash = this.hashes.pop();
          if (this.trackIds) {
            this.push(this.objectLiteral(hash.ids));
          }
          if (this.stringParams) {
            this.push(this.objectLiteral(hash.contexts));
            this.push(this.objectLiteral(hash.types));
          }
          this.push(this.objectLiteral(hash.values));
        },
        // [pushString]
        //
        // On stack, before: ...
        // On stack, after: quotedString(string), ...
        //
        // Push a quoted version of `string` onto the stack
        pushString: function pushString(string2) {
          this.pushStackLiteral(this.quotedString(string2));
        },
        // [pushLiteral]
        //
        // On stack, before: ...
        // On stack, after: value, ...
        //
        // Pushes a value onto the stack. This operation prevents
        // the compiler from creating a temporary variable to hold
        // it.
        pushLiteral: function pushLiteral(value) {
          this.pushStackLiteral(value);
        },
        // [pushProgram]
        //
        // On stack, before: ...
        // On stack, after: program(guid), ...
        //
        // Push a program expression onto the stack. This takes
        // a compile-time guid and converts it into a runtime-accessible
        // expression.
        pushProgram: function pushProgram(guid) {
          if (guid != null) {
            this.pushStackLiteral(this.programExpression(guid));
          } else {
            this.pushStackLiteral(null);
          }
        },
        // [registerDecorator]
        //
        // On stack, before: hash, program, params..., ...
        // On stack, after: ...
        //
        // Pops off the decorator's parameters, invokes the decorator,
        // and inserts the decorator into the decorators list.
        registerDecorator: function registerDecorator(paramSize, name) {
          var foundDecorator = this.nameLookup("decorators", name, "decorator"), options = this.setupHelperArgs(name, paramSize);
          this.decorators.push(["fn = ", this.decorators.functionCall(foundDecorator, "", ["fn", "props", "container", options]), " || fn;"]);
        },
        // [invokeHelper]
        //
        // On stack, before: hash, inverse, program, params..., ...
        // On stack, after: result of helper invocation
        //
        // Pops off the helper's parameters, invokes the helper,
        // and pushes the helper's return value onto the stack.
        //
        // If the helper is not found, `helperMissing` is called.
        invokeHelper: function invokeHelper(paramSize, name, isSimple) {
          var nonHelper = this.popStack(), helper = this.setupHelper(paramSize, name);
          var possibleFunctionCalls = [];
          if (isSimple) {
            possibleFunctionCalls.push(helper.name);
          }
          possibleFunctionCalls.push(nonHelper);
          if (!this.options.strict) {
            possibleFunctionCalls.push(this.aliasable("container.hooks.helperMissing"));
          }
          var functionLookupCode = ["(", this.itemsSeparatedBy(possibleFunctionCalls, "||"), ")"];
          var functionCall = this.source.functionCall(functionLookupCode, "call", helper.callParams);
          this.push(functionCall);
        },
        itemsSeparatedBy: function itemsSeparatedBy(items, separator) {
          var result = [];
          result.push(items[0]);
          for (var i = 1; i < items.length; i++) {
            result.push(separator, items[i]);
          }
          return result;
        },
        // [invokeKnownHelper]
        //
        // On stack, before: hash, inverse, program, params..., ...
        // On stack, after: result of helper invocation
        //
        // This operation is used when the helper is known to exist,
        // so a `helperMissing` fallback is not required.
        invokeKnownHelper: function invokeKnownHelper(paramSize, name) {
          var helper = this.setupHelper(paramSize, name);
          this.push(this.source.functionCall(helper.name, "call", helper.callParams));
        },
        // [invokeAmbiguous]
        //
        // On stack, before: hash, inverse, program, params..., ...
        // On stack, after: result of disambiguation
        //
        // This operation is used when an expression like `{{foo}}`
        // is provided, but we don't know at compile-time whether it
        // is a helper or a path.
        //
        // This operation emits more code than the other options,
        // and can be avoided by passing the `knownHelpers` and
        // `knownHelpersOnly` flags at compile-time.
        invokeAmbiguous: function invokeAmbiguous(name, helperCall) {
          this.useRegister("helper");
          var nonHelper = this.popStack();
          this.emptyHash();
          var helper = this.setupHelper(0, name, helperCall);
          var helperName = this.lastHelper = this.nameLookup("helpers", name, "helper");
          var lookup2 = ["(", "(helper = ", helperName, " || ", nonHelper, ")"];
          if (!this.options.strict) {
            lookup2[0] = "(helper = ";
            lookup2.push(" != null ? helper : ", this.aliasable("container.hooks.helperMissing"));
          }
          this.push(["(", lookup2, helper.paramsInit ? ["),(", helper.paramsInit] : [], "),", "(typeof helper === ", this.aliasable('"function"'), " ? ", this.source.functionCall("helper", "call", helper.callParams), " : helper))"]);
        },
        // [invokePartial]
        //
        // On stack, before: context, ...
        // On stack after: result of partial invocation
        //
        // This operation pops off a context, invokes a partial with that context,
        // and pushes the result of the invocation back.
        invokePartial: function invokePartial(isDynamic, name, indent) {
          var params = [], options = this.setupParams(name, 1, params);
          if (isDynamic) {
            name = this.popStack();
            delete options.name;
          }
          if (indent) {
            options.indent = JSON.stringify(indent);
          }
          options.helpers = "helpers";
          options.partials = "partials";
          options.decorators = "container.decorators";
          if (!isDynamic) {
            params.unshift(this.nameLookup("partials", name, "partial"));
          } else {
            params.unshift(name);
          }
          if (this.options.compat) {
            options.depths = "depths";
          }
          options = this.objectLiteral(options);
          params.push(options);
          this.push(this.source.functionCall("container.invokePartial", "", params));
        },
        // [assignToHash]
        //
        // On stack, before: value, ..., hash, ...
        // On stack, after: ..., hash, ...
        //
        // Pops a value off the stack and assigns it to the current hash
        assignToHash: function assignToHash(key) {
          var value = this.popStack(), context = void 0, type = void 0, id = void 0;
          if (this.trackIds) {
            id = this.popStack();
          }
          if (this.stringParams) {
            type = this.popStack();
            context = this.popStack();
          }
          var hash = this.hash;
          if (context) {
            hash.contexts[key] = context;
          }
          if (type) {
            hash.types[key] = type;
          }
          if (id) {
            hash.ids[key] = id;
          }
          hash.values[key] = value;
        },
        pushId: function pushId(type, name, child) {
          if (type === "BlockParam") {
            this.pushStackLiteral("blockParams[" + name[0] + "].path[" + name[1] + "]" + (child ? " + " + JSON.stringify("." + child) : ""));
          } else if (type === "PathExpression") {
            this.pushString(name);
          } else if (type === "SubExpression") {
            this.pushStackLiteral("true");
          } else {
            this.pushStackLiteral("null");
          }
        },
        // HELPERS
        compiler: JavaScriptCompiler,
        compileChildren: function compileChildren(environment, options) {
          var children = environment.children, child = void 0, compiler2 = void 0;
          for (var i = 0, l = children.length; i < l; i++) {
            child = children[i];
            compiler2 = new this.compiler();
            var existing = this.matchExistingProgram(child);
            if (existing == null) {
              this.context.programs.push("");
              var index = this.context.programs.length;
              child.index = index;
              child.name = "program" + index;
              this.context.programs[index] = compiler2.compile(child, options, this.context, !this.precompile);
              this.context.decorators[index] = compiler2.decorators;
              this.context.environments[index] = child;
              this.useDepths = this.useDepths || compiler2.useDepths;
              this.useBlockParams = this.useBlockParams || compiler2.useBlockParams;
              child.useDepths = this.useDepths;
              child.useBlockParams = this.useBlockParams;
            } else {
              child.index = existing.index;
              child.name = "program" + existing.index;
              this.useDepths = this.useDepths || existing.useDepths;
              this.useBlockParams = this.useBlockParams || existing.useBlockParams;
            }
          }
        },
        matchExistingProgram: function matchExistingProgram(child) {
          for (var i = 0, len = this.context.environments.length; i < len; i++) {
            var environment = this.context.environments[i];
            if (environment && environment.equals(child)) {
              return environment;
            }
          }
        },
        programExpression: function programExpression(guid) {
          var child = this.environment.children[guid], programParams = [child.index, "data", child.blockParams];
          if (this.useBlockParams || this.useDepths) {
            programParams.push("blockParams");
          }
          if (this.useDepths) {
            programParams.push("depths");
          }
          return "container.program(" + programParams.join(", ") + ")";
        },
        useRegister: function useRegister(name) {
          if (!this.registers[name]) {
            this.registers[name] = true;
            this.registers.list.push(name);
          }
        },
        push: function push(expr) {
          if (!(expr instanceof Literal)) {
            expr = this.source.wrap(expr);
          }
          this.inlineStack.push(expr);
          return expr;
        },
        pushStackLiteral: function pushStackLiteral(item) {
          this.push(new Literal(item));
        },
        pushSource: function pushSource(source) {
          if (this.pendingContent) {
            this.source.push(this.appendToBuffer(this.source.quotedString(this.pendingContent), this.pendingLocation));
            this.pendingContent = void 0;
          }
          if (source) {
            this.source.push(source);
          }
        },
        replaceStack: function replaceStack(callback) {
          var prefix = ["("], stack = void 0, createdStack = void 0, usedLiteral = void 0;
          if (!this.isInline()) {
            throw new _exception2["default"]("replaceStack on non-inline");
          }
          var top = this.popStack(true);
          if (top instanceof Literal) {
            stack = [top.value];
            prefix = ["(", stack];
            usedLiteral = true;
          } else {
            createdStack = true;
            var _name = this.incrStack();
            prefix = ["((", this.push(_name), " = ", top, ")"];
            stack = this.topStack();
          }
          var item = callback.call(this, stack);
          if (!usedLiteral) {
            this.popStack();
          }
          if (createdStack) {
            this.stackSlot--;
          }
          this.push(prefix.concat(item, ")"));
        },
        incrStack: function incrStack() {
          this.stackSlot++;
          if (this.stackSlot > this.stackVars.length) {
            this.stackVars.push("stack" + this.stackSlot);
          }
          return this.topStackName();
        },
        topStackName: function topStackName() {
          return "stack" + this.stackSlot;
        },
        flushInline: function flushInline() {
          var inlineStack = this.inlineStack;
          this.inlineStack = [];
          for (var i = 0, len = inlineStack.length; i < len; i++) {
            var entry = inlineStack[i];
            if (entry instanceof Literal) {
              this.compileStack.push(entry);
            } else {
              var stack = this.incrStack();
              this.pushSource([stack, " = ", entry, ";"]);
              this.compileStack.push(stack);
            }
          }
        },
        isInline: function isInline() {
          return this.inlineStack.length;
        },
        popStack: function popStack(wrapped) {
          var inline2 = this.isInline(), item = (inline2 ? this.inlineStack : this.compileStack).pop();
          if (!wrapped && item instanceof Literal) {
            return item.value;
          } else {
            if (!inline2) {
              if (!this.stackSlot) {
                throw new _exception2["default"]("Invalid stack pop");
              }
              this.stackSlot--;
            }
            return item;
          }
        },
        topStack: function topStack() {
          var stack = this.isInline() ? this.inlineStack : this.compileStack, item = stack[stack.length - 1];
          if (item instanceof Literal) {
            return item.value;
          } else {
            return item;
          }
        },
        contextName: function contextName(context) {
          if (this.useDepths && context) {
            return "depths[" + context + "]";
          } else {
            return "depth" + context;
          }
        },
        quotedString: function quotedString(str) {
          return this.source.quotedString(str);
        },
        objectLiteral: function objectLiteral(obj) {
          return this.source.objectLiteral(obj);
        },
        aliasable: function aliasable(name) {
          var ret = this.aliases[name];
          if (ret) {
            ret.referenceCount++;
            return ret;
          }
          ret = this.aliases[name] = this.source.wrap(name);
          ret.aliasable = true;
          ret.referenceCount = 1;
          return ret;
        },
        setupHelper: function setupHelper(paramSize, name, blockHelper) {
          var params = [], paramsInit = this.setupHelperArgs(name, paramSize, params, blockHelper);
          var foundHelper = this.nameLookup("helpers", name, "helper"), callContext = this.aliasable(this.contextName(0) + " != null ? " + this.contextName(0) + " : (container.nullContext || {})");
          return {
            params,
            paramsInit,
            name: foundHelper,
            callParams: [callContext].concat(params)
          };
        },
        setupParams: function setupParams(helper, paramSize, params) {
          var options = {}, contexts = [], types2 = [], ids = [], objectArgs = !params, param = void 0;
          if (objectArgs) {
            params = [];
          }
          options.name = this.quotedString(helper);
          options.hash = this.popStack();
          if (this.trackIds) {
            options.hashIds = this.popStack();
          }
          if (this.stringParams) {
            options.hashTypes = this.popStack();
            options.hashContexts = this.popStack();
          }
          var inverse = this.popStack(), program = this.popStack();
          if (program || inverse) {
            options.fn = program || "container.noop";
            options.inverse = inverse || "container.noop";
          }
          var i = paramSize;
          while (i--) {
            param = this.popStack();
            params[i] = param;
            if (this.trackIds) {
              ids[i] = this.popStack();
            }
            if (this.stringParams) {
              types2[i] = this.popStack();
              contexts[i] = this.popStack();
            }
          }
          if (objectArgs) {
            options.args = this.source.generateArray(params);
          }
          if (this.trackIds) {
            options.ids = this.source.generateArray(ids);
          }
          if (this.stringParams) {
            options.types = this.source.generateArray(types2);
            options.contexts = this.source.generateArray(contexts);
          }
          if (this.options.data) {
            options.data = "data";
          }
          if (this.useBlockParams) {
            options.blockParams = "blockParams";
          }
          return options;
        },
        setupHelperArgs: function setupHelperArgs(helper, paramSize, params, useRegister) {
          var options = this.setupParams(helper, paramSize, params);
          options.loc = JSON.stringify(this.source.currentLocation);
          options = this.objectLiteral(options);
          if (useRegister) {
            this.useRegister("options");
            params.push("options");
            return ["options=", options];
          } else if (params) {
            params.push(options);
            return "";
          } else {
            return options;
          }
        }
      };
      (function() {
        var reservedWords = "break else new var case finally return void catch for switch while continue function this with default if throw delete in try do instanceof typeof abstract enum int short boolean export interface static byte extends long super char final native synchronized class float package throws const goto private transient debugger implements protected volatile double import public let yield await null true false".split(" ");
        var compilerWords = JavaScriptCompiler.RESERVED_WORDS = {};
        for (var i = 0, l = reservedWords.length; i < l; i++) {
          compilerWords[reservedWords[i]] = true;
        }
      })();
      JavaScriptCompiler.isValidJavaScriptVariableName = function(name) {
        return !JavaScriptCompiler.RESERVED_WORDS[name] && /^[a-zA-Z_$][0-9a-zA-Z_$]*$/.test(name);
      };
      function strictLookup(requireTerminal, compiler2, parts, i, type) {
        var stack = compiler2.popStack(), len = parts.length;
        if (requireTerminal) {
          len--;
        }
        for (; i < len; i++) {
          stack = compiler2.nameLookup(stack, parts[i], type);
        }
        if (requireTerminal) {
          return [compiler2.aliasable("container.strict"), "(", stack, ", ", compiler2.quotedString(parts[i]), ", ", JSON.stringify(compiler2.source.currentLocation), " )"];
        } else {
          return stack;
        }
      }
      exports["default"] = JavaScriptCompiler;
      module.exports = exports["default"];
    })(javascriptCompiler, javascriptCompiler.exports);
    return javascriptCompiler.exports;
  }
  var hasRequiredHandlebars;
  function requireHandlebars() {
    if (hasRequiredHandlebars) return handlebars.exports;
    hasRequiredHandlebars = 1;
    (function(module, exports) {
      exports.__esModule = true;
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var _handlebarsRuntime = requireHandlebars_runtime();
      var _handlebarsRuntime2 = _interopRequireDefault(_handlebarsRuntime);
      var _handlebarsCompilerAst = requireAst();
      var _handlebarsCompilerAst2 = _interopRequireDefault(_handlebarsCompilerAst);
      var _handlebarsCompilerBase = requireBase();
      var _handlebarsCompilerCompiler = requireCompiler();
      var _handlebarsCompilerJavascriptCompiler = requireJavascriptCompiler();
      var _handlebarsCompilerJavascriptCompiler2 = _interopRequireDefault(_handlebarsCompilerJavascriptCompiler);
      var _handlebarsCompilerVisitor = requireVisitor();
      var _handlebarsCompilerVisitor2 = _interopRequireDefault(_handlebarsCompilerVisitor);
      var _handlebarsNoConflict = requireNoConflict();
      var _handlebarsNoConflict2 = _interopRequireDefault(_handlebarsNoConflict);
      var _create = _handlebarsRuntime2["default"].create;
      function create2() {
        var hb = _create();
        hb.compile = function(input, options) {
          return _handlebarsCompilerCompiler.compile(input, options, hb);
        };
        hb.precompile = function(input, options) {
          return _handlebarsCompilerCompiler.precompile(input, options, hb);
        };
        hb.AST = _handlebarsCompilerAst2["default"];
        hb.Compiler = _handlebarsCompilerCompiler.Compiler;
        hb.JavaScriptCompiler = _handlebarsCompilerJavascriptCompiler2["default"];
        hb.Parser = _handlebarsCompilerBase.parser;
        hb.parse = _handlebarsCompilerBase.parse;
        hb.parseWithoutProcessing = _handlebarsCompilerBase.parseWithoutProcessing;
        return hb;
      }
      var inst = create2();
      inst.create = create2;
      _handlebarsNoConflict2["default"](inst);
      inst.Visitor = _handlebarsCompilerVisitor2["default"];
      inst["default"] = inst;
      exports["default"] = inst;
      module.exports = exports["default"];
    })(handlebars, handlebars.exports);
    return handlebars.exports;
  }
  var handlebarsExports = requireHandlebars();
  const Handlebars = /* @__PURE__ */ getDefaultExportFromCjs(handlebarsExports);
  const {
    waitForElement: waitForElement$1
  } = utils$1;
  function convertToEmbed(url) {
    try {
      let embedHtml = "";
      if (url.includes("youtube.com") || url.includes("youtu.be")) {
        let videoId = url.match(/(?:youtube\.com\/watch\?v=|youtu\.be\/)([\w-]+)/)?.[1];
        if (videoId) {
          embedHtml = `<iframe width="320" height="200" src="https://www.youtube.com/embed/${videoId}" frameborder="0" allowfullscreen></iframe>`;
        }
      } else if (url.includes("twitter.com") || url.includes("x.com")) {
        embedHtml = `<blockquote class="twitter-tweet"><a href="${url}"></a></blockquote>
                         <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"><\/script>`;
      } else if (url.includes("tiktok.com")) {
        embedHtml = `<blockquote class="tiktok-embed" cite="${url}" data-video-id="${url.split("/").pop()}" style="max-width: 605px; min-width: 325px;">
                            <a href="${url}">Watch on TikTok</a>
                         </blockquote>
                         <script async src="https://www.tiktok.com/embed.js"><\/script>`;
      } else if (url.includes("instagram.com/p/")) {
        embedHtml = `<blockquote class="instagram-media" data-instgrm-permalink="${url}" data-instgrm-version="13">
                            <a href="${url}">View on Instagram</a>
                         </blockquote>
                         <script async src="https://www.instagram.com/embed.js"><\/script>`;
      }
      return embedHtml || `<a href="${url}" target="_blank" rel="noopener noreferrer">${url}</a>`;
    } catch (error) {
      console.error("Error generating embed:", error);
      return `<a href="${url}" target="_blank" rel="noopener noreferrer">${url}</a>`;
    }
  }
  function formatPostText(post2) {
    let text = post2.text;
    if (!post2.facets) return text;
    let charOffsets = [];
    let runningByteCount = 0;
    let utf16CharIndex = 0;
    for (let char of text) {
      let charSize = new TextEncoder().encode(char).length;
      charOffsets.push({ byteOffset: runningByteCount, charIndex: utf16CharIndex });
      runningByteCount += charSize;
      utf16CharIndex++;
    }
    post2.facets.slice().reverse().forEach((facet2) => {
      const { index, features } = facet2;
      let start = charOffsets.findLast((c) => c.byteOffset <= index.byteStart)?.charIndex || 0;
      let end = charOffsets.findLast((c) => c.byteOffset <= index.byteEnd)?.charIndex || text.length;
      let originalSubstring = text.slice(start, end);
      features.forEach((feature) => {
        if (feature.$type === "app.bsky.richtext.facet#mention") {
          let mentionLink = `<a href="https://bsky.app/profile/${feature.did}" class="mention">${originalSubstring}</a>`;
          text = text.slice(0, start) + mentionLink + text.slice(end + 1);
        } else if (feature.$type === "app.bsky.richtext.facet#link") {
          let url = feature.uri;
          let embedHtml = convertToEmbed(url);
          text = text.slice(0, start) + embedHtml + text.slice(end + 1);
        } else if (feature.$type === "app.bsky.richtext.facet#tag") {
          let hashtagLink = `<a href="https://bsky.app/search?q=%23${feature.tag}" class="hashtag">${originalSubstring}</a>`;
          text = text.slice(0, start) + hashtagLink + text.slice(end + 1);
        }
      });
    });
    return text;
  }
  function urlForPost(post2) {
    return `https://bsky.app/profile/${post2.author.handle}/post/${post2.uri.split("/").slice(-1)[0]}`;
  }
  function formatPost(post2) {
    const formatter = Intl.NumberFormat("en", { notation: "compact" });
    return {
      postId: post2.cid,
      postUrl: urlForPost(post2),
      avatar: post2.author.avatar,
      displayName: post2.author.displayName || post2.author.handle,
      handle: post2.author.handle,
      content: formatPostText(post2.record),
      // content: post.record.text,
      embed: post2.embed,
      timestamp: new Date(post2.record.createdAt).toLocaleString(),
      replySvg: constants$1.SIDECAR_SVG_REPLY,
      replyCount: formatter.format(post2.replyCount),
      repostSvg: constants$1.SIDECAR_SVG_REPOST[post2.viewer.repost ? 1 : 0],
      repostCount: formatter.format(post2.repostCount),
      likeSvg: constants$1.SIDECAR_SVG_LIKE[post2.viewer.like ? 1 : 0],
      likeCount: formatter.format(post2.likeCount)
    };
  }
  class Handler {
    constructor(name, config2, state2, api) {
      this.name = name;
      this.config = config2;
      this.state = state2;
      this.api = api;
      this.items = [];
      this.handleInput = this.handleInput.bind(this);
    }
    activate() {
      this.bindKeys();
    }
    deactivate() {
      this.unbindKeys();
    }
    isActive() {
      return true;
    }
    bindKeys() {
      document.addEventListener("keydown", this.handleInput, true);
    }
    unbindKeys() {
      document.removeEventListener("keydown", this.handleInput, true);
    }
    handleInput(event) {
      if (event.altKey && !event.metaKey) {
        if (event.code === "KeyH") {
          event.preventDefault();
          $("nav a[aria-label='Home']")[0].click();
        } else if (event.code === "KeyS") {
          event.preventDefault();
          $("nav a[aria-label='Search']")[0].click();
        } else if (event.code === "KeyN") {
          event.preventDefault();
          $("nav a[aria-label='Notifications']")[0].click();
        } else if (event.code === "KeyM") {
          event.preventDefault();
          $("nav a[aria-label='Chat']")[0].click();
        } else if (event.code === "KeyF") {
          event.preventDefault();
          $("nav a[aria-label='Feeds']")[0].click();
        } else if (event.code === "KeyL") {
          event.preventDefault();
          $("nav a[aria-label='Lists']")[0].click();
        } else if (event.code === "KeyP") {
          event.preventDefault();
          $("nav a[aria-label='Profile']")[0].click();
        } else if (event.code === "Comma") {
          event.preventDefault();
          $("nav a[aria-label='Settings']")[0].click();
        } else if (event.code === "Period") {
          event.preventDefault();
          this.config.open();
        } else if (event.code === "Enter" && $("#GM_config").is(":visible")) {
          event.preventDefault();
          this.config.save();
        }
      } else if (!event.altKey && !event.metaKey) {
        if (event.code == "Escape" && $("#GM_config").is(":visible")) {
          event.preventDefault();
          this.config.close();
        }
      }
    }
  }
  class ItemHandler extends Handler {
    // POPUP_MENU_SELECTOR = "div[data-radix-popper-content-wrapper]"
    POPUP_MENU_SELECTOR = "div[aria-label^='Context menu backdrop']";
    // FIXME: this belongs in PostItemHandler
    THREAD_PAGE_SELECTOR = "main > div > div > div";
    MOUSE_MOVEMENT_THRESHOLD = 10;
    FLOATING_BUTTON_IMAGES = {
      prev: [
        // 'https://www.svgrepo.com/show/491060/prev.svg'
        "https://www.svgrepo.com/show/238452/up-arrow.svg"
      ],
      next: [
        // 'https://www.svgrepo.com/show/491054/next.svg'
        "https://www.svgrepo.com/show/238463/down-arrow-multimedia-option.svg"
      ]
    };
    constructor(name, config2, state2, api, selector) {
      super(name, config2, state2, api);
      this.selector = selector;
      this._index = null;
      this._replyIndex = null;
      this._threadIndex = null;
      this.postId = null;
      this.loadNewerCallback = null;
      this.debounceTimeout = null;
      this.lastMousePosition = null;
      this.isPopupVisible = false;
      this.ignoreMouseMovement = false;
      this.onPopupAdd = this.onPopupAdd.bind(this);
      this.onPopupRemove = this.onPopupRemove.bind(this);
      this.onIntersection = this.onIntersection.bind(this);
      this.onFooterIntersection = this.onFooterIntersection.bind(this);
      this.onItemAdded = this.onItemAdded.bind(this);
      this.onScroll = this.onScroll.bind(this);
      this.handleNewThreadPage = this.handleNewThreadPage.bind(this);
      this.onItemMouseOver = this.onItemMouseOver.bind(this);
      this.onSidecarItemMouseOver = this.onSidecarItemMouseOver.bind(this);
      this.didMouseMove = this.didMouseMove.bind(this);
      this.getTimestampForItem = this.getTimestampForItem.bind(this);
      this.loading = false;
      this.loadingNew = false;
      this.enableScrollMonitor = false;
      this.enableIntersectionObserver = false;
      this.handlingClick = false;
      this.itemStats = {};
      this.visibleItems = [];
      this.scrollTick = false;
      this.scrollTop = 0;
      this.scrollDirection = 0;
      waitForElement$1(
        "#sidecar-replies-template",
        () => {
          this.repliesTemplate = Handlebars.compile($("#sidecar-replies-template").html());
        }
      );
      waitForElement$1(
        "#sidecar-post-template",
        () => {
          this.postTemplate = Handlebars.compile($("#sidecar-post-template").html());
          Handlebars.registerPartial("postTemplate", this.postTemplate);
        }
      );
      waitForElement$1(
        "#sidecar-embed-image-template",
        () => {
          this.imageTemplate = Handlebars.compile($("#sidecar-embed-image-template").html());
          Handlebars.registerPartial("imageTemplate", this.imageTemplate);
        }
      );
    }
    isActive() {
      return false;
    }
    activate() {
      this.keyState = [];
      this.popupObserver = waitForElement$1(this.POPUP_MENU_SELECTOR, this.onPopupAdd, this.onPopupRemove);
      this.intersectionObserver = new IntersectionObserver(this.onIntersection, {
        root: null,
        // Observing within the viewport
        // rootMargin: `-${ITEM_SCROLL_MARGIN}px 0px 0px 0px`,
        threshold: Array.from({ length: 101 }, (_, i) => i / 100)
      });
      this.setupIntersectionObserver();
      this.footerIntersectionObserver = new IntersectionObserver(this.onFooterIntersection, {
        root: null,
        // Observing within the viewport
        // threshold: [1]
        threshold: Array.from({ length: 101 }, (_, i) => i / 100)
      });
      const safeSelector = `${this.selector}:not(.thread ${this.selector})`;
      this.observer = waitForElement$1(safeSelector, (element) => {
        this.onItemAdded(element), this.onItemRemoved(element);
      });
      this.loadNewerObserver = waitForElement$1(constants$1.LOAD_NEW_INDICATOR_SELECTOR, (button) => {
        this.loadNewerButton = $(button)[0];
        $("a#loadNewerIndicatorLink").on("click", () => this.loadNewerItems());
        $("img#loadNewerIndicatorImage").addClass("image-highlight");
        $("img#loadNewerIndicatorImage").removeClass("toolbar-icon-pending");
        if ($("#loadNewerAction").length == 0) {
          $("#messageActions").append($('<div id="loadNewerAction"><a> Load newer posts</a></div>'));
          $("#loadNewerAction > a").on("click", () => this.loadNewerItems());
        }
        this.loadNewerButton.addEventListener(
          "click",
          (event) => {
            if (this.loadingNew) {
              return;
            }
            event.target;
            event.stopImmediatePropagation();
            setTimeout(() => {
              this.loadNewerItems();
            }, 0);
          },
          true
          // Capture phase
        );
      });
      this.enableIntersectionObserver = true;
      $(document).on("scroll", this.onScroll);
      $(document).on("scrollend", () => {
        setTimeout(
          () => this.ignoreMouseMovement = false,
          500
        );
      });
      console.log(this.state.mobileView);
      this.floatingButtonsObserver = waitForElement$1(
        this.state.mobileView ? constants$1.HOME_SCREEN_SELECTOR : constants$1.LEFT_SIDEBAR_SELECTOR,
        (container) => {
          console.log(container);
          if (!this.prevButton) {
            this.prevButton = $(`<div id="prevButton" title="previous post" class="css-175oi2r r-1loqt21 r-1otgn73 r-1oszu61 r-16y2uox r-1777fci r-gu64tb"><img id="prevButtonImage" class="indicator-image" src="${this.FLOATING_BUTTON_IMAGES.prev[0]}"/></div>`);
            $(container).append(this.prevButton);
            if (this.state.mobileView) {
              $("#prevButton").addClass("mobile");
            }
            $("#prevButton").on("click", (event) => {
              event.preventDefault();
              this.jumpToPrev(true);
            });
          }
          if (!this.nextButton) {
            this.nextButton = $(`<div id="nextButton" title="next post" class="css-175oi2r r-1loqt21 r-1otgn73 r-1oszu61 r-16y2uox r-1777fci r-gu64tb"><img id="nextButtonImage" class="indicator-image" src="${this.FLOATING_BUTTON_IMAGES.next[0]}"/></div>`);
            $(this.prevButton).after(this.nextButton);
            if (this.state.mobileView) {
              $("#nextButton").addClass("mobile");
            }
            $("#nextButton").on("click", (event) => {
              event.preventDefault();
              this.jumpToNext(true);
            });
          }
        }
      );
      super.activate();
    }
    deactivate() {
      if (this.floatingButtonsObserver) {
        this.floatingButtonsObserver.disconnect();
      }
      if (this.observer) {
        this.observer.disconnect();
      }
      if (this.popupObserver) {
        this.popupObserver.disconnect();
      }
      if (this.intersectionObserver) {
        this.intersectionObserver.disconnect();
      }
      this.disableFooterObserver();
      $(this.selector).off("mouseover mouseleave");
      $(document).off("scroll", this.onScroll);
      super.deactivate();
    }
    set index(value) {
      this._index = value;
      this._threadIndex = null;
      this.postId = this.postIdForItem(this.selectedItem);
      this.updateInfoIndicator();
    }
    get index() {
      return this._index;
    }
    set index(value) {
      this._index = value;
      this.postId = this.postIdForItem(this.selectedItem);
      this.updateInfoIndicator();
    }
    get selectedItem() {
      return $(this.items[this.index]);
    }
    getReplyForIndex(index) {
      return this.selectedItem.closest(".thread").find(".sidecar-post").eq(index);
    }
    get selectedReply() {
      return this.getReplyForIndex(this.replyIndex);
    }
    get replyIndex() {
      return this._replyIndex;
    }
    set replyIndex(value) {
      let oldIndex = this._replyIndex;
      const replies = $(this.selectedItem).parent().find("div.sidecar-post");
      if (value == oldIndex || value < 0 || value >= replies.length) {
        return;
      }
      if (oldIndex != null) {
        replies.eq(oldIndex).removeClass("reply-selection-active");
      }
      this._replyIndex = value;
      if (this.replyIndex == null) {
        $(this.selectedItem).addClass("item-selection-active");
        $(this.selectedItem).removeClass("item-selection-child-focused");
        replies.removeClass("reply-selection-active");
      } else {
        const selectedReply = replies.eq(this.replyIndex);
        if (selectedReply.length) {
          $(this.selectedItem).addClass("item-selection-child-focused");
          $(this.selectedItem).removeClass("item-selection-active");
          selectedReply.addClass("reply-selection-active");
          this.scrollToElement(selectedReply[0], "nearest");
        }
      }
    }
    get threadIndex() {
      return this._threadIndex;
    }
    set threadIndex(value) {
      let oldIndex = this._threadIndex;
      if (value == oldIndex) {
        return;
      } else if (value < 0) {
        this._threadIndex = null;
        this.setIndex(this.index - 1, false, true);
        return;
      } else if (value > this.unrolledReplies.length) {
        this._threadIndex = null;
        this.setIndex(this.index + 1, false, true);
        return;
      }
      if (oldIndex != null) {
        this.getPostForThreadIndex(oldIndex).removeClass("reply-selection-active");
      }
      this._threadIndex = value;
      if (this.threadIndex == null) {
        $(this.selectedItem).addClass("item-selection-active");
        $(this.selectedItem).removeClass("item-selection-child-focused");
      } else {
        if (this.unrolledReplies.length && this.selectedPost) {
          $(this.selectedItem).addClass("item-selection-child-focused");
          $(this.selectedItem).removeClass("item-selection-active");
          this.selectedPost.addClass("reply-selection-active");
          this.scrollToElement(this.selectedPost[0], "nearest");
        } else {
          return;
        }
      }
      this.updateInfoIndicator();
    }
    get unrolledReplies() {
      return $(this.selectedItem).find(".unrolled-reply");
    }
    getPostForThreadIndex(index) {
      return index > 0 ? this.unrolledReplies.eq(index - 1) : $(this.selectedItem).find(constants$1.POST_CONTENT_SELECTOR).first();
    }
    get selectedPost() {
      return this.getPostForThreadIndex(this.threadIndex);
    }
    onItemAdded(element) {
      this.applyItemStyle(element);
      clearTimeout(this.debounceTimeout);
      this.debounceTimeout = setTimeout(() => {
        this.loadItems();
      }, 500);
    }
    onItemRemoved(element) {
      if (this.intersectionObserver) {
        this.intersectionObserver.disconnect(element);
      }
    }
    onScroll(event) {
      if (!this.enableScrollMonitor) {
        console.log("!this.enableScrollMonitor");
        return;
      }
      this.ignoreMouseMovement = true;
      if (!this.scrollTick) {
        requestAnimationFrame(() => {
          let currentScroll = $(window).scrollTop();
          if (currentScroll > this.scrollTop) {
            this.scrollDirection = -1;
          } else if (currentScroll < this.scrollTop) {
            this.scrollDirection = 1;
          }
          this.scrollTop = currentScroll;
          this.scrollTick = false;
        });
        this.scrollTick = true;
      }
    }
    scrollToElement(target2, block2 = null) {
      this.enableIntersectionObserver = false;
      target2.scrollIntoView(
        {
          behavior: this.config.get("enableSmoothScrolling") ? "smooth" : "instant",
          block: block2 == null ? "start" : block2
        }
      );
    }
    // Function to programmatically play a video from the userscript
    playVideo(video2) {
      video2.dataset.allowPlay = "true";
      video2.play();
    }
    pauseVideo(video2) {
      video2.dataset.allowPlay = "true";
      video2.pause();
    }
    setupIntersectionObserver(entries) {
      if (this.intersectionObserver) {
        $(this.items).each(
          (i, item) => {
            this.intersectionObserver.observe($(item)[0]);
          }
        );
      }
    }
    onIntersection(entries) {
      if (!this.enableIntersectionObserver || this.loading || this.loadingNew) {
        return;
      }
      let target2 = null;
      entries.forEach((entry) => {
        if (entry.isIntersecting) {
          this.visibleItems = this.visibleItems.filter(
            (item) => item.target != entry.target
          );
          this.visibleItems.push(entry);
        } else {
          const oldLength = this.visibleItems.length;
          this.visibleItems = this.visibleItems.filter(
            (item) => item.target != entry.target
          );
          if (this.visibleItems.length < oldLength) {
            console.log("removed", entry.target);
            if (this.config.get("markReadOnScroll")) {
              var index2 = this.getIndexFromItem(entry.target);
              this.markItemRead(index2, true);
            }
          }
        }
      });
      const visibleItems = this.visibleItems.sort(
        (a, b) => this.scrollDirection == 1 ? b.target.getBoundingClientRect().top - a.target.getBoundingClientRect().top : a.target.getBoundingClientRect().top - b.target.getBoundingClientRect().top
      );
      if (!visibleItems.length) {
        return;
      }
      for (const [i, item] of visibleItems.entries()) {
        var index = this.getIndexFromItem(item.target);
        if (item.intersectionRatio == 1) {
          target2 = item.target;
          break;
        }
      }
      if (target2 == null) {
        target2 = this.scrollDirection == -1 ? visibleItems[0].target : visibleItems.slice(-1)[0].target;
        var index = this.getIndexFromItem(target2);
      }
      var index = this.getIndexFromItem(target2);
      this.setIndex(index);
    }
    onFooterIntersection(entries) {
      entries.forEach((entry) => {
        if (entry.isIntersecting) {
          entry.target;
          this.disableFooterObserver();
          this.loadOlderItems();
        }
      });
    }
    enableFooterObserver() {
      if (this.config.get("disableLoadMoreOnScroll")) {
        return;
      }
      if (!this.state.feedSortReverse && this.items.length > 0) {
        this.footerIntersectionObserver.observe(this.items.slice(-1)[0]);
      }
    }
    disableFooterObserver() {
      if (this.footerIntersectionObserver) {
        this.footerIntersectionObserver.disconnect();
      }
    }
    onPopupAdd() {
      this.isPopupVisible = true;
    }
    onPopupRemove() {
      this.isPopupVisible = false;
    }
    get scrollMargin() {
      var margin;
      if (this.state.mobileView) {
        var el = $(`${constants$1.HOME_SCREEN_SELECTOR} > div > div > div`);
        el = el.first().children().filter(":visible").first();
        if (this.index) {
          var transform = el[0].style.transform;
          var translateY = transform.indexOf("(") == -1 ? 0 : parseInt(transform.split("(")[1].split("px")[0]);
          margin = el.outerHeight() + translateY;
        } else {
          margin = el.outerHeight();
        }
      } else {
        var el = $(`${constants$1.HOME_SCREEN_SELECTOR} > div > div`).eq(2);
        margin = el.outerHeight();
      }
      var itemMargin = parseInt($(this.selector).css("margin-top").replace("px", ""));
      console.log(itemMargin);
      return margin + itemMargin;
    }
    applyItemStyle(element, selected2) {
      $(element).addClass("item");
      if (this.config.get("postActionButtonPosition") == "Left") {
        const postContainer = $(element).find(constants$1.POST_CONTENT_SELECTOR).prev();
        if (postContainer.length) {
          postContainer.css("flex", "");
        }
      }
      const postTimestampElement = $(element).find('a[href^="/profile/"][data-tooltip*=" at "]').first();
      if (!postTimestampElement.attr("data-bsky-navigator-age")) {
        postTimestampElement.attr("data-bsky-navigator-age", postTimestampElement.text());
      }
      const userFormat = this.config.get(
        this.state.mobileView ? "postTimestampFormatMobile" : "postTimestampFormat"
      );
      const postTimeString = postTimestampElement.attr("aria-label");
      if (postTimeString && userFormat) {
        const postTimestamp = new Date(postTimeString.replace(" at", ""));
        if (userFormat) {
          const formattedDate = format(postTimestamp, userFormat).replace("$age", postTimestampElement.attr("data-bsky-navigator-age"));
          if (this.config.get("showDebuggingInfo")) {
            postTimestampElement.text(`${formattedDate} (${$(element).parent().parent().attr("data-bsky-navigator-thread-index")}, ${$(element).attr("data-bsky-navigator-item-index")})`);
          } else {
            postTimestampElement.text(formattedDate);
          }
        }
      }
      const threadIndicator = $(element).find("div.r-lchren, div.r-1mhb1uw > svg");
      const avatarDiv = $(element).find('div[data-testid="userAvatarImage"]');
      $(element).parent().parent().addClass("thread");
      $(element).css("scroll-margin-top", `${this.scrollMargin}px`, `!important`);
      $(element).find("video").each(
        (i, video2) => {
          if (this.config.get("videoPreviewPlayback") == "Pause all" || this.config.get("videoPreviewPlayback") == "Play selected" && !selected2) {
            this.pauseVideo(video2);
          } else if (this.config.get("videoPreviewPlayback") == "Play selected" && selected2) {
            this.playVideo(video2);
          }
        }
      );
      if (selected2) {
        $(element).parent().parent().addClass("thread-selection-active");
        $(element).parent().parent().removeClass("thread-selection-inactive");
      } else {
        $(element).parent().parent().removeClass("thread-selection-active");
        $(element).parent().parent().addClass("thread-selection-inactive");
      }
      if (threadIndicator.length) {
        var parent = threadIndicator.parents().has(avatarDiv).first();
        var children = parent.find("*");
        if (threadIndicator.length == 1) {
          var parent = threadIndicator.parents().has(avatarDiv).first();
          var children = parent.find("*");
          if (children.index(threadIndicator) < children.index(avatarDiv)) {
            $(element).parent().parent().addClass("thread-last");
          } else {
            $(element).parent().parent().addClass("thread-first");
          }
        } else {
          $(element).parent().parent().addClass("thread-middle");
        }
      } else {
        $(element).parent().parent().addClass(["thread-first", "thread-middle", "thread-last"]);
      }
      if (selected2) {
        $(element).addClass("item-selection-active");
        $(element).removeClass("item-selection-inactive");
      } else {
        $(element).removeClass("item-selection-active");
        $(element).removeClass("item-selection-child-focused");
        $(element).addClass("item-selection-inactive");
      }
      var postId = this.postIdForItem($(element));
      if (postId != null && this.state.seen[postId]) {
        $(element).addClass("item-read");
        $(element).removeClass("item-unread");
      } else {
        $(element).addClass("item-unread");
        $(element).removeClass("item-read");
      }
      const handle2 = this.handleFromItem(element);
      if (this.state.blocks.all.includes(handle2)) {
        $(element).find(constants$1.PROFILE_SELECTOR).css(constants$1.CLEARSKY_BLOCKED_ALL_CSS);
      }
      if (this.state.blocks.recent.includes(handle2)) {
        $(element).find(constants$1.PROFILE_SELECTOR).css(constants$1.CLEARSKY_BLOCKED_RECENT_CSS);
      }
    }
    didMouseMove(event) {
      const currentPosition = { x: event.pageX, y: event.pageY };
      if (this.lastMousePosition) {
        const distanceMoved = Math.sqrt(
          Math.pow(currentPosition.x - this.lastMousePosition.x, 2) + Math.pow(currentPosition.y - this.lastMousePosition.y, 2)
        );
        this.lastMousePosition = currentPosition;
        if (distanceMoved >= this.MOUSE_MOVEMENT_THRESHOLD) {
          return true;
        }
      } else {
        this.lastMousePosition = currentPosition;
      }
      return false;
    }
    onItemMouseOver(event) {
      if (this.ignoreMouseMovement) {
        return;
      }
      var target2 = $(event.target).closest(this.selector);
      var index = this.getIndexFromItem(target2);
      this.replyIndex = null;
      if (index != this.index) {
        this.setIndex(index);
      }
    }
    onSidecarItemMouseOver(event) {
      if (this.ignoreMouseMovement) {
        return;
      }
      var target2 = $(event.target).closest(".sidecar-post");
      var index = this.getSidecarIndexFromItem(target2);
      var parent = target2.closest(".thread").find(".item");
      const parentIndex = this.getIndexFromItem(parent);
      this.setIndex(parentIndex);
      this.replyIndex = index;
    }
    handleInput(event) {
      if (this.handleMovementKey(event)) {
        return event.key;
      } else if (this.handleItemKey(event)) {
        return event.key;
      } else if (event.key == "U") {
        this.loadOlderItems();
      } else {
        return super.handleInput(event);
      }
    }
    filterItems() {
      return;
    }
    sortItems() {
      return;
    }
    showMessage(title, message2) {
      this.hideMessage();
      this.messageContainer = $('<div id="messageContainer">');
      if (title) {
        const messageTitle = $('<div class="messageTitle">');
        $(messageTitle).html(title);
        this.messageContainer.append(messageTitle);
      }
      const messageBody = $('<div class="messageBody">');
      this.messageContainer.append(messageBody);
      $(messageBody).html(message2);
      $(constants$1.FEED_CONTAINER_SELECTOR).filter(":visible").append(this.messageContainer);
      window.scrollTo(0, 0);
    }
    hideMessage() {
      $("#messageContainer").remove();
      this.messageContainer = null;
    }
    getTimestampForItem(item) {
      const postTimestampElement = $(item).find('a[href^="/profile/"][data-tooltip*=" at "]').first();
      const postTimeString = postTimestampElement.attr("aria-label");
      if (!postTimeString) {
        return null;
      }
      return new Date(postTimeString.replace(" at", ""));
    }
    loadItems(focusedPostId) {
      this.items.length;
      this.index;
      const classes = ["thread-first", "thread-middle", "thread-last"];
      let set = [];
      $(this.items).css("opacity", "0%");
      let itemIndex = 0;
      let threadIndex = 0;
      let threadOffset = 0;
      $(this.selector).filter(":visible").each((i, item) => {
        $(item).attr("data-bsky-navigator-item-index", itemIndex++);
        $(item).parent().parent().attr("data-bsky-navigator-thread-index", threadIndex);
        const threadDiv = $(item).parent().parent();
        if (classes.some((cls) => $(threadDiv).hasClass(cls))) {
          set.push(threadDiv[0]);
          $(item).attr("data-bsky-navigator-thread-offset", threadOffset);
          threadOffset++;
          if ($(threadDiv).hasClass("thread-last")) {
            threadIndex++;
            threadOffset = 0;
          }
        }
      });
      this.sortItems();
      this.filterItems();
      this.items = $(this.selector).filter(":visible");
      this.itemStats.oldest = this.itemStats.newest = null;
      $(this.selector).filter(":visible").each((i, item) => {
        const timestamp = this.getTimestampForItem(item);
        if (!this.itemStats.oldest || timestamp < this.itemStats.oldest) {
          this.itemStats.oldest = timestamp;
        }
        if (!this.itemStats.newest || timestamp > this.itemStats.newest) {
          this.itemStats.newest = timestamp;
        }
        if (this.config.get("showReplySidecar") && $(this.selectedItem).closest(".thread").outerWidth() >= this.config.get("showReplySidecarMinimumWidth")) {
          this.getSidecarContent().then(
            (content) => {
              if (!$(item).parent().find(".sidecar-replies").length) {
                $(item).parent().append(content);
              }
            }
          );
        }
      });
      this.setupIntersectionObserver();
      this.enableFooterObserver();
      if (this.index != null) {
        this.applyItemStyle(this.selectedItem, true);
      }
      $("div.r-1mhb1uw").each(
        (i, el) => {
          const ancestor = $(el).parent().parent().parent().parent();
          $(el).parent().parent().parent().addClass("item-selection-inactive");
          if ($(ancestor).prev().find("div.item-unread").length) {
            $(el).parent().parent().parent().addClass("item-unread");
            $(el).parent().parent().parent().removeClass("item-read");
          } else {
            $(el).parent().parent().parent().addClass("item-read");
            $(el).parent().parent().parent().removeClass("item-unread");
          }
        }
      );
      $("div.r-1mhb1uw svg").each(
        (i, el) => {
          $(el).find("line").attr("stroke", this.config.get("threadIndicatorColor"));
          $(el).find("circle").attr("fill", this.config.get("threadIndicatorColor"));
        }
      );
      $(this.selector).on("mouseover", this.onItemMouseOver);
      $(this.selector).closest("div.thread").addClass("bsky-navigator-seen");
      $(this.selector).closest("div.thread").removeClass(["loading-indicator-reverse", "loading-indicator-forward"]);
      this.refreshItems();
      this.loading = false;
      $("img#loadOlderIndicatorImage").addClass("image-highlight");
      $("img#loadOlderIndicatorImage").removeClass("toolbar-icon-pending");
      if (focusedPostId) {
        this.jumpToPost(focusedPostId);
      } else if (!this.jumpToPost(this.postId)) {
        this.setIndex(0);
      }
      this.updateInfoIndicator();
      this.enableFooterObserver();
      if ($(this.items).filter(":visible").length == 0) {
        this.showMessage("No more unread posts.", `
<p>
You're all caught up.
</p>

<div id="messageActions"/>
`);
        if ($("#loadOlderAction").length == 0) {
          $("#messageActions").append($('<div id="loadOlderAction"><a>Load older posts</a></div>'));
          $("#loadOlderAction > a").on("click", () => this.loadOlderItems());
        }
        if ($("img#loadNewerIndicatorImage").hasClass("image-highlight")) {
          $("#messageActions").append($('<div id="loadNewerAction"><a>Load newer posts</a></div>'));
          $("#loadNewerAction > a").on("click", () => this.loadNewerItems());
        }
      } else {
        this.hideMessage();
      }
      this.ignoreMouseMovement = false;
    }
    refreshItems() {
      $(this.items).each(
        (index, item) => {
          this.applyItemStyle(this.items[index], index == this.index);
        }
      );
      $(this.items).css("opacity", "100%");
    }
    updateInfoIndicator() {
      this.itemStats.unreadCount = this.items.filter(
        (i, item) => $(item).hasClass("item-unread")
      ).length;
      this.itemStats.filteredCount = this.items.filter(".filtered").length;
      this.itemStats.shownCount = this.items.length - this.itemStats.filteredCount;
      const index = this.itemStats.shownCount ? this.index + 1 : 0;
      $("div#infoIndicatorText").html(`
<div id="itemCountStats">
<strong>${index}${this.threadIndex != null ? `<small>.${this.threadIndex + 1}</small>` : ""}</strong>/<strong>${this.itemStats.shownCount}</strong> (<strong>${this.itemStats.filteredCount}</strong> filtered, <strong>${this.itemStats.unreadCount}</strong> new)
</div>
<div id="itemTimestampStats">
${this.itemStats.oldest ? `${format(this.itemStats.oldest, "yyyy-MM-dd hh:mmaaa")} - ${format(this.itemStats.newest, "yyyy-MM-dd hh:mmaaa")}</div>` : ``}`);
      if (this.config.get("showPostCounts") == "All" || selected && this.config.get("showPostCounts") == "Selection") {
        const bannerDiv = $(this.selectedItem).find("div.item-banner").first().length ? $(this.selectedItem).find("div.item-banner").first() : $(this.selectedItem).find("div").first().prepend($('<div class="item-banner"/>')).children(".item-banner").last();
        $(bannerDiv).html(`<strong>${index}${this.threadIndex != null ? `<small>.${this.threadIndex + 1}/${this.unrolledReplies.length + 1}</small>` : ""}</strong>/<strong>${this.itemStats.shownCount}</strong>`);
      }
    }
    loadNewerItems() {
      if (!this.loadNewerButton) {
        console.log("no button");
        return;
      }
      this.loadingNew = true;
      this.applyItemStyle(this.selectedItem, false);
      let oldPostId = this.postIdForItem(this.selectedItem);
      $(this.loadNewerButton).click();
      setTimeout(() => {
        this.loadItems(oldPostId);
        $("img#loadNewerIndicatorImage").removeClass("image-highlight");
        $("img#loadNewerIndicatorImage").removeClass("toolbar-icon-pending");
        $("#loadNewerAction").remove();
        this.loadingNew = false;
      }, 1e3);
    }
    loadOlderItems() {
      if (this.loading) {
        return;
      }
      console.log("loading more");
      $("img#loadOlderIndicatorImage").removeClass("image-highlight");
      $("img#loadOlderIndicatorImage").addClass("toolbar-icon-pending");
      this.loading = true;
      const reversed = this.state.feedSortReverse;
      const index = reversed ? 0 : this.items.length - 1;
      this.setIndex(index);
      this.updateItems();
      var indicatorElement = this.items.length ? this.items[index] : $(this.selector).eq(index)[0];
      var loadElement = this.items.length ? this.items[this.items.length - 1] : $(this.selector).first()[0];
      $(indicatorElement).closest("div.thread").addClass(this.state.feedSortReverse ? "loading-indicator-forward" : "loading-indicator-reverse");
      this.loadOlderItemsCallback(
        [
          {
            time: performance.now(),
            target: loadElement,
            isIntersecting: true,
            intersectionRatio: 1,
            boundingClientRect: loadElement.getBoundingClientRect(),
            intersectionRect: loadElement.getBoundingClientRect(),
            rootBounds: document.documentElement.getBoundingClientRect()
          }
        ]
      );
    }
    postIdFromUrl() {
      return window.location.href.split("/")[6];
    }
    urlForItem(item) {
      return `https://bsky.app${$(item).find("a[href*='/post/']").attr("href")}`;
    }
    postIdForItem(item) {
      try {
        return this.urlForItem(item).match(/post\/([^/]+)/)[1];
      } catch (e) {
        return this.postIdFromUrl();
      }
    }
    handleFromItem(item) {
      return $.trim($(item).find(constants$1.PROFILE_SELECTOR).find("span").eq(1).text().replace(/[\u200E\u200F\u202A-\u202E]/g, "")).slice(1);
    }
    async getThreadForItem(item) {
      const url = this.urlForItem(item);
      if (!url) {
        return;
      }
      const uri = await this.api.getAtprotoUri(url);
      if (!uri) {
        return;
      }
      const thread = await this.api.getThread(uri);
      return thread;
    }
    displayNameFromItem(item) {
      return $.trim($(item).find(constants$1.PROFILE_SELECTOR).find("span").eq(0).text().replace(/[\u200E\u200F\u202A-\u202E]/g, ""));
    }
    getHandles() {
      return Array.from(new Set(this.items.map((i, item) => this.handleFromItem(item))));
    }
    getDisplayNames() {
      return Array.from(new Set(this.items.map((i, item) => this.displayNameFromItem(item))));
    }
    getAuthors() {
      const authors = $(this.items).get().map((item) => ({
        handle: this.handleFromItem(item),
        displayName: this.displayNameFromItem(item)
      })).filter(
        (author) => author.handle.length > 0
      );
      const uniqueMap = /* @__PURE__ */ new Map();
      authors.forEach((author) => {
        uniqueMap.set(author.handle, author);
      });
      return Array.from(uniqueMap.values());
    }
    updateItems() {
      this.enableScrollMonitor = false;
      this.ignoreMouseMovement = true;
      if (this.index == 0) {
        window.scrollTo(0, 0);
      } else if (this.selectedItem) {
        this.scrollToElement($(this.selectedItem)[0]);
      } else ;
      setTimeout(() => {
        console.log("enable");
        this.ignoreMouseMovement = false;
        this.enableScrollMonitor = true;
      }, 2e3);
    }
    setIndex(index, mark, update) {
      let oldIndex = this.index;
      if (index == oldIndex) {
        console.log("unnecessary setIndex");
        return;
      }
      if (oldIndex != null) {
        if (mark) {
          this.markItemRead(oldIndex, true);
        }
      }
      if (index < 0 || index >= this.items.length) {
        return;
      }
      this.applyItemStyle(this.items[oldIndex], false);
      this.index = index;
      this.applyItemStyle(this.selectedItem, true);
      this.expandItem(this.selectedItem);
      if (update) {
        this.updateItems();
      }
      return true;
    }
    jumpToPost(postId) {
      for (const [i, item] of $(this.items).get().entries()) {
        const other = this.postIdForItem(item);
        if (postId == other) {
          this.setIndex(i);
          this.updateItems();
          return true;
        }
      }
      return false;
    }
    markItemRead(index, isRead) {
      if (this.name == "post" && !this.config.get("savePostState")) {
        return;
      }
      let mainItem = $(this.items)[index];
      let item = this.threadIndex != null ? this.getPostForThreadIndex(this.threadIndex) : mainItem;
      console.log(item);
      let postId = this.postIdForItem(item) || this.postIdForItem(mainItem);
      if (!postId) {
        debugger;
        console.log("no post");
        return;
      }
      var markedRead = this.markPostRead(postId, isRead);
      console.log(isRead, markedRead);
      if (this.unrolledReplies.length) {
        $(item).addClass(markedRead ? "item-read" : "item-unread");
        $(item).removeClass(markedRead ? "item-unread" : "item-read");
      } else {
        this.applyItemStyle(mainItem, index == this.index);
      }
      if (this.unrolledReplies.length && this.unrolledReplies.get().every(
        (r) => $(r).hasClass("item-read")
      )) {
        this.markPostRead(this.postIdForItem(mainItem), isRead);
        this.applyItemStyle(this.items[index], index == this.index);
      }
      this.updateInfoIndicator();
    }
    markPostRead(postId, isRead) {
      const currentTime = (/* @__PURE__ */ new Date()).toISOString();
      const seen = { ...this.state.seen };
      if (isRead || isRead == null && !seen[postId]) {
        seen[postId] = currentTime;
      } else {
        seen[postId] = null;
      }
      this.state.stateManager.updateState({ seen, lastUpdated: currentTime });
      return !!seen[postId];
    }
    markVisibleRead() {
      $(this.items).each(
        (i, item) => {
          this.markItemRead(i, true);
        }
      );
    }
    // FIXME: move to PostItemHanler
    handleNewThreadPage(element) {
      console.log(this.items.length);
      this.loadPageObserver.disconnect();
    }
    jumpToPrev(mark) {
      this.setIndex(this.index - 1, mark, true);
      return true;
    }
    jumpToNext(mark) {
      if (this.index < this.items.length) {
        this.setIndex(this.index + 1, mark, true);
      } else {
        var next = $(this.selectedItem).parent().parent().parent().next();
        if (next && $.trim(next.text()) == "Continue thread...") {
          this.loadPageObserver = waitForElement$1(
            this.THREAD_PAGE_SELECTOR,
            this.handleNewThreadPage
          );
          console.log(this.loadPageObserver);
          $(next).find("div").click();
        }
      }
      return true;
    }
    jumpToNextUnseenItem(mark) {
      var i;
      for (i = this.index + 1; i < this.items.length - 1; i++) {
        var postId = this.postIdForItem(this.items[i]);
        if (!this.state.seen[postId]) {
          break;
        }
      }
      this.setIndex(i, mark);
      this.updateItems();
    }
    toggleFocus() {
      if (this.replyIndex == null) {
        this.replyIndex = 0;
      } else {
        this.replyIndex = null;
      }
    }
    handleMovementKey(event) {
      var moved = false;
      var mark = false;
      this.index;
      if (this.isPopupVisible) {
        return;
      }
      this.ignoreMouseMovement = true;
      if (this.keyState.length == 0) {
        if (["j", "k", "h", "ArrowDown", "ArrowUp", "ArrowLeft", "ArrowRight", "J", "G"].includes(event.key)) {
          if (["j", "ArrowDown"].indexOf(event.key) != -1) {
            event.preventDefault();
            if (this.config.get("showReplySidecar") && this.replyIndex != null) {
              this.replyIndex += 1;
            } else if (this.config.get("unrolledPostSelection")) {
              if (event.key == "j") {
                this.markItemRead(this.index, true);
              }
              this.threadIndex += 1;
            } else {
              moved = this.jumpToNext(event.key == "j");
            }
          } else if (["k", "ArrowUp"].indexOf(event.key) != -1) {
            event.preventDefault();
            if (this.config.get("showReplySidecar") && this.replyIndex != null) {
              this.replyIndex -= 1;
            } else if (this.config.get("unrolledPostSelection")) {
              if (event.key == "k") {
                this.markItemRead(this.index, true);
              }
              this.threadIndex -= 1;
            } else {
              moved = this.jumpToPrev(event.key == "k");
            }
          } else if (event.key == "h") {
            var back_button = $("button[aria-label^='Back' i]").filter(":visible");
            if (back_button.length) {
              back_button.click();
            } else {
              history.back(1);
            }
          } else if (event.key == "ArrowLeft") {
            event.preventDefault();
            if (!this.config.get("showReplySidecar") || this.replyIndex == null) {
              return;
            }
            this.toggleFocus();
          } else if (event.key == "ArrowRight") {
            event.preventDefault();
            if (!this.config.get("showReplySidecar") || this.replyIndex != null) {
              return;
            }
            this.toggleFocus();
          } else if (event.key == "G") {
            event.preventDefault();
            moved = this.setIndex(this.items.length - 1, false, true);
          } else if (event.key == "J") {
            mark = true;
            this.jumpToNextUnseenItem(mark);
          }
          moved = true;
        } else if (event.key == "g") {
          this.keyState.push(event.key);
        }
      } else if (this.keyState[0] == "g") {
        if (event.key == "g") {
          if (this.index < this.items.length) {
            this.setIndex(0, false, true);
          }
          moved = true;
        }
        this.keyState = [];
      }
      if (moved) {
        this.lastMousePosition = null;
      }
    }
    getIndexFromItem(item) {
      return $(".item").filter(":visible").index(item);
    }
    getSidecarIndexFromItem(item) {
      return $(item).closest(".thread").find(".sidecar-post").filter(":visible").index(item);
    }
    shouldUnroll(item) {
      return this.config.get("unrollThreads");
    }
    shouldShowSidecar(item) {
      return this.config.get("showReplySidecar") && $(item).closest(".thread").outerWidth() >= this.config.get("showReplySidecarMinimumWidth");
    }
    shouldExpand(item) {
      return this.shouldUnroll(item) || this.shouldShowSidecar(item);
    }
    async expandItem(item) {
      if (!this.shouldExpand()) {
        return;
      }
      const thread = await this.getThreadForItem(item);
      if (!thread) {
        return;
      }
      if (this.shouldUnroll(item)) {
        await this.unrollThread(item, thread, true);
      }
      if (this.shouldShowSidecar(item)) {
        await this.showSidecar(item, thread, true);
      }
    }
    async unrollThread(item, thread) {
      const bodyTemplate = Handlebars.compile($("#sidecar-body-template").html());
      Handlebars.registerPartial("bodyTemplate", bodyTemplate);
      console.log(thread.parent, thread.parent?.post, thread.parent?.post?.author?.did, thread.post?.author?.did);
      if (thread.parent && thread.parent.post && thread.parent.post.author.did == thread.post.author.did) {
        return;
      }
      if (thread.replies.map((r) => r.post && r.post.author.did).includes(thread.post.author.did)) {
        let isRedundant = function(item2, threadIndex2) {
          return $(item2).data("bsky-navigator-thread-offset") != 0 && $(item2).closest(".thread").data("bsky-navigator-thread-index") == threadIndex2;
        };
        const unrolledPosts = await this.api.unrollThread(thread);
        const parent = $(item).find('div[data-testid="contentHider-post"]').parent();
        parent.css({ "overflow-y": "scroll", "max-height": "80vH", "padding-top": "1em" });
        var div = $(parent).find("div.unrolled-replies");
        if ($(div).length) {
          $(div).empty();
        } else {
          div = $('<div class="unrolled-replies"/>');
          parent.append(div);
        }
        unrolledPosts.slice(1).map((p, i) => {
          var reply = $('<div class="unrolled-reply" style="position: relative"/>');
          reply.append($('<hr class="unrolled-divider"/>'));
          reply.append($(`<div class="unrolled-banner"><a href="${urlForPost(p)}"/>${i + 2}/${unrolledPosts.length}</a></div>`));
          reply.append($(bodyTemplate(formatPost(p))));
          div.append(reply);
        });
        const threadIndex = $(item).closest(".thread").data("bsky-navigator-thread-index");
        this.items.each(
          (i, item2) => {
            if (isRedundant(item2, threadIndex)) {
              console.log("filtered", item2);
              $(item2).addClass("filtered");
            }
          }
        );
        console.log(this.items.length);
        this.items = this.items.filter((i, item2) => {
          return !isRedundant(item2, threadIndex);
        });
        console.log(this.items.length);
        this.threadIndex = 0;
      }
    }
    async getSidecarContent(item, thread) {
      if (!item) {
        return this.repliesTemplate({});
      }
      const post2 = thread.post;
      const replies = thread.replies.filter(
        (reply) => reply.post
      ).map(
        (reply) => reply?.post
      ).sort(
        (a, b) => {
          switch (this.config.get("sidecarReplySortOrder")) {
            case "Default":
              return 0;
            case "Oldest First":
              return new Date(a.record.createdAt) - new Date(b.record.createdAt);
            case "Newest First":
              return new Date(b.record.createdAt) - new Date(a.record.createdAt);
            case "Most Liked First":
              return b.likeCount - a.likeCount;
            case "Most Reposted First":
              return b.repostCount - a.repostCount;
            default:
              console.error(`unknown sort order: ${this.config.get("sidecarReplySortOrder")}`);
          }
        }
      ).map(formatPost);
      return this.repliesTemplate(
        {
          postId: post2.cid,
          parent: thread.parent ? formatPost(thread.parent.post) : null,
          replies
        }
      );
    }
    async showSidecar(item, thread, action = null) {
      const container = $(item).parent();
      const emptyContent = await this.getSidecarContent();
      let sidecar = $(container).find(".sidecar-replies")[0];
      if (!sidecar) {
        $(container).append(emptyContent);
      }
      const sidecarContent = await this.getSidecarContent(item, thread);
      console.log(sidecarContent);
      container.find(".sidecar-replies").replaceWith($(sidecarContent));
      container.find(".sidecar-post").each(
        (i, post2) => {
          $(post2).on("mouseover", this.onSidecarItemMouseOver);
        }
      );
      const display = action == null ? sidecar && $(sidecar).is(":visible") ? "none" : "flex" : action ? "flex" : "none";
      console.log(display);
      container.find(".sidecar-replies").css("display", display);
    }
    handleItemKey(event) {
      if (this.isPopupVisible) {
        return false;
      } else if (event.altKey && !event.metaKey) {
        if (event.code.startsWith("Digit")) {
          const num = parseInt(event.code.substr(5)) - 1;
          $("#bsky-navigator-search").autocomplete("disable");
          if (num >= 0) {
            const ruleName = Object.keys(this.state.rules)[num];
            console.log(ruleName);
            $("#bsky-navigator-search").val(`${event.shiftKey ? "!" : ""}$${ruleName}`);
          } else {
            $("#bsky-navigator-search").val(null);
          }
          $("#bsky-navigator-search").trigger("input");
          $("#bsky-navigator-search").autocomplete("enable");
          return event.key;
        } else {
          return false;
        }
      } else if (!event.metaKey) {
        var item = this.selectedItem;
        if (["o", "Enter"].includes(event.key) && !this.isPopupVisible) {
          if (this.replyIndex == null) {
            $(item).click();
          } else {
            console.log(this.selectedReply);
            this.selectedReply.find(".sidecar-post-timestamp a")[0].click();
          }
        } else if (event.key == "O") {
          var inner = $(item).find("div[aria-label^='Post by']");
          inner.click();
        } else if (event.key == "i") {
          if ($(item).find(constants$1.LINK_SELECTOR).length) {
            $(item).find(constants$1.LINK_SELECTOR)[0].click();
          }
        } else if (event.key == "m") {
          var media = $(item).find("img[src*='feed_thumbnail']");
          if (media.length > 0) {
            media[0].click();
          } else {
            const video2 = $(item).find("video")[0];
            if (video2) {
              event.preventDefault();
              if (video2.muted) {
                video2.muted = false;
              }
              if (video2.paused) {
                this.playVideo(video2);
              } else {
                this.pauseVideo(video2);
              }
            }
          }
        } else if (event.key == "r") {
          var button = $(item).find("button[aria-label^='Reply']");
          button.focus();
          button.click();
        } else if (event.key == "l") {
          if (this.config.get("showReplySidecar") && this.replyIndex != null) {
            this.api.getAtprotoUri(this.urlForItem(this.selectedReply)).then(
              (uri) => this.api.getThread(uri).then(
                (thread) => {
                  if (thread.post.viewer.like) {
                    this.api.agent.deleteLike(thread.post.viewer.like).then(
                      (response) => {
                        console.log(response);
                        $(this.selectedReply).find(".sidecar-like-button").html(constants$1.SIDECAR_SVG_LIKE[0]);
                      }
                    );
                  } else {
                    this.api.agent.like(uri, thread.post.cid).then(
                      (response) => {
                        console.log(response);
                        $(this.selectedReply).find(".sidecar-like-button").html(constants$1.SIDECAR_SVG_LIKE[1]);
                      }
                    );
                  }
                }
              )
            );
          } else {
            $(item).find("button[data-testid='likeBtn']").click();
          }
        } else if (event.key == "p") {
          $(item).find("button[aria-label^='Repost']").click();
        } else if (event.key == "P") {
          $(item).find("button[aria-label^='Repost']").click();
          setTimeout(function() {
            $("div[aria-label^='Repost'][role='menuitem']").click();
          }, 1e3);
        } else if (event.key == ".") {
          this.markItemRead(this.index, null);
        } else if (event.key == "A") {
          this.markVisibleRead();
        } else if (!isNaN(parseInt(event.key))) {
          $("div[role='tablist'] > div > div > div").filter(":visible")[parseInt(event.key) - 1].click();
        } else if (event.key == ";") {
          if (!this.api) {
            return;
          }
          this.expandItem(this.selectedItem);
        } else {
          return false;
        }
      }
      return event.key;
    }
  }
  class FeedItemHandler extends ItemHandler {
    INDICATOR_IMAGES = {
      loadTop: [
        "https://www.svgrepo.com/show/502348/circleupmajor.svg"
      ],
      loadBottom: [
        "https://www.svgrepo.com/show/502338/circledownmajor.svg"
      ],
      loadTime: [
        "https://www.svgrepo.com/show/446075/time-history.svg"
      ],
      filter: [
        "https://www.svgrepo.com/show/347140/mail.svg",
        "https://www.svgrepo.com/show/347147/mail-unread.svg"
      ],
      sort: [
        "https://www.svgrepo.com/show/506581/sort-numeric-alt-down.svg",
        "https://www.svgrepo.com/show/506582/sort-numeric-up.svg"
      ],
      preferences: [
        "https://www.svgrepo.com/show/522235/preferences.svg",
        "https://www.svgrepo.com/show/522236/preferences.svg"
      ]
    };
    constructor(name, config2, state2, api, selector) {
      super(name, config2, state2, api, selector);
      this.toggleSortOrder = this.toggleSortOrder.bind(this);
      this.onSearchAutocomplete = this.onSearchAutocomplete.bind(this);
      this.onSearchKeydown = this.onSearchKeydown.bind(this);
      this.setFilter = this.setFilter.bind(this);
      this.feedTabObserver = waitForElement$1(
        constants$1.FEED_TAB_SELECTOR,
        (tab) => {
          observeChanges$1(
            tab,
            (attributeName, oldValue, newValue, target2) => {
              if (attributeName == "class" && newValue.includes("r-13awgt0")) {
                console.log("refresh");
                this.refreshItems();
              }
            },
            false
          );
        }
      );
    }
    applyItemStyle(element, selected2) {
      super.applyItemStyle(element, selected2);
      const avatarDiv = $(element).find('div[data-testid="userAvatarImage"]');
      if (this.config.get("postActionButtonPosition") == "Left") {
        const buttonsDiv = $(element).find('button[data-testid="postDropdownBtn"]').parent().parent().parent();
        $(buttonsDiv).parent().css(
          {
            "min-height": "160px",
            "min-width": "80px"
            // "margin-left": "10px"
          }
        );
        $(buttonsDiv).parent().children().first().css(
          "flex",
          ""
        );
        buttonsDiv.css(
          {
            "display": "flex",
            "flex-direction": "column",
            "align-items": "flex-start",
            "position": "absolute",
            "bottom": "0px",
            "z-index": "10"
          }
        );
        $(buttonsDiv).find("> div").css(
          {
            "margin-left": "0px",
            "width": "100%"
          }
        );
        $(buttonsDiv).find("> div > div").css(
          {
            "width": "100%"
          }
        );
        const buttons = $(buttonsDiv).find('button[data-testid!="postDropdownBtn"]');
        buttons.each(
          (i, button) => {
            $(button).css(
              {
                "display": "flex",
                "align-items": "center",
                /* Ensures vertical alignment */
                "justify-content": "space-between",
                /* Pushes text to the right */
                "gap": "12px",
                /* Space between the icon and text */
                "width": "100%",
                "padding": "5px 2px"
              }
            );
            const div = $(button).find("> div").first();
            if (div.length) {
              $(div).css({
                "display": "flex",
                "align-items": "center",
                /* Ensures vertical alignment */
                "justify-content": "space-between",
                /* Pushes text to the right */
                "gap": "12px",
                /* Space between the icon and text */
                // "width": "100%",
                "padding": "0px"
              });
            }
            if ($(button).attr("aria-label").startsWith("Repost")) {
              $(div).css(
                "width",
                "100%"
              );
            }
            const svg = $(button).find("svg").first();
            $(svg).css({
              "flex-shrink": "0",
              /* Prevents icon from resizing */
              // "vertical-align": "middle", /* Ensures SVG is aligned with the text */
              "display": "block"
              /* Removes inline spacing issues */
            });
          }
        );
        avatarDiv.closest("div.r-c97pre").children().eq(0).after(buttonsDiv);
      }
    }
    addToolbar(beforeDiv) {
      this.toolbarDiv = $(`<div id="bsky-navigator-toolbar"/>`);
      $(beforeDiv).before(this.toolbarDiv);
      this.topLoadIndicator = $(`
<div id="topLoadIndicator" class="toolbar-icon css-175oi2r r-1loqt21 r-1otgn73 r-1oszu61 r-16y2uox r-1777fci r-gu64tb">
</div>`);
      $(this.toolbarDiv).append(this.topLoadIndicator);
      this.sortIndicator = $(`<div id="sortIndicator" title="change sort order" class="toolbar-icon css-175oi2r r-1loqt21 r-1otgn73 r-1oszu61 r-16y2uox r-1777fci r-gu64tb"><img id="sortIndicatorImage" class="indicator-image" src="${this.INDICATOR_IMAGES.sort[+this.state.feedSortReverse]}"/></div>`);
      $(this.toolbarDiv).append(this.sortIndicator);
      $(".indicator-image path").attr("fill", "currentColor");
      $("#sortIndicator").on("click", (event) => {
        event.preventDefault();
        this.toggleSortOrder();
      });
      this.filterIndicator = $(`<div id="filterIndicator" title="show all or unread" class="toolbar-icon css-175oi2r r-1loqt21 r-1otgn73 r-1oszu61 r-16y2uox r-1777fci r-gu64tb"><img id="filterIndicatorImage" class="indicator-image" src="${this.INDICATOR_IMAGES.filter[+this.state.feedHideRead]}"/></div>`);
      $(this.toolbarDiv).append(this.filterIndicator);
      $("#filterIndicator").on("click", (event) => {
        event.preventDefault();
        this.toggleHideRead();
      });
      this.searchField = $(`<input id="bsky-navigator-search" type="text"/>`);
      $(this.toolbarDiv).append(this.searchField);
      $("#bsky-navigator-search").autocomplete({
        minLength: 0,
        appendTo: 'div[data-testid="homeScreenFeedTabs"]',
        source: this.onSearchAutocomplete,
        focus: function(event, ui2) {
          event.preventDefault();
        },
        focus: function(event, ui2) {
          event.preventDefault();
        },
        select: function(event, ui2) {
          event.preventDefault();
          let input = this;
          let terms = splitTerms(input.value);
          terms.pop();
          terms.push(ui2.item.value);
          input.value = terms.join(" ") + " ";
          $(this).autocomplete("close");
        }
      });
      $("#bsky-navigator-search").on("keydown", function(event) {
        if (event.key === "Tab") {
          let autocompleteMenu = $(".ui-autocomplete:visible");
          let firstItem = autocompleteMenu.children(".ui-menu-item").first();
          if (firstItem.length) {
            let uiItem = firstItem.data("ui-autocomplete-item");
            $(this).autocomplete("close");
            let terms = splitTerms(this.value);
            terms.pop();
            terms.push(uiItem.value);
            this.value = terms.join(" ") + " ";
            event.preventDefault();
          }
        }
      });
      this.onSearchUpdate = (event) => {
        const val = $(event.target).val();
        console.log(val);
        if (val === "/") {
          $("#bsky-navigator-search").val("");
          $(this.searchField).autocomplete("close");
          $("a[aria-label='Search']")[0].click();
          return;
        }
        this.debouncedSearchUpdate(event);
      };
      this.debouncedSearchUpdate = debounce((event) => {
        const val = $(event.target).val();
        this.setFilter(val.trim());
        this.loadItems();
      }, 300);
      this.onSearchUpdate = this.onSearchUpdate.bind(this);
      $(this.searchField).on("keydown", this.onSearchKeydown);
      $(this.searchField).on("input", this.onSearchUpdate);
      $(this.searchField).on("focus", function() {
        $(this).autocomplete("search", "");
      });
      $(this.searchField).on("autocompletechange autocompleteclose", this.onSearchUpdate);
      $(this.searchField).on("autocompleteselect", this.onSearchUpdate);
      waitForElement$1(
        "#bsky-navigator-toolbar",
        null,
        (div) => {
          this.addToolbar(beforeDiv);
        }
      );
    }
    onSearchKeydown(event) {
      if (event.altKey) {
        event.preventDefault();
        event.stopPropagation();
        this.handleInput(event);
      }
    }
    refreshToolbars() {
      waitForElement$1(
        constants$1.TOOLBAR_CONTAINER_SELECTOR,
        (indicatorContainer) => {
          waitForElement$1(
            'div[data-testid="homeScreenFeedTabs"]',
            (homeScreenFeedTabsDiv) => {
              if (!$("#bsky-navigator-toolbar").length) {
                this.addToolbar(homeScreenFeedTabsDiv);
              }
            }
          );
        }
      );
      waitForElement$1(
        constants$1.STATUS_BAR_CONTAINER_SELECTOR,
        (statusBarContainer, observer) => {
          if (!$("#statusBar").length) {
            this.addStatusBar($(statusBarContainer).parent().parent().parent().parent().parent());
            observer.disconnect();
          }
        }
      );
      waitForElement$1(
        "#bsky-navigator-toolbar",
        (div) => {
          waitForElement$1(
            "#statusBar",
            (div2) => {
              this.setSortIcons();
            }
          );
        }
      );
    }
    onSearchAutocomplete(request, response) {
      const authors = this.getAuthors().sort((a, b) => a.handle.localeCompare(b.handle, void 0, { sensitivity: "base" }));
      const rules = Object.keys(this.state.rules);
      let term = extractLastTerm(request.term).toLowerCase();
      let isNegation = term.startsWith("!");
      if (isNegation) term = term.substring(1);
      let results = [];
      if (term === "") {
        results = rules.map((r) => ({ label: `$${r}`, value: `$${r}` }));
      } else if (term.startsWith("@") || term.startsWith("$")) {
        let type = term.charAt(0);
        let search = term.substring(1).toLowerCase();
        if (type === "@") {
          results = authors.filter(
            (a) => a.handle.toLowerCase().includes(search) || a.displayName.toLowerCase().includes(search)
          ).map((a) => ({
            label: `${isNegation ? "!" : ""}@${a.handle} (${a.displayName})`,
            value: `${isNegation ? "!" : ""}@${a.handle}`
          }));
        } else if (type === "$") {
          results = rules.filter((r) => r.toLowerCase().includes(search)).map((r) => ({
            label: `${isNegation ? "!" : ""}$${r}`
          }));
        }
      }
      response(results);
    }
    addStatusBar(statusBarContainer) {
      this.statusBar = $(`<div id="statusBar"></div>`);
      this.statusBarLeft = $(`<div id="statusBarLeft"></div>`);
      this.statusBarCenter = $(`<div id="statusBarCenter"></div>`);
      this.statusBarRight = $(`<div id="statusBarRight"></div>`);
      $(this.statusBar).append(this.statusBarLeft);
      $(this.statusBar).append(this.statusBarCenter);
      $(this.statusBar).append(this.statusBarRight);
      $(statusBarContainer).append(this.statusBar);
      this.bottomLoadIndicator = $(`
<div id="bottomLoadIndicator" class="toolbar-icon css-175oi2r r-1loqt21 r-1otgn73 r-1oszu61 r-16y2uox r-1777fci r-gu64tb"/>
`);
      $(this.statusBarLeft).append(this.bottomLoadIndicator);
      if (!this.infoIndicator) {
        this.infoIndicator = $(`<div id="infoIndicator" class="css-175oi2r r-1loqt21 r-1otgn73 r-1oszu61 r-16y2uox r-1777fci r-gu64tb"><div id="infoIndicatorText"/></div>`);
        $(this.statusBarCenter).append(this.infoIndicator);
      }
      if (!this.preferencesIcon) {
        this.preferencesIcon = $(`<div id="preferencesIndicator" class="toolbar-icon css-175oi2r r-1loqt21 r-1otgn73 r-1oszu61 r-16y2uox r-1777fci r-gu64tb"><div id="preferencesIcon"><img id="preferencesIconImage" class="indicator-image preferences-icon-overlay" src="${this.INDICATOR_IMAGES.preferences[0]}"/></div></div>`);
        $(this.preferencesIcon).on("click", () => {
          $("#preferencesIconImage").attr("src", this.INDICATOR_IMAGES.preferences[1]);
          this.config.open();
        });
        $(this.statusBarRight).append(this.preferencesIcon);
      }
    }
    activate() {
      super.activate();
      this.refreshToolbars();
      waitForElement$1(
        "#bsky-navigator-search",
        (el) => {
          $(el).val(this.state.filter);
        }
      );
    }
    deactivate() {
      super.deactivate();
    }
    isActive() {
      return window.location.pathname == "/";
    }
    toggleSortOrder() {
      this.state.stateManager.updateState({ feedSortReverse: !this.state.feedSortReverse });
      this.setSortIcons();
      $(this.selector).closest("div.thread").removeClass("bsky-navigator-seen");
      this.loadItems();
    }
    setSortIcons() {
      ["top", "bottom"].forEach(
        (bar) => {
          const which = !this.state.feedSortReverse && bar == "bottom" || this.state.feedSortReverse && bar == "top" ? "Older" : "Newer";
          const img = this.INDICATOR_IMAGES[`load${bar.toLowerCase().replace(/\b\w/g, (char) => char.toUpperCase())}`][0];
          $(`#${bar}LoadIndicator`).empty();
          $(`#${bar}LoadIndicator`).append(`
<div id="load${which}Indicator" title="Load ${which.toLowerCase()} items" class="toolbar-icon css-175oi2r r-1loqt21 r-1otgn73 r-1oszu61 r-16y2uox r-1777fci r-gu64tb">
      <a id="load${which}IndicatorLink">
<img id="load${which}IndicatorImage" class="indicator-image" src="${img}"/>
<img id="loadTime${which}IndicatorImage" class="indicator-image load-time-icon ${which == "Newer" ? "image-flip-x" : ""}" src="${this.INDICATOR_IMAGES.loadTime[0]}"/>
</a>
</div>
`);
        }
      );
      $("img#loadOlderIndicatorImage").addClass("image-highlight");
      $("a#loadOlderIndicatorLink").on("click", () => this.loadOlderItems());
    }
    toggleHideRead() {
      this.state.stateManager.updateState({ feedHideRead: !this.state.feedHideRead });
      $(this.selector).closest("div.thread").removeClass("bsky-navigator-seen");
      this.loadItems();
    }
    setFilter(text) {
      this.state.stateManager.saveStateImmediately(true, true);
      this.state.filter = text;
    }
    filterItem(item, thread) {
      if (this.state.feedHideRead) {
        if ($(item).hasClass("item-read")) {
          return false;
        }
      }
      if (this.state.filter && this.state.rules) {
        const activeRules = this.state.filter.split(/[ ]+/).map(
          (ruleStatement) => {
            const [_, invert, matchType, query] = ruleStatement.match(/(!)?([$@%])?"?([^"]+)"?/);
            return {
              invert,
              matchType,
              query
            };
          }
        );
        return activeRules.map(
          (activeRule) => {
            var allowed = null;
            switch (activeRule.matchType) {
              case "$":
                const rules = this.state.rules[activeRule.query];
                if (!rules) {
                  console.log(`no rule ${activeRule.query}`);
                  return null;
                }
                rules.forEach((rule) => {
                  if (rule.type === "all") {
                    allowed = rule.action === "allow";
                  } else if (rule.type === "from" && !!this.filterAuthor(item, rule.value.substring(1))) {
                    allowed = allowed || rule.action === "allow";
                  } else if (rule.type === "content" && !!this.filterContent(item, rule.value)) {
                    allowed = allowed || rule.action === "allow";
                  }
                });
                break;
              case "@":
                allowed = !!this.filterAuthor(item, activeRule.query);
                break;
              case "%":
                allowed = !!this.filterContent(item, activeRule.query);
                break;
              default:
                allowed = !!this.filterAuthor(item, activeRule.query) || !!this.filterContent(item, activeRule.query);
                break;
            }
            return activeRule.invert ? !allowed : allowed;
          }
        ).every((allowed) => allowed == true);
      }
      return true;
    }
    filterAuthor(item, author) {
      const pattern = new RegExp(author, "i");
      const handle2 = this.handleFromItem(item);
      const displayName = this.displayNameFromItem(item);
      if (!handle2.match(pattern) && !displayName.match(pattern)) {
        return false;
      }
      return true;
    }
    filterContent(item, query) {
      const pattern = new RegExp(query, "i");
      const content = $(item).find('div[data-testid="postText"]').text();
      return content.match(pattern);
    }
    filterThread(thread) {
      return $(thread).find(".item").length != $(thread).find(".filtered").length;
    }
    filterItems() {
      const hideRead = this.state.feedHideRead;
      $("#filterIndicatorImage").attr("src", this.INDICATOR_IMAGES.filter[+hideRead]);
      $("#filterIndicator").attr("title", `show all or unread (currently ${hideRead ? "unread" : "all"})`);
      const parent = $(this.selector).first().closest(".thread").parent();
      const unseenThreads = parent.find(".thread");
      $(unseenThreads).map(
        (i, thread) => {
          $(thread).find(".item").each(
            (i2, item) => {
              if (this.filterItem(item, thread)) {
                $(item).removeClass("filtered");
              } else {
                $(item).addClass("filtered");
              }
            }
          );
          if (this.filterThread(thread)) {
            $(thread).removeClass("filtered");
          } else {
            $(thread).addClass("filtered");
          }
        }
      );
      $(unseenThreads).map(
        (i, thread) => {
          $(thread).find(".item").each(
            (i2, item) => {
              const offset = parseInt($(item).data("bsky-navigator-thread-offset"));
              if (offset > 0 && $(item).hasClass("item-unread") && this.config.get("showReplyContext")) {
                const index = parseInt($(thread).data("bsky-navigator-thread-index"));
                const prev = $(`div[data-bsky-navigator-thread-index="${index}"] div[data-bsky-navigator-thread-offset="${offset - 1}"]`);
                $(prev).removeClass("filtered");
                $(prev).closest(".thread").removeClass("filtered");
              }
            }
          );
        }
      );
      this.refreshItems();
      if (hideRead && $(this.selectedItem).hasClass("item-read")) {
        console.log("jumping");
        this.jumpToNextUnseenItem();
      }
    }
    sortItems() {
      const reversed = this.state.feedSortReverse;
      $("#sortIndicatorImage").attr("src", this.INDICATOR_IMAGES.sort[+reversed]);
      $("#sortIndicator").attr("title", `change sort order (currently ${reversed ? "forward" : "reverse"} chronological)`);
      const parent = $(this.selector).closest(".thread").first().parent();
      const newItems = parent.children().filter(
        (i, item) => $(item).hasClass("thread")
      ).get().sort(
        (a, b) => {
          const threadIndexA = parseInt($(a).data("bsky-navigator-thread-index"));
          const threadIndexB = parseInt($(b).data("bsky-navigator-thread-index"));
          const itemIndexA = parseInt($(a).find(".item").data("bsky-navigator-item-index"));
          const itemIndexB = parseInt($(b).find(".item").data("bsky-navigator-item-index"));
          if (threadIndexA !== threadIndexB) {
            return reversed ? threadIndexB - threadIndexA : threadIndexA - threadIndexB;
          }
          return itemIndexA - itemIndexB;
        }
      );
      reversed ^ this.loadingNew ? parent.prepend(newItems) : parent.children(".thread").last().next().after(newItems);
    }
    handleInput(event) {
      var item = this.selectedItem;
      if (event.key == "a") {
        $(item).find(constants$1.PROFILE_SELECTOR)[0].click();
      } else if (event.key == "u") {
        this.loadNewerItems();
      } else if (event.key == ":") {
        this.toggleSortOrder();
      } else if (event.key == '"') {
        this.toggleHideRead();
      } else if (event.key == "/") {
        event.preventDefault();
        $("input#bsky-navigator-search").focus();
      } else if (event.key == ",") {
        this.loadItems();
      } else {
        super.handleInput(event);
      }
    }
  }
  class PostItemHandler extends ItemHandler {
    constructor(name, config2, state2, api, selector) {
      super(name, config2, state2, api, selector);
      this.indexMap = {};
      this.handleInput = this.handleInput.bind(this);
    }
    get index() {
      return this.indexMap?.[this.postId] ?? 0;
    }
    set index(value) {
      this.indexMap[this.postId] = value;
    }
    activate() {
      super.activate();
      this.postId = this.postIdFromUrl();
    }
    deactivate() {
      super.deactivate();
    }
    isActive() {
      return window.location.pathname.match(/\/post\//);
    }
    get scrollMargin() {
      return $('div[data-testid="postThreadScreen"] > div:visible').eq(0).outerHeight();
    }
    // getIndexFromItem(item) {
    //     return $(item).parent().parent().parent().parent().index() - 3
    // }
    handleInput(event) {
      if (["o", "Enter"].includes(event.key) && !(event.altKey || event.metaKey)) {
        var inner = $(item).find("div[aria-label^='Post by']");
        inner.click();
      }
      if (super.handleInput(event)) {
        return;
      }
      if (this.isPopupVisible || event.altKey || event.metaKey) {
        return;
      }
      var item = this.selectedItem;
      if (event.key == "a") {
        var handle2 = $.trim($(item).attr("data-testid").split("postThreadItem-by-")[1]);
        $(item).find("div").filter(
          (i, el) => $.trim($(el).text()).replace(/[\u200E\u200F\u202A-\u202E]/g, "") == `@${handle2}`
        )[0].click();
      }
    }
  }
  class ProfileItemHandler extends FeedItemHandler {
    constructor(name, config2, state2, api, selector) {
      super(name, config2, state2, api, selector);
    }
    activate() {
      this.setIndex(0);
      super.activate();
    }
    deactivate() {
      super.deactivate();
    }
    isActive() {
      return window.location.pathname.match(/^\/profile\//);
    }
    handleInput(event) {
      if (super.handleInput(event)) {
        return;
      }
      if (event.altKey || event.metaKey) {
        return;
      }
      if (event.key == "f") {
        $("button[data-testid='followBtn']").click();
      } else if (event.key == "F") {
        $("button[data-testid='unfollowBtn']").click();
      } else if (event.key == "L") {
        $("button[aria-label^='More options']").click();
        setTimeout(function() {
          $("div[data-testid='profileHeaderDropdownListAddRemoveBtn']").click();
        }, 200);
      } else if (event.key == "M") {
        $("button[aria-label^='More options']").click();
        setTimeout(function() {
          $("div[data-testid='profileHeaderDropdownMuteBtn']").click();
        }, 200);
      } else if (event.key == "B") {
        $("button[aria-label^='More options']").click();
        setTimeout(function() {
          $("div[data-testid='profileHeaderDropdownBlockBtn']").click();
        }, 200);
      } else if (event.key == "R") {
        $("button[aria-label^='More options']").click();
        setTimeout(function() {
          $("div[data-testid='profileHeaderDropdownReportBtn']").click();
        }, 200);
      }
    }
  }
  const {
    waitForElement,
    observeChanges,
    observeVisibilityChange
  } = utils$1;
  GM_addStyle(style);
  let config;
  let handlers;
  const screenPredicateMap = {
    search: (element) => $(element).find('div[data-testid="searchScreen"]').length,
    notifications: (element) => $(element).find('div[data-testid="notificationsScreen"]').length,
    chat: (element) => $(element).find('div:contains("Messages")').length,
    feeds: (element) => $(element).find('div[data-testid="FeedsScreen"]').length,
    lists: (element) => $(element).find('div[data-testid="listsScreen"]').length,
    profile: (element) => $(element).find('div[data-testid="profileScreen"]').length,
    settings: (element) => $(element).find('a[aria-label="Account"]').length,
    home: (element) => true
  };
  function getScreenFromElement(element) {
    for (const [page, predicate2] of Object.entries(screenPredicateMap)) {
      if (predicate2(element)) {
        return page;
      }
    }
    return "unknown";
  }
  (function() {
    var current_url = null;
    var context = null;
    function parseRulesConfig(configText) {
      const lines = configText.split("\n");
      const rules = {};
      let rulesName = null;
      for (let line of lines) {
        line = line.trim();
        if (!line || line.startsWith(";") || line.startsWith("#")) continue;
        const sectionMatch = line.match(/^\[(.+)\]$/);
        if (sectionMatch) {
          rulesName = sectionMatch[1];
          rules[rulesName] = [];
          continue;
        }
        if (!rulesName) continue;
        const ruleMatch = line.match(/(allow|deny) (all|from|content) "?([^"]+)"?/);
        if (ruleMatch) {
          const [_, action, type, value] = ruleMatch;
          rules[rulesName].push({ action, type, value });
          continue;
        }
        if (line.startsWith("@")) {
          rules[rulesName].push({ action: "allow", type: "from", value: line });
        } else {
          rules[rulesName].push({ action: "allow", type: "content", value: line });
        }
      }
      return rules;
    }
    function onConfigInit() {
      const stateManagerConfig = {
        stateSyncEnabled: config.get("stateSyncEnabled"),
        stateSyncConfig: config.get("stateSyncConfig"),
        stateSaveTimeout: config.get("stateSaveTimeout"),
        maxEntries: config.get("historyMax")
      };
      state.init(constants$1.STATE_KEY, stateManagerConfig, onStateInit);
    }
    function onConfigSave() {
      state.rulesConfig = config.get("rulesConfig");
      state.stateManager.saveStateImmediately(true, true);
      config.close();
    }
    function onStateInit() {
      let widthWatcher;
      let api;
      if (config.get("atprotoService") && config.get("atprotoIdentifier") && config.get("atprotoPassword")) {
        api = new BlueskyAPI(
          config.get("atprotoService"),
          config.get("atprotoIdentifier"),
          config.get("atprotoPassword")
        );
        api.login();
        async function loadSidecarTemplate(selector, html) {
          try {
            const popupContainer = $(selector).append(html);
            $(".close-btn").on("click", function() {
              $("#bluesky-popup").hide();
            });
            console.log("Popup loaded successfully!");
          } catch (error) {
            console.error("Failed to load popup:", error);
          }
        }
        loadSidecarTemplate("body", sidecarTemplatesHtml);
      }
      handlers = {
        feed: new FeedItemHandler("feed", config, state, api, constants$1.FEED_ITEM_SELECTOR),
        post: new PostItemHandler("post", config, state, api, constants$1.POST_ITEM_SELECTOR),
        profile: new ProfileItemHandler("profile", config, state, api, constants$1.FEED_ITEM_SELECTOR),
        input: new Handler("input", config, state, api)
      };
      if (state.rulesConfig) {
        config.set("rulesConfig", state.rulesConfig);
      }
      state.rules = parseRulesConfig(config.get("rulesConfig"));
      if (config.get("showDebuggingInfo")) {
        let appendLog = function(type, args) {
          const message2 = `[${type.toUpperCase()}] ${args.map((arg) => typeof arg === "object" ? JSON.stringify(arg, null, 2) : arg).join(" ")}`;
          $("#logContent").append(`<div style="margin-bottom: 5px;">${message2}</div>`);
          $("#logContent").scrollTop($("#logContent")[0].scrollHeight);
        };
        const logContainer = $(`<div id="logContainer"></div>`);
        $("body").append(logContainer);
        const logHeader = $(`<div id="logHeader"></div>`);
        logHeader.append($(`<button id="clearLogs"/>Clear</button>`));
        logContainer.append(logHeader);
        logContainer.append($(`<div id="logContent"></div>`));
        $("#clearLogs").on("click", function() {
          $("#logContent").empty();
        });
        const originalConsole = {};
        ["log", "warn", "error", "info"].forEach((type) => {
          originalConsole[type] = console[type];
          unsafeWindow.console[type] = function(...args) {
            appendLog(type, args);
            originalConsole[type].apply(console, args);
          };
        });
        window.console = unsafeWindow.console;
      }
      const stylesheet = `

        /* Feed itmes may be sorted, so we hide them visually and show them later */
        div[data-testid$="FeedPage"] ${constants$1.FEED_ITEM_SELECTOR} {
            opacity: 0%;
        }

        ${config.get("hideLoadNewButton") ? `
            ${constants$1.LOAD_NEW_BUTTON_SELECTOR} {
                display: none;
            }
            ` : ``}

        .item  {
            margin: 3px;
            ${config.get("posts")}
        }

        .item > div {
            border: none;
        }

        .item-selection-active {
            ${config.get("selectionActive")}
        }

        .item-selection-inactive {
            ${config.get("selectionInactive")}
        }

        .item-selection-child-focused {
            ${config.get("selectionChildFocused")}
        }

        .reply-selection-active {
            ${config.get("replySelectionActive")};
        }

        .sidecar-post {
            margin: 1px;
            ${config.get("replySelectionInactive")}
        }

        @media (prefers-color-scheme:light){
            .item-unread {
                ${config.get("unreadPosts")};
                ${config.get("unreadPostsLightMode")};
            }

            .item-read {
                ${config.get("readPosts")};
                ${config.get("readPostsLightMode")};
            }

        }

        @media (prefers-color-scheme:dark){
            .item-unread {
                ${config.get("unreadPosts")};
                ${config.get("unreadPostsDarkMode")};
            }

            .item-read {
                ${config.get("readPosts")};
                ${config.get("readPostsDarkMode")};
            }
        }

        .thread-first {
            margin-top: ${config.get("threadMargin")};
            border-top: 1px rgb(212, 219, 226) solid;
        }

        .thread-last {
            margin-bottom: ${config.get("threadMargin")};
        }

        /* hack to fix last thread item indicator being offset */
        .thread-last div.r-lchren {
            left: 10px;
        }

        div.r-m5arl1 {
            width: ${config.get("threadIndicatorWidth")}px;
            background-color: ${config.get("threadIndicatorColor")} !important;
        }

        div:has(main) {
            overflow-x: clip;
        }

        ${constants$1.POST_CONTENT_SELECTOR} {
            margin: 1em 1px 1px 1px;
        }

        ${constants$1.HOME_SCREEN_SELECTOR} .item > div:first-of-type > div:last-of-type > div:last-of-type > div:first-of-type {
            flex: unset !important;
        }



`;
      const styleElement = document.createElement("style");
      styleElement.type = "text/css";
      styleElement.textContent = stylesheet;
      document.head.appendChild(styleElement);
      function updateScreen(screen) {
        if (state.screen == screen) {
          return;
        }
        state.screen = screen;
        if (screen == "search") {
          if ($(":focus") != $('input[role="search"]')) {
            $('input[role="search"]').focus();
          }
        }
        if (!widthWatcher) {
          widthWatcher = waitForElement(
            constants$1.WIDTH_SELECTOR,
            onWindowResize
          );
        }
      }
      waitForElement(constants$1.SCREEN_SELECTOR, (element) => {
        updateScreen(getScreenFromElement(element));
        observeVisibilityChange($(element), (isVisible) => {
          if (isVisible) {
            updateScreen(getScreenFromElement(element));
          }
        });
      });
      function setContext(ctx) {
        if (context == ctx) {
          return;
        }
        context = ctx;
        console.log(`context: ${context}`);
        for (const [name, handler] of Object.entries(handlers)) {
          handler.deactivate();
        }
        if (handlers[context]) {
          handlers[context].activate();
        }
      }
      function setContextFromUrl() {
        current_url = window.location.href;
        for (const [name, handler] of Object.entries(handlers)) {
          if (handler.isActive()) {
            setContext(name);
            break;
          }
        }
      }
      function onFocus(e) {
        var target2 = e.target;
        if (typeof target2.tagName === "undefined") {
          return false;
        }
        var targetTagName = target2.tagName.toLowerCase();
        console.log(`onFocus: ${targetTagName}`);
        switch (targetTagName) {
          case "input":
          case "textarea":
            setContext("input");
            break;
          case "div":
            let maybeTiptap = $(target2).closest(".tiptap");
            if (maybeTiptap.length) {
              waitForElement(".tiptap", () => null, () => onBlur({ "target": maybeTiptap[0] }));
              setContext("input");
            } else {
              setContextFromUrl();
            }
            break;
          default:
            setContextFromUrl();
        }
      }
      function onBlur(e) {
        var target2 = e.target;
        if (typeof target2.tagName === "undefined") {
          return false;
        }
        var targetTagName = target2.tagName.toLowerCase();
        console.log(`onBlur: ${targetTagName}`);
        console.log(e.target);
        switch (targetTagName) {
          case "input":
          case "textarea":
            setContextFromUrl();
            break;
          case "div":
            if ($(target2).closest(".tiptap").length) {
              setContextFromUrl();
            }
            break;
          default:
            setContextFromUrl();
            break;
        }
      }
      document.addEventListener("focus", onFocus, true);
      document.addEventListener("blur", onBlur, true);
      function startMonitor() {
        setInterval(function() {
          if (window.location.href !== current_url) {
            setContextFromUrl();
          }
        }, constants$1.URL_MONITOR_INTERVAL);
      }
      state.mobileView = false;
      waitForElement(
        `${constants$1.DRAWER_MENU_SELECTOR}, ${constants$1.LEFT_SIDEBAR_SELECTOR}`,
        (element) => {
          console.log("viewport");
          state.mobileView = $(element).is(constants$1.DRAWER_MENU_SELECTOR);
          console.log(state.mobileView);
          startMonitor();
          setContextFromUrl();
        }
      );
      function adjustTransformX(el, offset) {
        var transform = $(el).css("transform");
        var translateX = 0;
        if (!transform || transform == "none") {
          $(el).css("transform", "translateX(0px);");
          transform = $(el).css("transform");
        }
        console.log(`translateX = ${translateX}`);
        $(el).css("transform", `translateX(${translateX + offset}px)`);
      }
      function setWidth(leftSidebar, width) {
        const LEFT_TRANSLATE_X_DEFAULT = -540;
        const RIGHT_TRANSLATE_X_DEFAULT = 300;
        const rightSidebar = $(leftSidebar).next();
        if (config.get("hideRightSidebar")) {
          $(rightSidebar).css("display", "none");
        }
        const sidebarDiff = width - 600;
        console.log("sidebarDiff", sidebarDiff);
        if (state.leftSidebarMinimized) {
          console.log("minimized");
          adjustTransformX(leftSidebar, LEFT_TRANSLATE_X_DEFAULT - sidebarDiff / 2 + constants$1.WIDTH_OFFSET);
          adjustTransformX("main", sidebarDiff / 2 - constants$1.WIDTH_OFFSET);
        } else if (sidebarDiff) {
          if (config.get("hideRightSidebar")) {
            adjustTransformX(leftSidebar, LEFT_TRANSLATE_X_DEFAULT - sidebarDiff / 2 + constants$1.WIDTH_OFFSET);
            adjustTransformX("main", sidebarDiff / 2 - constants$1.WIDTH_OFFSET);
          } else {
            adjustTransformX(leftSidebar, LEFT_TRANSLATE_X_DEFAULT - sidebarDiff / 2);
            adjustTransformX(rightSidebar, RIGHT_TRANSLATE_X_DEFAULT + sidebarDiff / 2);
          }
        } else {
          console.log("reset sidebars");
          $(leftSidebar).css("transform", `translateX(${LEFT_TRANSLATE_X_DEFAULT}px)`);
          $(rightSidebar).css("transform", `translateX(${RIGHT_TRANSLATE_X_DEFAULT}px)`);
        }
        $(constants$1.WIDTH_SELECTOR).css("max-width", `${width}px`, "!important");
        $('div[role="tablist"]').css("width", `${width}px`);
        $("#statusBar").css("max-width", `${width}px`);
        $('div[style^="position: fixed; inset: 0px 0px 0px 50%;"]').css("width", `${width}px`);
      }
      state.leftSidebarMinimized = false;
      waitForElement(
        constants$1.LEFT_SIDEBAR_SELECTOR,
        (leftSidebar) => {
          state.leftSidebarMinimized = !$(leftSidebar).hasClass("r-y46g1k");
          observeChanges(
            leftSidebar,
            (attributeName, oldValue, newValue, target2) => {
              if ($(leftSidebar).hasClass("r-y46g1k")) {
                state.leftSidebarMinimized = false;
              } else {
                state.leftSidebarMinimized = true;
              }
              console.log(state.leftSidebarMinimized);
            }
          );
        }
        // (leftSidebar) => {
        //     console.log("removed");
        // }
      );
      let resizeTimer;
      function onWindowResize() {
        if (state.mobileView) {
          return;
        }
        console.log("Resized to: " + $(window).width() + "x" + $(window).height());
        if (state.mobileView) {
          return;
        } else {
          const leftSidebar = $(constants$1.LEFT_SIDEBAR_SELECTOR);
          const rightSidebar = $(leftSidebar).next();
          const leftSidebarWidth = $(leftSidebar).outerWidth();
          const remainingWidth = $(window).width() - leftSidebarWidth - !config.get("hideRightSidebar") * ($(rightSidebar).outerWidth() || 0) - constants$1.WIDTH_OFFSET;
          console.log("remainingWidth", remainingWidth, "leftSidebarWidth", leftSidebarWidth);
          if (remainingWidth >= config.get("postWidthDesktop")) {
            setWidth($(constants$1.LEFT_SIDEBAR_SELECTOR), config.get("postWidthDesktop"));
          } else {
            setWidth($(constants$1.LEFT_SIDEBAR_SELECTOR), remainingWidth);
          }
        }
      }
      $(window).resize(function() {
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(onWindowResize, 500);
      });
      waitForElement(constants$1.WIDTH_SELECTOR, onWindowResize);
      function proxyIntersectionObserver() {
        const OriginalIntersectionObserver = unsafeWindow.IntersectionObserver;
        class ProxyIntersectionObserver {
          constructor(callback, options) {
            this.callback = callback;
            this.options = options;
            this.enabled = true;
            handlers["feed"].loadOlderItemsCallback = this.callback;
            this.realObserver = new OriginalIntersectionObserver((entries, observer) => {
              const filteredEntries = entries.filter(
                (entry) => !($(entry.target).hasClass("thread") || $(entry.target).hasClass("item") || $(entry.target).find('div[data-testid^="feedItem"]').length || $(entry.target).next()?.attr("style") == "height: 32px;")
              );
              callback(
                filteredEntries,
                observer
              );
            }, options);
          }
          enable() {
            this.enabled = true;
          }
          disable() {
            this.enabled = false;
          }
          // Custom logic to decide when to override
          shouldOverride(entries, observer) {
            return true;
          }
          // Custom override behavior
          overrideBehavior(entries, observer) {
          }
          // Proxy all methods to the real IntersectionObserver
          observe(target2) {
            this.realObserver.observe(target2);
          }
          unobserve(target2) {
            this.realObserver.unobserve(target2);
          }
          disconnect() {
            this.realObserver.disconnect();
          }
          takeRecords() {
            return this.realObserver.takeRecords();
          }
        }
        unsafeWindow.IntersectionObserver = ProxyIntersectionObserver;
      }
      proxyIntersectionObserver();
    }
    const configTitleDiv = `
    <div class="config-title">
      <h1><a href="https://github.com/tonycpsu/bluesky-navigator" target="_blank">Bluesky Navigator</a> v${GM_info.script.version}</h1>
      <h2>Configuration</h2>
    </div>
  `;
    function waitForGMConfig(callback) {
      if (typeof GM_config !== "undefined") {
        callback();
      } else {
        console.warn("GM_config not available yet. Retrying...");
        setTimeout(() => waitForGMConfig(callback), 100);
      }
    }
    waitForGMConfig(() => {
      config = new GM_config({
        id: "GM_config",
        title: configTitleDiv,
        fields: CONFIG_FIELDS,
        "events": {
          "init": onConfigInit,
          "save": onConfigSave,
          "close": () => $("#preferencesIconImage").attr("src", handlers["feed"].INDICATOR_IMAGES.preferences[0])
        },
        "css": configCss
      });
    });
    $(document).ready(function(e) {
      const originalPlay = HTMLMediaElement.prototype.play;
      HTMLMediaElement.prototype.play = function() {
        const isUserInitiated = this.dataset.allowPlay === "true";
        if (isUserInitiated || config.get("videoPreviewPlayback") == "Play all") {
          delete this.dataset.allowPlay;
          return originalPlay.apply(this, arguments);
        } else if ($(document.activeElement).is('button[aria-label^="Play"]')) {
          return originalPlay.apply(this, arguments);
        } else {
          return Promise.resolve();
        }
      };
    });
  })();
})();
