// ==UserScript==
// @name        bluesky-navigator
// @description Adds Vim-like navigation, read/unread post-tracking, and other features to Bluesky
// @version     1.0.31+638.1fddb3fc
// @author      https://bsky.app/profile/tonyc.org
// @namespace   https://tonyc.org/
// @match       https://bsky.app/*
// @require     https://code.jquery.com/jquery-3.7.1.min.js
// @require     https://raw.githubusercontent.com/sizzlemctwizzle/GM_config/refs/heads/master/gm_config.js
// @require     https:code.jquery.com/ui/1.12.1/jquery-ui.min.js
// @downloadURL https://github.com/tonycpsu/bluesky-navigator/raw/refs/heads/main/dist/bluesky-navigator.user.js
// @updateURL   https://github.com/tonycpsu/bluesky-navigator/raw/refs/heads/main/dist/bluesky-navigator.user.js
// @connect     clearsky.services
// @connect     surreal.cloud
// @connect     cdn.bsky.app
// @grant       GM_setValue
// @grant       GM_getValue
// @grant       GM_addStyle
// @grant       GM_xmlhttpRequest
// @grant       unsafeWindow
// @grant       GM_info
// @grant       GM_listValues
// @grant       GM.getValue
// @grant       GM.setValue
// @grant       GM.xmlhttpRequest
// ==/UserScript==

(function() {
  "use strict";
  const constants = {
    // 32 distinct colors for ruleset/filter list coloring
    // Carefully chosen to maximize perceptual distance between colors
    // Organized by hue with varying saturation/lightness to avoid similar pairs
    FILTER_LIST_COLORS: [
      // Primary and secondary hues (high saturation)
      "#e41a1c",
      // red
      "#ff7f00",
      // orange
      "#ffcd00",
      // golden yellow
      "#4daf4a",
      // green
      "#00a087",
      // teal
      "#377eb8",
      // blue
      "#6a3d9a",
      // purple
      "#e7298a",
      // magenta/pink
      // Tertiary hues (medium-high saturation)
      "#b35806",
      // burnt orange
      "#a6d854",
      // lime green
      "#33c4b3",
      // turquoise
      "#1a75cf",
      // azure
      "#984ea3",
      // violet
      "#d95f02",
      // rust
      "#66c2a5",
      // seafoam
      "#7570b3",
      // periwinkle
      // Darker variants
      "#8b0000",
      // dark red
      "#8b4513",
      // saddle brown
      "#556b2f",
      // dark olive
      "#006400",
      // dark green
      "#008b8b",
      // dark cyan
      "#00008b",
      // dark blue
      "#4b0082",
      // indigo
      "#8b008b",
      // dark magenta
      // Lighter/pastel variants
      "#fb9a99",
      // light coral
      "#fdbf6f",
      // light orange
      "#b2df8a",
      // light green
      "#a6cee3",
      // light blue
      "#cab2d6",
      // light purple
      "#bc80bd",
      // orchid
      "#80b1d3",
      // steel blue
      "#fccde5"
      // light pink
    ],
    // Timing constants
    DEFAULT_STATE_SAVE_TIMEOUT: 5e3,
    URL_MONITOR_INTERVAL: 500,
    REPOST_MENU_DELAY: 1e3,
    // Delay before clicking repost menu item
    // Video playback modes
    VIDEO_PLAYBACK: {
      PLAY_ALL: "Play all",
      PLAY_SELECTED: "Play selected",
      PAUSE_ALL: "Pause all"
    },
    // Layout constants for sidebar positioning
    SIDEBAR_LAYOUT: {
      LEFT_TRANSLATE_X_DEFAULT: -540,
      RIGHT_TRANSLATE_X_DEFAULT: 300
    },
    // Embed dimensions
    EMBED_DIMENSIONS: {
      YOUTUBE: { width: 320, height: 200 },
      TIKTOK: { maxWidth: 605, minWidth: 325 }
    },
    // State management
    STATE_KEY: "bluesky_state",
    DRAWER_MENU_SELECTOR: 'button[aria-label="Open drawer menu"]',
    SCREEN_SELECTOR: "main > div > div > div",
    HOME_SCREEN_SELECTOR: 'div[data-testid="HomeScreen"]',
    get FEED_TAB_SELECTOR() {
      return `${constants.HOME_SCREEN_SELECTOR} > div > div`;
    },
    get TOOLBAR_CONTAINER_SELECTOR() {
      return `${constants.FEED_TAB_SELECTOR} > div:first-child`;
    },
    LOAD_NEW_BUTTON_SELECTOR: "button[aria-label^='Load new']",
    get LOAD_NEW_INDICATOR_SELECTOR() {
      return `${constants.LOAD_NEW_BUTTON_SELECTOR} div[style*="border-color: rgb(197, 207, 217)"]`;
    },
    get FEED_CONTAINER_SELECTOR() {
      return `${constants.HOME_SCREEN_SELECTOR} div[data-testid$="FeedPage"] div[style*="removed-body-scroll-bar-size"] > div`;
    },
    get STATUS_BAR_CONTAINER_SELECTOR() {
      return `${constants.HOME_SCREEN_SELECTOR} div[data-testid$="FeedPage"] div[style*="removed-body-scroll-bar-size"]`;
    },
    FEED_ITEM_SELECTOR: 'div:not(.css-175oi2r) > div[tabindex="0"][role="link"]:not(.r-1awozwy)',
    LEFT_SIDEBAR_SELECTOR: 'nav[role="navigation"]',
    POST_ITEM_SELECTOR: 'div[data-testid^="postThreadItem-by-"]',
    POST_CONTENT_SELECTOR: 'div[data-testid="contentHider-post"]',
    MAIN_SELECTOR: 'main[role="main"]',
    WIDTH_SELECTOR: 'div[style*="removed-body-scroll-bar-size"][style*="width: 100%"]',
    PROFILE_SELECTOR: 'a[aria-label="View profile"]',
    LINK_SELECTOR: 'a[target="_blank"]',
    CLEARSKY_LIST_REFRESH_INTERVAL: 60 * 60 * 24,
    CLEARSKY_BLOCKED_ALL_CSS: { "background-color": "#ff8080" },
    CLEARSKY_BLOCKED_RECENT_CSS: { "background-color": "#cc4040" },
    ITEM_SCROLL_MARGIN: 100,
    SIDECAR_SVG_REPLY: `<svg fill="none" width="18" viewBox="0 0 24 24" height="18" style="color: rgb(111, 134, 159); pointer-events: none; flex-shrink: 0; display: block;"><path fill="hsl(211, 20%, 53%)" fill-rule="evenodd" clip-rule="evenodd" d="M2.002 6a3 3 0 0 1 3-3h14a3 3 0 0 1 3 3v10a3 3 0 0 1-3 3H12.28l-4.762 2.858A1 1 0 0 1 6.002 21v-2h-1a3 3 0 0 1-3-3V6Zm3-1a1 1 0 0 0-1 1v10a1 1 0 0 0 1 1h2a1 1 0 0 1 1 1v1.234l3.486-2.092a1 1 0 0 1 .514-.142h7a1 1 0 0 0 1-1V6a1 1 0 0 0-1-1h-14Z"></path></svg>`,
    SIDECAR_SVG_REPOST: [
      `<svg fill="none" width="18" viewBox="0 0 24 24" height="18" style="color: rgb(111, 134, 159); flex-shrink: 0; display: block;"><path fill="hsl(211, 20%, 53%)" fill-rule="evenodd" clip-rule="evenodd" d="M17.957 2.293a1 1 0 1 0-1.414 1.414L17.836 5H6a3 3 0 0 0-3 3v3a1 1 0 1 0 2 0V8a1 1 0 0 1 1-1h11.836l-1.293 1.293a1 1 0 0 0 1.414 1.414l2.47-2.47a1.75 1.75 0 0 0 0-2.474l-2.47-2.47ZM20 12a1 1 0 0 1 1 1v3a3 3 0 0 1-3 3H6.164l1.293 1.293a1 1 0 1 1-1.414 1.414l-2.47-2.47a1.75 1.75 0 0 1 0-2.474l2.47-2.47a1 1 0 0 1 1.414 1.414L6.164 17H18a1 1 0 0 0 1-1v-3a1 1 0 0 1 1-1Z"></path></svg>`,
      `<svg fill="none" width="18" viewBox="0 0 24 24" height="18" style="color: rgb(19, 195, 113); flex-shrink: 0; display: block;"><path fill="hsl(152, 82%, 42%)" fill-rule="evenodd" clip-rule="evenodd" d="M17.957 2.293a1 1 0 1 0-1.414 1.414L17.836 5H6a3 3 0 0 0-3 3v3a1 1 0 1 0 2 0V8a1 1 0 0 1 1-1h11.836l-1.293 1.293a1 1 0 0 0 1.414 1.414l2.47-2.47a1.75 1.75 0 0 0 0-2.474l-2.47-2.47ZM20 12a1 1 0 0 1 1 1v3a3 3 0 0 1-3 3H6.164l1.293 1.293a1 1 0 1 1-1.414 1.414l-2.47-2.47a1.75 1.75 0 0 1 0-2.474l2.47-2.47a1 1 0 0 1 1.414 1.414L6.164 17H18a1 1 0 0 0 1-1v-3a1 1 0 0 1 1-1Z"></path></svg>`
    ],
    SIDECAR_SVG_LIKE: [
      `<svg fill="none" width="18" viewBox="0 0 24 24" height="18" style="color: rgb(111, 134, 159); pointer-events: none; flex-shrink: 0; display: block;"><path fill="hsl(211, 20%, 53%)" fill-rule="evenodd" clip-rule="evenodd" d="M16.734 5.091c-1.238-.276-2.708.047-4.022 1.38a1 1 0 0 1-1.424 0C9.974 5.137 8.504 4.814 7.266 5.09c-1.263.282-2.379 1.206-2.92 2.556C3.33 10.18 4.252 14.84 12 19.348c7.747-4.508 8.67-9.168 7.654-11.7-.541-1.351-1.657-2.275-2.92-2.557Zm4.777 1.812c1.604 4-.494 9.69-9.022 14.47a1 1 0 0 1-.978 0C2.983 16.592.885 10.902 2.49 6.902c.779-1.942 2.414-3.334 4.342-3.764 1.697-.378 3.552.003 5.169 1.286 1.617-1.283 3.472-1.664 5.17-1.286 1.927.43 3.562 1.822 4.34 3.764Z"></path></svg>`,
      `<svg fill="none" width="18" viewBox="0 0 24 24" height="18" class="r-84gixx" style="flex-shrink: 0; display: block;"><path fill="#ec4899" fill-rule="evenodd" clip-rule="evenodd" d="M12.489 21.372c8.528-4.78 10.626-10.47 9.022-14.47-.779-1.941-2.414-3.333-4.342-3.763-1.697-.378-3.552.003-5.169 1.287-1.617-1.284-3.472-1.665-5.17-1.287-1.927.43-3.562 1.822-4.34 3.764-1.605 4 .493 9.69 9.021 14.47a1 1 0 0 0 .978 0Z"></path></svg>`
    ],
    WIDTH_OFFSET: 32
  };
  const DEFAULT_HISTORY_MAX = 5e3;
  class StateManager {
    constructor(key, _defaultState = {}, config2 = {}) {
      this.key = key;
      this.config = config2;
      if (!this.config) {
        console.warn("StateManager: config is undefined");
      }
      this.listeners = [];
      this.debounceTimeout = null;
      this.maxEntries = this.config.maxEntries || DEFAULT_HISTORY_MAX;
      this.state = {};
      this.isLocalStateDirty = false;
      this.isRemoteSyncPending = false;
      this.localSaveTimeout = null;
      this.remoteSyncTimeout = null;
      this.dirtySeenEntries = /* @__PURE__ */ new Map();
      this.lastSeenSnapshot = null;
      this.seenSyncCount = 0;
      this.handleBlockListResponse = this.handleBlockListResponse.bind(this);
      this.saveStateImmediately = this.saveStateImmediately.bind(this);
      this.saveRemoteStateSync = this.saveRemoteStateSync.bind(this);
      window.addEventListener("beforeunload", () => {
        this.saveStateImmediately();
        if (this.config.stateSyncEnabled && this.isRemoteSyncPending) {
          this.saveRemoteStateSync();
        }
      });
      document.addEventListener("visibilitychange", () => {
        if (document.visibilityState === "hidden" && this.config.stateSyncEnabled && this.isRemoteSyncPending) {
          this.saveRemoteStateSync();
        }
      });
      window.addEventListener("pagehide", () => {
        if (this.config.stateSyncEnabled && this.isRemoteSyncPending) {
          this.saveRemoteStateSync();
        }
      });
    }
    static async create(key, defaultState = {}, config2 = {}) {
      const instance2 = new StateManager(key, defaultState, config2);
      await instance2.initializeState(defaultState);
      return instance2;
    }
    async initializeState(defaultState) {
      this.state = await this.loadState(defaultState);
      this.ensureBlockState();
      this.updateBlockList();
    }
    ensureBlockState() {
      if (!this.state.blocks) {
        this.state.blocks = {
          all: { updated: null, dids: [] },
          recent: { updated: null, dids: [] }
        };
      }
      if (this.state.blocks.all && "handles" in this.state.blocks.all) {
        this.state.blocks.all.dids = [];
        delete this.state.blocks.all.handles;
      }
      if (this.state.blocks.recent && "handles" in this.state.blocks.recent) {
        this.state.blocks.recent.dids = [];
        delete this.state.blocks.recent.handles;
      }
    }
    setSyncStatus(status, title) {
      const overlay = $(".preferences-icon-overlay");
      if (!overlay) {
        return;
      }
      $(overlay).attr("title", `sync: ${status} ${title || ""}`);
      for (const s of ["ready", "pending", "success", "failure"]) {
        $(overlay).removeClass(`preferences-icon-overlay-sync-${s}`);
      }
      $(overlay).addClass(`preferences-icon-overlay-sync-${status}`);
      if (status == "success") {
        setTimeout(() => this.setSyncStatus("ready"), 3e3);
      }
    }
    /**
     * Executes a query against the remote database.
     * @param {string} query - The query string to execute.
     * @param {string} successStatus - The status to set on successful execution (e.g., "success").
     * @returns {Promise<Object>} - Resolves with the parsed result of the query.
     */
    async executeRemoteQuery(query, successStatus = "success") {
      const {
        url,
        namespace = "bluesky_navigator",
        database = "state",
        username,
        password
      } = JSON.parse(this.config.stateSyncConfig);
      return new Promise((resolve, reject) => {
        GM_xmlhttpRequest({
          method: "POST",
          url: `${url.replace(/\/$/, "")}/sql`,
          headers: {
            Accept: "application/json",
            Authorization: "Basic " + btoa(`${username}:${password}`)
          },
          data: `USE NS ${namespace} DB ${database}; ${query}`,
          onload: (response) => {
            try {
              if (response.status !== 200) {
                throw new Error(response.statusText);
              }
              const result = JSON.parse(response.responseText)[1]?.result[0];
              this.setSyncStatus(successStatus);
              resolve(result);
            } catch (error) {
              console.error("Error executing query:", error.message);
              this.setSyncStatus("failure", error.message);
              reject(error);
            }
          },
          onerror: (error) => {
            console.error("Network error executing query:", error.message);
            this.setSyncStatus("failure", error.message);
            reject(error);
          }
        });
      });
    }
    /**
     * Executes a query and returns ALL results (not just the first one).
     * @param {string} query - The query string to execute.
     * @param {string} successStatus - The status to set on successful execution.
     * @returns {Promise<Array>} - Resolves with all results from the query.
     */
    async executeRemoteQueryAll(query, successStatus = "success") {
      const {
        url,
        namespace = "bluesky_navigator",
        database = "state",
        username,
        password
      } = JSON.parse(this.config.stateSyncConfig);
      return new Promise((resolve, reject) => {
        GM_xmlhttpRequest({
          method: "POST",
          url: `${url.replace(/\/$/, "")}/sql`,
          headers: {
            Accept: "application/json",
            Authorization: "Basic " + btoa(`${username}:${password}`)
          },
          data: `USE NS ${namespace} DB ${database}; ${query}`,
          onload: (response) => {
            try {
              if (response.status !== 200) {
                throw new Error(response.statusText);
              }
              const result = JSON.parse(response.responseText)[1]?.result || [];
              this.setSyncStatus(successStatus);
              resolve(result);
            } catch (error) {
              console.error("Error executing query:", error.message);
              this.setSyncStatus("failure", error.message);
              reject(error);
            }
          },
          onerror: (error) => {
            console.error("Network error executing query:", error.message);
            this.setSyncStatus("failure", error.message);
            reject(error);
          }
        });
      });
    }
    async getRemoteStateUpdated() {
      const sinceResult = await this.executeRemoteQuery(`SELECT lastUpdated FROM state:current;`);
      return sinceResult["lastUpdated"];
    }
    /**
     * Loads state from storage or initializes with the default state.
     * Compares local and remote timestamps to use whichever is newer.
     */
    async loadState(defaultState) {
      try {
        const savedState = JSON.parse(GM_getValue(this.key, "{}"));
        const localLastUpdated = savedState.lastUpdated;
        if (this.config.stateSyncEnabled) {
          const remoteState = await this.loadRemoteState();
          if (remoteState) {
            const remoteLastUpdated = remoteState.lastUpdated;
            const localTime = localLastUpdated ? new Date(localLastUpdated).getTime() : 0;
            const remoteTime = remoteLastUpdated ? new Date(remoteLastUpdated).getTime() : 0;
            if (localTime > remoteTime) {
              return { ...defaultState, ...savedState };
            } else {
              const { filter: remoteFilter, ...remoteWithoutFilter } = remoteState;
              const mergedSeen = { ...savedState.seen || {} };
              const remoteSeen = remoteWithoutFilter.seen || {};
              for (const [postId, timestamp] of Object.entries(remoteSeen)) {
                if (!mergedSeen[postId] || new Date(timestamp) > new Date(mergedSeen[postId])) {
                  mergedSeen[postId] = timestamp;
                }
              }
              const mergedTimeouts = { ...savedState.timeouts || {} };
              const remoteTimeouts = remoteWithoutFilter.timeouts || {};
              for (const [handle2, expiresAt] of Object.entries(remoteTimeouts)) {
                if (!mergedTimeouts[handle2] || expiresAt > mergedTimeouts[handle2]) {
                  mergedTimeouts[handle2] = expiresAt;
                }
              }
              return {
                ...defaultState,
                ...remoteWithoutFilter,
                filter: savedState.filter || defaultState.filter || "",
                timeouts: mergedTimeouts,
                seen: mergedSeen
              };
            }
          } else {
            return { ...defaultState, ...savedState };
          }
        } else {
          return { ...defaultState, ...savedState };
        }
      } catch (error) {
        console.error("Error loading state, using defaults:", error);
        return defaultState;
      }
    }
    async loadRemoteState() {
      try {
        this.setSyncStatus("pending");
        const result = await this.executeRemoteQuery("SELECT * FROM state:current;");
        const stateObj = result || {};
        delete stateObj.id;
        const seenRecords = await this.executeRemoteQueryAll("SELECT postId, timestamp FROM seen;");
        if (seenRecords && seenRecords.length > 0) {
          stateObj.seen = {};
          for (const record2 of seenRecords) {
            if (record2.postId && record2.timestamp) {
              stateObj.seen[record2.postId] = record2.timestamp;
            }
          }
        }
        const stateSize = (JSON.stringify(stateObj).length / 1024).toFixed(2);
        const seenSize = stateObj.seen ? (JSON.stringify(stateObj.seen).length / 1024).toFixed(2) : "0";
        console.log(`[StateManager] Loaded remote state: ${stateSize} KB total, ${seenSize} KB seen (${seenRecords?.length || 0} entries)`);
        return stateObj;
      } catch (error) {
        console.error("Failed to load remote state:", error);
        return null;
      }
    }
    /**
     * Updates the state and schedules a chained local and remote save.
     */
    updateState(newState) {
      if (newState.seen && this.config.stateSyncEnabled) {
        const oldSeen = this.lastSeenSnapshot || {};
        const newSeen = newState.seen;
        for (const [postId, timestamp] of Object.entries(newSeen)) {
          if (oldSeen[postId] !== timestamp) {
            this.dirtySeenEntries.set(postId, timestamp);
          }
        }
        for (const postId of Object.keys(oldSeen)) {
          if (!(postId in newSeen)) {
            this.dirtySeenEntries.set(postId, null);
          }
        }
        this.lastSeenSnapshot = { ...newSeen };
      }
      this.state = { ...this.state, ...newState };
      this.state.lastUpdated = (/* @__PURE__ */ new Date()).toISOString();
      this.isLocalStateDirty = true;
      this.isRemoteSyncPending = true;
      this.scheduleLocalSave();
    }
    /**
     * Schedules a local state save after a 1-second delay.
     * Triggers remote sync only if local state is saved.
     */
    scheduleLocalSave() {
      clearTimeout(this.localSaveTimeout);
      this.localSaveTimeout = setTimeout(() => {
        const shouldSyncRemote = this.isLocalStateDirty;
        this.saveLocalState().then(() => {
          if (shouldSyncRemote) {
            this.scheduleRemoteSync();
          }
        });
      }, this.config.stateSaveTimeout);
    }
    /**
     * Saves the local state and resolves a promise.
     * @returns {Promise<void>}
     */
    async saveLocalState() {
      this.cleanupState();
      const { listCache, rules, ...serializableState } = this.state;
      const stateJson = JSON.stringify(serializableState);
      GM_setValue(this.key, stateJson);
      this.isLocalStateDirty = false;
      this.notifyListeners();
    }
    /**
     * Schedules a remote state synchronization after a longer delay.
     */
    scheduleRemoteSync() {
      if (!this.config.stateSyncEnabled) {
        return;
      }
      clearTimeout(this.remoteSyncTimeout);
      this.remoteSyncTimeout = setTimeout(() => {
        this.saveRemoteState(this.state.lastUpdated);
      }, this.config.stateSyncTimeout);
    }
    /**
     * Saves the remote state if needed.
     */
    async saveRemoteState(since) {
      try {
        const lastUpdated = await this.getRemoteStateUpdated();
        if (!since || !lastUpdated || new Date(since) < new Date(lastUpdated)) {
          return;
        }
        this.setSyncStatus("pending");
        const { filter, seen, listCache, rules, ...stateToSync } = this.state;
        stateToSync.created_at = (/* @__PURE__ */ new Date()).toISOString();
        const stateJson = JSON.stringify(stateToSync);
        const stateSize = (stateJson.length / 1024).toFixed(2);
        console.log(`[StateManager] Saving remote state: ${stateSize} KB (excluding seen)`);
        await this.executeRemoteQuery(
          `UPSERT state:current CONTENT ${stateJson}`,
          "success"
        );
        this.isRemoteSyncPending = false;
        await this.syncSeenToRemote();
      } catch (error) {
        console.error("Failed to save remote state:", error);
      }
    }
    /**
     * Syncs dirty seen entries to remote as individual records.
     * Each entry is stored as seen:<postId> with timestamp value.
     * Entries with null timestamp are deleted from remote.
     */
    async syncSeenToRemote() {
      if (this.dirtySeenEntries.size === 0) {
        return;
      }
      const entries = Array.from(this.dirtySeenEntries.entries());
      this.dirtySeenEntries.clear();
      const upserts = entries.filter(([, timestamp]) => timestamp != null);
      const deletes = entries.filter(([, timestamp]) => timestamp == null);
      const statements = [];
      for (const [postId, timestamp] of upserts) {
        const safeId = postId.replace(/[^a-zA-Z0-9_-]/g, "_");
        statements.push(`UPSERT seen:${safeId} SET postId = "${postId}", timestamp = "${timestamp}", updated_at = time::now();`);
      }
      for (const [postId] of deletes) {
        const safeId = postId.replace(/[^a-zA-Z0-9_-]/g, "_");
        statements.push(`DELETE seen:${safeId};`);
      }
      if (statements.length === 0) {
        return;
      }
      const query = statements.join(" ");
      const querySize = (query.length / 1024).toFixed(2);
      try {
        await this.executeRemoteQuery(query, "success");
        console.log(`[StateManager] Synced ${upserts.length} seen, deleted ${deletes.length} unseen entries (${querySize} KB)`);
        this.seenSyncCount++;
        if (this.seenSyncCount >= 10) {
          this.seenSyncCount = 0;
          this.cleanupRemoteSeenEntries();
        }
      } catch (error) {
        entries.forEach(([postId, timestamp]) => {
          this.dirtySeenEntries.set(postId, timestamp);
        });
        console.error("Failed to sync seen entries:", error);
      }
    }
    /**
     * Cleans up old seen entries from remote storage.
     * Deletes entries older than maxEntries based on timestamp.
     */
    async cleanupRemoteSeenEntries() {
      if (!this.config.stateSyncEnabled) {
        return;
      }
      try {
        const countResult = await this.executeRemoteQuery("SELECT count() FROM seen GROUP ALL;");
        const count = countResult?.count || 0;
        if (count <= this.maxEntries) {
          console.log(`[StateManager] Remote seen entries: ${count}/${this.maxEntries} (no cleanup needed)`);
          return;
        }
        const toDelete = count - this.maxEntries;
        await this.executeRemoteQuery(
          `DELETE FROM seen ORDER BY timestamp ASC LIMIT ${toDelete};`
        );
        console.log(`[StateManager] Remote cleanup: deleted ${toDelete} old entries (${count} \u2192 ${this.maxEntries})`);
      } catch (error) {
        console.error("Failed to cleanup remote seen entries:", error);
      }
    }
    /**
     * Immediately saves both local and remote states.
     */
    saveStateImmediately(saveLocal = true, saveRemote = false) {
      if (saveLocal) {
        this.saveLocalState();
      }
      if (this.config.stateSyncEnabled && saveRemote) {
        this.saveRemoteState(this.state.lastUpdated);
      }
    }
    /**
     * Saves remote state using fetch with keepalive for page unload scenarios.
     * This method is designed to be called during visibilitychange/pagehide events
     * where GM_xmlhttpRequest may not complete.
     */
    saveRemoteStateSync() {
      if (!this.config.stateSyncEnabled || !this.config.stateSyncConfig) {
        return;
      }
      this.isRemoteSyncPending = false;
      try {
        const {
          url,
          namespace = "bluesky_navigator",
          database = "state",
          username,
          password
        } = JSON.parse(this.config.stateSyncConfig);
        const sqlUrl = `${url.replace(/\/$/, "")}/sql`;
        const headers = {
          "Accept": "application/json",
          "Authorization": "Basic " + btoa(`${username}:${password}`)
        };
        const { filter, seen, listCache, rules, ...stateToSync } = this.state;
        stateToSync.created_at = (/* @__PURE__ */ new Date()).toISOString();
        const stateJson = JSON.stringify(stateToSync);
        const stateQuery = `USE NS ${namespace} DB ${database}; UPSERT state:current CONTENT ${stateJson}`;
        const stateSize = (stateJson.length / 1024).toFixed(2);
        console.log(`[StateManager] Saving remote state on unload: ${stateSize} KB (excluding seen)`);
        fetch(sqlUrl, {
          method: "POST",
          headers,
          body: stateQuery,
          keepalive: true
        }).catch(() => {
        });
        if (this.dirtySeenEntries.size > 0) {
          const entries = Array.from(this.dirtySeenEntries.entries());
          this.dirtySeenEntries.clear();
          const upserts = entries.filter(([, timestamp]) => timestamp != null);
          const deletes = entries.filter(([, timestamp]) => timestamp == null);
          const statements = [];
          for (const [postId, timestamp] of upserts) {
            const safeId = postId.replace(/[^a-zA-Z0-9_-]/g, "_");
            statements.push(`UPSERT seen:${safeId} SET postId = "${postId}", timestamp = "${timestamp}", updated_at = time::now();`);
          }
          for (const [postId] of deletes) {
            const safeId = postId.replace(/[^a-zA-Z0-9_-]/g, "_");
            statements.push(`DELETE seen:${safeId};`);
          }
          if (statements.length > 0) {
            const seenQuery = `USE NS ${namespace} DB ${database}; ${statements.join(" ")}`;
            const seenSize = (statements.join(" ").length / 1024).toFixed(2);
            console.log(`[StateManager] Syncing ${upserts.length} seen, ${deletes.length} unseen on unload (${seenSize} KB)`);
            fetch(sqlUrl, {
              method: "POST",
              headers,
              body: seenQuery,
              keepalive: true
            }).catch(() => {
            });
          }
        }
      } catch (error) {
        console.error("Error preparing remote state save:", error);
      }
    }
    /**
     * Keeps only the most recent N entries in the state.
     */
    cleanupState() {
      if (this.state.seen) {
        this.state.seen = this.keepMostRecentValues(this.state.seen, this.maxEntries);
      }
    }
    /**
     * Utility to keep only the most recent N entries in an object.
     * Assumes values are ISO date strings for sorting.
     * @param {Object} obj - The object to prune.
     * @param {number} maxEntries - The maximum number of entries to retain.
     */
    keepMostRecentValues(obj, maxEntries) {
      const entries = Object.entries(obj);
      entries.sort(([, dateA], [, dateB]) => new Date(dateB) - new Date(dateA));
      return Object.fromEntries(entries.slice(0, maxEntries));
    }
    /**
     * Resets state to the default value.
     * @param {Object} defaultState - The default state object.
     */
    resetState(defaultState = {}) {
      this.state = defaultState;
    }
    /**
     * Registers a listener for state changes.
     * @param {function} callback - The listener function to invoke on state change.
     */
    addListener(callback) {
      if (typeof callback === "function") {
        this.listeners.push(callback);
      }
    }
    /**
     * Notifies all registered listeners of a state change.
     */
    notifyListeners() {
      this.listeners.forEach((callback) => callback(this.state));
    }
    handleBlockListResponse(response, responseKey, stateKey) {
      const jsonResponse = $.parseJSON(response.response);
      try {
        this.state.blocks[stateKey].dids = jsonResponse.data[responseKey].map(
          (entry) => entry.did
        );
        this.state.blocks[stateKey].updated = Date.now();
      } catch (_error) {
        console.warn("[Clearsky] couldn't fetch block list");
      }
    }
    updateBlockList() {
      if (this.config.get && !this.config.get("clearskyEnabled")) return;
      const blockConfig = {
        all: {
          url: "https://api.clearsky.services/api/v1/anon/lists/fun-facts",
          responseKey: "blocked"
        },
        recent: {
          url: "https://api.clearsky.services/api/v1/anon/lists/funer-facts",
          responseKey: "blocked"
        }
      };
      for (const [stateKey, cfg] of Object.entries(blockConfig)) {
        if (this.state.blocks[stateKey].updated == null || Date.now() - this.state.blocks[stateKey].updated > constants.CLEARSKY_LIST_REFRESH_INTERVAL * 1e3) {
          GM_xmlhttpRequest({
            method: "GET",
            url: cfg.url,
            headers: {
              Accept: "application/json"
            },
            onload: (response) => this.handleBlockListResponse(response, cfg.responseKey, stateKey)
          });
        }
      }
    }
  }
  const DEFAULT_STATE = {
    seen: {},
    lastUpdated: null,
    page: "home",
    blocks: { all: [], recent: [] },
    feedSortReverse: false,
    feedHideRead: false,
    timeouts: {}
    // { handle: expiresAtTimestamp }
  };
  let stateManager;
  const target = {
    init(key, config2, onSuccess) {
      StateManager.create(key, DEFAULT_STATE, config2).then((initializedStateManager) => {
        stateManager = initializedStateManager;
        onSuccess();
      }).catch((error) => {
        console.error("Failed to initialize StateManager:", error);
      });
    }
  };
  const state = new Proxy(target, {
    get(target2, prop, receiver) {
      if (prop in target2) {
        return typeof target2[prop] === "function" ? target2[prop].bind(receiver) : target2[prop];
      } else if (prop == "stateManager") {
        return stateManager;
      } else if (prop in stateManager.state) {
        return stateManager.state[prop];
      }
      console.warn(`State Warning: ${prop} is not defined`);
      return void 0;
    },
    set(target2, prop, value) {
      stateManager.state[prop] = value;
      return true;
    }
  });
  function getDefaultExportFromCjs(x) {
    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
  }
  function getAugmentedNamespace(n) {
    if (Object.prototype.hasOwnProperty.call(n, "__esModule")) return n;
    var f = n.default;
    if (typeof f == "function") {
      var a = function a2() {
        if (this instanceof a2) {
          return Reflect.construct(f, arguments, this.constructor);
        }
        return f.apply(this, arguments);
      };
      a.prototype = f.prototype;
    } else a = {};
    Object.defineProperty(a, "__esModule", { value: true });
    Object.keys(n).forEach(function(k) {
      var d = Object.getOwnPropertyDescriptor(n, k);
      Object.defineProperty(a, k, d.get ? d : {
        enumerable: true,
        get: function() {
          return n[k];
        }
      });
    });
    return a;
  }
  var dist$5 = {};
  var dist$4 = {};
  var types$5 = {};
  var lib$1 = {};
  var external$1 = {};
  var errors = {};
  var en = {};
  var util$8 = {};
  var hasRequiredUtil$8;
  function requireUtil$8() {
    if (hasRequiredUtil$8) return util$8;
    hasRequiredUtil$8 = 1;
    (function(exports$1) {
      Object.defineProperty(exports$1, "__esModule", { value: true });
      exports$1.getParsedType = exports$1.ZodParsedType = exports$1.objectUtil = exports$1.util = void 0;
      var util2;
      (function(util3) {
        util3.assertEqual = (val) => val;
        function assertIs(_arg) {
        }
        util3.assertIs = assertIs;
        function assertNever(_x) {
          throw new Error();
        }
        util3.assertNever = assertNever;
        util3.arrayToEnum = (items) => {
          const obj = {};
          for (const item of items) {
            obj[item] = item;
          }
          return obj;
        };
        util3.getValidEnumValues = (obj) => {
          const validKeys = util3.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
          const filtered = {};
          for (const k of validKeys) {
            filtered[k] = obj[k];
          }
          return util3.objectValues(filtered);
        };
        util3.objectValues = (obj) => {
          return util3.objectKeys(obj).map(function(e) {
            return obj[e];
          });
        };
        util3.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
          const keys = [];
          for (const key in object) {
            if (Object.prototype.hasOwnProperty.call(object, key)) {
              keys.push(key);
            }
          }
          return keys;
        };
        util3.find = (arr, checker) => {
          for (const item of arr) {
            if (checker(item))
              return item;
          }
          return void 0;
        };
        util3.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
        function joinValues(array, separator = " | ") {
          return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
        }
        util3.joinValues = joinValues;
        util3.jsonStringifyReplacer = (_, value) => {
          if (typeof value === "bigint") {
            return value.toString();
          }
          return value;
        };
      })(util2 || (exports$1.util = util2 = {}));
      var objectUtil;
      (function(objectUtil2) {
        objectUtil2.mergeShapes = (first, second) => {
          return {
            ...first,
            ...second
            // second overwrites first
          };
        };
      })(objectUtil || (exports$1.objectUtil = objectUtil = {}));
      exports$1.ZodParsedType = util2.arrayToEnum([
        "string",
        "nan",
        "number",
        "integer",
        "float",
        "boolean",
        "date",
        "bigint",
        "symbol",
        "function",
        "undefined",
        "null",
        "array",
        "object",
        "unknown",
        "promise",
        "void",
        "never",
        "map",
        "set"
      ]);
      const getParsedType = (data) => {
        const t = typeof data;
        switch (t) {
          case "undefined":
            return exports$1.ZodParsedType.undefined;
          case "string":
            return exports$1.ZodParsedType.string;
          case "number":
            return isNaN(data) ? exports$1.ZodParsedType.nan : exports$1.ZodParsedType.number;
          case "boolean":
            return exports$1.ZodParsedType.boolean;
          case "function":
            return exports$1.ZodParsedType.function;
          case "bigint":
            return exports$1.ZodParsedType.bigint;
          case "symbol":
            return exports$1.ZodParsedType.symbol;
          case "object":
            if (Array.isArray(data)) {
              return exports$1.ZodParsedType.array;
            }
            if (data === null) {
              return exports$1.ZodParsedType.null;
            }
            if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
              return exports$1.ZodParsedType.promise;
            }
            if (typeof Map !== "undefined" && data instanceof Map) {
              return exports$1.ZodParsedType.map;
            }
            if (typeof Set !== "undefined" && data instanceof Set) {
              return exports$1.ZodParsedType.set;
            }
            if (typeof Date !== "undefined" && data instanceof Date) {
              return exports$1.ZodParsedType.date;
            }
            return exports$1.ZodParsedType.object;
          default:
            return exports$1.ZodParsedType.unknown;
        }
      };
      exports$1.getParsedType = getParsedType;
    })(util$8);
    return util$8;
  }
  var ZodError = {};
  var hasRequiredZodError;
  function requireZodError() {
    if (hasRequiredZodError) return ZodError;
    hasRequiredZodError = 1;
    Object.defineProperty(ZodError, "__esModule", { value: true });
    ZodError.ZodError = ZodError.quotelessJson = ZodError.ZodIssueCode = void 0;
    const util_1 = /* @__PURE__ */ requireUtil$8();
    ZodError.ZodIssueCode = util_1.util.arrayToEnum([
      "invalid_type",
      "invalid_literal",
      "custom",
      "invalid_union",
      "invalid_union_discriminator",
      "invalid_enum_value",
      "unrecognized_keys",
      "invalid_arguments",
      "invalid_return_type",
      "invalid_date",
      "invalid_string",
      "too_small",
      "too_big",
      "invalid_intersection_types",
      "not_multiple_of",
      "not_finite"
    ]);
    const quotelessJson = (obj) => {
      const json = JSON.stringify(obj, null, 2);
      return json.replace(/"([^"]+)":/g, "$1:");
    };
    ZodError.quotelessJson = quotelessJson;
    let ZodError$1 = class ZodError2 extends Error {
      get errors() {
        return this.issues;
      }
      constructor(issues) {
        super();
        this.issues = [];
        this.addIssue = (sub) => {
          this.issues = [...this.issues, sub];
        };
        this.addIssues = (subs = []) => {
          this.issues = [...this.issues, ...subs];
        };
        const actualProto = new.target.prototype;
        if (Object.setPrototypeOf) {
          Object.setPrototypeOf(this, actualProto);
        } else {
          this.__proto__ = actualProto;
        }
        this.name = "ZodError";
        this.issues = issues;
      }
      format(_mapper) {
        const mapper = _mapper || function(issue) {
          return issue.message;
        };
        const fieldErrors = { _errors: [] };
        const processError = (error) => {
          for (const issue of error.issues) {
            if (issue.code === "invalid_union") {
              issue.unionErrors.map(processError);
            } else if (issue.code === "invalid_return_type") {
              processError(issue.returnTypeError);
            } else if (issue.code === "invalid_arguments") {
              processError(issue.argumentsError);
            } else if (issue.path.length === 0) {
              fieldErrors._errors.push(mapper(issue));
            } else {
              let curr = fieldErrors;
              let i = 0;
              while (i < issue.path.length) {
                const el = issue.path[i];
                const terminal = i === issue.path.length - 1;
                if (!terminal) {
                  curr[el] = curr[el] || { _errors: [] };
                } else {
                  curr[el] = curr[el] || { _errors: [] };
                  curr[el]._errors.push(mapper(issue));
                }
                curr = curr[el];
                i++;
              }
            }
          }
        };
        processError(this);
        return fieldErrors;
      }
      static assert(value) {
        if (!(value instanceof ZodError2)) {
          throw new Error(`Not a ZodError: ${value}`);
        }
      }
      toString() {
        return this.message;
      }
      get message() {
        return JSON.stringify(this.issues, util_1.util.jsonStringifyReplacer, 2);
      }
      get isEmpty() {
        return this.issues.length === 0;
      }
      flatten(mapper = (issue) => issue.message) {
        const fieldErrors = {};
        const formErrors = [];
        for (const sub of this.issues) {
          if (sub.path.length > 0) {
            fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
            fieldErrors[sub.path[0]].push(mapper(sub));
          } else {
            formErrors.push(mapper(sub));
          }
        }
        return { formErrors, fieldErrors };
      }
      get formErrors() {
        return this.flatten();
      }
    };
    ZodError.ZodError = ZodError$1;
    ZodError$1.create = (issues) => {
      const error = new ZodError$1(issues);
      return error;
    };
    return ZodError;
  }
  var hasRequiredEn;
  function requireEn() {
    if (hasRequiredEn) return en;
    hasRequiredEn = 1;
    Object.defineProperty(en, "__esModule", { value: true });
    const util_1 = /* @__PURE__ */ requireUtil$8();
    const ZodError_1 = /* @__PURE__ */ requireZodError();
    const errorMap = (issue, _ctx) => {
      let message2;
      switch (issue.code) {
        case ZodError_1.ZodIssueCode.invalid_type:
          if (issue.received === util_1.ZodParsedType.undefined) {
            message2 = "Required";
          } else {
            message2 = `Expected ${issue.expected}, received ${issue.received}`;
          }
          break;
        case ZodError_1.ZodIssueCode.invalid_literal:
          message2 = `Invalid literal value, expected ${JSON.stringify(issue.expected, util_1.util.jsonStringifyReplacer)}`;
          break;
        case ZodError_1.ZodIssueCode.unrecognized_keys:
          message2 = `Unrecognized key(s) in object: ${util_1.util.joinValues(issue.keys, ", ")}`;
          break;
        case ZodError_1.ZodIssueCode.invalid_union:
          message2 = `Invalid input`;
          break;
        case ZodError_1.ZodIssueCode.invalid_union_discriminator:
          message2 = `Invalid discriminator value. Expected ${util_1.util.joinValues(issue.options)}`;
          break;
        case ZodError_1.ZodIssueCode.invalid_enum_value:
          message2 = `Invalid enum value. Expected ${util_1.util.joinValues(issue.options)}, received '${issue.received}'`;
          break;
        case ZodError_1.ZodIssueCode.invalid_arguments:
          message2 = `Invalid function arguments`;
          break;
        case ZodError_1.ZodIssueCode.invalid_return_type:
          message2 = `Invalid function return type`;
          break;
        case ZodError_1.ZodIssueCode.invalid_date:
          message2 = `Invalid date`;
          break;
        case ZodError_1.ZodIssueCode.invalid_string:
          if (typeof issue.validation === "object") {
            if ("includes" in issue.validation) {
              message2 = `Invalid input: must include "${issue.validation.includes}"`;
              if (typeof issue.validation.position === "number") {
                message2 = `${message2} at one or more positions greater than or equal to ${issue.validation.position}`;
              }
            } else if ("startsWith" in issue.validation) {
              message2 = `Invalid input: must start with "${issue.validation.startsWith}"`;
            } else if ("endsWith" in issue.validation) {
              message2 = `Invalid input: must end with "${issue.validation.endsWith}"`;
            } else {
              util_1.util.assertNever(issue.validation);
            }
          } else if (issue.validation !== "regex") {
            message2 = `Invalid ${issue.validation}`;
          } else {
            message2 = "Invalid";
          }
          break;
        case ZodError_1.ZodIssueCode.too_small:
          if (issue.type === "array")
            message2 = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
          else if (issue.type === "string")
            message2 = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
          else if (issue.type === "number")
            message2 = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
          else if (issue.type === "date")
            message2 = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
          else
            message2 = "Invalid input";
          break;
        case ZodError_1.ZodIssueCode.too_big:
          if (issue.type === "array")
            message2 = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
          else if (issue.type === "string")
            message2 = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
          else if (issue.type === "number")
            message2 = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
          else if (issue.type === "bigint")
            message2 = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
          else if (issue.type === "date")
            message2 = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
          else
            message2 = "Invalid input";
          break;
        case ZodError_1.ZodIssueCode.custom:
          message2 = `Invalid input`;
          break;
        case ZodError_1.ZodIssueCode.invalid_intersection_types:
          message2 = `Intersection results could not be merged`;
          break;
        case ZodError_1.ZodIssueCode.not_multiple_of:
          message2 = `Number must be a multiple of ${issue.multipleOf}`;
          break;
        case ZodError_1.ZodIssueCode.not_finite:
          message2 = "Number must be finite";
          break;
        default:
          message2 = _ctx.defaultError;
          util_1.util.assertNever(issue);
      }
      return { message: message2 };
    };
    en.default = errorMap;
    return en;
  }
  var hasRequiredErrors;
  function requireErrors() {
    if (hasRequiredErrors) return errors;
    hasRequiredErrors = 1;
    var __importDefault = errors && errors.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(errors, "__esModule", { value: true });
    errors.getErrorMap = errors.setErrorMap = errors.defaultErrorMap = void 0;
    const en_1 = __importDefault(/* @__PURE__ */ requireEn());
    errors.defaultErrorMap = en_1.default;
    let overrideErrorMap = en_1.default;
    function setErrorMap(map) {
      overrideErrorMap = map;
    }
    errors.setErrorMap = setErrorMap;
    function getErrorMap() {
      return overrideErrorMap;
    }
    errors.getErrorMap = getErrorMap;
    return errors;
  }
  var parseUtil = {};
  var hasRequiredParseUtil;
  function requireParseUtil() {
    if (hasRequiredParseUtil) return parseUtil;
    hasRequiredParseUtil = 1;
    (function(exports$1) {
      var __importDefault = parseUtil && parseUtil.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports$1, "__esModule", { value: true });
      exports$1.isAsync = exports$1.isValid = exports$1.isDirty = exports$1.isAborted = exports$1.OK = exports$1.DIRTY = exports$1.INVALID = exports$1.ParseStatus = exports$1.addIssueToContext = exports$1.EMPTY_PATH = exports$1.makeIssue = void 0;
      const errors_1 = /* @__PURE__ */ requireErrors();
      const en_1 = __importDefault(/* @__PURE__ */ requireEn());
      const makeIssue = (params) => {
        const { data, path, errorMaps, issueData } = params;
        const fullPath = [...path, ...issueData.path || []];
        const fullIssue = {
          ...issueData,
          path: fullPath
        };
        if (issueData.message !== void 0) {
          return {
            ...issueData,
            path: fullPath,
            message: issueData.message
          };
        }
        let errorMessage = "";
        const maps = errorMaps.filter((m) => !!m).slice().reverse();
        for (const map of maps) {
          errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
        }
        return {
          ...issueData,
          path: fullPath,
          message: errorMessage
        };
      };
      exports$1.makeIssue = makeIssue;
      exports$1.EMPTY_PATH = [];
      function addIssueToContext(ctx, issueData) {
        const overrideMap = (0, errors_1.getErrorMap)();
        const issue = (0, exports$1.makeIssue)({
          issueData,
          data: ctx.data,
          path: ctx.path,
          errorMaps: [
            ctx.common.contextualErrorMap,
            // contextual error map is first priority
            ctx.schemaErrorMap,
            // then schema-bound map if available
            overrideMap,
            // then global override map
            overrideMap === en_1.default ? void 0 : en_1.default
            // then global default map
          ].filter((x) => !!x)
        });
        ctx.common.issues.push(issue);
      }
      exports$1.addIssueToContext = addIssueToContext;
      class ParseStatus {
        constructor() {
          this.value = "valid";
        }
        dirty() {
          if (this.value === "valid")
            this.value = "dirty";
        }
        abort() {
          if (this.value !== "aborted")
            this.value = "aborted";
        }
        static mergeArray(status, results) {
          const arrayValue = [];
          for (const s of results) {
            if (s.status === "aborted")
              return exports$1.INVALID;
            if (s.status === "dirty")
              status.dirty();
            arrayValue.push(s.value);
          }
          return { status: status.value, value: arrayValue };
        }
        static async mergeObjectAsync(status, pairs) {
          const syncPairs = [];
          for (const pair of pairs) {
            const key = await pair.key;
            const value = await pair.value;
            syncPairs.push({
              key,
              value
            });
          }
          return ParseStatus.mergeObjectSync(status, syncPairs);
        }
        static mergeObjectSync(status, pairs) {
          const finalObject = {};
          for (const pair of pairs) {
            const { key, value } = pair;
            if (key.status === "aborted")
              return exports$1.INVALID;
            if (value.status === "aborted")
              return exports$1.INVALID;
            if (key.status === "dirty")
              status.dirty();
            if (value.status === "dirty")
              status.dirty();
            if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
              finalObject[key.value] = value.value;
            }
          }
          return { status: status.value, value: finalObject };
        }
      }
      exports$1.ParseStatus = ParseStatus;
      exports$1.INVALID = Object.freeze({
        status: "aborted"
      });
      const DIRTY = (value) => ({ status: "dirty", value });
      exports$1.DIRTY = DIRTY;
      const OK = (value) => ({ status: "valid", value });
      exports$1.OK = OK;
      const isAborted = (x) => x.status === "aborted";
      exports$1.isAborted = isAborted;
      const isDirty = (x) => x.status === "dirty";
      exports$1.isDirty = isDirty;
      const isValid2 = (x) => x.status === "valid";
      exports$1.isValid = isValid2;
      const isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
      exports$1.isAsync = isAsync;
    })(parseUtil);
    return parseUtil;
  }
  var typeAliases = {};
  var hasRequiredTypeAliases;
  function requireTypeAliases() {
    if (hasRequiredTypeAliases) return typeAliases;
    hasRequiredTypeAliases = 1;
    Object.defineProperty(typeAliases, "__esModule", { value: true });
    return typeAliases;
  }
  var types$4 = {};
  var errorUtil = {};
  var hasRequiredErrorUtil;
  function requireErrorUtil() {
    if (hasRequiredErrorUtil) return errorUtil;
    hasRequiredErrorUtil = 1;
    Object.defineProperty(errorUtil, "__esModule", { value: true });
    errorUtil.errorUtil = void 0;
    var errorUtil$1;
    (function(errorUtil2) {
      errorUtil2.errToObj = (message2) => typeof message2 === "string" ? { message: message2 } : message2 || {};
      errorUtil2.toString = (message2) => typeof message2 === "string" ? message2 : message2 === null || message2 === void 0 ? void 0 : message2.message;
    })(errorUtil$1 || (errorUtil.errorUtil = errorUtil$1 = {}));
    return errorUtil;
  }
  var hasRequiredTypes$5;
  function requireTypes$5() {
    if (hasRequiredTypes$5) return types$4;
    hasRequiredTypes$5 = 1;
    var __classPrivateFieldGet = types$4 && types$4.__classPrivateFieldGet || function(receiver, state2, kind, f) {
      if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
      if (typeof state2 === "function" ? receiver !== state2 || !f : !state2.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state2.get(receiver);
    };
    var __classPrivateFieldSet = types$4 && types$4.__classPrivateFieldSet || function(receiver, state2, value, kind, f) {
      if (kind === "m") throw new TypeError("Private method is not writable");
      if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
      if (typeof state2 === "function" ? receiver !== state2 || !f : !state2.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state2.set(receiver, value), value;
    };
    var _ZodEnum_cache, _ZodNativeEnum_cache;
    Object.defineProperty(types$4, "__esModule", { value: true });
    types$4.boolean = types$4.bigint = types$4.array = types$4.any = types$4.coerce = types$4.ZodFirstPartyTypeKind = types$4.late = types$4.ZodSchema = types$4.Schema = types$4.custom = types$4.ZodReadonly = types$4.ZodPipeline = types$4.ZodBranded = types$4.BRAND = types$4.ZodNaN = types$4.ZodCatch = types$4.ZodDefault = types$4.ZodNullable = types$4.ZodOptional = types$4.ZodTransformer = types$4.ZodEffects = types$4.ZodPromise = types$4.ZodNativeEnum = types$4.ZodEnum = types$4.ZodLiteral = types$4.ZodLazy = types$4.ZodFunction = types$4.ZodSet = types$4.ZodMap = types$4.ZodRecord = types$4.ZodTuple = types$4.ZodIntersection = types$4.ZodDiscriminatedUnion = types$4.ZodUnion = types$4.ZodObject = types$4.ZodArray = types$4.ZodVoid = types$4.ZodNever = types$4.ZodUnknown = types$4.ZodAny = types$4.ZodNull = types$4.ZodUndefined = types$4.ZodSymbol = types$4.ZodDate = types$4.ZodBoolean = types$4.ZodBigInt = types$4.ZodNumber = types$4.ZodString = types$4.datetimeRegex = types$4.ZodType = void 0;
    types$4.NEVER = types$4.void = types$4.unknown = types$4.union = types$4.undefined = types$4.tuple = types$4.transformer = types$4.symbol = types$4.string = types$4.strictObject = types$4.set = types$4.record = types$4.promise = types$4.preprocess = types$4.pipeline = types$4.ostring = types$4.optional = types$4.onumber = types$4.oboolean = types$4.object = types$4.number = types$4.nullable = types$4.null = types$4.never = types$4.nativeEnum = types$4.nan = types$4.map = types$4.literal = types$4.lazy = types$4.intersection = types$4.instanceof = types$4.function = types$4.enum = types$4.effect = types$4.discriminatedUnion = types$4.date = void 0;
    const errors_1 = /* @__PURE__ */ requireErrors();
    const errorUtil_1 = /* @__PURE__ */ requireErrorUtil();
    const parseUtil_1 = /* @__PURE__ */ requireParseUtil();
    const util_1 = /* @__PURE__ */ requireUtil$8();
    const ZodError_1 = /* @__PURE__ */ requireZodError();
    class ParseInputLazyPath {
      constructor(parent, value, path, key) {
        this._cachedPath = [];
        this.parent = parent;
        this.data = value;
        this._path = path;
        this._key = key;
      }
      get path() {
        if (!this._cachedPath.length) {
          if (this._key instanceof Array) {
            this._cachedPath.push(...this._path, ...this._key);
          } else {
            this._cachedPath.push(...this._path, this._key);
          }
        }
        return this._cachedPath;
      }
    }
    const handleResult = (ctx, result) => {
      if ((0, parseUtil_1.isValid)(result)) {
        return { success: true, data: result.value };
      } else {
        if (!ctx.common.issues.length) {
          throw new Error("Validation failed but no issues detected.");
        }
        return {
          success: false,
          get error() {
            if (this._error)
              return this._error;
            const error = new ZodError_1.ZodError(ctx.common.issues);
            this._error = error;
            return this._error;
          }
        };
      }
    };
    function processCreateParams(params) {
      if (!params)
        return {};
      const { errorMap, invalid_type_error, required_error, description } = params;
      if (errorMap && (invalid_type_error || required_error)) {
        throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
      }
      if (errorMap)
        return { errorMap, description };
      const customMap = (iss, ctx) => {
        var _a, _b;
        const { message: message2 } = params;
        if (iss.code === "invalid_enum_value") {
          return { message: message2 !== null && message2 !== void 0 ? message2 : ctx.defaultError };
        }
        if (typeof ctx.data === "undefined") {
          return { message: (_a = message2 !== null && message2 !== void 0 ? message2 : required_error) !== null && _a !== void 0 ? _a : ctx.defaultError };
        }
        if (iss.code !== "invalid_type")
          return { message: ctx.defaultError };
        return { message: (_b = message2 !== null && message2 !== void 0 ? message2 : invalid_type_error) !== null && _b !== void 0 ? _b : ctx.defaultError };
      };
      return { errorMap: customMap, description };
    }
    class ZodType {
      get description() {
        return this._def.description;
      }
      _getType(input) {
        return (0, util_1.getParsedType)(input.data);
      }
      _getOrReturnCtx(input, ctx) {
        return ctx || {
          common: input.parent.common,
          data: input.data,
          parsedType: (0, util_1.getParsedType)(input.data),
          schemaErrorMap: this._def.errorMap,
          path: input.path,
          parent: input.parent
        };
      }
      _processInputParams(input) {
        return {
          status: new parseUtil_1.ParseStatus(),
          ctx: {
            common: input.parent.common,
            data: input.data,
            parsedType: (0, util_1.getParsedType)(input.data),
            schemaErrorMap: this._def.errorMap,
            path: input.path,
            parent: input.parent
          }
        };
      }
      _parseSync(input) {
        const result = this._parse(input);
        if ((0, parseUtil_1.isAsync)(result)) {
          throw new Error("Synchronous parse encountered promise.");
        }
        return result;
      }
      _parseAsync(input) {
        const result = this._parse(input);
        return Promise.resolve(result);
      }
      parse(data, params) {
        const result = this.safeParse(data, params);
        if (result.success)
          return result.data;
        throw result.error;
      }
      safeParse(data, params) {
        var _a;
        const ctx = {
          common: {
            issues: [],
            async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
            contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
          },
          path: (params === null || params === void 0 ? void 0 : params.path) || [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data,
          parsedType: (0, util_1.getParsedType)(data)
        };
        const result = this._parseSync({ data, path: ctx.path, parent: ctx });
        return handleResult(ctx, result);
      }
      "~validate"(data) {
        var _a, _b;
        const ctx = {
          common: {
            issues: [],
            async: !!this["~standard"].async
          },
          path: [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data,
          parsedType: (0, util_1.getParsedType)(data)
        };
        if (!this["~standard"].async) {
          try {
            const result = this._parseSync({ data, path: [], parent: ctx });
            return (0, parseUtil_1.isValid)(result) ? {
              value: result.value
            } : {
              issues: ctx.common.issues
            };
          } catch (err) {
            if ((_b = (_a = err === null || err === void 0 ? void 0 : err.message) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === null || _b === void 0 ? void 0 : _b.includes("encountered")) {
              this["~standard"].async = true;
            }
            ctx.common = {
              issues: [],
              async: true
            };
          }
        }
        return this._parseAsync({ data, path: [], parent: ctx }).then((result) => (0, parseUtil_1.isValid)(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        });
      }
      async parseAsync(data, params) {
        const result = await this.safeParseAsync(data, params);
        if (result.success)
          return result.data;
        throw result.error;
      }
      async safeParseAsync(data, params) {
        const ctx = {
          common: {
            issues: [],
            contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
            async: true
          },
          path: (params === null || params === void 0 ? void 0 : params.path) || [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data,
          parsedType: (0, util_1.getParsedType)(data)
        };
        const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
        const result = await ((0, parseUtil_1.isAsync)(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
        return handleResult(ctx, result);
      }
      refine(check2, message2) {
        const getIssueProperties = (val) => {
          if (typeof message2 === "string" || typeof message2 === "undefined") {
            return { message: message2 };
          } else if (typeof message2 === "function") {
            return message2(val);
          } else {
            return message2;
          }
        };
        return this._refinement((val, ctx) => {
          const result = check2(val);
          const setError = () => ctx.addIssue({
            code: ZodError_1.ZodIssueCode.custom,
            ...getIssueProperties(val)
          });
          if (typeof Promise !== "undefined" && result instanceof Promise) {
            return result.then((data) => {
              if (!data) {
                setError();
                return false;
              } else {
                return true;
              }
            });
          }
          if (!result) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      refinement(check2, refinementData) {
        return this._refinement((val, ctx) => {
          if (!check2(val)) {
            ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
            return false;
          } else {
            return true;
          }
        });
      }
      _refinement(refinement) {
        return new ZodEffects({
          schema: this,
          typeName: ZodFirstPartyTypeKind.ZodEffects,
          effect: { type: "refinement", refinement }
        });
      }
      superRefine(refinement) {
        return this._refinement(refinement);
      }
      constructor(def) {
        this.spa = this.safeParseAsync;
        this._def = def;
        this.parse = this.parse.bind(this);
        this.safeParse = this.safeParse.bind(this);
        this.parseAsync = this.parseAsync.bind(this);
        this.safeParseAsync = this.safeParseAsync.bind(this);
        this.spa = this.spa.bind(this);
        this.refine = this.refine.bind(this);
        this.refinement = this.refinement.bind(this);
        this.superRefine = this.superRefine.bind(this);
        this.optional = this.optional.bind(this);
        this.nullable = this.nullable.bind(this);
        this.nullish = this.nullish.bind(this);
        this.array = this.array.bind(this);
        this.promise = this.promise.bind(this);
        this.or = this.or.bind(this);
        this.and = this.and.bind(this);
        this.transform = this.transform.bind(this);
        this.brand = this.brand.bind(this);
        this.default = this.default.bind(this);
        this.catch = this.catch.bind(this);
        this.describe = this.describe.bind(this);
        this.pipe = this.pipe.bind(this);
        this.readonly = this.readonly.bind(this);
        this.isNullable = this.isNullable.bind(this);
        this.isOptional = this.isOptional.bind(this);
        this["~standard"] = {
          version: 1,
          vendor: "zod",
          validate: (data) => this["~validate"](data)
        };
      }
      optional() {
        return ZodOptional.create(this, this._def);
      }
      nullable() {
        return ZodNullable.create(this, this._def);
      }
      nullish() {
        return this.nullable().optional();
      }
      array() {
        return ZodArray.create(this);
      }
      promise() {
        return ZodPromise.create(this, this._def);
      }
      or(option) {
        return ZodUnion.create([this, option], this._def);
      }
      and(incoming) {
        return ZodIntersection.create(this, incoming, this._def);
      }
      transform(transform) {
        return new ZodEffects({
          ...processCreateParams(this._def),
          schema: this,
          typeName: ZodFirstPartyTypeKind.ZodEffects,
          effect: { type: "transform", transform }
        });
      }
      default(def) {
        const defaultValueFunc = typeof def === "function" ? def : () => def;
        return new ZodDefault({
          ...processCreateParams(this._def),
          innerType: this,
          defaultValue: defaultValueFunc,
          typeName: ZodFirstPartyTypeKind.ZodDefault
        });
      }
      brand() {
        return new ZodBranded({
          typeName: ZodFirstPartyTypeKind.ZodBranded,
          type: this,
          ...processCreateParams(this._def)
        });
      }
      catch(def) {
        const catchValueFunc = typeof def === "function" ? def : () => def;
        return new ZodCatch({
          ...processCreateParams(this._def),
          innerType: this,
          catchValue: catchValueFunc,
          typeName: ZodFirstPartyTypeKind.ZodCatch
        });
      }
      describe(description) {
        const This = this.constructor;
        return new This({
          ...this._def,
          description
        });
      }
      pipe(target2) {
        return ZodPipeline.create(this, target2);
      }
      readonly() {
        return ZodReadonly.create(this);
      }
      isOptional() {
        return this.safeParse(void 0).success;
      }
      isNullable() {
        return this.safeParse(null).success;
      }
    }
    types$4.ZodType = ZodType;
    types$4.Schema = ZodType;
    types$4.ZodSchema = ZodType;
    const cuidRegex = /^c[^\s-]{8,}$/i;
    const cuid2Regex = /^[0-9a-z]+$/;
    const ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
    const uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
    const nanoidRegex = /^[a-z0-9_-]{21}$/i;
    const jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
    const durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
    const emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
    const _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
    let emojiRegex;
    const ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
    const ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
    const ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
    const ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
    const base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
    const base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
    const dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
    const dateRegex = new RegExp(`^${dateRegexSource}$`);
    function timeRegexSource(args) {
      let regex = `([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d`;
      if (args.precision) {
        regex = `${regex}\\.\\d{${args.precision}}`;
      } else if (args.precision == null) {
        regex = `${regex}(\\.\\d+)?`;
      }
      return regex;
    }
    function timeRegex(args) {
      return new RegExp(`^${timeRegexSource(args)}$`);
    }
    function datetimeRegex(args) {
      let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
      const opts = [];
      opts.push(args.local ? `Z?` : `Z`);
      if (args.offset)
        opts.push(`([+-]\\d{2}:?\\d{2})`);
      regex = `${regex}(${opts.join("|")})`;
      return new RegExp(`^${regex}$`);
    }
    types$4.datetimeRegex = datetimeRegex;
    function isValidIP(ip, version2) {
      if ((version2 === "v4" || !version2) && ipv4Regex.test(ip)) {
        return true;
      }
      if ((version2 === "v6" || !version2) && ipv6Regex.test(ip)) {
        return true;
      }
      return false;
    }
    function isValidJWT(jwt, alg) {
      if (!jwtRegex.test(jwt))
        return false;
      try {
        const [header] = jwt.split(".");
        const base642 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
        const decoded = JSON.parse(atob(base642));
        if (typeof decoded !== "object" || decoded === null)
          return false;
        if (!decoded.typ || !decoded.alg)
          return false;
        if (alg && decoded.alg !== alg)
          return false;
        return true;
      } catch (_a) {
        return false;
      }
    }
    function isValidCidr(ip, version2) {
      if ((version2 === "v4" || !version2) && ipv4CidrRegex.test(ip)) {
        return true;
      }
      if ((version2 === "v6" || !version2) && ipv6CidrRegex.test(ip)) {
        return true;
      }
      return false;
    }
    class ZodString extends ZodType {
      _parse(input) {
        if (this._def.coerce) {
          input.data = String(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.string) {
          const ctx2 = this._getOrReturnCtx(input);
          (0, parseUtil_1.addIssueToContext)(ctx2, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.string,
            received: ctx2.parsedType
          });
          return parseUtil_1.INVALID;
        }
        const status = new parseUtil_1.ParseStatus();
        let ctx = void 0;
        for (const check2 of this._def.checks) {
          if (check2.kind === "min") {
            if (input.data.length < check2.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.too_small,
                minimum: check2.value,
                type: "string",
                inclusive: true,
                exact: false,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "max") {
            if (input.data.length > check2.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.too_big,
                maximum: check2.value,
                type: "string",
                inclusive: true,
                exact: false,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "length") {
            const tooBig = input.data.length > check2.value;
            const tooSmall = input.data.length < check2.value;
            if (tooBig || tooSmall) {
              ctx = this._getOrReturnCtx(input, ctx);
              if (tooBig) {
                (0, parseUtil_1.addIssueToContext)(ctx, {
                  code: ZodError_1.ZodIssueCode.too_big,
                  maximum: check2.value,
                  type: "string",
                  inclusive: true,
                  exact: true,
                  message: check2.message
                });
              } else if (tooSmall) {
                (0, parseUtil_1.addIssueToContext)(ctx, {
                  code: ZodError_1.ZodIssueCode.too_small,
                  minimum: check2.value,
                  type: "string",
                  inclusive: true,
                  exact: true,
                  message: check2.message
                });
              }
              status.dirty();
            }
          } else if (check2.kind === "email") {
            if (!emailRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                validation: "email",
                code: ZodError_1.ZodIssueCode.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "emoji") {
            if (!emojiRegex) {
              emojiRegex = new RegExp(_emojiRegex, "u");
            }
            if (!emojiRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                validation: "emoji",
                code: ZodError_1.ZodIssueCode.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "uuid") {
            if (!uuidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                validation: "uuid",
                code: ZodError_1.ZodIssueCode.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "nanoid") {
            if (!nanoidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                validation: "nanoid",
                code: ZodError_1.ZodIssueCode.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "cuid") {
            if (!cuidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                validation: "cuid",
                code: ZodError_1.ZodIssueCode.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "cuid2") {
            if (!cuid2Regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                validation: "cuid2",
                code: ZodError_1.ZodIssueCode.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "ulid") {
            if (!ulidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                validation: "ulid",
                code: ZodError_1.ZodIssueCode.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "url") {
            try {
              new URL(input.data);
            } catch (_a) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                validation: "url",
                code: ZodError_1.ZodIssueCode.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "regex") {
            check2.regex.lastIndex = 0;
            const testResult = check2.regex.test(input.data);
            if (!testResult) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                validation: "regex",
                code: ZodError_1.ZodIssueCode.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "trim") {
            input.data = input.data.trim();
          } else if (check2.kind === "includes") {
            if (!input.data.includes(check2.value, check2.position)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_string,
                validation: { includes: check2.value, position: check2.position },
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "toLowerCase") {
            input.data = input.data.toLowerCase();
          } else if (check2.kind === "toUpperCase") {
            input.data = input.data.toUpperCase();
          } else if (check2.kind === "startsWith") {
            if (!input.data.startsWith(check2.value)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_string,
                validation: { startsWith: check2.value },
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "endsWith") {
            if (!input.data.endsWith(check2.value)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_string,
                validation: { endsWith: check2.value },
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "datetime") {
            const regex = datetimeRegex(check2);
            if (!regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_string,
                validation: "datetime",
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "date") {
            const regex = dateRegex;
            if (!regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_string,
                validation: "date",
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "time") {
            const regex = timeRegex(check2);
            if (!regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_string,
                validation: "time",
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "duration") {
            if (!durationRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                validation: "duration",
                code: ZodError_1.ZodIssueCode.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "ip") {
            if (!isValidIP(input.data, check2.version)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                validation: "ip",
                code: ZodError_1.ZodIssueCode.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "jwt") {
            if (!isValidJWT(input.data, check2.alg)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                validation: "jwt",
                code: ZodError_1.ZodIssueCode.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "cidr") {
            if (!isValidCidr(input.data, check2.version)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                validation: "cidr",
                code: ZodError_1.ZodIssueCode.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "base64") {
            if (!base64Regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                validation: "base64",
                code: ZodError_1.ZodIssueCode.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "base64url") {
            if (!base64urlRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                validation: "base64url",
                code: ZodError_1.ZodIssueCode.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else {
            util_1.util.assertNever(check2);
          }
        }
        return { status: status.value, value: input.data };
      }
      _regex(regex, validation2, message2) {
        return this.refinement((data) => regex.test(data), {
          validation: validation2,
          code: ZodError_1.ZodIssueCode.invalid_string,
          ...errorUtil_1.errorUtil.errToObj(message2)
        });
      }
      _addCheck(check2) {
        return new ZodString({
          ...this._def,
          checks: [...this._def.checks, check2]
        });
      }
      email(message2) {
        return this._addCheck({ kind: "email", ...errorUtil_1.errorUtil.errToObj(message2) });
      }
      url(message2) {
        return this._addCheck({ kind: "url", ...errorUtil_1.errorUtil.errToObj(message2) });
      }
      emoji(message2) {
        return this._addCheck({ kind: "emoji", ...errorUtil_1.errorUtil.errToObj(message2) });
      }
      uuid(message2) {
        return this._addCheck({ kind: "uuid", ...errorUtil_1.errorUtil.errToObj(message2) });
      }
      nanoid(message2) {
        return this._addCheck({ kind: "nanoid", ...errorUtil_1.errorUtil.errToObj(message2) });
      }
      cuid(message2) {
        return this._addCheck({ kind: "cuid", ...errorUtil_1.errorUtil.errToObj(message2) });
      }
      cuid2(message2) {
        return this._addCheck({ kind: "cuid2", ...errorUtil_1.errorUtil.errToObj(message2) });
      }
      ulid(message2) {
        return this._addCheck({ kind: "ulid", ...errorUtil_1.errorUtil.errToObj(message2) });
      }
      base64(message2) {
        return this._addCheck({ kind: "base64", ...errorUtil_1.errorUtil.errToObj(message2) });
      }
      base64url(message2) {
        return this._addCheck({
          kind: "base64url",
          ...errorUtil_1.errorUtil.errToObj(message2)
        });
      }
      jwt(options) {
        return this._addCheck({ kind: "jwt", ...errorUtil_1.errorUtil.errToObj(options) });
      }
      ip(options) {
        return this._addCheck({ kind: "ip", ...errorUtil_1.errorUtil.errToObj(options) });
      }
      cidr(options) {
        return this._addCheck({ kind: "cidr", ...errorUtil_1.errorUtil.errToObj(options) });
      }
      datetime(options) {
        var _a, _b;
        if (typeof options === "string") {
          return this._addCheck({
            kind: "datetime",
            precision: null,
            offset: false,
            local: false,
            message: options
          });
        }
        return this._addCheck({
          kind: "datetime",
          precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
          offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,
          local: (_b = options === null || options === void 0 ? void 0 : options.local) !== null && _b !== void 0 ? _b : false,
          ...errorUtil_1.errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
        });
      }
      date(message2) {
        return this._addCheck({ kind: "date", message: message2 });
      }
      time(options) {
        if (typeof options === "string") {
          return this._addCheck({
            kind: "time",
            precision: null,
            message: options
          });
        }
        return this._addCheck({
          kind: "time",
          precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
          ...errorUtil_1.errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
        });
      }
      duration(message2) {
        return this._addCheck({ kind: "duration", ...errorUtil_1.errorUtil.errToObj(message2) });
      }
      regex(regex, message2) {
        return this._addCheck({
          kind: "regex",
          regex,
          ...errorUtil_1.errorUtil.errToObj(message2)
        });
      }
      includes(value, options) {
        return this._addCheck({
          kind: "includes",
          value,
          position: options === null || options === void 0 ? void 0 : options.position,
          ...errorUtil_1.errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
        });
      }
      startsWith(value, message2) {
        return this._addCheck({
          kind: "startsWith",
          value,
          ...errorUtil_1.errorUtil.errToObj(message2)
        });
      }
      endsWith(value, message2) {
        return this._addCheck({
          kind: "endsWith",
          value,
          ...errorUtil_1.errorUtil.errToObj(message2)
        });
      }
      min(minLength, message2) {
        return this._addCheck({
          kind: "min",
          value: minLength,
          ...errorUtil_1.errorUtil.errToObj(message2)
        });
      }
      max(maxLength, message2) {
        return this._addCheck({
          kind: "max",
          value: maxLength,
          ...errorUtil_1.errorUtil.errToObj(message2)
        });
      }
      length(len, message2) {
        return this._addCheck({
          kind: "length",
          value: len,
          ...errorUtil_1.errorUtil.errToObj(message2)
        });
      }
      /**
       * Equivalent to `.min(1)`
       */
      nonempty(message2) {
        return this.min(1, errorUtil_1.errorUtil.errToObj(message2));
      }
      trim() {
        return new ZodString({
          ...this._def,
          checks: [...this._def.checks, { kind: "trim" }]
        });
      }
      toLowerCase() {
        return new ZodString({
          ...this._def,
          checks: [...this._def.checks, { kind: "toLowerCase" }]
        });
      }
      toUpperCase() {
        return new ZodString({
          ...this._def,
          checks: [...this._def.checks, { kind: "toUpperCase" }]
        });
      }
      get isDatetime() {
        return !!this._def.checks.find((ch) => ch.kind === "datetime");
      }
      get isDate() {
        return !!this._def.checks.find((ch) => ch.kind === "date");
      }
      get isTime() {
        return !!this._def.checks.find((ch) => ch.kind === "time");
      }
      get isDuration() {
        return !!this._def.checks.find((ch) => ch.kind === "duration");
      }
      get isEmail() {
        return !!this._def.checks.find((ch) => ch.kind === "email");
      }
      get isURL() {
        return !!this._def.checks.find((ch) => ch.kind === "url");
      }
      get isEmoji() {
        return !!this._def.checks.find((ch) => ch.kind === "emoji");
      }
      get isUUID() {
        return !!this._def.checks.find((ch) => ch.kind === "uuid");
      }
      get isNANOID() {
        return !!this._def.checks.find((ch) => ch.kind === "nanoid");
      }
      get isCUID() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid");
      }
      get isCUID2() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid2");
      }
      get isULID() {
        return !!this._def.checks.find((ch) => ch.kind === "ulid");
      }
      get isIP() {
        return !!this._def.checks.find((ch) => ch.kind === "ip");
      }
      get isCIDR() {
        return !!this._def.checks.find((ch) => ch.kind === "cidr");
      }
      get isBase64() {
        return !!this._def.checks.find((ch) => ch.kind === "base64");
      }
      get isBase64url() {
        return !!this._def.checks.find((ch) => ch.kind === "base64url");
      }
      get minLength() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min;
      }
      get maxLength() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max;
      }
    }
    types$4.ZodString = ZodString;
    ZodString.create = (params) => {
      var _a;
      return new ZodString({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodString,
        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
        ...processCreateParams(params)
      });
    };
    function floatSafeRemainder(val, step) {
      const valDecCount = (val.toString().split(".")[1] || "").length;
      const stepDecCount = (step.toString().split(".")[1] || "").length;
      const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
      const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
      const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
      return valInt % stepInt / Math.pow(10, decCount);
    }
    class ZodNumber extends ZodType {
      constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
        this.step = this.multipleOf;
      }
      _parse(input) {
        if (this._def.coerce) {
          input.data = Number(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.number) {
          const ctx2 = this._getOrReturnCtx(input);
          (0, parseUtil_1.addIssueToContext)(ctx2, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.number,
            received: ctx2.parsedType
          });
          return parseUtil_1.INVALID;
        }
        let ctx = void 0;
        const status = new parseUtil_1.ParseStatus();
        for (const check2 of this._def.checks) {
          if (check2.kind === "int") {
            if (!util_1.util.isInteger(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.invalid_type,
                expected: "integer",
                received: "float",
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "min") {
            const tooSmall = check2.inclusive ? input.data < check2.value : input.data <= check2.value;
            if (tooSmall) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.too_small,
                minimum: check2.value,
                type: "number",
                inclusive: check2.inclusive,
                exact: false,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "max") {
            const tooBig = check2.inclusive ? input.data > check2.value : input.data >= check2.value;
            if (tooBig) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.too_big,
                maximum: check2.value,
                type: "number",
                inclusive: check2.inclusive,
                exact: false,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "multipleOf") {
            if (floatSafeRemainder(input.data, check2.value) !== 0) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.not_multiple_of,
                multipleOf: check2.value,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "finite") {
            if (!Number.isFinite(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.not_finite,
                message: check2.message
              });
              status.dirty();
            }
          } else {
            util_1.util.assertNever(check2);
          }
        }
        return { status: status.value, value: input.data };
      }
      gte(value, message2) {
        return this.setLimit("min", value, true, errorUtil_1.errorUtil.toString(message2));
      }
      gt(value, message2) {
        return this.setLimit("min", value, false, errorUtil_1.errorUtil.toString(message2));
      }
      lte(value, message2) {
        return this.setLimit("max", value, true, errorUtil_1.errorUtil.toString(message2));
      }
      lt(value, message2) {
        return this.setLimit("max", value, false, errorUtil_1.errorUtil.toString(message2));
      }
      setLimit(kind, value, inclusive, message2) {
        return new ZodNumber({
          ...this._def,
          checks: [
            ...this._def.checks,
            {
              kind,
              value,
              inclusive,
              message: errorUtil_1.errorUtil.toString(message2)
            }
          ]
        });
      }
      _addCheck(check2) {
        return new ZodNumber({
          ...this._def,
          checks: [...this._def.checks, check2]
        });
      }
      int(message2) {
        return this._addCheck({
          kind: "int",
          message: errorUtil_1.errorUtil.toString(message2)
        });
      }
      positive(message2) {
        return this._addCheck({
          kind: "min",
          value: 0,
          inclusive: false,
          message: errorUtil_1.errorUtil.toString(message2)
        });
      }
      negative(message2) {
        return this._addCheck({
          kind: "max",
          value: 0,
          inclusive: false,
          message: errorUtil_1.errorUtil.toString(message2)
        });
      }
      nonpositive(message2) {
        return this._addCheck({
          kind: "max",
          value: 0,
          inclusive: true,
          message: errorUtil_1.errorUtil.toString(message2)
        });
      }
      nonnegative(message2) {
        return this._addCheck({
          kind: "min",
          value: 0,
          inclusive: true,
          message: errorUtil_1.errorUtil.toString(message2)
        });
      }
      multipleOf(value, message2) {
        return this._addCheck({
          kind: "multipleOf",
          value,
          message: errorUtil_1.errorUtil.toString(message2)
        });
      }
      finite(message2) {
        return this._addCheck({
          kind: "finite",
          message: errorUtil_1.errorUtil.toString(message2)
        });
      }
      safe(message2) {
        return this._addCheck({
          kind: "min",
          inclusive: true,
          value: Number.MIN_SAFE_INTEGER,
          message: errorUtil_1.errorUtil.toString(message2)
        })._addCheck({
          kind: "max",
          inclusive: true,
          value: Number.MAX_SAFE_INTEGER,
          message: errorUtil_1.errorUtil.toString(message2)
        });
      }
      get minValue() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min;
      }
      get maxValue() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max;
      }
      get isInt() {
        return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util_1.util.isInteger(ch.value));
      }
      get isFinite() {
        let max = null, min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
            return true;
          } else if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          } else if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return Number.isFinite(min) && Number.isFinite(max);
      }
    }
    types$4.ZodNumber = ZodNumber;
    ZodNumber.create = (params) => {
      return new ZodNumber({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodNumber,
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        ...processCreateParams(params)
      });
    };
    class ZodBigInt extends ZodType {
      constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
      }
      _parse(input) {
        if (this._def.coerce) {
          try {
            input.data = BigInt(input.data);
          } catch (_a) {
            return this._getInvalidInput(input);
          }
        }
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.bigint) {
          return this._getInvalidInput(input);
        }
        let ctx = void 0;
        const status = new parseUtil_1.ParseStatus();
        for (const check2 of this._def.checks) {
          if (check2.kind === "min") {
            const tooSmall = check2.inclusive ? input.data < check2.value : input.data <= check2.value;
            if (tooSmall) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.too_small,
                type: "bigint",
                minimum: check2.value,
                inclusive: check2.inclusive,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "max") {
            const tooBig = check2.inclusive ? input.data > check2.value : input.data >= check2.value;
            if (tooBig) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.too_big,
                type: "bigint",
                maximum: check2.value,
                inclusive: check2.inclusive,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "multipleOf") {
            if (input.data % check2.value !== BigInt(0)) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.not_multiple_of,
                multipleOf: check2.value,
                message: check2.message
              });
              status.dirty();
            }
          } else {
            util_1.util.assertNever(check2);
          }
        }
        return { status: status.value, value: input.data };
      }
      _getInvalidInput(input) {
        const ctx = this._getOrReturnCtx(input);
        (0, parseUtil_1.addIssueToContext)(ctx, {
          code: ZodError_1.ZodIssueCode.invalid_type,
          expected: util_1.ZodParsedType.bigint,
          received: ctx.parsedType
        });
        return parseUtil_1.INVALID;
      }
      gte(value, message2) {
        return this.setLimit("min", value, true, errorUtil_1.errorUtil.toString(message2));
      }
      gt(value, message2) {
        return this.setLimit("min", value, false, errorUtil_1.errorUtil.toString(message2));
      }
      lte(value, message2) {
        return this.setLimit("max", value, true, errorUtil_1.errorUtil.toString(message2));
      }
      lt(value, message2) {
        return this.setLimit("max", value, false, errorUtil_1.errorUtil.toString(message2));
      }
      setLimit(kind, value, inclusive, message2) {
        return new ZodBigInt({
          ...this._def,
          checks: [
            ...this._def.checks,
            {
              kind,
              value,
              inclusive,
              message: errorUtil_1.errorUtil.toString(message2)
            }
          ]
        });
      }
      _addCheck(check2) {
        return new ZodBigInt({
          ...this._def,
          checks: [...this._def.checks, check2]
        });
      }
      positive(message2) {
        return this._addCheck({
          kind: "min",
          value: BigInt(0),
          inclusive: false,
          message: errorUtil_1.errorUtil.toString(message2)
        });
      }
      negative(message2) {
        return this._addCheck({
          kind: "max",
          value: BigInt(0),
          inclusive: false,
          message: errorUtil_1.errorUtil.toString(message2)
        });
      }
      nonpositive(message2) {
        return this._addCheck({
          kind: "max",
          value: BigInt(0),
          inclusive: true,
          message: errorUtil_1.errorUtil.toString(message2)
        });
      }
      nonnegative(message2) {
        return this._addCheck({
          kind: "min",
          value: BigInt(0),
          inclusive: true,
          message: errorUtil_1.errorUtil.toString(message2)
        });
      }
      multipleOf(value, message2) {
        return this._addCheck({
          kind: "multipleOf",
          value,
          message: errorUtil_1.errorUtil.toString(message2)
        });
      }
      get minValue() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min;
      }
      get maxValue() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max;
      }
    }
    types$4.ZodBigInt = ZodBigInt;
    ZodBigInt.create = (params) => {
      var _a;
      return new ZodBigInt({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodBigInt,
        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
        ...processCreateParams(params)
      });
    };
    class ZodBoolean extends ZodType {
      _parse(input) {
        if (this._def.coerce) {
          input.data = Boolean(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.boolean) {
          const ctx = this._getOrReturnCtx(input);
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.boolean,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
      }
    }
    types$4.ZodBoolean = ZodBoolean;
    ZodBoolean.create = (params) => {
      return new ZodBoolean({
        typeName: ZodFirstPartyTypeKind.ZodBoolean,
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        ...processCreateParams(params)
      });
    };
    class ZodDate extends ZodType {
      _parse(input) {
        if (this._def.coerce) {
          input.data = new Date(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.date) {
          const ctx2 = this._getOrReturnCtx(input);
          (0, parseUtil_1.addIssueToContext)(ctx2, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.date,
            received: ctx2.parsedType
          });
          return parseUtil_1.INVALID;
        }
        if (isNaN(input.data.getTime())) {
          const ctx2 = this._getOrReturnCtx(input);
          (0, parseUtil_1.addIssueToContext)(ctx2, {
            code: ZodError_1.ZodIssueCode.invalid_date
          });
          return parseUtil_1.INVALID;
        }
        const status = new parseUtil_1.ParseStatus();
        let ctx = void 0;
        for (const check2 of this._def.checks) {
          if (check2.kind === "min") {
            if (input.data.getTime() < check2.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.too_small,
                message: check2.message,
                inclusive: true,
                exact: false,
                minimum: check2.value,
                type: "date"
              });
              status.dirty();
            }
          } else if (check2.kind === "max") {
            if (input.data.getTime() > check2.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.too_big,
                message: check2.message,
                inclusive: true,
                exact: false,
                maximum: check2.value,
                type: "date"
              });
              status.dirty();
            }
          } else {
            util_1.util.assertNever(check2);
          }
        }
        return {
          status: status.value,
          value: new Date(input.data.getTime())
        };
      }
      _addCheck(check2) {
        return new ZodDate({
          ...this._def,
          checks: [...this._def.checks, check2]
        });
      }
      min(minDate, message2) {
        return this._addCheck({
          kind: "min",
          value: minDate.getTime(),
          message: errorUtil_1.errorUtil.toString(message2)
        });
      }
      max(maxDate, message2) {
        return this._addCheck({
          kind: "max",
          value: maxDate.getTime(),
          message: errorUtil_1.errorUtil.toString(message2)
        });
      }
      get minDate() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min != null ? new Date(min) : null;
      }
      get maxDate() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max != null ? new Date(max) : null;
      }
    }
    types$4.ZodDate = ZodDate;
    ZodDate.create = (params) => {
      return new ZodDate({
        checks: [],
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        typeName: ZodFirstPartyTypeKind.ZodDate,
        ...processCreateParams(params)
      });
    };
    class ZodSymbol extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.symbol) {
          const ctx = this._getOrReturnCtx(input);
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.symbol,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
      }
    }
    types$4.ZodSymbol = ZodSymbol;
    ZodSymbol.create = (params) => {
      return new ZodSymbol({
        typeName: ZodFirstPartyTypeKind.ZodSymbol,
        ...processCreateParams(params)
      });
    };
    class ZodUndefined extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.undefined) {
          const ctx = this._getOrReturnCtx(input);
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.undefined,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
      }
    }
    types$4.ZodUndefined = ZodUndefined;
    ZodUndefined.create = (params) => {
      return new ZodUndefined({
        typeName: ZodFirstPartyTypeKind.ZodUndefined,
        ...processCreateParams(params)
      });
    };
    class ZodNull extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.null) {
          const ctx = this._getOrReturnCtx(input);
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.null,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
      }
    }
    types$4.ZodNull = ZodNull;
    ZodNull.create = (params) => {
      return new ZodNull({
        typeName: ZodFirstPartyTypeKind.ZodNull,
        ...processCreateParams(params)
      });
    };
    class ZodAny extends ZodType {
      constructor() {
        super(...arguments);
        this._any = true;
      }
      _parse(input) {
        return (0, parseUtil_1.OK)(input.data);
      }
    }
    types$4.ZodAny = ZodAny;
    ZodAny.create = (params) => {
      return new ZodAny({
        typeName: ZodFirstPartyTypeKind.ZodAny,
        ...processCreateParams(params)
      });
    };
    class ZodUnknown extends ZodType {
      constructor() {
        super(...arguments);
        this._unknown = true;
      }
      _parse(input) {
        return (0, parseUtil_1.OK)(input.data);
      }
    }
    types$4.ZodUnknown = ZodUnknown;
    ZodUnknown.create = (params) => {
      return new ZodUnknown({
        typeName: ZodFirstPartyTypeKind.ZodUnknown,
        ...processCreateParams(params)
      });
    };
    class ZodNever extends ZodType {
      _parse(input) {
        const ctx = this._getOrReturnCtx(input);
        (0, parseUtil_1.addIssueToContext)(ctx, {
          code: ZodError_1.ZodIssueCode.invalid_type,
          expected: util_1.ZodParsedType.never,
          received: ctx.parsedType
        });
        return parseUtil_1.INVALID;
      }
    }
    types$4.ZodNever = ZodNever;
    ZodNever.create = (params) => {
      return new ZodNever({
        typeName: ZodFirstPartyTypeKind.ZodNever,
        ...processCreateParams(params)
      });
    };
    class ZodVoid extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.undefined) {
          const ctx = this._getOrReturnCtx(input);
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.void,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
      }
    }
    types$4.ZodVoid = ZodVoid;
    ZodVoid.create = (params) => {
      return new ZodVoid({
        typeName: ZodFirstPartyTypeKind.ZodVoid,
        ...processCreateParams(params)
      });
    };
    class ZodArray extends ZodType {
      _parse(input) {
        const { ctx, status } = this._processInputParams(input);
        const def = this._def;
        if (ctx.parsedType !== util_1.ZodParsedType.array) {
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.array,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        if (def.exactLength !== null) {
          const tooBig = ctx.data.length > def.exactLength.value;
          const tooSmall = ctx.data.length < def.exactLength.value;
          if (tooBig || tooSmall) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: tooBig ? ZodError_1.ZodIssueCode.too_big : ZodError_1.ZodIssueCode.too_small,
              minimum: tooSmall ? def.exactLength.value : void 0,
              maximum: tooBig ? def.exactLength.value : void 0,
              type: "array",
              inclusive: true,
              exact: true,
              message: def.exactLength.message
            });
            status.dirty();
          }
        }
        if (def.minLength !== null) {
          if (ctx.data.length < def.minLength.value) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.too_small,
              minimum: def.minLength.value,
              type: "array",
              inclusive: true,
              exact: false,
              message: def.minLength.message
            });
            status.dirty();
          }
        }
        if (def.maxLength !== null) {
          if (ctx.data.length > def.maxLength.value) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.too_big,
              maximum: def.maxLength.value,
              type: "array",
              inclusive: true,
              exact: false,
              message: def.maxLength.message
            });
            status.dirty();
          }
        }
        if (ctx.common.async) {
          return Promise.all([...ctx.data].map((item, i) => {
            return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
          })).then((result2) => {
            return parseUtil_1.ParseStatus.mergeArray(status, result2);
          });
        }
        const result = [...ctx.data].map((item, i) => {
          return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
        });
        return parseUtil_1.ParseStatus.mergeArray(status, result);
      }
      get element() {
        return this._def.type;
      }
      min(minLength, message2) {
        return new ZodArray({
          ...this._def,
          minLength: { value: minLength, message: errorUtil_1.errorUtil.toString(message2) }
        });
      }
      max(maxLength, message2) {
        return new ZodArray({
          ...this._def,
          maxLength: { value: maxLength, message: errorUtil_1.errorUtil.toString(message2) }
        });
      }
      length(len, message2) {
        return new ZodArray({
          ...this._def,
          exactLength: { value: len, message: errorUtil_1.errorUtil.toString(message2) }
        });
      }
      nonempty(message2) {
        return this.min(1, message2);
      }
    }
    types$4.ZodArray = ZodArray;
    ZodArray.create = (schema2, params) => {
      return new ZodArray({
        type: schema2,
        minLength: null,
        maxLength: null,
        exactLength: null,
        typeName: ZodFirstPartyTypeKind.ZodArray,
        ...processCreateParams(params)
      });
    };
    function deepPartialify(schema2) {
      if (schema2 instanceof ZodObject) {
        const newShape = {};
        for (const key in schema2.shape) {
          const fieldSchema = schema2.shape[key];
          newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
        }
        return new ZodObject({
          ...schema2._def,
          shape: () => newShape
        });
      } else if (schema2 instanceof ZodArray) {
        return new ZodArray({
          ...schema2._def,
          type: deepPartialify(schema2.element)
        });
      } else if (schema2 instanceof ZodOptional) {
        return ZodOptional.create(deepPartialify(schema2.unwrap()));
      } else if (schema2 instanceof ZodNullable) {
        return ZodNullable.create(deepPartialify(schema2.unwrap()));
      } else if (schema2 instanceof ZodTuple) {
        return ZodTuple.create(schema2.items.map((item) => deepPartialify(item)));
      } else {
        return schema2;
      }
    }
    class ZodObject extends ZodType {
      constructor() {
        super(...arguments);
        this._cached = null;
        this.nonstrict = this.passthrough;
        this.augment = this.extend;
      }
      _getCached() {
        if (this._cached !== null)
          return this._cached;
        const shape = this._def.shape();
        const keys = util_1.util.objectKeys(shape);
        return this._cached = { shape, keys };
      }
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.object) {
          const ctx2 = this._getOrReturnCtx(input);
          (0, parseUtil_1.addIssueToContext)(ctx2, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.object,
            received: ctx2.parsedType
          });
          return parseUtil_1.INVALID;
        }
        const { status, ctx } = this._processInputParams(input);
        const { shape, keys: shapeKeys } = this._getCached();
        const extraKeys = [];
        if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
          for (const key in ctx.data) {
            if (!shapeKeys.includes(key)) {
              extraKeys.push(key);
            }
          }
        }
        const pairs = [];
        for (const key of shapeKeys) {
          const keyValidator = shape[key];
          const value = ctx.data[key];
          pairs.push({
            key: { status: "valid", value: key },
            value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
            alwaysSet: key in ctx.data
          });
        }
        if (this._def.catchall instanceof ZodNever) {
          const unknownKeys = this._def.unknownKeys;
          if (unknownKeys === "passthrough") {
            for (const key of extraKeys) {
              pairs.push({
                key: { status: "valid", value: key },
                value: { status: "valid", value: ctx.data[key] }
              });
            }
          } else if (unknownKeys === "strict") {
            if (extraKeys.length > 0) {
              (0, parseUtil_1.addIssueToContext)(ctx, {
                code: ZodError_1.ZodIssueCode.unrecognized_keys,
                keys: extraKeys
              });
              status.dirty();
            }
          } else if (unknownKeys === "strip") ;
          else {
            throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
          }
        } else {
          const catchall = this._def.catchall;
          for (const key of extraKeys) {
            const value = ctx.data[key];
            pairs.push({
              key: { status: "valid", value: key },
              value: catchall._parse(
                new ParseInputLazyPath(ctx, value, ctx.path, key)
                //, ctx.child(key), value, getParsedType(value)
              ),
              alwaysSet: key in ctx.data
            });
          }
        }
        if (ctx.common.async) {
          return Promise.resolve().then(async () => {
            const syncPairs = [];
            for (const pair of pairs) {
              const key = await pair.key;
              const value = await pair.value;
              syncPairs.push({
                key,
                value,
                alwaysSet: pair.alwaysSet
              });
            }
            return syncPairs;
          }).then((syncPairs) => {
            return parseUtil_1.ParseStatus.mergeObjectSync(status, syncPairs);
          });
        } else {
          return parseUtil_1.ParseStatus.mergeObjectSync(status, pairs);
        }
      }
      get shape() {
        return this._def.shape();
      }
      strict(message2) {
        errorUtil_1.errorUtil.errToObj;
        return new ZodObject({
          ...this._def,
          unknownKeys: "strict",
          ...message2 !== void 0 ? {
            errorMap: (issue, ctx) => {
              var _a, _b, _c, _d;
              const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
              if (issue.code === "unrecognized_keys")
                return {
                  message: (_d = errorUtil_1.errorUtil.errToObj(message2).message) !== null && _d !== void 0 ? _d : defaultError
                };
              return {
                message: defaultError
              };
            }
          } : {}
        });
      }
      strip() {
        return new ZodObject({
          ...this._def,
          unknownKeys: "strip"
        });
      }
      passthrough() {
        return new ZodObject({
          ...this._def,
          unknownKeys: "passthrough"
        });
      }
      // const AugmentFactory =
      //   <Def extends ZodObjectDef>(def: Def) =>
      //   <Augmentation extends ZodRawShape>(
      //     augmentation: Augmentation
      //   ): ZodObject<
      //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
      //     Def["unknownKeys"],
      //     Def["catchall"]
      //   > => {
      //     return new ZodObject({
      //       ...def,
      //       shape: () => ({
      //         ...def.shape(),
      //         ...augmentation,
      //       }),
      //     }) as any;
      //   };
      extend(augmentation) {
        return new ZodObject({
          ...this._def,
          shape: () => ({
            ...this._def.shape(),
            ...augmentation
          })
        });
      }
      /**
       * Prior to zod@1.0.12 there was a bug in the
       * inferred type of merged objects. Please
       * upgrade if you are experiencing issues.
       */
      merge(merging) {
        const merged = new ZodObject({
          unknownKeys: merging._def.unknownKeys,
          catchall: merging._def.catchall,
          shape: () => ({
            ...this._def.shape(),
            ...merging._def.shape()
          }),
          typeName: ZodFirstPartyTypeKind.ZodObject
        });
        return merged;
      }
      // merge<
      //   Incoming extends AnyZodObject,
      //   Augmentation extends Incoming["shape"],
      //   NewOutput extends {
      //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
      //       ? Augmentation[k]["_output"]
      //       : k extends keyof Output
      //       ? Output[k]
      //       : never;
      //   },
      //   NewInput extends {
      //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
      //       ? Augmentation[k]["_input"]
      //       : k extends keyof Input
      //       ? Input[k]
      //       : never;
      //   }
      // >(
      //   merging: Incoming
      // ): ZodObject<
      //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
      //   Incoming["_def"]["unknownKeys"],
      //   Incoming["_def"]["catchall"],
      //   NewOutput,
      //   NewInput
      // > {
      //   const merged: any = new ZodObject({
      //     unknownKeys: merging._def.unknownKeys,
      //     catchall: merging._def.catchall,
      //     shape: () =>
      //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
      //     typeName: ZodFirstPartyTypeKind.ZodObject,
      //   }) as any;
      //   return merged;
      // }
      setKey(key, schema2) {
        return this.augment({ [key]: schema2 });
      }
      // merge<Incoming extends AnyZodObject>(
      //   merging: Incoming
      // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
      // ZodObject<
      //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
      //   Incoming["_def"]["unknownKeys"],
      //   Incoming["_def"]["catchall"]
      // > {
      //   // const mergedShape = objectUtil.mergeShapes(
      //   //   this._def.shape(),
      //   //   merging._def.shape()
      //   // );
      //   const merged: any = new ZodObject({
      //     unknownKeys: merging._def.unknownKeys,
      //     catchall: merging._def.catchall,
      //     shape: () =>
      //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
      //     typeName: ZodFirstPartyTypeKind.ZodObject,
      //   }) as any;
      //   return merged;
      // }
      catchall(index) {
        return new ZodObject({
          ...this._def,
          catchall: index
        });
      }
      pick(mask) {
        const shape = {};
        util_1.util.objectKeys(mask).forEach((key) => {
          if (mask[key] && this.shape[key]) {
            shape[key] = this.shape[key];
          }
        });
        return new ZodObject({
          ...this._def,
          shape: () => shape
        });
      }
      omit(mask) {
        const shape = {};
        util_1.util.objectKeys(this.shape).forEach((key) => {
          if (!mask[key]) {
            shape[key] = this.shape[key];
          }
        });
        return new ZodObject({
          ...this._def,
          shape: () => shape
        });
      }
      /**
       * @deprecated
       */
      deepPartial() {
        return deepPartialify(this);
      }
      partial(mask) {
        const newShape = {};
        util_1.util.objectKeys(this.shape).forEach((key) => {
          const fieldSchema = this.shape[key];
          if (mask && !mask[key]) {
            newShape[key] = fieldSchema;
          } else {
            newShape[key] = fieldSchema.optional();
          }
        });
        return new ZodObject({
          ...this._def,
          shape: () => newShape
        });
      }
      required(mask) {
        const newShape = {};
        util_1.util.objectKeys(this.shape).forEach((key) => {
          if (mask && !mask[key]) {
            newShape[key] = this.shape[key];
          } else {
            const fieldSchema = this.shape[key];
            let newField = fieldSchema;
            while (newField instanceof ZodOptional) {
              newField = newField._def.innerType;
            }
            newShape[key] = newField;
          }
        });
        return new ZodObject({
          ...this._def,
          shape: () => newShape
        });
      }
      keyof() {
        return createZodEnum(util_1.util.objectKeys(this.shape));
      }
    }
    types$4.ZodObject = ZodObject;
    ZodObject.create = (shape, params) => {
      return new ZodObject({
        shape: () => shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params)
      });
    };
    ZodObject.strictCreate = (shape, params) => {
      return new ZodObject({
        shape: () => shape,
        unknownKeys: "strict",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params)
      });
    };
    ZodObject.lazycreate = (shape, params) => {
      return new ZodObject({
        shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params)
      });
    };
    class ZodUnion extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const options = this._def.options;
        function handleResults(results) {
          for (const result of results) {
            if (result.result.status === "valid") {
              return result.result;
            }
          }
          for (const result of results) {
            if (result.result.status === "dirty") {
              ctx.common.issues.push(...result.ctx.common.issues);
              return result.result;
            }
          }
          const unionErrors = results.map((result) => new ZodError_1.ZodError(result.ctx.common.issues));
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_union,
            unionErrors
          });
          return parseUtil_1.INVALID;
        }
        if (ctx.common.async) {
          return Promise.all(options.map(async (option) => {
            const childCtx = {
              ...ctx,
              common: {
                ...ctx.common,
                issues: []
              },
              parent: null
            };
            return {
              result: await option._parseAsync({
                data: ctx.data,
                path: ctx.path,
                parent: childCtx
              }),
              ctx: childCtx
            };
          })).then(handleResults);
        } else {
          let dirty = void 0;
          const issues = [];
          for (const option of options) {
            const childCtx = {
              ...ctx,
              common: {
                ...ctx.common,
                issues: []
              },
              parent: null
            };
            const result = option._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: childCtx
            });
            if (result.status === "valid") {
              return result;
            } else if (result.status === "dirty" && !dirty) {
              dirty = { result, ctx: childCtx };
            }
            if (childCtx.common.issues.length) {
              issues.push(childCtx.common.issues);
            }
          }
          if (dirty) {
            ctx.common.issues.push(...dirty.ctx.common.issues);
            return dirty.result;
          }
          const unionErrors = issues.map((issues2) => new ZodError_1.ZodError(issues2));
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_union,
            unionErrors
          });
          return parseUtil_1.INVALID;
        }
      }
      get options() {
        return this._def.options;
      }
    }
    types$4.ZodUnion = ZodUnion;
    ZodUnion.create = (types2, params) => {
      return new ZodUnion({
        options: types2,
        typeName: ZodFirstPartyTypeKind.ZodUnion,
        ...processCreateParams(params)
      });
    };
    const getDiscriminator = (type) => {
      if (type instanceof ZodLazy) {
        return getDiscriminator(type.schema);
      } else if (type instanceof ZodEffects) {
        return getDiscriminator(type.innerType());
      } else if (type instanceof ZodLiteral) {
        return [type.value];
      } else if (type instanceof ZodEnum) {
        return type.options;
      } else if (type instanceof ZodNativeEnum) {
        return util_1.util.objectValues(type.enum);
      } else if (type instanceof ZodDefault) {
        return getDiscriminator(type._def.innerType);
      } else if (type instanceof ZodUndefined) {
        return [void 0];
      } else if (type instanceof ZodNull) {
        return [null];
      } else if (type instanceof ZodOptional) {
        return [void 0, ...getDiscriminator(type.unwrap())];
      } else if (type instanceof ZodNullable) {
        return [null, ...getDiscriminator(type.unwrap())];
      } else if (type instanceof ZodBranded) {
        return getDiscriminator(type.unwrap());
      } else if (type instanceof ZodReadonly) {
        return getDiscriminator(type.unwrap());
      } else if (type instanceof ZodCatch) {
        return getDiscriminator(type._def.innerType);
      } else {
        return [];
      }
    };
    class ZodDiscriminatedUnion extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1.ZodParsedType.object) {
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.object,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        const discriminator = this.discriminator;
        const discriminatorValue = ctx.data[discriminator];
        const option = this.optionsMap.get(discriminatorValue);
        if (!option) {
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_union_discriminator,
            options: Array.from(this.optionsMap.keys()),
            path: [discriminator]
          });
          return parseUtil_1.INVALID;
        }
        if (ctx.common.async) {
          return option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
        } else {
          return option._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
        }
      }
      get discriminator() {
        return this._def.discriminator;
      }
      get options() {
        return this._def.options;
      }
      get optionsMap() {
        return this._def.optionsMap;
      }
      /**
       * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
       * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
       * have a different value for each object in the union.
       * @param discriminator the name of the discriminator property
       * @param types an array of object schemas
       * @param params
       */
      static create(discriminator, options, params) {
        const optionsMap = /* @__PURE__ */ new Map();
        for (const type of options) {
          const discriminatorValues = getDiscriminator(type.shape[discriminator]);
          if (!discriminatorValues.length) {
            throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
          }
          for (const value of discriminatorValues) {
            if (optionsMap.has(value)) {
              throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
            }
            optionsMap.set(value, type);
          }
        }
        return new ZodDiscriminatedUnion({
          typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
          discriminator,
          options,
          optionsMap,
          ...processCreateParams(params)
        });
      }
    }
    types$4.ZodDiscriminatedUnion = ZodDiscriminatedUnion;
    function mergeValues(a, b) {
      const aType = (0, util_1.getParsedType)(a);
      const bType = (0, util_1.getParsedType)(b);
      if (a === b) {
        return { valid: true, data: a };
      } else if (aType === util_1.ZodParsedType.object && bType === util_1.ZodParsedType.object) {
        const bKeys = util_1.util.objectKeys(b);
        const sharedKeys = util_1.util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
        const newObj = { ...a, ...b };
        for (const key of sharedKeys) {
          const sharedValue = mergeValues(a[key], b[key]);
          if (!sharedValue.valid) {
            return { valid: false };
          }
          newObj[key] = sharedValue.data;
        }
        return { valid: true, data: newObj };
      } else if (aType === util_1.ZodParsedType.array && bType === util_1.ZodParsedType.array) {
        if (a.length !== b.length) {
          return { valid: false };
        }
        const newArray = [];
        for (let index = 0; index < a.length; index++) {
          const itemA = a[index];
          const itemB = b[index];
          const sharedValue = mergeValues(itemA, itemB);
          if (!sharedValue.valid) {
            return { valid: false };
          }
          newArray.push(sharedValue.data);
        }
        return { valid: true, data: newArray };
      } else if (aType === util_1.ZodParsedType.date && bType === util_1.ZodParsedType.date && +a === +b) {
        return { valid: true, data: a };
      } else {
        return { valid: false };
      }
    }
    class ZodIntersection extends ZodType {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const handleParsed = (parsedLeft, parsedRight) => {
          if ((0, parseUtil_1.isAborted)(parsedLeft) || (0, parseUtil_1.isAborted)(parsedRight)) {
            return parseUtil_1.INVALID;
          }
          const merged = mergeValues(parsedLeft.value, parsedRight.value);
          if (!merged.valid) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.invalid_intersection_types
            });
            return parseUtil_1.INVALID;
          }
          if ((0, parseUtil_1.isDirty)(parsedLeft) || (0, parseUtil_1.isDirty)(parsedRight)) {
            status.dirty();
          }
          return { status: status.value, value: merged.data };
        };
        if (ctx.common.async) {
          return Promise.all([
            this._def.left._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            }),
            this._def.right._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            })
          ]).then(([left, right]) => handleParsed(left, right));
        } else {
          return handleParsed(this._def.left._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }), this._def.right._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }));
        }
      }
    }
    types$4.ZodIntersection = ZodIntersection;
    ZodIntersection.create = (left, right, params) => {
      return new ZodIntersection({
        left,
        right,
        typeName: ZodFirstPartyTypeKind.ZodIntersection,
        ...processCreateParams(params)
      });
    };
    class ZodTuple extends ZodType {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1.ZodParsedType.array) {
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.array,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        if (ctx.data.length < this._def.items.length) {
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.too_small,
            minimum: this._def.items.length,
            inclusive: true,
            exact: false,
            type: "array"
          });
          return parseUtil_1.INVALID;
        }
        const rest = this._def.rest;
        if (!rest && ctx.data.length > this._def.items.length) {
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.too_big,
            maximum: this._def.items.length,
            inclusive: true,
            exact: false,
            type: "array"
          });
          status.dirty();
        }
        const items = [...ctx.data].map((item, itemIndex) => {
          const schema2 = this._def.items[itemIndex] || this._def.rest;
          if (!schema2)
            return null;
          return schema2._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
        }).filter((x) => !!x);
        if (ctx.common.async) {
          return Promise.all(items).then((results) => {
            return parseUtil_1.ParseStatus.mergeArray(status, results);
          });
        } else {
          return parseUtil_1.ParseStatus.mergeArray(status, items);
        }
      }
      get items() {
        return this._def.items;
      }
      rest(rest) {
        return new ZodTuple({
          ...this._def,
          rest
        });
      }
    }
    types$4.ZodTuple = ZodTuple;
    ZodTuple.create = (schemas, params) => {
      if (!Array.isArray(schemas)) {
        throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
      }
      return new ZodTuple({
        items: schemas,
        typeName: ZodFirstPartyTypeKind.ZodTuple,
        rest: null,
        ...processCreateParams(params)
      });
    };
    class ZodRecord extends ZodType {
      get keySchema() {
        return this._def.keyType;
      }
      get valueSchema() {
        return this._def.valueType;
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1.ZodParsedType.object) {
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.object,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        const pairs = [];
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        for (const key in ctx.data) {
          pairs.push({
            key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
            value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
            alwaysSet: key in ctx.data
          });
        }
        if (ctx.common.async) {
          return parseUtil_1.ParseStatus.mergeObjectAsync(status, pairs);
        } else {
          return parseUtil_1.ParseStatus.mergeObjectSync(status, pairs);
        }
      }
      get element() {
        return this._def.valueType;
      }
      static create(first, second, third) {
        if (second instanceof ZodType) {
          return new ZodRecord({
            keyType: first,
            valueType: second,
            typeName: ZodFirstPartyTypeKind.ZodRecord,
            ...processCreateParams(third)
          });
        }
        return new ZodRecord({
          keyType: ZodString.create(),
          valueType: first,
          typeName: ZodFirstPartyTypeKind.ZodRecord,
          ...processCreateParams(second)
        });
      }
    }
    types$4.ZodRecord = ZodRecord;
    class ZodMap extends ZodType {
      get keySchema() {
        return this._def.keyType;
      }
      get valueSchema() {
        return this._def.valueType;
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1.ZodParsedType.map) {
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.map,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        const pairs = [...ctx.data.entries()].map(([key, value], index) => {
          return {
            key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
            value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
          };
        });
        if (ctx.common.async) {
          const finalMap = /* @__PURE__ */ new Map();
          return Promise.resolve().then(async () => {
            for (const pair of pairs) {
              const key = await pair.key;
              const value = await pair.value;
              if (key.status === "aborted" || value.status === "aborted") {
                return parseUtil_1.INVALID;
              }
              if (key.status === "dirty" || value.status === "dirty") {
                status.dirty();
              }
              finalMap.set(key.value, value.value);
            }
            return { status: status.value, value: finalMap };
          });
        } else {
          const finalMap = /* @__PURE__ */ new Map();
          for (const pair of pairs) {
            const key = pair.key;
            const value = pair.value;
            if (key.status === "aborted" || value.status === "aborted") {
              return parseUtil_1.INVALID;
            }
            if (key.status === "dirty" || value.status === "dirty") {
              status.dirty();
            }
            finalMap.set(key.value, value.value);
          }
          return { status: status.value, value: finalMap };
        }
      }
    }
    types$4.ZodMap = ZodMap;
    ZodMap.create = (keyType, valueType, params) => {
      return new ZodMap({
        valueType,
        keyType,
        typeName: ZodFirstPartyTypeKind.ZodMap,
        ...processCreateParams(params)
      });
    };
    class ZodSet extends ZodType {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1.ZodParsedType.set) {
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.set,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        const def = this._def;
        if (def.minSize !== null) {
          if (ctx.data.size < def.minSize.value) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.too_small,
              minimum: def.minSize.value,
              type: "set",
              inclusive: true,
              exact: false,
              message: def.minSize.message
            });
            status.dirty();
          }
        }
        if (def.maxSize !== null) {
          if (ctx.data.size > def.maxSize.value) {
            (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.too_big,
              maximum: def.maxSize.value,
              type: "set",
              inclusive: true,
              exact: false,
              message: def.maxSize.message
            });
            status.dirty();
          }
        }
        const valueType = this._def.valueType;
        function finalizeSet(elements2) {
          const parsedSet = /* @__PURE__ */ new Set();
          for (const element of elements2) {
            if (element.status === "aborted")
              return parseUtil_1.INVALID;
            if (element.status === "dirty")
              status.dirty();
            parsedSet.add(element.value);
          }
          return { status: status.value, value: parsedSet };
        }
        const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
        if (ctx.common.async) {
          return Promise.all(elements).then((elements2) => finalizeSet(elements2));
        } else {
          return finalizeSet(elements);
        }
      }
      min(minSize, message2) {
        return new ZodSet({
          ...this._def,
          minSize: { value: minSize, message: errorUtil_1.errorUtil.toString(message2) }
        });
      }
      max(maxSize, message2) {
        return new ZodSet({
          ...this._def,
          maxSize: { value: maxSize, message: errorUtil_1.errorUtil.toString(message2) }
        });
      }
      size(size, message2) {
        return this.min(size, message2).max(size, message2);
      }
      nonempty(message2) {
        return this.min(1, message2);
      }
    }
    types$4.ZodSet = ZodSet;
    ZodSet.create = (valueType, params) => {
      return new ZodSet({
        valueType,
        minSize: null,
        maxSize: null,
        typeName: ZodFirstPartyTypeKind.ZodSet,
        ...processCreateParams(params)
      });
    };
    class ZodFunction extends ZodType {
      constructor() {
        super(...arguments);
        this.validate = this.implement;
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1.ZodParsedType.function) {
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.function,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        function makeArgsIssue(args, error) {
          return (0, parseUtil_1.makeIssue)({
            data: args,
            path: ctx.path,
            errorMaps: [
              ctx.common.contextualErrorMap,
              ctx.schemaErrorMap,
              (0, errors_1.getErrorMap)(),
              errors_1.defaultErrorMap
            ].filter((x) => !!x),
            issueData: {
              code: ZodError_1.ZodIssueCode.invalid_arguments,
              argumentsError: error
            }
          });
        }
        function makeReturnsIssue(returns, error) {
          return (0, parseUtil_1.makeIssue)({
            data: returns,
            path: ctx.path,
            errorMaps: [
              ctx.common.contextualErrorMap,
              ctx.schemaErrorMap,
              (0, errors_1.getErrorMap)(),
              errors_1.defaultErrorMap
            ].filter((x) => !!x),
            issueData: {
              code: ZodError_1.ZodIssueCode.invalid_return_type,
              returnTypeError: error
            }
          });
        }
        const params = { errorMap: ctx.common.contextualErrorMap };
        const fn = ctx.data;
        if (this._def.returns instanceof ZodPromise) {
          const me = this;
          return (0, parseUtil_1.OK)(async function(...args) {
            const error = new ZodError_1.ZodError([]);
            const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
              error.addIssue(makeArgsIssue(args, e));
              throw error;
            });
            const result = await Reflect.apply(fn, this, parsedArgs);
            const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
              error.addIssue(makeReturnsIssue(result, e));
              throw error;
            });
            return parsedReturns;
          });
        } else {
          const me = this;
          return (0, parseUtil_1.OK)(function(...args) {
            const parsedArgs = me._def.args.safeParse(args, params);
            if (!parsedArgs.success) {
              throw new ZodError_1.ZodError([makeArgsIssue(args, parsedArgs.error)]);
            }
            const result = Reflect.apply(fn, this, parsedArgs.data);
            const parsedReturns = me._def.returns.safeParse(result, params);
            if (!parsedReturns.success) {
              throw new ZodError_1.ZodError([makeReturnsIssue(result, parsedReturns.error)]);
            }
            return parsedReturns.data;
          });
        }
      }
      parameters() {
        return this._def.args;
      }
      returnType() {
        return this._def.returns;
      }
      args(...items) {
        return new ZodFunction({
          ...this._def,
          args: ZodTuple.create(items).rest(ZodUnknown.create())
        });
      }
      returns(returnType) {
        return new ZodFunction({
          ...this._def,
          returns: returnType
        });
      }
      implement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
      }
      strictImplement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
      }
      static create(args, returns, params) {
        return new ZodFunction({
          args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
          returns: returns || ZodUnknown.create(),
          typeName: ZodFirstPartyTypeKind.ZodFunction,
          ...processCreateParams(params)
        });
      }
    }
    types$4.ZodFunction = ZodFunction;
    class ZodLazy extends ZodType {
      get schema() {
        return this._def.getter();
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const lazySchema = this._def.getter();
        return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
      }
    }
    types$4.ZodLazy = ZodLazy;
    ZodLazy.create = (getter, params) => {
      return new ZodLazy({
        getter,
        typeName: ZodFirstPartyTypeKind.ZodLazy,
        ...processCreateParams(params)
      });
    };
    class ZodLiteral extends ZodType {
      _parse(input) {
        if (input.data !== this._def.value) {
          const ctx = this._getOrReturnCtx(input);
          (0, parseUtil_1.addIssueToContext)(ctx, {
            received: ctx.data,
            code: ZodError_1.ZodIssueCode.invalid_literal,
            expected: this._def.value
          });
          return parseUtil_1.INVALID;
        }
        return { status: "valid", value: input.data };
      }
      get value() {
        return this._def.value;
      }
    }
    types$4.ZodLiteral = ZodLiteral;
    ZodLiteral.create = (value, params) => {
      return new ZodLiteral({
        value,
        typeName: ZodFirstPartyTypeKind.ZodLiteral,
        ...processCreateParams(params)
      });
    };
    function createZodEnum(values, params) {
      return new ZodEnum({
        values,
        typeName: ZodFirstPartyTypeKind.ZodEnum,
        ...processCreateParams(params)
      });
    }
    class ZodEnum extends ZodType {
      constructor() {
        super(...arguments);
        _ZodEnum_cache.set(this, void 0);
      }
      _parse(input) {
        if (typeof input.data !== "string") {
          const ctx = this._getOrReturnCtx(input);
          const expectedValues = this._def.values;
          (0, parseUtil_1.addIssueToContext)(ctx, {
            expected: util_1.util.joinValues(expectedValues),
            received: ctx.parsedType,
            code: ZodError_1.ZodIssueCode.invalid_type
          });
          return parseUtil_1.INVALID;
        }
        if (!__classPrivateFieldGet(this, _ZodEnum_cache, "f")) {
          __classPrivateFieldSet(this, _ZodEnum_cache, new Set(this._def.values), "f");
        }
        if (!__classPrivateFieldGet(this, _ZodEnum_cache, "f").has(input.data)) {
          const ctx = this._getOrReturnCtx(input);
          const expectedValues = this._def.values;
          (0, parseUtil_1.addIssueToContext)(ctx, {
            received: ctx.data,
            code: ZodError_1.ZodIssueCode.invalid_enum_value,
            options: expectedValues
          });
          return parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
      }
      get options() {
        return this._def.values;
      }
      get enum() {
        const enumValues = {};
        for (const val of this._def.values) {
          enumValues[val] = val;
        }
        return enumValues;
      }
      get Values() {
        const enumValues = {};
        for (const val of this._def.values) {
          enumValues[val] = val;
        }
        return enumValues;
      }
      get Enum() {
        const enumValues = {};
        for (const val of this._def.values) {
          enumValues[val] = val;
        }
        return enumValues;
      }
      extract(values, newDef = this._def) {
        return ZodEnum.create(values, {
          ...this._def,
          ...newDef
        });
      }
      exclude(values, newDef = this._def) {
        return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
          ...this._def,
          ...newDef
        });
      }
    }
    types$4.ZodEnum = ZodEnum;
    _ZodEnum_cache = /* @__PURE__ */ new WeakMap();
    ZodEnum.create = createZodEnum;
    class ZodNativeEnum extends ZodType {
      constructor() {
        super(...arguments);
        _ZodNativeEnum_cache.set(this, void 0);
      }
      _parse(input) {
        const nativeEnumValues = util_1.util.getValidEnumValues(this._def.values);
        const ctx = this._getOrReturnCtx(input);
        if (ctx.parsedType !== util_1.ZodParsedType.string && ctx.parsedType !== util_1.ZodParsedType.number) {
          const expectedValues = util_1.util.objectValues(nativeEnumValues);
          (0, parseUtil_1.addIssueToContext)(ctx, {
            expected: util_1.util.joinValues(expectedValues),
            received: ctx.parsedType,
            code: ZodError_1.ZodIssueCode.invalid_type
          });
          return parseUtil_1.INVALID;
        }
        if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, "f")) {
          __classPrivateFieldSet(this, _ZodNativeEnum_cache, new Set(util_1.util.getValidEnumValues(this._def.values)), "f");
        }
        if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, "f").has(input.data)) {
          const expectedValues = util_1.util.objectValues(nativeEnumValues);
          (0, parseUtil_1.addIssueToContext)(ctx, {
            received: ctx.data,
            code: ZodError_1.ZodIssueCode.invalid_enum_value,
            options: expectedValues
          });
          return parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
      }
      get enum() {
        return this._def.values;
      }
    }
    types$4.ZodNativeEnum = ZodNativeEnum;
    _ZodNativeEnum_cache = /* @__PURE__ */ new WeakMap();
    ZodNativeEnum.create = (values, params) => {
      return new ZodNativeEnum({
        values,
        typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
        ...processCreateParams(params)
      });
    };
    class ZodPromise extends ZodType {
      unwrap() {
        return this._def.type;
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1.ZodParsedType.promise && ctx.common.async === false) {
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.promise,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        const promisified = ctx.parsedType === util_1.ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
        return (0, parseUtil_1.OK)(promisified.then((data) => {
          return this._def.type.parseAsync(data, {
            path: ctx.path,
            errorMap: ctx.common.contextualErrorMap
          });
        }));
      }
    }
    types$4.ZodPromise = ZodPromise;
    ZodPromise.create = (schema2, params) => {
      return new ZodPromise({
        type: schema2,
        typeName: ZodFirstPartyTypeKind.ZodPromise,
        ...processCreateParams(params)
      });
    };
    class ZodEffects extends ZodType {
      innerType() {
        return this._def.schema;
      }
      sourceType() {
        return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const effect = this._def.effect || null;
        const checkCtx = {
          addIssue: (arg) => {
            (0, parseUtil_1.addIssueToContext)(ctx, arg);
            if (arg.fatal) {
              status.abort();
            } else {
              status.dirty();
            }
          },
          get path() {
            return ctx.path;
          }
        };
        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
        if (effect.type === "preprocess") {
          const processed = effect.transform(ctx.data, checkCtx);
          if (ctx.common.async) {
            return Promise.resolve(processed).then(async (processed2) => {
              if (status.value === "aborted")
                return parseUtil_1.INVALID;
              const result = await this._def.schema._parseAsync({
                data: processed2,
                path: ctx.path,
                parent: ctx
              });
              if (result.status === "aborted")
                return parseUtil_1.INVALID;
              if (result.status === "dirty")
                return (0, parseUtil_1.DIRTY)(result.value);
              if (status.value === "dirty")
                return (0, parseUtil_1.DIRTY)(result.value);
              return result;
            });
          } else {
            if (status.value === "aborted")
              return parseUtil_1.INVALID;
            const result = this._def.schema._parseSync({
              data: processed,
              path: ctx.path,
              parent: ctx
            });
            if (result.status === "aborted")
              return parseUtil_1.INVALID;
            if (result.status === "dirty")
              return (0, parseUtil_1.DIRTY)(result.value);
            if (status.value === "dirty")
              return (0, parseUtil_1.DIRTY)(result.value);
            return result;
          }
        }
        if (effect.type === "refinement") {
          const executeRefinement = (acc) => {
            const result = effect.refinement(acc, checkCtx);
            if (ctx.common.async) {
              return Promise.resolve(result);
            }
            if (result instanceof Promise) {
              throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
            }
            return acc;
          };
          if (ctx.common.async === false) {
            const inner = this._def.schema._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (inner.status === "aborted")
              return parseUtil_1.INVALID;
            if (inner.status === "dirty")
              status.dirty();
            executeRefinement(inner.value);
            return { status: status.value, value: inner.value };
          } else {
            return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
              if (inner.status === "aborted")
                return parseUtil_1.INVALID;
              if (inner.status === "dirty")
                status.dirty();
              return executeRefinement(inner.value).then(() => {
                return { status: status.value, value: inner.value };
              });
            });
          }
        }
        if (effect.type === "transform") {
          if (ctx.common.async === false) {
            const base3 = this._def.schema._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (!(0, parseUtil_1.isValid)(base3))
              return base3;
            const result = effect.transform(base3.value, checkCtx);
            if (result instanceof Promise) {
              throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
            }
            return { status: status.value, value: result };
          } else {
            return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base3) => {
              if (!(0, parseUtil_1.isValid)(base3))
                return base3;
              return Promise.resolve(effect.transform(base3.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
            });
          }
        }
        util_1.util.assertNever(effect);
      }
    }
    types$4.ZodEffects = ZodEffects;
    types$4.ZodTransformer = ZodEffects;
    ZodEffects.create = (schema2, effect, params) => {
      return new ZodEffects({
        schema: schema2,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect,
        ...processCreateParams(params)
      });
    };
    ZodEffects.createWithPreprocess = (preprocess, schema2, params) => {
      return new ZodEffects({
        schema: schema2,
        effect: { type: "preprocess", transform: preprocess },
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        ...processCreateParams(params)
      });
    };
    class ZodOptional extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === util_1.ZodParsedType.undefined) {
          return (0, parseUtil_1.OK)(void 0);
        }
        return this._def.innerType._parse(input);
      }
      unwrap() {
        return this._def.innerType;
      }
    }
    types$4.ZodOptional = ZodOptional;
    ZodOptional.create = (type, params) => {
      return new ZodOptional({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodOptional,
        ...processCreateParams(params)
      });
    };
    class ZodNullable extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === util_1.ZodParsedType.null) {
          return (0, parseUtil_1.OK)(null);
        }
        return this._def.innerType._parse(input);
      }
      unwrap() {
        return this._def.innerType;
      }
    }
    types$4.ZodNullable = ZodNullable;
    ZodNullable.create = (type, params) => {
      return new ZodNullable({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodNullable,
        ...processCreateParams(params)
      });
    };
    class ZodDefault extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        let data = ctx.data;
        if (ctx.parsedType === util_1.ZodParsedType.undefined) {
          data = this._def.defaultValue();
        }
        return this._def.innerType._parse({
          data,
          path: ctx.path,
          parent: ctx
        });
      }
      removeDefault() {
        return this._def.innerType;
      }
    }
    types$4.ZodDefault = ZodDefault;
    ZodDefault.create = (type, params) => {
      return new ZodDefault({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodDefault,
        defaultValue: typeof params.default === "function" ? params.default : () => params.default,
        ...processCreateParams(params)
      });
    };
    class ZodCatch extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const newCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          }
        };
        const result = this._def.innerType._parse({
          data: newCtx.data,
          path: newCtx.path,
          parent: {
            ...newCtx
          }
        });
        if ((0, parseUtil_1.isAsync)(result)) {
          return result.then((result2) => {
            return {
              status: "valid",
              value: result2.status === "valid" ? result2.value : this._def.catchValue({
                get error() {
                  return new ZodError_1.ZodError(newCtx.common.issues);
                },
                input: newCtx.data
              })
            };
          });
        } else {
          return {
            status: "valid",
            value: result.status === "valid" ? result.value : this._def.catchValue({
              get error() {
                return new ZodError_1.ZodError(newCtx.common.issues);
              },
              input: newCtx.data
            })
          };
        }
      }
      removeCatch() {
        return this._def.innerType;
      }
    }
    types$4.ZodCatch = ZodCatch;
    ZodCatch.create = (type, params) => {
      return new ZodCatch({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodCatch,
        catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
        ...processCreateParams(params)
      });
    };
    class ZodNaN extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== util_1.ZodParsedType.nan) {
          const ctx = this._getOrReturnCtx(input);
          (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.nan,
            received: ctx.parsedType
          });
          return parseUtil_1.INVALID;
        }
        return { status: "valid", value: input.data };
      }
    }
    types$4.ZodNaN = ZodNaN;
    ZodNaN.create = (params) => {
      return new ZodNaN({
        typeName: ZodFirstPartyTypeKind.ZodNaN,
        ...processCreateParams(params)
      });
    };
    types$4.BRAND = Symbol("zod_brand");
    class ZodBranded extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const data = ctx.data;
        return this._def.type._parse({
          data,
          path: ctx.path,
          parent: ctx
        });
      }
      unwrap() {
        return this._def.type;
      }
    }
    types$4.ZodBranded = ZodBranded;
    class ZodPipeline extends ZodType {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.common.async) {
          const handleAsync = async () => {
            const inResult = await this._def.in._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (inResult.status === "aborted")
              return parseUtil_1.INVALID;
            if (inResult.status === "dirty") {
              status.dirty();
              return (0, parseUtil_1.DIRTY)(inResult.value);
            } else {
              return this._def.out._parseAsync({
                data: inResult.value,
                path: ctx.path,
                parent: ctx
              });
            }
          };
          return handleAsync();
        } else {
          const inResult = this._def.in._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inResult.status === "aborted")
            return parseUtil_1.INVALID;
          if (inResult.status === "dirty") {
            status.dirty();
            return {
              status: "dirty",
              value: inResult.value
            };
          } else {
            return this._def.out._parseSync({
              data: inResult.value,
              path: ctx.path,
              parent: ctx
            });
          }
        }
      }
      static create(a, b) {
        return new ZodPipeline({
          in: a,
          out: b,
          typeName: ZodFirstPartyTypeKind.ZodPipeline
        });
      }
    }
    types$4.ZodPipeline = ZodPipeline;
    class ZodReadonly extends ZodType {
      _parse(input) {
        const result = this._def.innerType._parse(input);
        const freeze = (data) => {
          if ((0, parseUtil_1.isValid)(data)) {
            data.value = Object.freeze(data.value);
          }
          return data;
        };
        return (0, parseUtil_1.isAsync)(result) ? result.then((data) => freeze(data)) : freeze(result);
      }
      unwrap() {
        return this._def.innerType;
      }
    }
    types$4.ZodReadonly = ZodReadonly;
    ZodReadonly.create = (type, params) => {
      return new ZodReadonly({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodReadonly,
        ...processCreateParams(params)
      });
    };
    function cleanParams(params, data) {
      const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
      const p2 = typeof p === "string" ? { message: p } : p;
      return p2;
    }
    function custom(check2, _params = {}, fatal) {
      if (check2)
        return ZodAny.create().superRefine((data, ctx) => {
          var _a, _b;
          const r = check2(data);
          if (r instanceof Promise) {
            return r.then((r2) => {
              var _a2, _b2;
              if (!r2) {
                const params = cleanParams(_params, data);
                const _fatal = (_b2 = (_a2 = params.fatal) !== null && _a2 !== void 0 ? _a2 : fatal) !== null && _b2 !== void 0 ? _b2 : true;
                ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
              }
            });
          }
          if (!r) {
            const params = cleanParams(_params, data);
            const _fatal = (_b = (_a = params.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;
            ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
          }
          return;
        });
      return ZodAny.create();
    }
    types$4.custom = custom;
    types$4.late = {
      object: ZodObject.lazycreate
    };
    var ZodFirstPartyTypeKind;
    (function(ZodFirstPartyTypeKind2) {
      ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
      ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
      ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
      ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
      ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
      ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
      ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
      ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
      ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
      ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
      ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
      ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
      ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
      ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
      ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
      ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
      ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
      ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
      ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
      ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
      ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
      ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
      ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
      ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
      ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
      ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
      ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
      ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
      ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
      ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
      ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
      ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
      ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
      ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
      ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
      ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
    })(ZodFirstPartyTypeKind || (types$4.ZodFirstPartyTypeKind = ZodFirstPartyTypeKind = {}));
    const instanceOfType = (cls, params = {
      message: `Input not instance of ${cls.name}`
    }) => custom((data) => data instanceof cls, params);
    types$4.instanceof = instanceOfType;
    const stringType = ZodString.create;
    types$4.string = stringType;
    const numberType = ZodNumber.create;
    types$4.number = numberType;
    const nanType = ZodNaN.create;
    types$4.nan = nanType;
    const bigIntType = ZodBigInt.create;
    types$4.bigint = bigIntType;
    const booleanType = ZodBoolean.create;
    types$4.boolean = booleanType;
    const dateType = ZodDate.create;
    types$4.date = dateType;
    const symbolType = ZodSymbol.create;
    types$4.symbol = symbolType;
    const undefinedType = ZodUndefined.create;
    types$4.undefined = undefinedType;
    const nullType = ZodNull.create;
    types$4.null = nullType;
    const anyType = ZodAny.create;
    types$4.any = anyType;
    const unknownType = ZodUnknown.create;
    types$4.unknown = unknownType;
    const neverType = ZodNever.create;
    types$4.never = neverType;
    const voidType = ZodVoid.create;
    types$4.void = voidType;
    const arrayType = ZodArray.create;
    types$4.array = arrayType;
    const objectType = ZodObject.create;
    types$4.object = objectType;
    const strictObjectType = ZodObject.strictCreate;
    types$4.strictObject = strictObjectType;
    const unionType = ZodUnion.create;
    types$4.union = unionType;
    const discriminatedUnionType = ZodDiscriminatedUnion.create;
    types$4.discriminatedUnion = discriminatedUnionType;
    const intersectionType = ZodIntersection.create;
    types$4.intersection = intersectionType;
    const tupleType = ZodTuple.create;
    types$4.tuple = tupleType;
    const recordType = ZodRecord.create;
    types$4.record = recordType;
    const mapType = ZodMap.create;
    types$4.map = mapType;
    const setType = ZodSet.create;
    types$4.set = setType;
    const functionType = ZodFunction.create;
    types$4.function = functionType;
    const lazyType = ZodLazy.create;
    types$4.lazy = lazyType;
    const literalType = ZodLiteral.create;
    types$4.literal = literalType;
    const enumType = ZodEnum.create;
    types$4.enum = enumType;
    const nativeEnumType = ZodNativeEnum.create;
    types$4.nativeEnum = nativeEnumType;
    const promiseType = ZodPromise.create;
    types$4.promise = promiseType;
    const effectsType = ZodEffects.create;
    types$4.effect = effectsType;
    types$4.transformer = effectsType;
    const optionalType = ZodOptional.create;
    types$4.optional = optionalType;
    const nullableType = ZodNullable.create;
    types$4.nullable = nullableType;
    const preprocessType = ZodEffects.createWithPreprocess;
    types$4.preprocess = preprocessType;
    const pipelineType = ZodPipeline.create;
    types$4.pipeline = pipelineType;
    const ostring = () => stringType().optional();
    types$4.ostring = ostring;
    const onumber = () => numberType().optional();
    types$4.onumber = onumber;
    const oboolean = () => booleanType().optional();
    types$4.oboolean = oboolean;
    types$4.coerce = {
      string: ((arg) => ZodString.create({ ...arg, coerce: true })),
      number: ((arg) => ZodNumber.create({ ...arg, coerce: true })),
      boolean: ((arg) => ZodBoolean.create({
        ...arg,
        coerce: true
      })),
      bigint: ((arg) => ZodBigInt.create({ ...arg, coerce: true })),
      date: ((arg) => ZodDate.create({ ...arg, coerce: true }))
    };
    types$4.NEVER = parseUtil_1.INVALID;
    return types$4;
  }
  var hasRequiredExternal$1;
  function requireExternal$1() {
    if (hasRequiredExternal$1) return external$1;
    hasRequiredExternal$1 = 1;
    (function(exports$1) {
      var __createBinding = external$1 && external$1.__createBinding || (Object.create ? (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      }));
      var __exportStar = external$1 && external$1.__exportStar || function(m, exports$12) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$12, p)) __createBinding(exports$12, m, p);
      };
      Object.defineProperty(exports$1, "__esModule", { value: true });
      __exportStar(/* @__PURE__ */ requireErrors(), exports$1);
      __exportStar(/* @__PURE__ */ requireParseUtil(), exports$1);
      __exportStar(/* @__PURE__ */ requireTypeAliases(), exports$1);
      __exportStar(/* @__PURE__ */ requireUtil$8(), exports$1);
      __exportStar(/* @__PURE__ */ requireTypes$5(), exports$1);
      __exportStar(/* @__PURE__ */ requireZodError(), exports$1);
    })(external$1);
    return external$1;
  }
  var hasRequiredLib$1;
  function requireLib$1() {
    if (hasRequiredLib$1) return lib$1;
    hasRequiredLib$1 = 1;
    (function(exports$1) {
      var __createBinding = lib$1 && lib$1.__createBinding || (Object.create ? (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      }));
      var __setModuleDefault = lib$1 && lib$1.__setModuleDefault || (Object.create ? (function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      }) : function(o, v) {
        o["default"] = v;
      });
      var __importStar = lib$1 && lib$1.__importStar || function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      var __exportStar = lib$1 && lib$1.__exportStar || function(m, exports$12) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$12, p)) __createBinding(exports$12, m, p);
      };
      Object.defineProperty(exports$1, "__esModule", { value: true });
      exports$1.z = void 0;
      const z = __importStar(/* @__PURE__ */ requireExternal$1());
      exports$1.z = z;
      __exportStar(/* @__PURE__ */ requireExternal$1(), exports$1);
      exports$1.default = z;
    })(lib$1);
    return lib$1;
  }
  var dist$3 = {};
  var handle = {};
  var hasRequiredHandle;
  function requireHandle() {
    if (hasRequiredHandle) return handle;
    hasRequiredHandle = 1;
    (function(exports$1) {
      Object.defineProperty(exports$1, "__esModule", { value: true });
      exports$1.DisallowedDomainError = exports$1.UnsupportedDomainError = exports$1.ReservedHandleError = exports$1.InvalidHandleError = exports$1.isValidTld = exports$1.isValidHandle = exports$1.normalizeAndEnsureValidHandle = exports$1.normalizeHandle = exports$1.ensureValidHandleRegex = exports$1.ensureValidHandle = exports$1.DISALLOWED_TLDS = exports$1.INVALID_HANDLE = void 0;
      exports$1.INVALID_HANDLE = "handle.invalid";
      exports$1.DISALLOWED_TLDS = [
        ".local",
        ".arpa",
        ".invalid",
        ".localhost",
        ".internal",
        ".example",
        ".alt",
        // policy could concievably change on ".onion" some day
        ".onion"
        // NOTE: .test is allowed in testing and devopment. In practical terms
        // "should" "never" actually resolve and get registered in production
      ];
      const ensureValidHandle = (handle2) => {
        if (!/^[a-zA-Z0-9.-]*$/.test(handle2)) {
          throw new InvalidHandleError("Disallowed characters in handle (ASCII letters, digits, dashes, periods only)");
        }
        if (handle2.length > 253) {
          throw new InvalidHandleError("Handle is too long (253 chars max)");
        }
        const labels2 = handle2.split(".");
        if (labels2.length < 2) {
          throw new InvalidHandleError("Handle domain needs at least two parts");
        }
        for (let i = 0; i < labels2.length; i++) {
          const l = labels2[i];
          if (l.length < 1) {
            throw new InvalidHandleError("Handle parts can not be empty");
          }
          if (l.length > 63) {
            throw new InvalidHandleError("Handle part too long (max 63 chars)");
          }
          if (l.endsWith("-") || l.startsWith("-")) {
            throw new InvalidHandleError("Handle parts can not start or end with hyphens");
          }
          if (i + 1 === labels2.length && !/^[a-zA-Z]/.test(l)) {
            throw new InvalidHandleError("Handle final component (TLD) must start with ASCII letter");
          }
        }
      };
      exports$1.ensureValidHandle = ensureValidHandle;
      const ensureValidHandleRegex = (handle2) => {
        if (!/^([a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?$/.test(handle2)) {
          throw new InvalidHandleError("Handle didn't validate via regex");
        }
        if (handle2.length > 253) {
          throw new InvalidHandleError("Handle is too long (253 chars max)");
        }
      };
      exports$1.ensureValidHandleRegex = ensureValidHandleRegex;
      const normalizeHandle = (handle2) => {
        return handle2.toLowerCase();
      };
      exports$1.normalizeHandle = normalizeHandle;
      const normalizeAndEnsureValidHandle = (handle2) => {
        const normalized = (0, exports$1.normalizeHandle)(handle2);
        (0, exports$1.ensureValidHandle)(normalized);
        return normalized;
      };
      exports$1.normalizeAndEnsureValidHandle = normalizeAndEnsureValidHandle;
      const isValidHandle = (handle2) => {
        try {
          (0, exports$1.ensureValidHandle)(handle2);
        } catch (err) {
          if (err instanceof InvalidHandleError) {
            return false;
          }
          throw err;
        }
        return true;
      };
      exports$1.isValidHandle = isValidHandle;
      const isValidTld = (handle2) => {
        return !exports$1.DISALLOWED_TLDS.some((domain) => handle2.endsWith(domain));
      };
      exports$1.isValidTld = isValidTld;
      class InvalidHandleError extends Error {
      }
      exports$1.InvalidHandleError = InvalidHandleError;
      class ReservedHandleError extends Error {
      }
      exports$1.ReservedHandleError = ReservedHandleError;
      class UnsupportedDomainError extends Error {
      }
      exports$1.UnsupportedDomainError = UnsupportedDomainError;
      class DisallowedDomainError extends Error {
      }
      exports$1.DisallowedDomainError = DisallowedDomainError;
    })(handle);
    return handle;
  }
  var did = {};
  var hasRequiredDid;
  function requireDid() {
    if (hasRequiredDid) return did;
    hasRequiredDid = 1;
    Object.defineProperty(did, "__esModule", { value: true });
    did.InvalidDidError = did.ensureValidDidRegex = did.ensureValidDid = void 0;
    const ensureValidDid = (did2) => {
      if (!did2.startsWith("did:")) {
        throw new InvalidDidError('DID requires "did:" prefix');
      }
      if (!/^[a-zA-Z0-9._:%-]*$/.test(did2)) {
        throw new InvalidDidError("Disallowed characters in DID (ASCII letters, digits, and a couple other characters only)");
      }
      const { length: length2, 1: method } = did2.split(":");
      if (length2 < 3) {
        throw new InvalidDidError("DID requires prefix, method, and method-specific content");
      }
      if (!/^[a-z]+$/.test(method)) {
        throw new InvalidDidError("DID method must be lower-case letters");
      }
      if (did2.endsWith(":") || did2.endsWith("%")) {
        throw new InvalidDidError('DID can not end with ":" or "%"');
      }
      if (did2.length > 2 * 1024) {
        throw new InvalidDidError("DID is too long (2048 chars max)");
      }
    };
    did.ensureValidDid = ensureValidDid;
    const ensureValidDidRegex = (did2) => {
      if (!/^did:[a-z]+:[a-zA-Z0-9._:%-]*[a-zA-Z0-9._-]$/.test(did2)) {
        throw new InvalidDidError("DID didn't validate via regex");
      }
      if (did2.length > 2 * 1024) {
        throw new InvalidDidError("DID is too long (2048 chars max)");
      }
    };
    did.ensureValidDidRegex = ensureValidDidRegex;
    class InvalidDidError extends Error {
    }
    did.InvalidDidError = InvalidDidError;
    return did;
  }
  var nsid = {};
  var hasRequiredNsid;
  function requireNsid() {
    if (hasRequiredNsid) return nsid;
    hasRequiredNsid = 1;
    (function(exports$1) {
      Object.defineProperty(exports$1, "__esModule", { value: true });
      exports$1.InvalidNsidError = exports$1.ensureValidNsidRegex = exports$1.ensureValidNsid = exports$1.NSID = void 0;
      class NSID {
        static parse(nsid2) {
          return new NSID(nsid2);
        }
        static create(authority, name) {
          const segments = [...authority.split(".").reverse(), name].join(".");
          return new NSID(segments);
        }
        static isValid(nsid2) {
          try {
            NSID.parse(nsid2);
            return true;
          } catch (e) {
            return false;
          }
        }
        constructor(nsid2) {
          Object.defineProperty(this, "segments", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
          });
          (0, exports$1.ensureValidNsid)(nsid2);
          this.segments = nsid2.split(".");
        }
        get authority() {
          return this.segments.slice(0, this.segments.length - 1).reverse().join(".");
        }
        get name() {
          return this.segments.at(this.segments.length - 1);
        }
        toString() {
          return this.segments.join(".");
        }
      }
      exports$1.NSID = NSID;
      const ensureValidNsid = (nsid2) => {
        const toCheck = nsid2;
        if (!/^[a-zA-Z0-9.-]*$/.test(toCheck)) {
          throw new InvalidNsidError("Disallowed characters in NSID (ASCII letters, digits, dashes, periods only)");
        }
        if (toCheck.length > 253 + 1 + 63) {
          throw new InvalidNsidError("NSID is too long (317 chars max)");
        }
        const labels2 = toCheck.split(".");
        if (labels2.length < 3) {
          throw new InvalidNsidError("NSID needs at least three parts");
        }
        for (let i = 0; i < labels2.length; i++) {
          const l = labels2[i];
          if (l.length < 1) {
            throw new InvalidNsidError("NSID parts can not be empty");
          }
          if (l.length > 63) {
            throw new InvalidNsidError("NSID part too long (max 63 chars)");
          }
          if (l.endsWith("-") || l.startsWith("-")) {
            throw new InvalidNsidError("NSID parts can not start or end with hyphen");
          }
          if (/^[0-9]/.test(l) && i === 0) {
            throw new InvalidNsidError("NSID first part may not start with a digit");
          }
          if (!/^[a-zA-Z]+$/.test(l) && i + 1 === labels2.length) {
            throw new InvalidNsidError("NSID name part must be only letters");
          }
        }
      };
      exports$1.ensureValidNsid = ensureValidNsid;
      const ensureValidNsidRegex = (nsid2) => {
        if (!/^[a-zA-Z]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(\.[a-zA-Z]([a-zA-Z]{0,61}[a-zA-Z])?)$/.test(nsid2)) {
          throw new InvalidNsidError("NSID didn't validate via regex");
        }
        if (nsid2.length > 253 + 1 + 63) {
          throw new InvalidNsidError("NSID is too long (317 chars max)");
        }
      };
      exports$1.ensureValidNsidRegex = ensureValidNsidRegex;
      class InvalidNsidError extends Error {
      }
      exports$1.InvalidNsidError = InvalidNsidError;
    })(nsid);
    return nsid;
  }
  var aturi = {};
  var aturi_validation = {};
  var hasRequiredAturi_validation;
  function requireAturi_validation() {
    if (hasRequiredAturi_validation) return aturi_validation;
    hasRequiredAturi_validation = 1;
    Object.defineProperty(aturi_validation, "__esModule", { value: true });
    aturi_validation.ensureValidAtUriRegex = aturi_validation.ensureValidAtUri = void 0;
    const did_1 = requireDid();
    const handle_1 = requireHandle();
    const nsid_1 = requireNsid();
    const ensureValidAtUri = (uri) => {
      const uriParts = uri.split("#");
      if (uriParts.length > 2) {
        throw new Error('ATURI can have at most one "#", separating fragment out');
      }
      const fragmentPart = uriParts[1] || null;
      uri = uriParts[0];
      if (!/^[a-zA-Z0-9._~:@!$&')(*+,;=%/-]*$/.test(uri)) {
        throw new Error("Disallowed characters in ATURI (ASCII)");
      }
      const parts = uri.split("/");
      if (parts.length >= 3 && (parts[0] !== "at:" || parts[1].length !== 0)) {
        throw new Error('ATURI must start with "at://"');
      }
      if (parts.length < 3) {
        throw new Error("ATURI requires at least method and authority sections");
      }
      try {
        if (parts[2].startsWith("did:")) {
          (0, did_1.ensureValidDid)(parts[2]);
        } else {
          (0, handle_1.ensureValidHandle)(parts[2]);
        }
      } catch {
        throw new Error("ATURI authority must be a valid handle or DID");
      }
      if (parts.length >= 4) {
        if (parts[3].length === 0) {
          throw new Error("ATURI can not have a slash after authority without a path segment");
        }
        try {
          (0, nsid_1.ensureValidNsid)(parts[3]);
        } catch {
          throw new Error("ATURI requires first path segment (if supplied) to be valid NSID");
        }
      }
      if (parts.length >= 5) {
        if (parts[4].length === 0) {
          throw new Error("ATURI can not have a slash after collection, unless record key is provided");
        }
      }
      if (parts.length >= 6) {
        throw new Error("ATURI path can have at most two parts, and no trailing slash");
      }
      if (uriParts.length >= 2 && fragmentPart == null) {
        throw new Error("ATURI fragment must be non-empty and start with slash");
      }
      if (fragmentPart != null) {
        if (fragmentPart.length === 0 || fragmentPart[0] !== "/") {
          throw new Error("ATURI fragment must be non-empty and start with slash");
        }
        if (!/^\/[a-zA-Z0-9._~:@!$&')(*+,;=%[\]/-]*$/.test(fragmentPart)) {
          throw new Error("Disallowed characters in ATURI fragment (ASCII)");
        }
      }
      if (uri.length > 8 * 1024) {
        throw new Error("ATURI is far too long");
      }
    };
    aturi_validation.ensureValidAtUri = ensureValidAtUri;
    const ensureValidAtUriRegex = (uri) => {
      const aturiRegex = /^at:\/\/(?<authority>[a-zA-Z0-9._:%-]+)(\/(?<collection>[a-zA-Z0-9-.]+)(\/(?<rkey>[a-zA-Z0-9._~:@!$&%')(*+,;=-]+))?)?(#(?<fragment>\/[a-zA-Z0-9._~:@!$&%')(*+,;=\-[\]/\\]*))?$/;
      const rm = uri.match(aturiRegex);
      if (!rm || !rm.groups) {
        throw new Error("ATURI didn't validate via regex");
      }
      const groups = rm.groups;
      try {
        (0, handle_1.ensureValidHandleRegex)(groups.authority);
      } catch {
        try {
          (0, did_1.ensureValidDidRegex)(groups.authority);
        } catch {
          throw new Error("ATURI authority must be a valid handle or DID");
        }
      }
      if (groups.collection) {
        try {
          (0, nsid_1.ensureValidNsidRegex)(groups.collection);
        } catch {
          throw new Error("ATURI collection path segment must be a valid NSID");
        }
      }
      if (uri.length > 8 * 1024) {
        throw new Error("ATURI is far too long");
      }
    };
    aturi_validation.ensureValidAtUriRegex = ensureValidAtUriRegex;
    return aturi_validation;
  }
  var hasRequiredAturi;
  function requireAturi() {
    if (hasRequiredAturi) return aturi;
    hasRequiredAturi = 1;
    (function(exports$1) {
      var __createBinding = aturi && aturi.__createBinding || (Object.create ? (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      }));
      var __exportStar = aturi && aturi.__exportStar || function(m, exports$12) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$12, p)) __createBinding(exports$12, m, p);
      };
      Object.defineProperty(exports$1, "__esModule", { value: true });
      exports$1.AtUri = exports$1.ATP_URI_REGEX = void 0;
      __exportStar(requireAturi_validation(), exports$1);
      exports$1.ATP_URI_REGEX = // proto-    --did--------------   --name----------------   --path----   --query--   --hash--
      /^(at:\/\/)?((?:did:[a-z0-9:%-]+)|(?:[a-z0-9][a-z0-9.:-]*))(\/[^?#\s]*)?(\?[^#\s]+)?(#[^\s]+)?$/i;
      const RELATIVE_REGEX = /^(\/[^?#\s]*)?(\?[^#\s]+)?(#[^\s]+)?$/i;
      class AtUri {
        constructor(uri, base3) {
          Object.defineProperty(this, "hash", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "host", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "pathname", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "searchParams", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          let parsed;
          if (base3) {
            parsed = parse(base3);
            if (!parsed) {
              throw new Error(`Invalid at uri: ${base3}`);
            }
            const relativep = parseRelative(uri);
            if (!relativep) {
              throw new Error(`Invalid path: ${uri}`);
            }
            Object.assign(parsed, relativep);
          } else {
            parsed = parse(uri);
            if (!parsed) {
              throw new Error(`Invalid at uri: ${uri}`);
            }
          }
          this.hash = parsed.hash;
          this.host = parsed.host;
          this.pathname = parsed.pathname;
          this.searchParams = parsed.searchParams;
        }
        static make(handleOrDid, collection, rkey) {
          let str = handleOrDid;
          if (collection)
            str += "/" + collection;
          if (rkey)
            str += "/" + rkey;
          return new AtUri(str);
        }
        get protocol() {
          return "at:";
        }
        get origin() {
          return `at://${this.host}`;
        }
        get hostname() {
          return this.host;
        }
        set hostname(v) {
          this.host = v;
        }
        get search() {
          return this.searchParams.toString();
        }
        set search(v) {
          this.searchParams = new URLSearchParams(v);
        }
        get collection() {
          return this.pathname.split("/").filter(Boolean)[0] || "";
        }
        set collection(v) {
          const parts = this.pathname.split("/").filter(Boolean);
          parts[0] = v;
          this.pathname = parts.join("/");
        }
        get rkey() {
          return this.pathname.split("/").filter(Boolean)[1] || "";
        }
        set rkey(v) {
          const parts = this.pathname.split("/").filter(Boolean);
          if (!parts[0])
            parts[0] = "undefined";
          parts[1] = v;
          this.pathname = parts.join("/");
        }
        get href() {
          return this.toString();
        }
        toString() {
          let path = this.pathname || "/";
          if (!path.startsWith("/")) {
            path = `/${path}`;
          }
          let qs = this.searchParams.toString();
          if (qs && !qs.startsWith("?")) {
            qs = `?${qs}`;
          }
          let hash = this.hash;
          if (hash && !hash.startsWith("#")) {
            hash = `#${hash}`;
          }
          return `at://${this.host}${path}${qs}${hash}`;
        }
      }
      exports$1.AtUri = AtUri;
      function parse(str) {
        const match2 = exports$1.ATP_URI_REGEX.exec(str);
        if (match2) {
          return {
            hash: match2[5] || "",
            host: match2[2] || "",
            pathname: match2[3] || "",
            searchParams: new URLSearchParams(match2[4] || "")
          };
        }
        return void 0;
      }
      function parseRelative(str) {
        const match2 = RELATIVE_REGEX.exec(str);
        if (match2) {
          return {
            hash: match2[3] || "",
            pathname: match2[1] || "",
            searchParams: new URLSearchParams(match2[2] || "")
          };
        }
        return void 0;
      }
    })(aturi);
    return aturi;
  }
  var tid$1 = {};
  var hasRequiredTid$1;
  function requireTid$1() {
    if (hasRequiredTid$1) return tid$1;
    hasRequiredTid$1 = 1;
    Object.defineProperty(tid$1, "__esModule", { value: true });
    tid$1.InvalidTidError = tid$1.isValidTid = tid$1.ensureValidTid = void 0;
    const TID_LENGTH = 13;
    const TID_REGEX = /^[234567abcdefghij][234567abcdefghijklmnopqrstuvwxyz]{12}$/;
    const ensureValidTid = (tid2) => {
      if (tid2.length !== TID_LENGTH) {
        throw new InvalidTidError(`TID must be ${TID_LENGTH} characters`);
      }
      if (!TID_REGEX.test(tid2)) {
        throw new InvalidTidError("TID syntax not valid (regex)");
      }
    };
    tid$1.ensureValidTid = ensureValidTid;
    const isValidTid = (tid2) => {
      return tid2.length === TID_LENGTH && TID_REGEX.test(tid2);
    };
    tid$1.isValidTid = isValidTid;
    class InvalidTidError extends Error {
    }
    tid$1.InvalidTidError = InvalidTidError;
    return tid$1;
  }
  var recordkey = {};
  var hasRequiredRecordkey;
  function requireRecordkey() {
    if (hasRequiredRecordkey) return recordkey;
    hasRequiredRecordkey = 1;
    (function(exports$1) {
      Object.defineProperty(exports$1, "__esModule", { value: true });
      exports$1.InvalidRecordKeyError = exports$1.isValidRecordKey = exports$1.ensureValidRecordKey = void 0;
      const ensureValidRecordKey = (rkey) => {
        if (rkey.length > 512 || rkey.length < 1) {
          throw new InvalidRecordKeyError("record key must be 1 to 512 characters");
        }
        if (!/^[a-zA-Z0-9_~.:-]{1,512}$/.test(rkey)) {
          throw new InvalidRecordKeyError("record key syntax not valid (regex)");
        }
        if (rkey === "." || rkey === "..")
          throw new InvalidRecordKeyError('record key can not be "." or ".."');
      };
      exports$1.ensureValidRecordKey = ensureValidRecordKey;
      const isValidRecordKey = (rkey) => {
        try {
          (0, exports$1.ensureValidRecordKey)(rkey);
        } catch (err) {
          if (err instanceof InvalidRecordKeyError) {
            return false;
          }
          throw err;
        }
        return true;
      };
      exports$1.isValidRecordKey = isValidRecordKey;
      class InvalidRecordKeyError extends Error {
      }
      exports$1.InvalidRecordKeyError = InvalidRecordKeyError;
    })(recordkey);
    return recordkey;
  }
  var datetime = {};
  var hasRequiredDatetime;
  function requireDatetime() {
    if (hasRequiredDatetime) return datetime;
    hasRequiredDatetime = 1;
    (function(exports$1) {
      Object.defineProperty(exports$1, "__esModule", { value: true });
      exports$1.InvalidDatetimeError = exports$1.normalizeDatetimeAlways = exports$1.normalizeDatetime = exports$1.isValidDatetime = exports$1.ensureValidDatetime = void 0;
      const ensureValidDatetime = (dtStr) => {
        const date = new Date(dtStr);
        if (isNaN(date.getTime())) {
          throw new InvalidDatetimeError("datetime did not parse as ISO 8601");
        }
        if (date.toISOString().startsWith("-")) {
          throw new InvalidDatetimeError("datetime normalized to a negative time");
        }
        if (!/^[0-9]{4}-[01][0-9]-[0-3][0-9]T[0-2][0-9]:[0-6][0-9]:[0-6][0-9](.[0-9]{1,20})?(Z|([+-][0-2][0-9]:[0-5][0-9]))$/.test(dtStr)) {
          throw new InvalidDatetimeError("datetime didn't validate via regex");
        }
        if (dtStr.length > 64) {
          throw new InvalidDatetimeError("datetime is too long (64 chars max)");
        }
        if (dtStr.endsWith("-00:00")) {
          throw new InvalidDatetimeError('datetime can not use "-00:00" for UTC timezone');
        }
        if (dtStr.startsWith("000")) {
          throw new InvalidDatetimeError("datetime so close to year zero not allowed");
        }
      };
      exports$1.ensureValidDatetime = ensureValidDatetime;
      const isValidDatetime = (dtStr) => {
        try {
          (0, exports$1.ensureValidDatetime)(dtStr);
        } catch (err) {
          if (err instanceof InvalidDatetimeError) {
            return false;
          }
          throw err;
        }
        return true;
      };
      exports$1.isValidDatetime = isValidDatetime;
      const normalizeDatetime = (dtStr) => {
        if ((0, exports$1.isValidDatetime)(dtStr)) {
          const outStr = new Date(dtStr).toISOString();
          if ((0, exports$1.isValidDatetime)(outStr)) {
            return outStr;
          }
        }
        if (!/.*(([+-]\d\d:?\d\d)|[a-zA-Z])$/.test(dtStr)) {
          const date2 = /* @__PURE__ */ new Date(dtStr + "Z");
          if (!isNaN(date2.getTime())) {
            const tzStr = date2.toISOString();
            if ((0, exports$1.isValidDatetime)(tzStr)) {
              return tzStr;
            }
          }
        }
        const date = new Date(dtStr);
        if (isNaN(date.getTime())) {
          throw new InvalidDatetimeError("datetime did not parse as any timestamp format");
        }
        const isoStr = date.toISOString();
        if ((0, exports$1.isValidDatetime)(isoStr)) {
          return isoStr;
        } else {
          throw new InvalidDatetimeError("datetime normalized to invalid timestamp string");
        }
      };
      exports$1.normalizeDatetime = normalizeDatetime;
      const normalizeDatetimeAlways = (dtStr) => {
        try {
          return (0, exports$1.normalizeDatetime)(dtStr);
        } catch (err) {
          if (err instanceof InvalidDatetimeError) {
            return (/* @__PURE__ */ new Date(0)).toISOString();
          }
          throw err;
        }
      };
      exports$1.normalizeDatetimeAlways = normalizeDatetimeAlways;
      class InvalidDatetimeError extends Error {
      }
      exports$1.InvalidDatetimeError = InvalidDatetimeError;
    })(datetime);
    return datetime;
  }
  var hasRequiredDist$5;
  function requireDist$5() {
    if (hasRequiredDist$5) return dist$3;
    hasRequiredDist$5 = 1;
    (function(exports$1) {
      var __createBinding = dist$3 && dist$3.__createBinding || (Object.create ? (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      }));
      var __exportStar = dist$3 && dist$3.__exportStar || function(m, exports$12) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$12, p)) __createBinding(exports$12, m, p);
      };
      Object.defineProperty(exports$1, "__esModule", { value: true });
      __exportStar(requireHandle(), exports$1);
      __exportStar(requireDid(), exports$1);
      __exportStar(requireNsid(), exports$1);
      __exportStar(requireAturi(), exports$1);
      __exportStar(requireTid$1(), exports$1);
      __exportStar(requireRecordkey(), exports$1);
      __exportStar(requireDatetime(), exports$1);
    })(dist$3);
    return dist$3;
  }
  var util$7 = {};
  var hasRequiredUtil$7;
  function requireUtil$7() {
    if (hasRequiredUtil$7) return util$7;
    hasRequiredUtil$7 = 1;
    Object.defineProperty(util$7, "__esModule", { value: true });
    util$7.toLexUri = toLexUri;
    util$7.requiredPropertiesRefinement = requiredPropertiesRefinement;
    const zod_1 = /* @__PURE__ */ requireLib$1();
    function toLexUri(str, baseUri) {
      if (str.split("#").length > 2) {
        throw new Error("Uri can only have one hash segment");
      }
      if (str.startsWith("lex:")) {
        return str;
      }
      if (str.startsWith("#")) {
        if (!baseUri) {
          throw new Error(`Unable to resolve uri without anchor: ${str}`);
        }
        return `${baseUri}${str}`;
      }
      return `lex:${str}`;
    }
    function requiredPropertiesRefinement(object, ctx) {
      if (object.required === void 0) {
        return;
      }
      if (!Array.isArray(object.required)) {
        ctx.addIssue({
          code: zod_1.z.ZodIssueCode.invalid_type,
          received: typeof object.required,
          expected: "array"
        });
        return;
      }
      if (object.properties === void 0) {
        if (object.required.length > 0) {
          ctx.addIssue({
            code: zod_1.z.ZodIssueCode.custom,
            message: `Required fields defined but no properties defined`
          });
        }
        return;
      }
      for (const field of object.required) {
        if (object.properties[field] === void 0) {
          ctx.addIssue({
            code: zod_1.z.ZodIssueCode.custom,
            message: `Required field "${field}" not defined`
          });
        }
      }
    }
    return util$7;
  }
  var hasRequiredTypes$4;
  function requireTypes$4() {
    if (hasRequiredTypes$4) return types$5;
    hasRequiredTypes$4 = 1;
    (function(exports$1) {
      Object.defineProperty(exports$1, "__esModule", { value: true });
      exports$1.LexiconDefNotFoundError = exports$1.InvalidLexiconError = exports$1.ValidationError = exports$1.lexiconDoc = exports$1.lexUserType = exports$1.lexRecord = exports$1.lexXrpcSubscription = exports$1.lexXrpcProcedure = exports$1.lexXrpcQuery = exports$1.lexXrpcError = exports$1.lexXrpcSubscriptionMessage = exports$1.lexXrpcBody = exports$1.lexXrpcParameters = exports$1.lexObject = exports$1.lexToken = exports$1.lexPrimitiveArray = exports$1.lexArray = exports$1.lexBlob = exports$1.lexRefVariant = exports$1.lexRefUnion = exports$1.lexRef = exports$1.lexIpldType = exports$1.lexCidLink = exports$1.lexBytes = exports$1.lexPrimitive = exports$1.lexUnknown = exports$1.lexString = exports$1.lexStringFormat = exports$1.lexInteger = exports$1.lexBoolean = void 0;
      exports$1.isValidLexiconDoc = isValidLexiconDoc;
      exports$1.isObj = isObj;
      exports$1.isDiscriminatedObject = isDiscriminatedObject;
      exports$1.parseLexiconDoc = parseLexiconDoc;
      const zod_1 = /* @__PURE__ */ requireLib$1();
      const syntax_1 = requireDist$5();
      const util_1 = requireUtil$7();
      exports$1.lexBoolean = zod_1.z.object({
        type: zod_1.z.literal("boolean"),
        description: zod_1.z.string().optional(),
        default: zod_1.z.boolean().optional(),
        const: zod_1.z.boolean().optional()
      }).strict();
      exports$1.lexInteger = zod_1.z.object({
        type: zod_1.z.literal("integer"),
        description: zod_1.z.string().optional(),
        default: zod_1.z.number().int().optional(),
        minimum: zod_1.z.number().int().optional(),
        maximum: zod_1.z.number().int().optional(),
        enum: zod_1.z.number().int().array().optional(),
        const: zod_1.z.number().int().optional()
      }).strict();
      exports$1.lexStringFormat = zod_1.z.enum([
        "datetime",
        "uri",
        "at-uri",
        "did",
        "handle",
        "at-identifier",
        "nsid",
        "cid",
        "language",
        "tid",
        "record-key"
      ]);
      exports$1.lexString = zod_1.z.object({
        type: zod_1.z.literal("string"),
        format: exports$1.lexStringFormat.optional(),
        description: zod_1.z.string().optional(),
        default: zod_1.z.string().optional(),
        minLength: zod_1.z.number().int().optional(),
        maxLength: zod_1.z.number().int().optional(),
        minGraphemes: zod_1.z.number().int().optional(),
        maxGraphemes: zod_1.z.number().int().optional(),
        enum: zod_1.z.string().array().optional(),
        const: zod_1.z.string().optional(),
        knownValues: zod_1.z.string().array().optional()
      }).strict();
      exports$1.lexUnknown = zod_1.z.object({
        type: zod_1.z.literal("unknown"),
        description: zod_1.z.string().optional()
      }).strict();
      exports$1.lexPrimitive = zod_1.z.discriminatedUnion("type", [
        exports$1.lexBoolean,
        exports$1.lexInteger,
        exports$1.lexString,
        exports$1.lexUnknown
      ]);
      exports$1.lexBytes = zod_1.z.object({
        type: zod_1.z.literal("bytes"),
        description: zod_1.z.string().optional(),
        maxLength: zod_1.z.number().optional(),
        minLength: zod_1.z.number().optional()
      }).strict();
      exports$1.lexCidLink = zod_1.z.object({
        type: zod_1.z.literal("cid-link"),
        description: zod_1.z.string().optional()
      }).strict();
      exports$1.lexIpldType = zod_1.z.discriminatedUnion("type", [exports$1.lexBytes, exports$1.lexCidLink]);
      exports$1.lexRef = zod_1.z.object({
        type: zod_1.z.literal("ref"),
        description: zod_1.z.string().optional(),
        ref: zod_1.z.string()
      }).strict();
      exports$1.lexRefUnion = zod_1.z.object({
        type: zod_1.z.literal("union"),
        description: zod_1.z.string().optional(),
        refs: zod_1.z.string().array(),
        closed: zod_1.z.boolean().optional()
      }).strict();
      exports$1.lexRefVariant = zod_1.z.discriminatedUnion("type", [exports$1.lexRef, exports$1.lexRefUnion]);
      exports$1.lexBlob = zod_1.z.object({
        type: zod_1.z.literal("blob"),
        description: zod_1.z.string().optional(),
        accept: zod_1.z.string().array().optional(),
        maxSize: zod_1.z.number().optional()
      }).strict();
      exports$1.lexArray = zod_1.z.object({
        type: zod_1.z.literal("array"),
        description: zod_1.z.string().optional(),
        items: zod_1.z.discriminatedUnion("type", [
          // lexPrimitive
          exports$1.lexBoolean,
          exports$1.lexInteger,
          exports$1.lexString,
          exports$1.lexUnknown,
          // lexIpldType
          exports$1.lexBytes,
          exports$1.lexCidLink,
          // lexRefVariant
          exports$1.lexRef,
          exports$1.lexRefUnion,
          // other
          exports$1.lexBlob
        ]),
        minLength: zod_1.z.number().int().optional(),
        maxLength: zod_1.z.number().int().optional()
      }).strict();
      exports$1.lexPrimitiveArray = exports$1.lexArray.merge(zod_1.z.object({
        items: exports$1.lexPrimitive
      }).strict());
      exports$1.lexToken = zod_1.z.object({
        type: zod_1.z.literal("token"),
        description: zod_1.z.string().optional()
      }).strict();
      exports$1.lexObject = zod_1.z.object({
        type: zod_1.z.literal("object"),
        description: zod_1.z.string().optional(),
        required: zod_1.z.string().array().optional(),
        nullable: zod_1.z.string().array().optional(),
        properties: zod_1.z.record(zod_1.z.discriminatedUnion("type", [
          exports$1.lexArray,
          // lexPrimitive
          exports$1.lexBoolean,
          exports$1.lexInteger,
          exports$1.lexString,
          exports$1.lexUnknown,
          // lexIpldType
          exports$1.lexBytes,
          exports$1.lexCidLink,
          // lexRefVariant
          exports$1.lexRef,
          exports$1.lexRefUnion,
          // other
          exports$1.lexBlob
        ]))
      }).strict().superRefine(util_1.requiredPropertiesRefinement);
      exports$1.lexXrpcParameters = zod_1.z.object({
        type: zod_1.z.literal("params"),
        description: zod_1.z.string().optional(),
        required: zod_1.z.string().array().optional(),
        properties: zod_1.z.record(zod_1.z.discriminatedUnion("type", [
          exports$1.lexPrimitiveArray,
          // lexPrimitive
          exports$1.lexBoolean,
          exports$1.lexInteger,
          exports$1.lexString,
          exports$1.lexUnknown
        ]))
      }).strict().superRefine(util_1.requiredPropertiesRefinement);
      exports$1.lexXrpcBody = zod_1.z.object({
        description: zod_1.z.string().optional(),
        encoding: zod_1.z.string(),
        // @NOTE using discriminatedUnion with a refined schema requires zod >= 4
        schema: zod_1.z.union([exports$1.lexRefVariant, exports$1.lexObject]).optional()
      }).strict();
      exports$1.lexXrpcSubscriptionMessage = zod_1.z.object({
        description: zod_1.z.string().optional(),
        // @NOTE using discriminatedUnion with a refined schema requires zod >= 4
        schema: zod_1.z.union([exports$1.lexRefVariant, exports$1.lexObject]).optional()
      }).strict();
      exports$1.lexXrpcError = zod_1.z.object({
        name: zod_1.z.string(),
        description: zod_1.z.string().optional()
      }).strict();
      exports$1.lexXrpcQuery = zod_1.z.object({
        type: zod_1.z.literal("query"),
        description: zod_1.z.string().optional(),
        parameters: exports$1.lexXrpcParameters.optional(),
        output: exports$1.lexXrpcBody.optional(),
        errors: exports$1.lexXrpcError.array().optional()
      }).strict();
      exports$1.lexXrpcProcedure = zod_1.z.object({
        type: zod_1.z.literal("procedure"),
        description: zod_1.z.string().optional(),
        parameters: exports$1.lexXrpcParameters.optional(),
        input: exports$1.lexXrpcBody.optional(),
        output: exports$1.lexXrpcBody.optional(),
        errors: exports$1.lexXrpcError.array().optional()
      }).strict();
      exports$1.lexXrpcSubscription = zod_1.z.object({
        type: zod_1.z.literal("subscription"),
        description: zod_1.z.string().optional(),
        parameters: exports$1.lexXrpcParameters.optional(),
        message: exports$1.lexXrpcSubscriptionMessage.optional(),
        errors: exports$1.lexXrpcError.array().optional()
      }).strict();
      exports$1.lexRecord = zod_1.z.object({
        type: zod_1.z.literal("record"),
        description: zod_1.z.string().optional(),
        key: zod_1.z.string().optional(),
        record: exports$1.lexObject
      }).strict();
      exports$1.lexUserType = zod_1.z.custom((val) => {
        if (!val || typeof val !== "object") {
          return;
        }
        if (val["type"] === void 0) {
          return;
        }
        switch (val["type"]) {
          case "record":
            return exports$1.lexRecord.parse(val);
          case "query":
            return exports$1.lexXrpcQuery.parse(val);
          case "procedure":
            return exports$1.lexXrpcProcedure.parse(val);
          case "subscription":
            return exports$1.lexXrpcSubscription.parse(val);
          case "blob":
            return exports$1.lexBlob.parse(val);
          case "array":
            return exports$1.lexArray.parse(val);
          case "token":
            return exports$1.lexToken.parse(val);
          case "object":
            return exports$1.lexObject.parse(val);
          case "boolean":
            return exports$1.lexBoolean.parse(val);
          case "integer":
            return exports$1.lexInteger.parse(val);
          case "string":
            return exports$1.lexString.parse(val);
          case "bytes":
            return exports$1.lexBytes.parse(val);
          case "cid-link":
            return exports$1.lexCidLink.parse(val);
          case "unknown":
            return exports$1.lexUnknown.parse(val);
        }
      }, (val) => {
        if (!val || typeof val !== "object") {
          return {
            message: "Must be an object",
            fatal: true
          };
        }
        if (val["type"] === void 0) {
          return {
            message: "Must have a type",
            fatal: true
          };
        }
        if (typeof val["type"] !== "string") {
          return {
            message: "Type property must be a string",
            fatal: true
          };
        }
        return {
          message: `Invalid type: ${val["type"]} must be one of: record, query, procedure, subscription, blob, array, token, object, boolean, integer, string, bytes, cid-link, unknown`,
          fatal: true
        };
      });
      exports$1.lexiconDoc = zod_1.z.object({
        lexicon: zod_1.z.literal(1),
        id: zod_1.z.string().refine((v) => syntax_1.NSID.isValid(v), {
          message: "Must be a valid NSID"
        }),
        revision: zod_1.z.number().optional(),
        description: zod_1.z.string().optional(),
        defs: zod_1.z.record(exports$1.lexUserType)
      }).strict().superRefine((doc, ctx) => {
        for (const defId in doc.defs) {
          const def = doc.defs[defId];
          if (defId !== "main" && (def.type === "record" || def.type === "procedure" || def.type === "query" || def.type === "subscription")) {
            ctx.addIssue({
              code: zod_1.z.ZodIssueCode.custom,
              message: `Records, procedures, queries, and subscriptions must be the main definition.`
            });
          }
        }
      });
      function isValidLexiconDoc(v) {
        return exports$1.lexiconDoc.safeParse(v).success;
      }
      function isObj(v) {
        return v != null && typeof v === "object";
      }
      function isDiscriminatedObject(v) {
        return isObj(v) && "$type" in v && typeof v.$type === "string";
      }
      function parseLexiconDoc(v) {
        exports$1.lexiconDoc.parse(v);
        return v;
      }
      class ValidationError extends Error {
      }
      exports$1.ValidationError = ValidationError;
      class InvalidLexiconError extends Error {
      }
      exports$1.InvalidLexiconError = InvalidLexiconError;
      class LexiconDefNotFoundError extends Error {
      }
      exports$1.LexiconDefNotFoundError = LexiconDefNotFoundError;
    })(types$5);
    return types$5;
  }
  var lexicons$1 = {};
  var validation = {};
  var complex = {};
  var blob = {};
  var blobRefs = {};
  var encode_1 = encode$2;
  var MSB = 128, MSBALL = -128, INT = Math.pow(2, 31);
  function encode$2(num, out, offset) {
    out = out || [];
    offset = offset || 0;
    var oldOffset = offset;
    while (num >= INT) {
      out[offset++] = num & 255 | MSB;
      num /= 128;
    }
    while (num & MSBALL) {
      out[offset++] = num & 255 | MSB;
      num >>>= 7;
    }
    out[offset] = num | 0;
    encode$2.bytes = offset - oldOffset + 1;
    return out;
  }
  var decode$4 = read;
  var MSB$1 = 128, REST$1 = 127;
  function read(buf, offset) {
    var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;
    do {
      if (counter >= l) {
        read.bytes = 0;
        throw new RangeError("Could not decode varint");
      }
      b = buf[counter++];
      res += shift < 28 ? (b & REST$1) << shift : (b & REST$1) * Math.pow(2, shift);
      shift += 7;
    } while (b >= MSB$1);
    read.bytes = counter - offset;
    return res;
  }
  var N1 = Math.pow(2, 7);
  var N2 = Math.pow(2, 14);
  var N3 = Math.pow(2, 21);
  var N4 = Math.pow(2, 28);
  var N5 = Math.pow(2, 35);
  var N6 = Math.pow(2, 42);
  var N7 = Math.pow(2, 49);
  var N8 = Math.pow(2, 56);
  var N9 = Math.pow(2, 63);
  var length = function(value) {
    return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
  };
  var varint = {
    encode: encode_1,
    decode: decode$4,
    encodingLength: length
  };
  var _brrp_varint = varint;
  const decode$3 = (data, offset = 0) => {
    const code = _brrp_varint.decode(data, offset);
    return [
      code,
      _brrp_varint.decode.bytes
    ];
  };
  const encodeTo = (int, target2, offset = 0) => {
    _brrp_varint.encode(int, target2, offset);
    return target2;
  };
  const encodingLength = (int) => {
    return _brrp_varint.encodingLength(int);
  };
  const equals$2 = (aa, bb) => {
    if (aa === bb)
      return true;
    if (aa.byteLength !== bb.byteLength) {
      return false;
    }
    for (let ii = 0; ii < aa.byteLength; ii++) {
      if (aa[ii] !== bb[ii]) {
        return false;
      }
    }
    return true;
  };
  const coerce = (o) => {
    if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
      return o;
    if (o instanceof ArrayBuffer)
      return new Uint8Array(o);
    if (ArrayBuffer.isView(o)) {
      return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
    }
    throw new Error("Unknown type, must be binary type");
  };
  const fromString$1 = (str) => new TextEncoder().encode(str);
  const toString$1 = (b) => new TextDecoder().decode(b);
  const create = (code, digest) => {
    const size = digest.byteLength;
    const sizeOffset = encodingLength(code);
    const digestOffset = sizeOffset + encodingLength(size);
    const bytes = new Uint8Array(digestOffset + size);
    encodeTo(code, bytes, 0);
    encodeTo(size, bytes, sizeOffset);
    bytes.set(digest, digestOffset);
    return new Digest(code, size, digest, bytes);
  };
  const decode$2 = (multihash) => {
    const bytes = coerce(multihash);
    const [code, sizeOffset] = decode$3(bytes);
    const [size, digestOffset] = decode$3(bytes.subarray(sizeOffset));
    const digest = bytes.subarray(sizeOffset + digestOffset);
    if (digest.byteLength !== size) {
      throw new Error("Incorrect length");
    }
    return new Digest(code, size, digest, bytes);
  };
  const equals$1 = (a, b) => {
    if (a === b) {
      return true;
    } else {
      return a.code === b.code && a.size === b.size && equals$2(a.bytes, b.bytes);
    }
  };
  class Digest {
    constructor(code, size, digest, bytes) {
      this.code = code;
      this.size = size;
      this.digest = digest;
      this.bytes = bytes;
    }
  }
  function base$2(ALPHABET, name) {
    if (ALPHABET.length >= 255) {
      throw new TypeError("Alphabet too long");
    }
    var BASE_MAP = new Uint8Array(256);
    for (var j = 0; j < BASE_MAP.length; j++) {
      BASE_MAP[j] = 255;
    }
    for (var i = 0; i < ALPHABET.length; i++) {
      var x = ALPHABET.charAt(i);
      var xc = x.charCodeAt(0);
      if (BASE_MAP[xc] !== 255) {
        throw new TypeError(x + " is ambiguous");
      }
      BASE_MAP[xc] = i;
    }
    var BASE = ALPHABET.length;
    var LEADER = ALPHABET.charAt(0);
    var FACTOR = Math.log(BASE) / Math.log(256);
    var iFACTOR = Math.log(256) / Math.log(BASE);
    function encode2(source) {
      if (source instanceof Uint8Array) ;
      else if (ArrayBuffer.isView(source)) {
        source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
      } else if (Array.isArray(source)) {
        source = Uint8Array.from(source);
      }
      if (!(source instanceof Uint8Array)) {
        throw new TypeError("Expected Uint8Array");
      }
      if (source.length === 0) {
        return "";
      }
      var zeroes = 0;
      var length2 = 0;
      var pbegin = 0;
      var pend = source.length;
      while (pbegin !== pend && source[pbegin] === 0) {
        pbegin++;
        zeroes++;
      }
      var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
      var b58 = new Uint8Array(size);
      while (pbegin !== pend) {
        var carry = source[pbegin];
        var i2 = 0;
        for (var it1 = size - 1; (carry !== 0 || i2 < length2) && it1 !== -1; it1--, i2++) {
          carry += 256 * b58[it1] >>> 0;
          b58[it1] = carry % BASE >>> 0;
          carry = carry / BASE >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length2 = i2;
        pbegin++;
      }
      var it2 = size - length2;
      while (it2 !== size && b58[it2] === 0) {
        it2++;
      }
      var str = LEADER.repeat(zeroes);
      for (; it2 < size; ++it2) {
        str += ALPHABET.charAt(b58[it2]);
      }
      return str;
    }
    function decodeUnsafe(source) {
      if (typeof source !== "string") {
        throw new TypeError("Expected String");
      }
      if (source.length === 0) {
        return new Uint8Array();
      }
      var psz = 0;
      if (source[psz] === " ") {
        return;
      }
      var zeroes = 0;
      var length2 = 0;
      while (source[psz] === LEADER) {
        zeroes++;
        psz++;
      }
      var size = (source.length - psz) * FACTOR + 1 >>> 0;
      var b256 = new Uint8Array(size);
      while (source[psz]) {
        var carry = BASE_MAP[source.charCodeAt(psz)];
        if (carry === 255) {
          return;
        }
        var i2 = 0;
        for (var it3 = size - 1; (carry !== 0 || i2 < length2) && it3 !== -1; it3--, i2++) {
          carry += BASE * b256[it3] >>> 0;
          b256[it3] = carry % 256 >>> 0;
          carry = carry / 256 >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length2 = i2;
        psz++;
      }
      if (source[psz] === " ") {
        return;
      }
      var it4 = size - length2;
      while (it4 !== size && b256[it4] === 0) {
        it4++;
      }
      var vch = new Uint8Array(zeroes + (size - it4));
      var j2 = zeroes;
      while (it4 !== size) {
        vch[j2++] = b256[it4++];
      }
      return vch;
    }
    function decode2(string2) {
      var buffer = decodeUnsafe(string2);
      if (buffer) {
        return buffer;
      }
      throw new Error(`Non-${name} character`);
    }
    return {
      encode: encode2,
      decodeUnsafe,
      decode: decode2
    };
  }
  var src$1 = base$2;
  var _brrp__multiformats_scope_baseX = src$1;
  class Encoder {
    constructor(name, prefix, baseEncode) {
      this.name = name;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
    }
    encode(bytes) {
      if (bytes instanceof Uint8Array) {
        return `${this.prefix}${this.baseEncode(bytes)}`;
      } else {
        throw Error("Unknown type, must be binary type");
      }
    }
  }
  class Decoder {
    constructor(name, prefix, baseDecode) {
      this.name = name;
      this.prefix = prefix;
      if (prefix.codePointAt(0) === void 0) {
        throw new Error("Invalid prefix character");
      }
      this.prefixCodePoint = prefix.codePointAt(0);
      this.baseDecode = baseDecode;
    }
    decode(text) {
      if (typeof text === "string") {
        if (text.codePointAt(0) !== this.prefixCodePoint) {
          throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
        }
        return this.baseDecode(text.slice(this.prefix.length));
      } else {
        throw Error("Can only multibase decode strings");
      }
    }
    or(decoder) {
      return or(this, decoder);
    }
  }
  class ComposedDecoder {
    constructor(decoders) {
      this.decoders = decoders;
    }
    or(decoder) {
      return or(this, decoder);
    }
    decode(input) {
      const prefix = input[0];
      const decoder = this.decoders[prefix];
      if (decoder) {
        return decoder.decode(input);
      } else {
        throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
      }
    }
  }
  const or = (left, right) => new ComposedDecoder({
    ...left.decoders || { [left.prefix]: left },
    ...right.decoders || { [right.prefix]: right }
  });
  class Codec {
    constructor(name, prefix, baseEncode, baseDecode) {
      this.name = name;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
      this.baseDecode = baseDecode;
      this.encoder = new Encoder(name, prefix, baseEncode);
      this.decoder = new Decoder(name, prefix, baseDecode);
    }
    encode(input) {
      return this.encoder.encode(input);
    }
    decode(input) {
      return this.decoder.decode(input);
    }
  }
  const from = ({ name, prefix, encode: encode2, decode: decode2 }) => new Codec(name, prefix, encode2, decode2);
  const baseX = ({ prefix, name, alphabet: alphabet2 }) => {
    const { encode: encode2, decode: decode2 } = _brrp__multiformats_scope_baseX(alphabet2, name);
    return from({
      prefix,
      name,
      encode: encode2,
      decode: (text) => coerce(decode2(text))
    });
  };
  const decode$1 = (string2, alphabet2, bitsPerChar, name) => {
    const codes = {};
    for (let i = 0; i < alphabet2.length; ++i) {
      codes[alphabet2[i]] = i;
    }
    let end = string2.length;
    while (string2[end - 1] === "=") {
      --end;
    }
    const out = new Uint8Array(end * bitsPerChar / 8 | 0);
    let bits = 0;
    let buffer = 0;
    let written = 0;
    for (let i = 0; i < end; ++i) {
      const value = codes[string2[i]];
      if (value === void 0) {
        throw new SyntaxError(`Non-${name} character`);
      }
      buffer = buffer << bitsPerChar | value;
      bits += bitsPerChar;
      if (bits >= 8) {
        bits -= 8;
        out[written++] = 255 & buffer >> bits;
      }
    }
    if (bits >= bitsPerChar || 255 & buffer << 8 - bits) {
      throw new SyntaxError("Unexpected end of data");
    }
    return out;
  };
  const encode$1 = (data, alphabet2, bitsPerChar) => {
    const pad = alphabet2[alphabet2.length - 1] === "=";
    const mask = (1 << bitsPerChar) - 1;
    let out = "";
    let bits = 0;
    let buffer = 0;
    for (let i = 0; i < data.length; ++i) {
      buffer = buffer << 8 | data[i];
      bits += 8;
      while (bits > bitsPerChar) {
        bits -= bitsPerChar;
        out += alphabet2[mask & buffer >> bits];
      }
    }
    if (bits) {
      out += alphabet2[mask & buffer << bitsPerChar - bits];
    }
    if (pad) {
      while (out.length * bitsPerChar & 7) {
        out += "=";
      }
    }
    return out;
  };
  const rfc4648 = ({ name, prefix, bitsPerChar, alphabet: alphabet2 }) => {
    return from({
      prefix,
      name,
      encode(input) {
        return encode$1(input, alphabet2, bitsPerChar);
      },
      decode(input) {
        return decode$1(input, alphabet2, bitsPerChar, name);
      }
    });
  };
  const base58btc = baseX({
    name: "base58btc",
    prefix: "z",
    alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
  });
  const base58flickr = baseX({
    name: "base58flickr",
    prefix: "Z",
    alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
  });
  const base58 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    base58btc,
    base58flickr
  }, Symbol.toStringTag, { value: "Module" }));
  const base32 = rfc4648({
    prefix: "b",
    name: "base32",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567",
    bitsPerChar: 5
  });
  const base32upper = rfc4648({
    prefix: "B",
    name: "base32upper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
    bitsPerChar: 5
  });
  const base32pad = rfc4648({
    prefix: "c",
    name: "base32pad",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
    bitsPerChar: 5
  });
  const base32padupper = rfc4648({
    prefix: "C",
    name: "base32padupper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
    bitsPerChar: 5
  });
  const base32hex = rfc4648({
    prefix: "v",
    name: "base32hex",
    alphabet: "0123456789abcdefghijklmnopqrstuv",
    bitsPerChar: 5
  });
  const base32hexupper = rfc4648({
    prefix: "V",
    name: "base32hexupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
    bitsPerChar: 5
  });
  const base32hexpad = rfc4648({
    prefix: "t",
    name: "base32hexpad",
    alphabet: "0123456789abcdefghijklmnopqrstuv=",
    bitsPerChar: 5
  });
  const base32hexpadupper = rfc4648({
    prefix: "T",
    name: "base32hexpadupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
    bitsPerChar: 5
  });
  const base32z = rfc4648({
    prefix: "h",
    name: "base32z",
    alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
    bitsPerChar: 5
  });
  const base32$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    base32,
    base32hex,
    base32hexpad,
    base32hexpadupper,
    base32hexupper,
    base32pad,
    base32padupper,
    base32upper,
    base32z
  }, Symbol.toStringTag, { value: "Module" }));
  class CID {
    constructor(version2, code, multihash, bytes) {
      this.code = code;
      this.version = version2;
      this.multihash = multihash;
      this.bytes = bytes;
      this.byteOffset = bytes.byteOffset;
      this.byteLength = bytes.byteLength;
      this.asCID = this;
      this._baseCache = /* @__PURE__ */ new Map();
      Object.defineProperties(this, {
        byteOffset: hidden,
        byteLength: hidden,
        code: readonly,
        version: readonly,
        multihash: readonly,
        bytes: readonly,
        _baseCache: hidden,
        asCID: hidden
      });
    }
    toV0() {
      switch (this.version) {
        case 0: {
          return this;
        }
        default: {
          const { code, multihash } = this;
          if (code !== DAG_PB_CODE) {
            throw new Error("Cannot convert a non dag-pb CID to CIDv0");
          }
          if (multihash.code !== SHA_256_CODE) {
            throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
          }
          return CID.createV0(multihash);
        }
      }
    }
    toV1() {
      switch (this.version) {
        case 0: {
          const { code, digest } = this.multihash;
          const multihash = create(code, digest);
          return CID.createV1(this.code, multihash);
        }
        case 1: {
          return this;
        }
        default: {
          throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
        }
      }
    }
    equals(other) {
      return other && this.code === other.code && this.version === other.version && equals$1(this.multihash, other.multihash);
    }
    toString(base3) {
      const { bytes, version: version2, _baseCache } = this;
      switch (version2) {
        case 0:
          return toStringV0(bytes, _baseCache, base3 || base58btc.encoder);
        default:
          return toStringV1(bytes, _baseCache, base3 || base32.encoder);
      }
    }
    toJSON() {
      return {
        code: this.code,
        version: this.version,
        hash: this.multihash.bytes
      };
    }
    get [Symbol.toStringTag]() {
      return "CID";
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
      return "CID(" + this.toString() + ")";
    }
    static isCID(value) {
      deprecate(/^0\.0/, IS_CID_DEPRECATION);
      return !!(value && (value[cidSymbol] || value.asCID === value));
    }
    get toBaseEncodedString() {
      throw new Error("Deprecated, use .toString()");
    }
    get codec() {
      throw new Error('"codec" property is deprecated, use integer "code" property instead');
    }
    get buffer() {
      throw new Error("Deprecated .buffer property, use .bytes to get Uint8Array instead");
    }
    get multibaseName() {
      throw new Error('"multibaseName" property is deprecated');
    }
    get prefix() {
      throw new Error('"prefix" property is deprecated');
    }
    static asCID(value) {
      if (value instanceof CID) {
        return value;
      } else if (value != null && value.asCID === value) {
        const { version: version2, code, multihash, bytes } = value;
        return new CID(version2, code, multihash, bytes || encodeCID(version2, code, multihash.bytes));
      } else if (value != null && value[cidSymbol] === true) {
        const { version: version2, multihash, code } = value;
        const digest = decode$2(multihash);
        return CID.create(version2, code, digest);
      } else {
        return null;
      }
    }
    static create(version2, code, digest) {
      if (typeof code !== "number") {
        throw new Error("String codecs are no longer supported");
      }
      switch (version2) {
        case 0: {
          if (code !== DAG_PB_CODE) {
            throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`);
          } else {
            return new CID(version2, code, digest, digest.bytes);
          }
        }
        case 1: {
          const bytes = encodeCID(version2, code, digest.bytes);
          return new CID(version2, code, digest, bytes);
        }
        default: {
          throw new Error("Invalid version");
        }
      }
    }
    static createV0(digest) {
      return CID.create(0, DAG_PB_CODE, digest);
    }
    static createV1(code, digest) {
      return CID.create(1, code, digest);
    }
    static decode(bytes) {
      const [cid2, remainder] = CID.decodeFirst(bytes);
      if (remainder.length) {
        throw new Error("Incorrect length");
      }
      return cid2;
    }
    static decodeFirst(bytes) {
      const specs = CID.inspectBytes(bytes);
      const prefixSize = specs.size - specs.multihashSize;
      const multihashBytes = coerce(bytes.subarray(prefixSize, prefixSize + specs.multihashSize));
      if (multihashBytes.byteLength !== specs.multihashSize) {
        throw new Error("Incorrect length");
      }
      const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
      const digest = new Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
      const cid2 = specs.version === 0 ? CID.createV0(digest) : CID.createV1(specs.codec, digest);
      return [
        cid2,
        bytes.subarray(specs.size)
      ];
    }
    static inspectBytes(initialBytes) {
      let offset = 0;
      const next = () => {
        const [i, length2] = decode$3(initialBytes.subarray(offset));
        offset += length2;
        return i;
      };
      let version2 = next();
      let codec = DAG_PB_CODE;
      if (version2 === 18) {
        version2 = 0;
        offset = 0;
      } else if (version2 === 1) {
        codec = next();
      }
      if (version2 !== 0 && version2 !== 1) {
        throw new RangeError(`Invalid CID version ${version2}`);
      }
      const prefixSize = offset;
      const multihashCode = next();
      const digestSize = next();
      const size = offset + digestSize;
      const multihashSize = size - prefixSize;
      return {
        version: version2,
        codec,
        multihashCode,
        digestSize,
        multihashSize,
        size
      };
    }
    static parse(source, base3) {
      const [prefix, bytes] = parseCIDtoBytes(source, base3);
      const cid2 = CID.decode(bytes);
      cid2._baseCache.set(prefix, source);
      return cid2;
    }
  }
  const parseCIDtoBytes = (source, base3) => {
    switch (source[0]) {
      case "Q": {
        const decoder = base3 || base58btc;
        return [
          base58btc.prefix,
          decoder.decode(`${base58btc.prefix}${source}`)
        ];
      }
      case base58btc.prefix: {
        const decoder = base3 || base58btc;
        return [
          base58btc.prefix,
          decoder.decode(source)
        ];
      }
      case base32.prefix: {
        const decoder = base3 || base32;
        return [
          base32.prefix,
          decoder.decode(source)
        ];
      }
      default: {
        if (base3 == null) {
          throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
        }
        return [
          source[0],
          base3.decode(source)
        ];
      }
    }
  };
  const toStringV0 = (bytes, cache2, base3) => {
    const { prefix } = base3;
    if (prefix !== base58btc.prefix) {
      throw Error(`Cannot string encode V0 in ${base3.name} encoding`);
    }
    const cid2 = cache2.get(prefix);
    if (cid2 == null) {
      const cid3 = base3.encode(bytes).slice(1);
      cache2.set(prefix, cid3);
      return cid3;
    } else {
      return cid2;
    }
  };
  const toStringV1 = (bytes, cache2, base3) => {
    const { prefix } = base3;
    const cid2 = cache2.get(prefix);
    if (cid2 == null) {
      const cid3 = base3.encode(bytes);
      cache2.set(prefix, cid3);
      return cid3;
    } else {
      return cid2;
    }
  };
  const DAG_PB_CODE = 112;
  const SHA_256_CODE = 18;
  const encodeCID = (version2, code, multihash) => {
    const codeOffset = encodingLength(version2);
    const hashOffset = codeOffset + encodingLength(code);
    const bytes = new Uint8Array(hashOffset + multihash.byteLength);
    encodeTo(version2, bytes, 0);
    encodeTo(code, bytes, codeOffset);
    bytes.set(multihash, hashOffset);
    return bytes;
  };
  const cidSymbol = Symbol.for("@ipld/js-cid/CID");
  const readonly = {
    writable: false,
    configurable: false,
    enumerable: true
  };
  const hidden = {
    writable: false,
    enumerable: false,
    configurable: false
  };
  const version = "0.0.0-dev";
  const deprecate = (range, message2) => {
    if (range.test(version)) {
      console.warn(message2);
    } else {
      throw new Error(message2);
    }
  };
  const IS_CID_DEPRECATION = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`;
  const cid = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    CID
  }, Symbol.toStringTag, { value: "Module" }));
  const require$$0$1 = /* @__PURE__ */ getAugmentedNamespace(cid);
  var dist$2 = {};
  var check = {};
  var hasRequiredCheck;
  function requireCheck() {
    if (hasRequiredCheck) return check;
    hasRequiredCheck = 1;
    Object.defineProperty(check, "__esModule", { value: true });
    check.isObject = check.assure = check.create = check.is = void 0;
    const is = (obj, def) => {
      return def.safeParse(obj).success;
    };
    check.is = is;
    const create2 = (def) => (v) => def.safeParse(v).success;
    check.create = create2;
    const assure = (def, obj) => {
      return def.parse(obj);
    };
    check.assure = assure;
    const isObject = (obj) => {
      return typeof obj === "object" && obj !== null;
    };
    check.isObject = isObject;
    return check;
  }
  var util$6 = {};
  var hasRequiredUtil$6;
  function requireUtil$6() {
    if (hasRequiredUtil$6) return util$6;
    hasRequiredUtil$6 = 1;
    (function(exports$1) {
      Object.defineProperty(exports$1, "__esModule", { value: true });
      exports$1.parseIntWithFallback = exports$1.dedupeStrs = exports$1.range = exports$1.chunkArray = exports$1.errHasMsg = exports$1.isErrnoException = exports$1.asyncFilter = exports$1.s32decode = exports$1.s32encode = exports$1.streamToBuffer = exports$1.flattenUint8Arrays = exports$1.bailableWait = exports$1.wait = exports$1.jitter = exports$1.noUndefinedVals = void 0;
      exports$1.omit = omit;
      const noUndefinedVals = (obj) => {
        Object.keys(obj).forEach((k) => {
          if (obj[k] === void 0) {
            delete obj[k];
          }
        });
        return obj;
      };
      exports$1.noUndefinedVals = noUndefinedVals;
      function omit(src2, rejectedKeys) {
        if (!src2)
          return src2;
        const dst = {};
        const srcKeys = Object.keys(src2);
        for (let i = 0; i < srcKeys.length; i++) {
          const key = srcKeys[i];
          if (!rejectedKeys.includes(key)) {
            dst[key] = src2[key];
          }
        }
        return dst;
      }
      const jitter = (maxMs) => {
        return Math.round((Math.random() - 0.5) * maxMs * 2);
      };
      exports$1.jitter = jitter;
      const wait = (ms) => {
        return new Promise((res) => setTimeout(res, ms));
      };
      exports$1.wait = wait;
      const bailableWait = (ms) => {
        let bail;
        const waitPromise = new Promise((res) => {
          const timeout = setTimeout(res, ms);
          bail = () => {
            clearTimeout(timeout);
            res();
          };
        });
        return { bail, wait: () => waitPromise };
      };
      exports$1.bailableWait = bailableWait;
      const flattenUint8Arrays = (arrs) => {
        const length2 = arrs.reduce((acc, cur) => {
          return acc + cur.length;
        }, 0);
        const flattened = new Uint8Array(length2);
        let offset = 0;
        arrs.forEach((arr) => {
          flattened.set(arr, offset);
          offset += arr.length;
        });
        return flattened;
      };
      exports$1.flattenUint8Arrays = flattenUint8Arrays;
      const streamToBuffer = async (stream) => {
        const arrays2 = [];
        for await (const chunk of stream) {
          arrays2.push(chunk);
        }
        return (0, exports$1.flattenUint8Arrays)(arrays2);
      };
      exports$1.streamToBuffer = streamToBuffer;
      const S32_CHAR = "234567abcdefghijklmnopqrstuvwxyz";
      const s32encode = (i) => {
        let s = "";
        while (i) {
          const c = i % 32;
          i = Math.floor(i / 32);
          s = S32_CHAR.charAt(c) + s;
        }
        return s;
      };
      exports$1.s32encode = s32encode;
      const s32decode = (s) => {
        let i = 0;
        for (const c of s) {
          i = i * 32 + S32_CHAR.indexOf(c);
        }
        return i;
      };
      exports$1.s32decode = s32decode;
      const asyncFilter = async (arr, fn) => {
        const results = await Promise.all(arr.map((t) => fn(t)));
        return arr.filter((_, i) => results[i]);
      };
      exports$1.asyncFilter = asyncFilter;
      const isErrnoException = (err) => {
        return !!err && err["code"];
      };
      exports$1.isErrnoException = isErrnoException;
      const errHasMsg = (err, msg) => {
        return !!err && typeof err === "object" && err["message"] === msg;
      };
      exports$1.errHasMsg = errHasMsg;
      const chunkArray = (arr, chunkSize) => {
        return arr.reduce((acc, cur, i) => {
          const chunkI = Math.floor(i / chunkSize);
          if (!acc[chunkI]) {
            acc[chunkI] = [];
          }
          acc[chunkI].push(cur);
          return acc;
        }, []);
      };
      exports$1.chunkArray = chunkArray;
      const range = (num) => {
        const nums = [];
        for (let i = 0; i < num; i++) {
          nums.push(i);
        }
        return nums;
      };
      exports$1.range = range;
      const dedupeStrs = (strs) => {
        return [...new Set(strs)];
      };
      exports$1.dedupeStrs = dedupeStrs;
      const parseIntWithFallback = (value, fallback) => {
        const parsed = parseInt(value || "", 10);
        return isNaN(parsed) ? fallback : parsed;
      };
      exports$1.parseIntWithFallback = parseIntWithFallback;
    })(util$6);
    return util$6;
  }
  var arrays = {};
  var hasRequiredArrays;
  function requireArrays() {
    if (hasRequiredArrays) return arrays;
    hasRequiredArrays = 1;
    Object.defineProperty(arrays, "__esModule", { value: true });
    arrays.mapDefined = void 0;
    arrays.keyBy = keyBy;
    function keyBy(arr, key) {
      return arr.reduce((acc, cur) => {
        acc.set(cur[key], cur);
        return acc;
      }, /* @__PURE__ */ new Map());
    }
    const mapDefined = (arr, fn) => {
      const output = [];
      for (const item of arr) {
        const val = fn(item);
        if (val !== void 0) {
          output.push(val);
        }
      }
      return output;
    };
    arrays.mapDefined = mapDefined;
    return arrays;
  }
  var async = {};
  var hasRequiredAsync;
  function requireAsync() {
    if (hasRequiredAsync) return async;
    hasRequiredAsync = 1;
    (function(exports$1) {
      Object.defineProperty(exports$1, "__esModule", { value: true });
      exports$1.AsyncBufferFullError = exports$1.AsyncBuffer = exports$1.allComplete = exports$1.createDeferrables = exports$1.createDeferrable = exports$1.readFromGenerator = void 0;
      exports$1.allFulfilled = allFulfilled;
      exports$1.handleAllSettledErrors = handleAllSettledErrors;
      exports$1.isRejectedResult = isRejectedResult;
      exports$1.isFulfilledResult = isFulfilledResult;
      const util_1 = requireUtil$6();
      const readFromGenerator = async (gen, isDone, waitFor = Promise.resolve(), maxLength = Number.MAX_SAFE_INTEGER) => {
        const evts = [];
        let bail;
        let hasBroke = false;
        const awaitDone = async () => {
          if (await isDone(evts.at(-1))) {
            return true;
          }
          const bailable = (0, util_1.bailableWait)(20);
          await bailable.wait();
          bail = bailable.bail;
          if (hasBroke)
            return false;
          return await awaitDone();
        };
        const breakOn = new Promise((resolve) => {
          waitFor.then(() => {
            awaitDone().then(() => resolve());
          });
        });
        try {
          while (evts.length < maxLength) {
            const maybeEvt = await Promise.race([gen.next(), breakOn]);
            if (!maybeEvt)
              break;
            const evt = maybeEvt;
            if (evt.done)
              break;
            evts.push(evt.value);
          }
        } finally {
          hasBroke = true;
          bail && bail();
        }
        return evts;
      };
      exports$1.readFromGenerator = readFromGenerator;
      const createDeferrable = () => {
        let resolve;
        const promise = new Promise((res) => {
          resolve = () => res();
        });
        return { resolve, complete: promise };
      };
      exports$1.createDeferrable = createDeferrable;
      const createDeferrables = (count) => {
        const list2 = [];
        for (let i = 0; i < count; i++) {
          list2.push((0, exports$1.createDeferrable)());
        }
        return list2;
      };
      exports$1.createDeferrables = createDeferrables;
      const allComplete = async (deferrables) => {
        await Promise.all(deferrables.map((d) => d.complete));
      };
      exports$1.allComplete = allComplete;
      class AsyncBuffer {
        constructor(maxSize) {
          Object.defineProperty(this, "maxSize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: maxSize
          });
          Object.defineProperty(this, "buffer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
          });
          Object.defineProperty(this, "promise", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "resolve", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "closed", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
          });
          Object.defineProperty(this, "toThrow", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          this.promise = Promise.resolve();
          this.resolve = () => null;
          this.resetPromise();
        }
        get curr() {
          return this.buffer;
        }
        get size() {
          return this.buffer.length;
        }
        get isClosed() {
          return this.closed;
        }
        resetPromise() {
          this.promise = new Promise((r) => this.resolve = r);
        }
        push(item) {
          this.buffer.push(item);
          this.resolve();
        }
        pushMany(items) {
          items.forEach((i) => this.buffer.push(i));
          this.resolve();
        }
        async *events() {
          while (true) {
            if (this.closed && this.buffer.length === 0) {
              if (this.toThrow) {
                throw this.toThrow;
              } else {
                return;
              }
            }
            await this.promise;
            if (this.toThrow) {
              throw this.toThrow;
            }
            if (this.maxSize && this.size > this.maxSize) {
              throw new AsyncBufferFullError(this.maxSize);
            }
            const [first, ...rest] = this.buffer;
            if (first) {
              this.buffer = rest;
              yield first;
            } else {
              this.resetPromise();
            }
          }
        }
        throw(err) {
          this.toThrow = err;
          this.closed = true;
          this.resolve();
        }
        close() {
          this.closed = true;
          this.resolve();
        }
      }
      exports$1.AsyncBuffer = AsyncBuffer;
      class AsyncBufferFullError extends Error {
        constructor(maxSize) {
          super(`ReachedMaxBufferSize: ${maxSize}`);
        }
      }
      exports$1.AsyncBufferFullError = AsyncBufferFullError;
      function allFulfilled(promises) {
        return Promise.allSettled(promises).then(handleAllSettledErrors);
      }
      function handleAllSettledErrors(results) {
        const errors2 = results.filter(isRejectedResult).map(extractReason);
        if (errors2.length === 0) {
          return results.map(extractValue);
        }
        if (errors2.length === 1) {
          throw errors2[0];
        }
        throw new AggregateError(errors2, `Multiple errors: ${errors2.map(stringifyReason).join("\n")}`);
      }
      function isRejectedResult(result) {
        return result.status === "rejected";
      }
      function extractReason(result) {
        return result.reason;
      }
      function isFulfilledResult(result) {
        return result.status === "fulfilled";
      }
      function extractValue(result) {
        return result.value;
      }
      function stringifyReason(reason) {
        if (reason instanceof Error) {
          return reason.message;
        }
        return String(reason);
      }
    })(async);
    return async;
  }
  var tid = {};
  var hasRequiredTid;
  function requireTid() {
    if (hasRequiredTid) return tid;
    hasRequiredTid = 1;
    Object.defineProperty(tid, "__esModule", { value: true });
    tid.TID = void 0;
    const util_1 = requireUtil$6();
    const TID_LEN = 13;
    let lastTimestamp = 0;
    let timestampCount = 0;
    let clockid = null;
    function dedash(str) {
      return str.replaceAll("-", "");
    }
    class TID {
      constructor(str) {
        Object.defineProperty(this, "str", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        const noDashes = dedash(str);
        if (noDashes.length !== TID_LEN) {
          throw new Error(`Poorly formatted TID: ${noDashes.length} length`);
        }
        this.str = noDashes;
      }
      static next(prev) {
        const time = Math.max(Date.now(), lastTimestamp);
        if (time === lastTimestamp) {
          timestampCount++;
        }
        lastTimestamp = time;
        const timestamp = time * 1e3 + timestampCount;
        if (clockid === null) {
          clockid = Math.floor(Math.random() * 32);
        }
        const tid2 = TID.fromTime(timestamp, clockid);
        if (!prev || tid2.newerThan(prev)) {
          return tid2;
        }
        return TID.fromTime(prev.timestamp() + 1, clockid);
      }
      static nextStr(prev) {
        return TID.next(prev ? new TID(prev) : void 0).toString();
      }
      static fromTime(timestamp, clockid2) {
        const str = `${(0, util_1.s32encode)(timestamp)}${(0, util_1.s32encode)(clockid2).padStart(2, "2")}`;
        return new TID(str);
      }
      static fromStr(str) {
        return new TID(str);
      }
      static oldestFirst(a, b) {
        return a.compareTo(b);
      }
      static newestFirst(a, b) {
        return b.compareTo(a);
      }
      static is(str) {
        return dedash(str).length === TID_LEN;
      }
      timestamp() {
        return (0, util_1.s32decode)(this.str.slice(0, 11));
      }
      clockid() {
        return (0, util_1.s32decode)(this.str.slice(11, 13));
      }
      formatted() {
        const str = this.toString();
        return `${str.slice(0, 4)}-${str.slice(4, 7)}-${str.slice(7, 11)}-${str.slice(11, 13)}`;
      }
      toString() {
        return this.str;
      }
      // newer > older
      compareTo(other) {
        if (this.str > other.str)
          return 1;
        if (this.str < other.str)
          return -1;
        return 0;
      }
      equals(other) {
        return this.str === other.str;
      }
      newerThan(other) {
        return this.compareTo(other) > 0;
      }
      olderThan(other) {
        return this.compareTo(other) < 0;
      }
    }
    tid.TID = TID;
    return tid;
  }
  var ipld = {};
  function compare(a, b) {
    for (let i = 0; i < a.byteLength; i++) {
      if (a[i] < b[i]) {
        return -1;
      }
      if (a[i] > b[i]) {
        return 1;
      }
    }
    if (a.byteLength > b.byteLength) {
      return 1;
    }
    if (a.byteLength < b.byteLength) {
      return -1;
    }
    return 0;
  }
  function concat(arrays2, length2) {
    if (!length2) {
      length2 = arrays2.reduce((acc, curr) => acc + curr.length, 0);
    }
    const output = new Uint8Array(length2);
    let offset = 0;
    for (const arr of arrays2) {
      output.set(arr, offset);
      offset += arr.length;
    }
    return output;
  }
  function equals(a, b) {
    if (a === b) {
      return true;
    }
    if (a.byteLength !== b.byteLength) {
      return false;
    }
    for (let i = 0; i < a.byteLength; i++) {
      if (a[i] !== b[i]) {
        return false;
      }
    }
    return true;
  }
  const identity = from({
    prefix: "\0",
    name: "identity",
    encode: (buf) => toString$1(buf),
    decode: (str) => fromString$1(str)
  });
  const identityBase = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    identity
  }, Symbol.toStringTag, { value: "Module" }));
  const base2 = rfc4648({
    prefix: "0",
    name: "base2",
    alphabet: "01",
    bitsPerChar: 1
  });
  const base2$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    base2
  }, Symbol.toStringTag, { value: "Module" }));
  const base8 = rfc4648({
    prefix: "7",
    name: "base8",
    alphabet: "01234567",
    bitsPerChar: 3
  });
  const base8$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    base8
  }, Symbol.toStringTag, { value: "Module" }));
  const base10 = baseX({
    prefix: "9",
    name: "base10",
    alphabet: "0123456789"
  });
  const base10$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    base10
  }, Symbol.toStringTag, { value: "Module" }));
  const base16 = rfc4648({
    prefix: "f",
    name: "base16",
    alphabet: "0123456789abcdef",
    bitsPerChar: 4
  });
  const base16upper = rfc4648({
    prefix: "F",
    name: "base16upper",
    alphabet: "0123456789ABCDEF",
    bitsPerChar: 4
  });
  const base16$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    base16,
    base16upper
  }, Symbol.toStringTag, { value: "Module" }));
  const base36 = baseX({
    prefix: "k",
    name: "base36",
    alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
  });
  const base36upper = baseX({
    prefix: "K",
    name: "base36upper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
  });
  const base36$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    base36,
    base36upper
  }, Symbol.toStringTag, { value: "Module" }));
  const base64$1 = rfc4648({
    prefix: "m",
    name: "base64",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
    bitsPerChar: 6
  });
  const base64pad = rfc4648({
    prefix: "M",
    name: "base64pad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
    bitsPerChar: 6
  });
  const base64url = rfc4648({
    prefix: "u",
    name: "base64url",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
    bitsPerChar: 6
  });
  const base64urlpad = rfc4648({
    prefix: "U",
    name: "base64urlpad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
    bitsPerChar: 6
  });
  const base64$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    base64: base64$1,
    base64pad,
    base64url,
    base64urlpad
  }, Symbol.toStringTag, { value: "Module" }));
  const alphabet = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
  const alphabetBytesToChars = alphabet.reduce((p, c, i) => {
    p[i] = c;
    return p;
  }, []);
  const alphabetCharsToBytes = alphabet.reduce((p, c, i) => {
    p[c.codePointAt(0)] = i;
    return p;
  }, []);
  function encode(data) {
    return data.reduce((p, c) => {
      p += alphabetBytesToChars[c];
      return p;
    }, "");
  }
  function decode(str) {
    const byts = [];
    for (const char of str) {
      const byt = alphabetCharsToBytes[char.codePointAt(0)];
      if (byt === void 0) {
        throw new Error(`Non-base256emoji character: ${char}`);
      }
      byts.push(byt);
    }
    return new Uint8Array(byts);
  }
  const base256emoji = from({
    prefix: "\u{1F680}",
    name: "base256emoji",
    encode,
    decode
  });
  const base256emoji$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    base256emoji
  }, Symbol.toStringTag, { value: "Module" }));
  new TextEncoder();
  new TextDecoder();
  const bases = {
    ...identityBase,
    ...base2$1,
    ...base8$1,
    ...base10$1,
    ...base16$1,
    ...base32$1,
    ...base36$1,
    ...base58,
    ...base64$2,
    ...base256emoji$1
  };
  function createCodec(name, prefix, encode2, decode2) {
    return {
      name,
      prefix,
      encoder: {
        name,
        prefix,
        encode: encode2
      },
      decoder: { decode: decode2 }
    };
  }
  const string = createCodec("utf8", "u", (buf) => {
    const decoder = new TextDecoder("utf8");
    return "u" + decoder.decode(buf);
  }, (str) => {
    const encoder = new TextEncoder();
    return encoder.encode(str.substring(1));
  });
  const ascii = createCodec("ascii", "a", (buf) => {
    let string2 = "a";
    for (let i = 0; i < buf.length; i++) {
      string2 += String.fromCharCode(buf[i]);
    }
    return string2;
  }, (str) => {
    str = str.substring(1);
    const buf = new Uint8Array(str.length);
    for (let i = 0; i < str.length; i++) {
      buf[i] = str.charCodeAt(i);
    }
    return buf;
  });
  const BASES = {
    utf8: string,
    "utf-8": string,
    hex: bases.base16,
    latin1: ascii,
    ascii,
    binary: ascii,
    ...bases
  };
  function fromString(string2, encoding = "utf8") {
    const base3 = BASES[encoding];
    if (!base3) {
      throw new Error(`Unsupported encoding "${encoding}"`);
    }
    return base3.decoder.decode(`${base3.prefix}${string2}`);
  }
  function toString(array, encoding = "utf8") {
    const base3 = BASES[encoding];
    if (!base3) {
      throw new Error(`Unsupported encoding "${encoding}"`);
    }
    return base3.encoder.encode(array).substring(1);
  }
  function xor(a, b) {
    if (a.length !== b.length) {
      throw new Error("Inputs should have the same length");
    }
    const result = new Uint8Array(a.length);
    for (let i = 0; i < a.length; i++) {
      result[i] = a[i] ^ b[i];
    }
    return result;
  }
  const src = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    compare,
    concat,
    equals,
    fromString,
    toString,
    xor
  }, Symbol.toStringTag, { value: "Module" }));
  const require$$1 = /* @__PURE__ */ getAugmentedNamespace(src);
  var hasRequiredIpld;
  function requireIpld() {
    if (hasRequiredIpld) return ipld;
    hasRequiredIpld = 1;
    (function(exports$1) {
      var __createBinding = ipld && ipld.__createBinding || (Object.create ? (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      }));
      var __setModuleDefault = ipld && ipld.__setModuleDefault || (Object.create ? (function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      }) : function(o, v) {
        o["default"] = v;
      });
      var __importStar = ipld && ipld.__importStar || function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports$1, "__esModule", { value: true });
      exports$1.ipldEquals = exports$1.ipldToJson = exports$1.jsonToIpld = void 0;
      const cid_1 = require$$0$1;
      const ui8 = __importStar(require$$1);
      const jsonToIpld = (val) => {
        if (Array.isArray(val)) {
          return val.map((item) => (0, exports$1.jsonToIpld)(item));
        }
        if (val && typeof val === "object") {
          if (typeof val["$link"] === "string" && Object.keys(val).length === 1) {
            return cid_1.CID.parse(val["$link"]);
          }
          if (typeof val["$bytes"] === "string" && Object.keys(val).length === 1) {
            return ui8.fromString(val["$bytes"], "base64");
          }
          const toReturn = {};
          for (const key of Object.keys(val)) {
            toReturn[key] = (0, exports$1.jsonToIpld)(val[key]);
          }
          return toReturn;
        }
        return val;
      };
      exports$1.jsonToIpld = jsonToIpld;
      const ipldToJson = (val) => {
        if (Array.isArray(val)) {
          return val.map((item) => (0, exports$1.ipldToJson)(item));
        }
        if (val && typeof val === "object") {
          if (val instanceof Uint8Array) {
            return {
              $bytes: ui8.toString(val, "base64")
            };
          }
          if (cid_1.CID.asCID(val)) {
            return {
              $link: val.toString()
            };
          }
          const toReturn = {};
          for (const key of Object.keys(val)) {
            toReturn[key] = (0, exports$1.ipldToJson)(val[key]);
          }
          return toReturn;
        }
        return val;
      };
      exports$1.ipldToJson = ipldToJson;
      const ipldEquals = (a, b) => {
        if (Array.isArray(a) && Array.isArray(b)) {
          if (a.length !== b.length)
            return false;
          for (let i = 0; i < a.length; i++) {
            if (!(0, exports$1.ipldEquals)(a[i], b[i]))
              return false;
          }
          return true;
        }
        if (a && b && typeof a === "object" && typeof b === "object") {
          if (a instanceof Uint8Array && b instanceof Uint8Array) {
            return ui8.equals(a, b);
          }
          if (cid_1.CID.asCID(a) && cid_1.CID.asCID(b)) {
            return cid_1.CID.asCID(a)?.equals(cid_1.CID.asCID(b));
          }
          if (Object.keys(a).length !== Object.keys(b).length)
            return false;
          for (const key of Object.keys(a)) {
            if (!(0, exports$1.ipldEquals)(a[key], b[key]))
              return false;
          }
          return true;
        }
        return a === b;
      };
      exports$1.ipldEquals = ipldEquals;
    })(ipld);
    return ipld;
  }
  var retry = {};
  var hasRequiredRetry;
  function requireRetry() {
    if (hasRequiredRetry) return retry;
    hasRequiredRetry = 1;
    Object.defineProperty(retry, "__esModule", { value: true });
    retry.retry = retry$1;
    retry.createRetryable = createRetryable;
    retry.backoffMs = backoffMs;
    const util_1 = requireUtil$6();
    async function retry$1(fn, opts = {}) {
      const { maxRetries = 3, retryable = () => true, getWaitMs = backoffMs } = opts;
      let retries = 0;
      let doneError;
      while (!doneError) {
        try {
          return await fn();
        } catch (err) {
          const waitMs = getWaitMs(retries);
          const willRetry = retries < maxRetries && waitMs !== null && retryable(err);
          if (willRetry) {
            retries += 1;
            if (waitMs !== 0) {
              await (0, util_1.wait)(waitMs);
            }
          } else {
            doneError = err;
          }
        }
      }
      throw doneError;
    }
    function createRetryable(retryable) {
      return async (fn, opts) => retry$1(fn, { ...opts, retryable });
    }
    function backoffMs(n, multiplier = 100, max = 1e3) {
      const exponentialMs = Math.pow(2, n) * multiplier;
      const ms = Math.min(exponentialMs, max);
      return jitter(ms);
    }
    function jitter(value) {
      const delta = value * 0.15;
      return value + randomRange(-delta, delta);
    }
    function randomRange(from2, to) {
      const rand = Math.random() * (to - from2);
      return rand + from2;
    }
    return retry;
  }
  var types$3 = {};
  var hasRequiredTypes$3;
  function requireTypes$3() {
    if (hasRequiredTypes$3) return types$3;
    hasRequiredTypes$3 = 1;
    (function(exports$1) {
      Object.defineProperty(exports$1, "__esModule", { value: true });
      exports$1.def = exports$1.schema = void 0;
      const cid_1 = require$$0$1;
      const zod_1 = /* @__PURE__ */ requireLib$1();
      const cidSchema = zod_1.z.any().refine((obj) => cid_1.CID.asCID(obj) !== null, {
        message: "Not a CID"
      }).transform((obj) => cid_1.CID.asCID(obj));
      exports$1.schema = {
        cid: cidSchema,
        bytes: zod_1.z.instanceof(Uint8Array),
        string: zod_1.z.string(),
        array: zod_1.z.array(zod_1.z.unknown()),
        map: zod_1.z.record(zod_1.z.string(), zod_1.z.unknown()),
        unknown: zod_1.z.unknown()
      };
      exports$1.def = {
        cid: {
          name: "cid",
          schema: exports$1.schema.cid
        },
        bytes: {
          name: "bytes",
          schema: exports$1.schema.bytes
        },
        string: {
          name: "string",
          schema: exports$1.schema.string
        },
        map: {
          name: "map",
          schema: exports$1.schema.map
        },
        unknown: {
          name: "unknown",
          schema: exports$1.schema.unknown
        }
      };
    })(types$3);
    return types$3;
  }
  var times = {};
  var hasRequiredTimes;
  function requireTimes() {
    if (hasRequiredTimes) return times;
    hasRequiredTimes = 1;
    (function(exports$1) {
      Object.defineProperty(exports$1, "__esModule", { value: true });
      exports$1.addHoursToDate = exports$1.lessThanAgoMs = exports$1.DAY = exports$1.HOUR = exports$1.MINUTE = exports$1.SECOND = void 0;
      exports$1.SECOND = 1e3;
      exports$1.MINUTE = exports$1.SECOND * 60;
      exports$1.HOUR = exports$1.MINUTE * 60;
      exports$1.DAY = exports$1.HOUR * 24;
      const lessThanAgoMs = (time, range) => {
        return Date.now() < time.getTime() + range;
      };
      exports$1.lessThanAgoMs = lessThanAgoMs;
      const addHoursToDate = (hours, startingDate) => {
        const currentDate = startingDate ? new Date(startingDate) : /* @__PURE__ */ new Date();
        currentDate.setHours(currentDate.getHours() + hours);
        return currentDate;
      };
      exports$1.addHoursToDate = addHoursToDate;
    })(times);
    return times;
  }
  var strings = {};
  var lib = {};
  var Graphemer = {};
  var boundaries = {};
  var hasRequiredBoundaries;
  function requireBoundaries() {
    if (hasRequiredBoundaries) return boundaries;
    hasRequiredBoundaries = 1;
    (function(exports$1) {
      Object.defineProperty(exports$1, "__esModule", { value: true });
      exports$1.EXTENDED_PICTOGRAPHIC = exports$1.CLUSTER_BREAK = void 0;
      (function(CLUSTER_BREAK) {
        CLUSTER_BREAK[CLUSTER_BREAK["CR"] = 0] = "CR";
        CLUSTER_BREAK[CLUSTER_BREAK["LF"] = 1] = "LF";
        CLUSTER_BREAK[CLUSTER_BREAK["CONTROL"] = 2] = "CONTROL";
        CLUSTER_BREAK[CLUSTER_BREAK["EXTEND"] = 3] = "EXTEND";
        CLUSTER_BREAK[CLUSTER_BREAK["REGIONAL_INDICATOR"] = 4] = "REGIONAL_INDICATOR";
        CLUSTER_BREAK[CLUSTER_BREAK["SPACINGMARK"] = 5] = "SPACINGMARK";
        CLUSTER_BREAK[CLUSTER_BREAK["L"] = 6] = "L";
        CLUSTER_BREAK[CLUSTER_BREAK["V"] = 7] = "V";
        CLUSTER_BREAK[CLUSTER_BREAK["T"] = 8] = "T";
        CLUSTER_BREAK[CLUSTER_BREAK["LV"] = 9] = "LV";
        CLUSTER_BREAK[CLUSTER_BREAK["LVT"] = 10] = "LVT";
        CLUSTER_BREAK[CLUSTER_BREAK["OTHER"] = 11] = "OTHER";
        CLUSTER_BREAK[CLUSTER_BREAK["PREPEND"] = 12] = "PREPEND";
        CLUSTER_BREAK[CLUSTER_BREAK["E_BASE"] = 13] = "E_BASE";
        CLUSTER_BREAK[CLUSTER_BREAK["E_MODIFIER"] = 14] = "E_MODIFIER";
        CLUSTER_BREAK[CLUSTER_BREAK["ZWJ"] = 15] = "ZWJ";
        CLUSTER_BREAK[CLUSTER_BREAK["GLUE_AFTER_ZWJ"] = 16] = "GLUE_AFTER_ZWJ";
        CLUSTER_BREAK[CLUSTER_BREAK["E_BASE_GAZ"] = 17] = "E_BASE_GAZ";
      })(exports$1.CLUSTER_BREAK || (exports$1.CLUSTER_BREAK = {}));
      exports$1.EXTENDED_PICTOGRAPHIC = 101;
    })(boundaries);
    return boundaries;
  }
  var GraphemerHelper = {};
  var hasRequiredGraphemerHelper;
  function requireGraphemerHelper() {
    if (hasRequiredGraphemerHelper) return GraphemerHelper;
    hasRequiredGraphemerHelper = 1;
    Object.defineProperty(GraphemerHelper, "__esModule", { value: true });
    const boundaries_1 = requireBoundaries();
    const NotBreak = 0;
    const BreakStart = 1;
    const Break = 2;
    const BreakLastRegional = 3;
    const BreakPenultimateRegional = 4;
    let GraphemerHelper$1 = class GraphemerHelper {
      /**
       * Check if the the character at the position {pos} of the string is surrogate
       * @param str {string}
       * @param pos {number}
       * @returns {boolean}
       */
      static isSurrogate(str, pos) {
        return 55296 <= str.charCodeAt(pos) && str.charCodeAt(pos) <= 56319 && 56320 <= str.charCodeAt(pos + 1) && str.charCodeAt(pos + 1) <= 57343;
      }
      /**
       * The String.prototype.codePointAt polyfill
       * Private function, gets a Unicode code point from a JavaScript UTF-16 string
       * handling surrogate pairs appropriately
       * @param str {string}
       * @param idx {number}
       * @returns {number}
       */
      static codePointAt(str, idx) {
        if (idx === void 0) {
          idx = 0;
        }
        const code = str.charCodeAt(idx);
        if (55296 <= code && code <= 56319 && idx < str.length - 1) {
          const hi = code;
          const low = str.charCodeAt(idx + 1);
          if (56320 <= low && low <= 57343) {
            return (hi - 55296) * 1024 + (low - 56320) + 65536;
          }
          return hi;
        }
        if (56320 <= code && code <= 57343 && idx >= 1) {
          const hi = str.charCodeAt(idx - 1);
          const low = code;
          if (55296 <= hi && hi <= 56319) {
            return (hi - 55296) * 1024 + (low - 56320) + 65536;
          }
          return low;
        }
        return code;
      }
      //
      /**
       * Private function, returns whether a break is allowed between the two given grapheme breaking classes
       * Implemented the UAX #29 3.1.1 Grapheme Cluster Boundary Rules on extended grapheme clusters
       * @param start {number}
       * @param mid {Array<number>}
       * @param end {number}
       * @param startEmoji {number}
       * @param midEmoji {Array<number>}
       * @param endEmoji {number}
       * @returns {number}
       */
      static shouldBreak(start, mid, end, startEmoji, midEmoji, endEmoji) {
        const all = [start].concat(mid).concat([end]);
        const allEmoji = [startEmoji].concat(midEmoji).concat([endEmoji]);
        const previous = all[all.length - 2];
        const next = end;
        const nextEmoji = endEmoji;
        const rIIndex = all.lastIndexOf(boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR);
        if (rIIndex > 0 && all.slice(1, rIIndex).every(function(c) {
          return c === boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR;
        }) && [boundaries_1.CLUSTER_BREAK.PREPEND, boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR].indexOf(previous) === -1) {
          if (all.filter(function(c) {
            return c === boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR;
          }).length % 2 === 1) {
            return BreakLastRegional;
          } else {
            return BreakPenultimateRegional;
          }
        }
        if (previous === boundaries_1.CLUSTER_BREAK.CR && next === boundaries_1.CLUSTER_BREAK.LF) {
          return NotBreak;
        } else if (previous === boundaries_1.CLUSTER_BREAK.CONTROL || previous === boundaries_1.CLUSTER_BREAK.CR || previous === boundaries_1.CLUSTER_BREAK.LF) {
          return BreakStart;
        } else if (next === boundaries_1.CLUSTER_BREAK.CONTROL || next === boundaries_1.CLUSTER_BREAK.CR || next === boundaries_1.CLUSTER_BREAK.LF) {
          return BreakStart;
        } else if (previous === boundaries_1.CLUSTER_BREAK.L && (next === boundaries_1.CLUSTER_BREAK.L || next === boundaries_1.CLUSTER_BREAK.V || next === boundaries_1.CLUSTER_BREAK.LV || next === boundaries_1.CLUSTER_BREAK.LVT)) {
          return NotBreak;
        } else if ((previous === boundaries_1.CLUSTER_BREAK.LV || previous === boundaries_1.CLUSTER_BREAK.V) && (next === boundaries_1.CLUSTER_BREAK.V || next === boundaries_1.CLUSTER_BREAK.T)) {
          return NotBreak;
        } else if ((previous === boundaries_1.CLUSTER_BREAK.LVT || previous === boundaries_1.CLUSTER_BREAK.T) && next === boundaries_1.CLUSTER_BREAK.T) {
          return NotBreak;
        } else if (next === boundaries_1.CLUSTER_BREAK.EXTEND || next === boundaries_1.CLUSTER_BREAK.ZWJ) {
          return NotBreak;
        } else if (next === boundaries_1.CLUSTER_BREAK.SPACINGMARK) {
          return NotBreak;
        } else if (previous === boundaries_1.CLUSTER_BREAK.PREPEND) {
          return NotBreak;
        }
        const previousNonExtendIndex = allEmoji.slice(0, -1).lastIndexOf(boundaries_1.EXTENDED_PICTOGRAPHIC);
        if (previousNonExtendIndex !== -1 && allEmoji[previousNonExtendIndex] === boundaries_1.EXTENDED_PICTOGRAPHIC && all.slice(previousNonExtendIndex + 1, -2).every(function(c) {
          return c === boundaries_1.CLUSTER_BREAK.EXTEND;
        }) && previous === boundaries_1.CLUSTER_BREAK.ZWJ && nextEmoji === boundaries_1.EXTENDED_PICTOGRAPHIC) {
          return NotBreak;
        }
        if (mid.indexOf(boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR) !== -1) {
          return Break;
        }
        if (previous === boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR && next === boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR) {
          return NotBreak;
        }
        return BreakStart;
      }
    };
    GraphemerHelper.default = GraphemerHelper$1;
    return GraphemerHelper;
  }
  var GraphemerIterator = {};
  var hasRequiredGraphemerIterator;
  function requireGraphemerIterator() {
    if (hasRequiredGraphemerIterator) return GraphemerIterator;
    hasRequiredGraphemerIterator = 1;
    Object.defineProperty(GraphemerIterator, "__esModule", { value: true });
    let GraphemerIterator$1 = class GraphemerIterator {
      constructor(str, nextBreak) {
        this._index = 0;
        this._str = str;
        this._nextBreak = nextBreak;
      }
      [Symbol.iterator]() {
        return this;
      }
      next() {
        let brk;
        if ((brk = this._nextBreak(this._str, this._index)) < this._str.length) {
          const value = this._str.slice(this._index, brk);
          this._index = brk;
          return { value, done: false };
        }
        if (this._index < this._str.length) {
          const value = this._str.slice(this._index);
          this._index = this._str.length;
          return { value, done: false };
        }
        return { value: void 0, done: true };
      }
    };
    GraphemerIterator.default = GraphemerIterator$1;
    return GraphemerIterator;
  }
  var hasRequiredGraphemer;
  function requireGraphemer() {
    if (hasRequiredGraphemer) return Graphemer;
    hasRequiredGraphemer = 1;
    var __importDefault = Graphemer && Graphemer.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(Graphemer, "__esModule", { value: true });
    const boundaries_1 = requireBoundaries();
    const GraphemerHelper_1 = __importDefault(requireGraphemerHelper());
    const GraphemerIterator_1 = __importDefault(requireGraphemerIterator());
    let Graphemer$1 = class Graphemer2 {
      /**
       * Returns the next grapheme break in the string after the given index
       * @param string {string}
       * @param index {number}
       * @returns {number}
       */
      static nextBreak(string2, index) {
        if (index === void 0) {
          index = 0;
        }
        if (index < 0) {
          return 0;
        }
        if (index >= string2.length - 1) {
          return string2.length;
        }
        const prevCP = GraphemerHelper_1.default.codePointAt(string2, index);
        const prev = Graphemer2.getGraphemeBreakProperty(prevCP);
        const prevEmoji = Graphemer2.getEmojiProperty(prevCP);
        const mid = [];
        const midEmoji = [];
        for (let i = index + 1; i < string2.length; i++) {
          if (GraphemerHelper_1.default.isSurrogate(string2, i - 1)) {
            continue;
          }
          const nextCP = GraphemerHelper_1.default.codePointAt(string2, i);
          const next = Graphemer2.getGraphemeBreakProperty(nextCP);
          const nextEmoji = Graphemer2.getEmojiProperty(nextCP);
          if (GraphemerHelper_1.default.shouldBreak(prev, mid, next, prevEmoji, midEmoji, nextEmoji)) {
            return i;
          }
          mid.push(next);
          midEmoji.push(nextEmoji);
        }
        return string2.length;
      }
      /**
       * Breaks the given string into an array of grapheme clusters
       * @param str {string}
       * @returns {string[]}
       */
      splitGraphemes(str) {
        const res = [];
        let index = 0;
        let brk;
        while ((brk = Graphemer2.nextBreak(str, index)) < str.length) {
          res.push(str.slice(index, brk));
          index = brk;
        }
        if (index < str.length) {
          res.push(str.slice(index));
        }
        return res;
      }
      /**
       * Returns an iterator of grapheme clusters in the given string
       * @param str {string}
       * @returns {GraphemerIterator}
       */
      iterateGraphemes(str) {
        return new GraphemerIterator_1.default(str, Graphemer2.nextBreak);
      }
      /**
       * Returns the number of grapheme clusters in the given string
       * @param str {string}
       * @returns {number}
       */
      countGraphemes(str) {
        let count = 0;
        let index = 0;
        let brk;
        while ((brk = Graphemer2.nextBreak(str, index)) < str.length) {
          index = brk;
          count++;
        }
        if (index < str.length) {
          count++;
        }
        return count;
      }
      /**
       * Given a Unicode code point, determines this symbol's grapheme break property
       * @param code {number} Unicode code point
       * @returns {number}
       */
      static getGraphemeBreakProperty(code) {
        if (code < 48905) {
          if (code < 44116) {
            if (code < 4141) {
              if (code < 2818) {
                if (code < 2363) {
                  if (code < 1759) {
                    if (code < 1471) {
                      if (code < 127) {
                        if (code < 11) {
                          if (code < 10) {
                            if (0 <= code && code <= 9) {
                              return boundaries_1.CLUSTER_BREAK.CONTROL;
                            }
                          } else {
                            if (10 === code) {
                              return boundaries_1.CLUSTER_BREAK.LF;
                            }
                          }
                        } else {
                          if (code < 13) {
                            if (11 <= code && code <= 12) {
                              return boundaries_1.CLUSTER_BREAK.CONTROL;
                            }
                          } else {
                            if (code < 14) {
                              if (13 === code) {
                                return boundaries_1.CLUSTER_BREAK.CR;
                              }
                            } else {
                              if (14 <= code && code <= 31) {
                                return boundaries_1.CLUSTER_BREAK.CONTROL;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 768) {
                          if (code < 173) {
                            if (127 <= code && code <= 159) {
                              return boundaries_1.CLUSTER_BREAK.CONTROL;
                            }
                          } else {
                            if (173 === code) {
                              return boundaries_1.CLUSTER_BREAK.CONTROL;
                            }
                          }
                        } else {
                          if (code < 1155) {
                            if (768 <= code && code <= 879) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 1425) {
                              if (1155 <= code && code <= 1161) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (1425 <= code && code <= 1469) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 1552) {
                        if (code < 1476) {
                          if (code < 1473) {
                            if (1471 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (1473 <= code && code <= 1474) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 1479) {
                            if (1476 <= code && code <= 1477) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 1536) {
                              if (1479 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (1536 <= code && code <= 1541) {
                                return boundaries_1.CLUSTER_BREAK.PREPEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 1648) {
                          if (code < 1564) {
                            if (1552 <= code && code <= 1562) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 1611) {
                              if (1564 === code) {
                                return boundaries_1.CLUSTER_BREAK.CONTROL;
                              }
                            } else {
                              if (1611 <= code && code <= 1631) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        } else {
                          if (code < 1750) {
                            if (1648 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 1757) {
                              if (1750 <= code && code <= 1756) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (1757 === code) {
                                return boundaries_1.CLUSTER_BREAK.PREPEND;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code < 2075) {
                      if (code < 1840) {
                        if (code < 1770) {
                          if (code < 1767) {
                            if (1759 <= code && code <= 1764) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (1767 <= code && code <= 1768) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 1807) {
                            if (1770 <= code && code <= 1773) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (1807 === code) {
                              return boundaries_1.CLUSTER_BREAK.PREPEND;
                            }
                            if (1809 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        }
                      } else {
                        if (code < 2027) {
                          if (code < 1958) {
                            if (1840 <= code && code <= 1866) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (1958 <= code && code <= 1968) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 2045) {
                            if (2027 <= code && code <= 2035) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 2070) {
                              if (2045 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (2070 <= code && code <= 2073) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 2200) {
                        if (code < 2089) {
                          if (code < 2085) {
                            if (2075 <= code && code <= 2083) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (2085 <= code && code <= 2087) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 2137) {
                            if (2089 <= code && code <= 2093) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 2192) {
                              if (2137 <= code && code <= 2139) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (2192 <= code && code <= 2193) {
                                return boundaries_1.CLUSTER_BREAK.PREPEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 2275) {
                          if (code < 2250) {
                            if (2200 <= code && code <= 2207) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 2274) {
                              if (2250 <= code && code <= 2273) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (2274 === code) {
                                return boundaries_1.CLUSTER_BREAK.PREPEND;
                              }
                            }
                          }
                        } else {
                          if (code < 2307) {
                            if (2275 <= code && code <= 2306) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (2307 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                            if (2362 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  if (code < 2561) {
                    if (code < 2434) {
                      if (code < 2381) {
                        if (code < 2366) {
                          if (2363 === code) {
                            return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                          }
                          if (2364 === code) {
                            return boundaries_1.CLUSTER_BREAK.EXTEND;
                          }
                        } else {
                          if (code < 2369) {
                            if (2366 <= code && code <= 2368) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code < 2377) {
                              if (2369 <= code && code <= 2376) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (2377 <= code && code <= 2380) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 2385) {
                          if (code < 2382) {
                            if (2381 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (2382 <= code && code <= 2383) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          }
                        } else {
                          if (code < 2402) {
                            if (2385 <= code && code <= 2391) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 2433) {
                              if (2402 <= code && code <= 2403) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (2433 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 2503) {
                        if (code < 2494) {
                          if (code < 2492) {
                            if (2434 <= code && code <= 2435) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (2492 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 2495) {
                            if (2494 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 2497) {
                              if (2495 <= code && code <= 2496) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (2497 <= code && code <= 2500) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 2519) {
                          if (code < 2507) {
                            if (2503 <= code && code <= 2504) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code < 2509) {
                              if (2507 <= code && code <= 2508) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (2509 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        } else {
                          if (code < 2530) {
                            if (2519 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 2558) {
                              if (2530 <= code && code <= 2531) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (2558 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code < 2691) {
                      if (code < 2631) {
                        if (code < 2620) {
                          if (code < 2563) {
                            if (2561 <= code && code <= 2562) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (2563 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          }
                        } else {
                          if (code < 2622) {
                            if (2620 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 2625) {
                              if (2622 <= code && code <= 2624) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (2625 <= code && code <= 2626) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 2672) {
                          if (code < 2635) {
                            if (2631 <= code && code <= 2632) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 2641) {
                              if (2635 <= code && code <= 2637) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (2641 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        } else {
                          if (code < 2677) {
                            if (2672 <= code && code <= 2673) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 2689) {
                              if (2677 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (2689 <= code && code <= 2690) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 2761) {
                        if (code < 2750) {
                          if (2691 === code) {
                            return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                          }
                          if (2748 === code) {
                            return boundaries_1.CLUSTER_BREAK.EXTEND;
                          }
                        } else {
                          if (code < 2753) {
                            if (2750 <= code && code <= 2752) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code < 2759) {
                              if (2753 <= code && code <= 2757) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (2759 <= code && code <= 2760) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 2786) {
                          if (code < 2763) {
                            if (2761 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code < 2765) {
                              if (2763 <= code && code <= 2764) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (2765 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        } else {
                          if (code < 2810) {
                            if (2786 <= code && code <= 2787) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 2817) {
                              if (2810 <= code && code <= 2815) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (2817 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              } else {
                if (code < 3315) {
                  if (code < 3076) {
                    if (code < 2946) {
                      if (code < 2887) {
                        if (code < 2878) {
                          if (code < 2876) {
                            if (2818 <= code && code <= 2819) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (2876 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 2880) {
                            if (2878 <= code && code <= 2879) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 2881) {
                              if (2880 === code) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (2881 <= code && code <= 2884) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 2893) {
                          if (code < 2891) {
                            if (2887 <= code && code <= 2888) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (2891 <= code && code <= 2892) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          }
                        } else {
                          if (code < 2901) {
                            if (2893 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 2914) {
                              if (2901 <= code && code <= 2903) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (2914 <= code && code <= 2915) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 3014) {
                        if (code < 3007) {
                          if (2946 === code) {
                            return boundaries_1.CLUSTER_BREAK.EXTEND;
                          }
                          if (3006 === code) {
                            return boundaries_1.CLUSTER_BREAK.EXTEND;
                          }
                        } else {
                          if (code < 3008) {
                            if (3007 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code < 3009) {
                              if (3008 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (3009 <= code && code <= 3010) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 3031) {
                          if (code < 3018) {
                            if (3014 <= code && code <= 3016) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code < 3021) {
                              if (3018 <= code && code <= 3020) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (3021 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        } else {
                          if (code < 3072) {
                            if (3031 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 3073) {
                              if (3072 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (3073 <= code && code <= 3075) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code < 3262) {
                      if (code < 3146) {
                        if (code < 3134) {
                          if (3076 === code) {
                            return boundaries_1.CLUSTER_BREAK.EXTEND;
                          }
                          if (3132 === code) {
                            return boundaries_1.CLUSTER_BREAK.EXTEND;
                          }
                        } else {
                          if (code < 3137) {
                            if (3134 <= code && code <= 3136) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 3142) {
                              if (3137 <= code && code <= 3140) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (3142 <= code && code <= 3144) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 3201) {
                          if (code < 3157) {
                            if (3146 <= code && code <= 3149) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 3170) {
                              if (3157 <= code && code <= 3158) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (3170 <= code && code <= 3171) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        } else {
                          if (code < 3202) {
                            if (3201 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 3260) {
                              if (3202 <= code && code <= 3203) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (3260 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 3270) {
                        if (code < 3264) {
                          if (3262 === code) {
                            return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                          }
                          if (3263 === code) {
                            return boundaries_1.CLUSTER_BREAK.EXTEND;
                          }
                        } else {
                          if (code < 3266) {
                            if (3264 <= code && code <= 3265) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code < 3267) {
                              if (3266 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (3267 <= code && code <= 3268) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 3276) {
                          if (code < 3271) {
                            if (3270 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 3274) {
                              if (3271 <= code && code <= 3272) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (3274 <= code && code <= 3275) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        } else {
                          if (code < 3285) {
                            if (3276 <= code && code <= 3277) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 3298) {
                              if (3285 <= code && code <= 3286) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (3298 <= code && code <= 3299) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  if (code < 3551) {
                    if (code < 3406) {
                      if (code < 3391) {
                        if (code < 3330) {
                          if (code < 3328) {
                            if (3315 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (3328 <= code && code <= 3329) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 3387) {
                            if (3330 <= code && code <= 3331) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code < 3390) {
                              if (3387 <= code && code <= 3388) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (3390 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 3398) {
                          if (code < 3393) {
                            if (3391 <= code && code <= 3392) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (3393 <= code && code <= 3396) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 3402) {
                            if (3398 <= code && code <= 3400) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code < 3405) {
                              if (3402 <= code && code <= 3404) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (3405 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 3530) {
                        if (code < 3426) {
                          if (3406 === code) {
                            return boundaries_1.CLUSTER_BREAK.PREPEND;
                          }
                          if (3415 === code) {
                            return boundaries_1.CLUSTER_BREAK.EXTEND;
                          }
                        } else {
                          if (code < 3457) {
                            if (3426 <= code && code <= 3427) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 3458) {
                              if (3457 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (3458 <= code && code <= 3459) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 3538) {
                          if (code < 3535) {
                            if (3530 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 3536) {
                              if (3535 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (3536 <= code && code <= 3537) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        } else {
                          if (code < 3542) {
                            if (3538 <= code && code <= 3540) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 3544) {
                              if (3542 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (3544 <= code && code <= 3550) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code < 3893) {
                      if (code < 3655) {
                        if (code < 3633) {
                          if (code < 3570) {
                            if (3551 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (3570 <= code && code <= 3571) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          }
                        } else {
                          if (code < 3635) {
                            if (3633 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 3636) {
                              if (3635 === code) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (3636 <= code && code <= 3642) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 3764) {
                          if (code < 3761) {
                            if (3655 <= code && code <= 3662) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (3761 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                            if (3763 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          }
                        } else {
                          if (code < 3784) {
                            if (3764 <= code && code <= 3772) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 3864) {
                              if (3784 <= code && code <= 3790) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (3864 <= code && code <= 3865) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 3967) {
                        if (code < 3897) {
                          if (3893 === code) {
                            return boundaries_1.CLUSTER_BREAK.EXTEND;
                          }
                          if (3895 === code) {
                            return boundaries_1.CLUSTER_BREAK.EXTEND;
                          }
                        } else {
                          if (code < 3902) {
                            if (3897 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 3953) {
                              if (3902 <= code && code <= 3903) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (3953 <= code && code <= 3966) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 3981) {
                          if (code < 3968) {
                            if (3967 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code < 3974) {
                              if (3968 <= code && code <= 3972) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (3974 <= code && code <= 3975) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        } else {
                          if (code < 3993) {
                            if (3981 <= code && code <= 3991) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 4038) {
                              if (3993 <= code && code <= 4028) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (4038 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            } else {
              if (code < 7204) {
                if (code < 6448) {
                  if (code < 5938) {
                    if (code < 4226) {
                      if (code < 4157) {
                        if (code < 4146) {
                          if (code < 4145) {
                            if (4141 <= code && code <= 4144) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (4145 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          }
                        } else {
                          if (code < 4153) {
                            if (4146 <= code && code <= 4151) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 4155) {
                              if (4153 <= code && code <= 4154) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (4155 <= code && code <= 4156) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 4184) {
                          if (code < 4182) {
                            if (4157 <= code && code <= 4158) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (4182 <= code && code <= 4183) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          }
                        } else {
                          if (code < 4190) {
                            if (4184 <= code && code <= 4185) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 4209) {
                              if (4190 <= code && code <= 4192) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (4209 <= code && code <= 4212) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 4352) {
                        if (code < 4229) {
                          if (4226 === code) {
                            return boundaries_1.CLUSTER_BREAK.EXTEND;
                          }
                          if (4228 === code) {
                            return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                          }
                        } else {
                          if (code < 4237) {
                            if (4229 <= code && code <= 4230) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (4237 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                            if (4253 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        }
                      } else {
                        if (code < 4957) {
                          if (code < 4448) {
                            if (4352 <= code && code <= 4447) {
                              return boundaries_1.CLUSTER_BREAK.L;
                            }
                          } else {
                            if (code < 4520) {
                              if (4448 <= code && code <= 4519) {
                                return boundaries_1.CLUSTER_BREAK.V;
                              }
                            } else {
                              if (4520 <= code && code <= 4607) {
                                return boundaries_1.CLUSTER_BREAK.T;
                              }
                            }
                          }
                        } else {
                          if (code < 5906) {
                            if (4957 <= code && code <= 4959) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 5909) {
                              if (5906 <= code && code <= 5908) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (5909 === code) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code < 6089) {
                      if (code < 6070) {
                        if (code < 5970) {
                          if (code < 5940) {
                            if (5938 <= code && code <= 5939) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (5940 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          }
                        } else {
                          if (code < 6002) {
                            if (5970 <= code && code <= 5971) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 6068) {
                              if (6002 <= code && code <= 6003) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (6068 <= code && code <= 6069) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 6078) {
                          if (code < 6071) {
                            if (6070 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (6071 <= code && code <= 6077) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 6086) {
                            if (6078 <= code && code <= 6085) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code < 6087) {
                              if (6086 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (6087 <= code && code <= 6088) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 6277) {
                        if (code < 6155) {
                          if (code < 6109) {
                            if (6089 <= code && code <= 6099) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (6109 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 6158) {
                            if (6155 <= code && code <= 6157) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (6158 === code) {
                              return boundaries_1.CLUSTER_BREAK.CONTROL;
                            }
                            if (6159 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        }
                      } else {
                        if (code < 6435) {
                          if (code < 6313) {
                            if (6277 <= code && code <= 6278) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 6432) {
                              if (6313 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (6432 <= code && code <= 6434) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        } else {
                          if (code < 6439) {
                            if (6435 <= code && code <= 6438) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code < 6441) {
                              if (6439 <= code && code <= 6440) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (6441 <= code && code <= 6443) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  if (code < 6971) {
                    if (code < 6744) {
                      if (code < 6681) {
                        if (code < 6451) {
                          if (code < 6450) {
                            if (6448 <= code && code <= 6449) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (6450 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 6457) {
                            if (6451 <= code && code <= 6456) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code < 6679) {
                              if (6457 <= code && code <= 6459) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (6679 <= code && code <= 6680) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 6741) {
                          if (code < 6683) {
                            if (6681 <= code && code <= 6682) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (6683 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 6742) {
                            if (6741 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (6742 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                            if (6743 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 6771) {
                        if (code < 6754) {
                          if (code < 6752) {
                            if (6744 <= code && code <= 6750) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (6752 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 6757) {
                            if (6754 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 6765) {
                              if (6757 <= code && code <= 6764) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (6765 <= code && code <= 6770) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 6912) {
                          if (code < 6783) {
                            if (6771 <= code && code <= 6780) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 6832) {
                              if (6783 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (6832 <= code && code <= 6862) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        } else {
                          if (code < 6916) {
                            if (6912 <= code && code <= 6915) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 6964) {
                              if (6916 === code) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (6964 <= code && code <= 6970) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code < 7080) {
                      if (code < 7019) {
                        if (code < 6973) {
                          if (6971 === code) {
                            return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                          }
                          if (6972 === code) {
                            return boundaries_1.CLUSTER_BREAK.EXTEND;
                          }
                        } else {
                          if (code < 6978) {
                            if (6973 <= code && code <= 6977) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code < 6979) {
                              if (6978 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (6979 <= code && code <= 6980) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 7073) {
                          if (code < 7040) {
                            if (7019 <= code && code <= 7027) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 7042) {
                              if (7040 <= code && code <= 7041) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (7042 === code) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        } else {
                          if (code < 7074) {
                            if (7073 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code < 7078) {
                              if (7074 <= code && code <= 7077) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (7078 <= code && code <= 7079) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 7144) {
                        if (code < 7083) {
                          if (code < 7082) {
                            if (7080 <= code && code <= 7081) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (7082 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          }
                        } else {
                          if (code < 7142) {
                            if (7083 <= code && code <= 7085) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (7142 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                            if (7143 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          }
                        }
                      } else {
                        if (code < 7150) {
                          if (code < 7146) {
                            if (7144 <= code && code <= 7145) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 7149) {
                              if (7146 <= code && code <= 7148) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (7149 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        } else {
                          if (code < 7151) {
                            if (7150 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code < 7154) {
                              if (7151 <= code && code <= 7153) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (7154 <= code && code <= 7155) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              } else {
                if (code < 43346) {
                  if (code < 11647) {
                    if (code < 7415) {
                      if (code < 7380) {
                        if (code < 7220) {
                          if (code < 7212) {
                            if (7204 <= code && code <= 7211) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (7212 <= code && code <= 7219) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 7222) {
                            if (7220 <= code && code <= 7221) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code < 7376) {
                              if (7222 <= code && code <= 7223) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (7376 <= code && code <= 7378) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 7394) {
                          if (code < 7393) {
                            if (7380 <= code && code <= 7392) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (7393 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          }
                        } else {
                          if (code < 7405) {
                            if (7394 <= code && code <= 7400) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (7405 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                            if (7412 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 8205) {
                        if (code < 7616) {
                          if (code < 7416) {
                            if (7415 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (7416 <= code && code <= 7417) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 8203) {
                            if (7616 <= code && code <= 7679) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (8203 === code) {
                              return boundaries_1.CLUSTER_BREAK.CONTROL;
                            }
                            if (8204 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        }
                      } else {
                        if (code < 8288) {
                          if (code < 8206) {
                            if (8205 === code) {
                              return boundaries_1.CLUSTER_BREAK.ZWJ;
                            }
                          } else {
                            if (code < 8232) {
                              if (8206 <= code && code <= 8207) {
                                return boundaries_1.CLUSTER_BREAK.CONTROL;
                              }
                            } else {
                              if (8232 <= code && code <= 8238) {
                                return boundaries_1.CLUSTER_BREAK.CONTROL;
                              }
                            }
                          }
                        } else {
                          if (code < 8400) {
                            if (8288 <= code && code <= 8303) {
                              return boundaries_1.CLUSTER_BREAK.CONTROL;
                            }
                          } else {
                            if (code < 11503) {
                              if (8400 <= code && code <= 8432) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (11503 <= code && code <= 11505) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code < 43043) {
                      if (code < 42612) {
                        if (code < 12330) {
                          if (code < 11744) {
                            if (11647 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (11744 <= code && code <= 11775) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 12441) {
                            if (12330 <= code && code <= 12335) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 42607) {
                              if (12441 <= code && code <= 12442) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (42607 <= code && code <= 42610) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 43010) {
                          if (code < 42654) {
                            if (42612 <= code && code <= 42621) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 42736) {
                              if (42654 <= code && code <= 42655) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (42736 <= code && code <= 42737) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        } else {
                          if (code < 43014) {
                            if (43010 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (43014 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                            if (43019 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 43188) {
                        if (code < 43047) {
                          if (code < 43045) {
                            if (43043 <= code && code <= 43044) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (43045 <= code && code <= 43046) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 43052) {
                            if (43047 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code < 43136) {
                              if (43052 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (43136 <= code && code <= 43137) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 43263) {
                          if (code < 43204) {
                            if (43188 <= code && code <= 43203) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code < 43232) {
                              if (43204 <= code && code <= 43205) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (43232 <= code && code <= 43249) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        } else {
                          if (code < 43302) {
                            if (43263 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 43335) {
                              if (43302 <= code && code <= 43309) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (43335 <= code && code <= 43345) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  if (code < 43698) {
                    if (code < 43493) {
                      if (code < 43444) {
                        if (code < 43392) {
                          if (code < 43360) {
                            if (43346 <= code && code <= 43347) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (43360 <= code && code <= 43388) {
                              return boundaries_1.CLUSTER_BREAK.L;
                            }
                          }
                        } else {
                          if (code < 43395) {
                            if (43392 <= code && code <= 43394) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (43395 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                            if (43443 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        }
                      } else {
                        if (code < 43450) {
                          if (code < 43446) {
                            if (43444 <= code && code <= 43445) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (43446 <= code && code <= 43449) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 43452) {
                            if (43450 <= code && code <= 43451) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code < 43454) {
                              if (43452 <= code && code <= 43453) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (43454 <= code && code <= 43456) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 43573) {
                        if (code < 43567) {
                          if (code < 43561) {
                            if (43493 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (43561 <= code && code <= 43566) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 43569) {
                            if (43567 <= code && code <= 43568) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code < 43571) {
                              if (43569 <= code && code <= 43570) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (43571 <= code && code <= 43572) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 43597) {
                          if (code < 43587) {
                            if (43573 <= code && code <= 43574) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (43587 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                            if (43596 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 43644) {
                            if (43597 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (43644 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                            if (43696 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code < 44006) {
                      if (code < 43756) {
                        if (code < 43710) {
                          if (code < 43703) {
                            if (43698 <= code && code <= 43700) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (43703 <= code && code <= 43704) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 43713) {
                            if (43710 <= code && code <= 43711) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (43713 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                            if (43755 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          }
                        }
                      } else {
                        if (code < 43766) {
                          if (code < 43758) {
                            if (43756 <= code && code <= 43757) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 43765) {
                              if (43758 <= code && code <= 43759) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (43765 === code) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        } else {
                          if (code < 44003) {
                            if (43766 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 44005) {
                              if (44003 <= code && code <= 44004) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (44005 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 44032) {
                        if (code < 44009) {
                          if (code < 44008) {
                            if (44006 <= code && code <= 44007) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (44008 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 44012) {
                            if (44009 <= code && code <= 44010) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (44012 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                            if (44013 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        }
                      } else {
                        if (code < 44061) {
                          if (code < 44033) {
                            if (44032 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 44060) {
                              if (44033 <= code && code <= 44059) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (44060 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code < 44088) {
                            if (44061 <= code && code <= 44087) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 44089) {
                              if (44088 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (44089 <= code && code <= 44115) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          } else {
            if (code < 46497) {
              if (code < 45293) {
                if (code < 44704) {
                  if (code < 44397) {
                    if (code < 44256) {
                      if (code < 44173) {
                        if (code < 44144) {
                          if (code < 44117) {
                            if (44116 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (44117 <= code && code <= 44143) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 44145) {
                            if (44144 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 44172) {
                              if (44145 <= code && code <= 44171) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (44172 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 44201) {
                          if (code < 44200) {
                            if (44173 <= code && code <= 44199) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (44200 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 44228) {
                            if (44201 <= code && code <= 44227) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 44229) {
                              if (44228 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (44229 <= code && code <= 44255) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 44313) {
                        if (code < 44284) {
                          if (code < 44257) {
                            if (44256 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (44257 <= code && code <= 44283) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 44285) {
                            if (44284 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 44312) {
                              if (44285 <= code && code <= 44311) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (44312 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 44368) {
                          if (code < 44340) {
                            if (44313 <= code && code <= 44339) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 44341) {
                              if (44340 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (44341 <= code && code <= 44367) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code < 44369) {
                            if (44368 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 44396) {
                              if (44369 <= code && code <= 44395) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (44396 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code < 44537) {
                      if (code < 44480) {
                        if (code < 44425) {
                          if (code < 44424) {
                            if (44397 <= code && code <= 44423) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (44424 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 44452) {
                            if (44425 <= code && code <= 44451) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 44453) {
                              if (44452 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (44453 <= code && code <= 44479) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 44508) {
                          if (code < 44481) {
                            if (44480 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (44481 <= code && code <= 44507) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 44509) {
                            if (44508 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 44536) {
                              if (44509 <= code && code <= 44535) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (44536 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 44620) {
                        if (code < 44565) {
                          if (code < 44564) {
                            if (44537 <= code && code <= 44563) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (44564 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 44592) {
                            if (44565 <= code && code <= 44591) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 44593) {
                              if (44592 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (44593 <= code && code <= 44619) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 44649) {
                          if (code < 44621) {
                            if (44620 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 44648) {
                              if (44621 <= code && code <= 44647) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (44648 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code < 44676) {
                            if (44649 <= code && code <= 44675) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 44677) {
                              if (44676 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (44677 <= code && code <= 44703) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  if (code < 44985) {
                    if (code < 44844) {
                      if (code < 44761) {
                        if (code < 44732) {
                          if (code < 44705) {
                            if (44704 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (44705 <= code && code <= 44731) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 44733) {
                            if (44732 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 44760) {
                              if (44733 <= code && code <= 44759) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (44760 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 44789) {
                          if (code < 44788) {
                            if (44761 <= code && code <= 44787) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (44788 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 44816) {
                            if (44789 <= code && code <= 44815) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 44817) {
                              if (44816 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (44817 <= code && code <= 44843) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 44901) {
                        if (code < 44872) {
                          if (code < 44845) {
                            if (44844 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (44845 <= code && code <= 44871) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 44873) {
                            if (44872 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 44900) {
                              if (44873 <= code && code <= 44899) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (44900 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 44956) {
                          if (code < 44928) {
                            if (44901 <= code && code <= 44927) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 44929) {
                              if (44928 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (44929 <= code && code <= 44955) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code < 44957) {
                            if (44956 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 44984) {
                              if (44957 <= code && code <= 44983) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (44984 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code < 45152) {
                      if (code < 45068) {
                        if (code < 45013) {
                          if (code < 45012) {
                            if (44985 <= code && code <= 45011) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (45012 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 45040) {
                            if (45013 <= code && code <= 45039) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 45041) {
                              if (45040 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (45041 <= code && code <= 45067) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 45097) {
                          if (code < 45069) {
                            if (45068 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 45096) {
                              if (45069 <= code && code <= 45095) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (45096 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code < 45124) {
                            if (45097 <= code && code <= 45123) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 45125) {
                              if (45124 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (45125 <= code && code <= 45151) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 45209) {
                        if (code < 45180) {
                          if (code < 45153) {
                            if (45152 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (45153 <= code && code <= 45179) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 45181) {
                            if (45180 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 45208) {
                              if (45181 <= code && code <= 45207) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (45208 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 45264) {
                          if (code < 45236) {
                            if (45209 <= code && code <= 45235) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 45237) {
                              if (45236 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (45237 <= code && code <= 45263) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code < 45265) {
                            if (45264 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 45292) {
                              if (45265 <= code && code <= 45291) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (45292 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              } else {
                if (code < 45908) {
                  if (code < 45600) {
                    if (code < 45433) {
                      if (code < 45376) {
                        if (code < 45321) {
                          if (code < 45320) {
                            if (45293 <= code && code <= 45319) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (45320 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 45348) {
                            if (45321 <= code && code <= 45347) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 45349) {
                              if (45348 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (45349 <= code && code <= 45375) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 45404) {
                          if (code < 45377) {
                            if (45376 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (45377 <= code && code <= 45403) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 45405) {
                            if (45404 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 45432) {
                              if (45405 <= code && code <= 45431) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (45432 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 45516) {
                        if (code < 45461) {
                          if (code < 45460) {
                            if (45433 <= code && code <= 45459) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (45460 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 45488) {
                            if (45461 <= code && code <= 45487) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 45489) {
                              if (45488 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (45489 <= code && code <= 45515) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 45545) {
                          if (code < 45517) {
                            if (45516 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 45544) {
                              if (45517 <= code && code <= 45543) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (45544 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code < 45572) {
                            if (45545 <= code && code <= 45571) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 45573) {
                              if (45572 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (45573 <= code && code <= 45599) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code < 45741) {
                      if (code < 45657) {
                        if (code < 45628) {
                          if (code < 45601) {
                            if (45600 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (45601 <= code && code <= 45627) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 45629) {
                            if (45628 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 45656) {
                              if (45629 <= code && code <= 45655) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (45656 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 45712) {
                          if (code < 45684) {
                            if (45657 <= code && code <= 45683) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 45685) {
                              if (45684 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (45685 <= code && code <= 45711) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code < 45713) {
                            if (45712 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 45740) {
                              if (45713 <= code && code <= 45739) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (45740 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 45824) {
                        if (code < 45769) {
                          if (code < 45768) {
                            if (45741 <= code && code <= 45767) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (45768 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 45796) {
                            if (45769 <= code && code <= 45795) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 45797) {
                              if (45796 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (45797 <= code && code <= 45823) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 45853) {
                          if (code < 45825) {
                            if (45824 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 45852) {
                              if (45825 <= code && code <= 45851) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (45852 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code < 45880) {
                            if (45853 <= code && code <= 45879) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 45881) {
                              if (45880 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (45881 <= code && code <= 45907) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  if (code < 46189) {
                    if (code < 46048) {
                      if (code < 45965) {
                        if (code < 45936) {
                          if (code < 45909) {
                            if (45908 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (45909 <= code && code <= 45935) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 45937) {
                            if (45936 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 45964) {
                              if (45937 <= code && code <= 45963) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (45964 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 45993) {
                          if (code < 45992) {
                            if (45965 <= code && code <= 45991) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (45992 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 46020) {
                            if (45993 <= code && code <= 46019) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 46021) {
                              if (46020 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (46021 <= code && code <= 46047) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 46105) {
                        if (code < 46076) {
                          if (code < 46049) {
                            if (46048 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (46049 <= code && code <= 46075) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 46077) {
                            if (46076 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 46104) {
                              if (46077 <= code && code <= 46103) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (46104 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 46160) {
                          if (code < 46132) {
                            if (46105 <= code && code <= 46131) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 46133) {
                              if (46132 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (46133 <= code && code <= 46159) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code < 46161) {
                            if (46160 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 46188) {
                              if (46161 <= code && code <= 46187) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (46188 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code < 46356) {
                      if (code < 46272) {
                        if (code < 46217) {
                          if (code < 46216) {
                            if (46189 <= code && code <= 46215) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (46216 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 46244) {
                            if (46217 <= code && code <= 46243) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 46245) {
                              if (46244 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (46245 <= code && code <= 46271) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 46301) {
                          if (code < 46273) {
                            if (46272 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 46300) {
                              if (46273 <= code && code <= 46299) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (46300 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code < 46328) {
                            if (46301 <= code && code <= 46327) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 46329) {
                              if (46328 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (46329 <= code && code <= 46355) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 46413) {
                        if (code < 46384) {
                          if (code < 46357) {
                            if (46356 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (46357 <= code && code <= 46383) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 46385) {
                            if (46384 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 46412) {
                              if (46385 <= code && code <= 46411) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (46412 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 46468) {
                          if (code < 46440) {
                            if (46413 <= code && code <= 46439) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 46441) {
                              if (46440 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (46441 <= code && code <= 46467) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code < 46469) {
                            if (46468 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 46496) {
                              if (46469 <= code && code <= 46495) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (46496 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            } else {
              if (code < 47701) {
                if (code < 47112) {
                  if (code < 46804) {
                    if (code < 46637) {
                      if (code < 46580) {
                        if (code < 46525) {
                          if (code < 46524) {
                            if (46497 <= code && code <= 46523) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (46524 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 46552) {
                            if (46525 <= code && code <= 46551) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 46553) {
                              if (46552 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (46553 <= code && code <= 46579) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 46608) {
                          if (code < 46581) {
                            if (46580 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (46581 <= code && code <= 46607) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 46609) {
                            if (46608 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 46636) {
                              if (46609 <= code && code <= 46635) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (46636 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 46720) {
                        if (code < 46665) {
                          if (code < 46664) {
                            if (46637 <= code && code <= 46663) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (46664 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 46692) {
                            if (46665 <= code && code <= 46691) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 46693) {
                              if (46692 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (46693 <= code && code <= 46719) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 46749) {
                          if (code < 46721) {
                            if (46720 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 46748) {
                              if (46721 <= code && code <= 46747) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (46748 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code < 46776) {
                            if (46749 <= code && code <= 46775) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 46777) {
                              if (46776 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (46777 <= code && code <= 46803) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code < 46945) {
                      if (code < 46861) {
                        if (code < 46832) {
                          if (code < 46805) {
                            if (46804 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (46805 <= code && code <= 46831) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 46833) {
                            if (46832 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 46860) {
                              if (46833 <= code && code <= 46859) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (46860 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 46916) {
                          if (code < 46888) {
                            if (46861 <= code && code <= 46887) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 46889) {
                              if (46888 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (46889 <= code && code <= 46915) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code < 46917) {
                            if (46916 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 46944) {
                              if (46917 <= code && code <= 46943) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (46944 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 47028) {
                        if (code < 46973) {
                          if (code < 46972) {
                            if (46945 <= code && code <= 46971) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (46972 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 47e3) {
                            if (46973 <= code && code <= 46999) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 47001) {
                              if (47e3 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (47001 <= code && code <= 47027) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 47057) {
                          if (code < 47029) {
                            if (47028 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 47056) {
                              if (47029 <= code && code <= 47055) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (47056 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code < 47084) {
                            if (47057 <= code && code <= 47083) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 47085) {
                              if (47084 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (47085 <= code && code <= 47111) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  if (code < 47393) {
                    if (code < 47252) {
                      if (code < 47169) {
                        if (code < 47140) {
                          if (code < 47113) {
                            if (47112 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (47113 <= code && code <= 47139) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 47141) {
                            if (47140 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 47168) {
                              if (47141 <= code && code <= 47167) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (47168 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 47197) {
                          if (code < 47196) {
                            if (47169 <= code && code <= 47195) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (47196 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 47224) {
                            if (47197 <= code && code <= 47223) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 47225) {
                              if (47224 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (47225 <= code && code <= 47251) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 47309) {
                        if (code < 47280) {
                          if (code < 47253) {
                            if (47252 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (47253 <= code && code <= 47279) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 47281) {
                            if (47280 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 47308) {
                              if (47281 <= code && code <= 47307) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (47308 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 47364) {
                          if (code < 47336) {
                            if (47309 <= code && code <= 47335) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 47337) {
                              if (47336 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (47337 <= code && code <= 47363) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code < 47365) {
                            if (47364 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 47392) {
                              if (47365 <= code && code <= 47391) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (47392 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code < 47560) {
                      if (code < 47476) {
                        if (code < 47421) {
                          if (code < 47420) {
                            if (47393 <= code && code <= 47419) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (47420 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 47448) {
                            if (47421 <= code && code <= 47447) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 47449) {
                              if (47448 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (47449 <= code && code <= 47475) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 47505) {
                          if (code < 47477) {
                            if (47476 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 47504) {
                              if (47477 <= code && code <= 47503) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (47504 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code < 47532) {
                            if (47505 <= code && code <= 47531) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 47533) {
                              if (47532 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (47533 <= code && code <= 47559) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 47617) {
                        if (code < 47588) {
                          if (code < 47561) {
                            if (47560 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (47561 <= code && code <= 47587) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 47589) {
                            if (47588 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 47616) {
                              if (47589 <= code && code <= 47615) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (47616 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 47672) {
                          if (code < 47644) {
                            if (47617 <= code && code <= 47643) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 47645) {
                              if (47644 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (47645 <= code && code <= 47671) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code < 47673) {
                            if (47672 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 47700) {
                              if (47673 <= code && code <= 47699) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (47700 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              } else {
                if (code < 48316) {
                  if (code < 48008) {
                    if (code < 47841) {
                      if (code < 47784) {
                        if (code < 47729) {
                          if (code < 47728) {
                            if (47701 <= code && code <= 47727) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (47728 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 47756) {
                            if (47729 <= code && code <= 47755) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 47757) {
                              if (47756 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (47757 <= code && code <= 47783) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 47812) {
                          if (code < 47785) {
                            if (47784 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (47785 <= code && code <= 47811) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 47813) {
                            if (47812 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 47840) {
                              if (47813 <= code && code <= 47839) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (47840 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 47924) {
                        if (code < 47869) {
                          if (code < 47868) {
                            if (47841 <= code && code <= 47867) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (47868 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 47896) {
                            if (47869 <= code && code <= 47895) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 47897) {
                              if (47896 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (47897 <= code && code <= 47923) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 47953) {
                          if (code < 47925) {
                            if (47924 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 47952) {
                              if (47925 <= code && code <= 47951) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (47952 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code < 47980) {
                            if (47953 <= code && code <= 47979) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 47981) {
                              if (47980 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (47981 <= code && code <= 48007) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code < 48149) {
                      if (code < 48065) {
                        if (code < 48036) {
                          if (code < 48009) {
                            if (48008 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (48009 <= code && code <= 48035) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 48037) {
                            if (48036 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 48064) {
                              if (48037 <= code && code <= 48063) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (48064 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 48120) {
                          if (code < 48092) {
                            if (48065 <= code && code <= 48091) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 48093) {
                              if (48092 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (48093 <= code && code <= 48119) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code < 48121) {
                            if (48120 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 48148) {
                              if (48121 <= code && code <= 48147) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (48148 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 48232) {
                        if (code < 48177) {
                          if (code < 48176) {
                            if (48149 <= code && code <= 48175) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (48176 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 48204) {
                            if (48177 <= code && code <= 48203) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 48205) {
                              if (48204 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (48205 <= code && code <= 48231) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 48261) {
                          if (code < 48233) {
                            if (48232 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 48260) {
                              if (48233 <= code && code <= 48259) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (48260 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code < 48288) {
                            if (48261 <= code && code <= 48287) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 48289) {
                              if (48288 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (48289 <= code && code <= 48315) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  if (code < 48597) {
                    if (code < 48456) {
                      if (code < 48373) {
                        if (code < 48344) {
                          if (code < 48317) {
                            if (48316 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (48317 <= code && code <= 48343) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 48345) {
                            if (48344 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 48372) {
                              if (48345 <= code && code <= 48371) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (48372 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 48401) {
                          if (code < 48400) {
                            if (48373 <= code && code <= 48399) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (48400 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 48428) {
                            if (48401 <= code && code <= 48427) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 48429) {
                              if (48428 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (48429 <= code && code <= 48455) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 48513) {
                        if (code < 48484) {
                          if (code < 48457) {
                            if (48456 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (48457 <= code && code <= 48483) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 48485) {
                            if (48484 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 48512) {
                              if (48485 <= code && code <= 48511) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (48512 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 48568) {
                          if (code < 48540) {
                            if (48513 <= code && code <= 48539) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 48541) {
                              if (48540 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (48541 <= code && code <= 48567) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code < 48569) {
                            if (48568 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 48596) {
                              if (48569 <= code && code <= 48595) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (48596 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code < 48764) {
                      if (code < 48680) {
                        if (code < 48625) {
                          if (code < 48624) {
                            if (48597 <= code && code <= 48623) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (48624 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 48652) {
                            if (48625 <= code && code <= 48651) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 48653) {
                              if (48652 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (48653 <= code && code <= 48679) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 48709) {
                          if (code < 48681) {
                            if (48680 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 48708) {
                              if (48681 <= code && code <= 48707) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (48708 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code < 48736) {
                            if (48709 <= code && code <= 48735) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 48737) {
                              if (48736 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (48737 <= code && code <= 48763) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 48821) {
                        if (code < 48792) {
                          if (code < 48765) {
                            if (48764 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (48765 <= code && code <= 48791) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 48793) {
                            if (48792 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 48820) {
                              if (48793 <= code && code <= 48819) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (48820 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 48876) {
                          if (code < 48848) {
                            if (48821 <= code && code <= 48847) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 48849) {
                              if (48848 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (48849 <= code && code <= 48875) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code < 48877) {
                            if (48876 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 48904) {
                              if (48877 <= code && code <= 48903) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (48904 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        } else {
          if (code < 53720) {
            if (code < 51312) {
              if (code < 50108) {
                if (code < 49493) {
                  if (code < 49212) {
                    if (code < 49045) {
                      if (code < 48988) {
                        if (code < 48933) {
                          if (code < 48932) {
                            if (48905 <= code && code <= 48931) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (48932 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 48960) {
                            if (48933 <= code && code <= 48959) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 48961) {
                              if (48960 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (48961 <= code && code <= 48987) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 49016) {
                          if (code < 48989) {
                            if (48988 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (48989 <= code && code <= 49015) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 49017) {
                            if (49016 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 49044) {
                              if (49017 <= code && code <= 49043) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (49044 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 49128) {
                        if (code < 49073) {
                          if (code < 49072) {
                            if (49045 <= code && code <= 49071) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (49072 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 49100) {
                            if (49073 <= code && code <= 49099) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 49101) {
                              if (49100 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (49101 <= code && code <= 49127) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 49157) {
                          if (code < 49129) {
                            if (49128 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 49156) {
                              if (49129 <= code && code <= 49155) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (49156 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code < 49184) {
                            if (49157 <= code && code <= 49183) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 49185) {
                              if (49184 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (49185 <= code && code <= 49211) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code < 49352) {
                      if (code < 49269) {
                        if (code < 49240) {
                          if (code < 49213) {
                            if (49212 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (49213 <= code && code <= 49239) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 49241) {
                            if (49240 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 49268) {
                              if (49241 <= code && code <= 49267) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (49268 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 49297) {
                          if (code < 49296) {
                            if (49269 <= code && code <= 49295) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (49296 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 49324) {
                            if (49297 <= code && code <= 49323) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 49325) {
                              if (49324 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (49325 <= code && code <= 49351) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 49409) {
                        if (code < 49380) {
                          if (code < 49353) {
                            if (49352 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (49353 <= code && code <= 49379) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 49381) {
                            if (49380 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 49408) {
                              if (49381 <= code && code <= 49407) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (49408 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 49464) {
                          if (code < 49436) {
                            if (49409 <= code && code <= 49435) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 49437) {
                              if (49436 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (49437 <= code && code <= 49463) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code < 49465) {
                            if (49464 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 49492) {
                              if (49465 <= code && code <= 49491) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (49492 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  if (code < 49800) {
                    if (code < 49633) {
                      if (code < 49576) {
                        if (code < 49521) {
                          if (code < 49520) {
                            if (49493 <= code && code <= 49519) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (49520 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 49548) {
                            if (49521 <= code && code <= 49547) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 49549) {
                              if (49548 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (49549 <= code && code <= 49575) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 49604) {
                          if (code < 49577) {
                            if (49576 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (49577 <= code && code <= 49603) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 49605) {
                            if (49604 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 49632) {
                              if (49605 <= code && code <= 49631) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (49632 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 49716) {
                        if (code < 49661) {
                          if (code < 49660) {
                            if (49633 <= code && code <= 49659) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (49660 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 49688) {
                            if (49661 <= code && code <= 49687) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 49689) {
                              if (49688 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (49689 <= code && code <= 49715) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 49745) {
                          if (code < 49717) {
                            if (49716 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 49744) {
                              if (49717 <= code && code <= 49743) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (49744 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code < 49772) {
                            if (49745 <= code && code <= 49771) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 49773) {
                              if (49772 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (49773 <= code && code <= 49799) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code < 49941) {
                      if (code < 49857) {
                        if (code < 49828) {
                          if (code < 49801) {
                            if (49800 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (49801 <= code && code <= 49827) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 49829) {
                            if (49828 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 49856) {
                              if (49829 <= code && code <= 49855) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (49856 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 49912) {
                          if (code < 49884) {
                            if (49857 <= code && code <= 49883) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 49885) {
                              if (49884 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (49885 <= code && code <= 49911) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code < 49913) {
                            if (49912 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 49940) {
                              if (49913 <= code && code <= 49939) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (49940 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 50024) {
                        if (code < 49969) {
                          if (code < 49968) {
                            if (49941 <= code && code <= 49967) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (49968 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 49996) {
                            if (49969 <= code && code <= 49995) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 49997) {
                              if (49996 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (49997 <= code && code <= 50023) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 50053) {
                          if (code < 50025) {
                            if (50024 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 50052) {
                              if (50025 <= code && code <= 50051) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (50052 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code < 50080) {
                            if (50053 <= code && code <= 50079) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 50081) {
                              if (50080 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (50081 <= code && code <= 50107) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              } else {
                if (code < 50697) {
                  if (code < 50389) {
                    if (code < 50248) {
                      if (code < 50165) {
                        if (code < 50136) {
                          if (code < 50109) {
                            if (50108 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (50109 <= code && code <= 50135) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 50137) {
                            if (50136 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 50164) {
                              if (50137 <= code && code <= 50163) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (50164 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 50193) {
                          if (code < 50192) {
                            if (50165 <= code && code <= 50191) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (50192 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 50220) {
                            if (50193 <= code && code <= 50219) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 50221) {
                              if (50220 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (50221 <= code && code <= 50247) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 50305) {
                        if (code < 50276) {
                          if (code < 50249) {
                            if (50248 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (50249 <= code && code <= 50275) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 50277) {
                            if (50276 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 50304) {
                              if (50277 <= code && code <= 50303) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (50304 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 50360) {
                          if (code < 50332) {
                            if (50305 <= code && code <= 50331) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 50333) {
                              if (50332 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (50333 <= code && code <= 50359) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code < 50361) {
                            if (50360 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 50388) {
                              if (50361 <= code && code <= 50387) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (50388 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code < 50556) {
                      if (code < 50472) {
                        if (code < 50417) {
                          if (code < 50416) {
                            if (50389 <= code && code <= 50415) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (50416 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 50444) {
                            if (50417 <= code && code <= 50443) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 50445) {
                              if (50444 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (50445 <= code && code <= 50471) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 50501) {
                          if (code < 50473) {
                            if (50472 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 50500) {
                              if (50473 <= code && code <= 50499) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (50500 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code < 50528) {
                            if (50501 <= code && code <= 50527) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 50529) {
                              if (50528 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (50529 <= code && code <= 50555) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 50613) {
                        if (code < 50584) {
                          if (code < 50557) {
                            if (50556 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (50557 <= code && code <= 50583) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 50585) {
                            if (50584 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 50612) {
                              if (50585 <= code && code <= 50611) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (50612 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 50668) {
                          if (code < 50640) {
                            if (50613 <= code && code <= 50639) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 50641) {
                              if (50640 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (50641 <= code && code <= 50667) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code < 50669) {
                            if (50668 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 50696) {
                              if (50669 <= code && code <= 50695) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (50696 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  if (code < 51004) {
                    if (code < 50837) {
                      if (code < 50780) {
                        if (code < 50725) {
                          if (code < 50724) {
                            if (50697 <= code && code <= 50723) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (50724 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 50752) {
                            if (50725 <= code && code <= 50751) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 50753) {
                              if (50752 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (50753 <= code && code <= 50779) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 50808) {
                          if (code < 50781) {
                            if (50780 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (50781 <= code && code <= 50807) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 50809) {
                            if (50808 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 50836) {
                              if (50809 <= code && code <= 50835) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (50836 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 50920) {
                        if (code < 50865) {
                          if (code < 50864) {
                            if (50837 <= code && code <= 50863) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (50864 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 50892) {
                            if (50865 <= code && code <= 50891) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 50893) {
                              if (50892 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (50893 <= code && code <= 50919) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 50949) {
                          if (code < 50921) {
                            if (50920 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 50948) {
                              if (50921 <= code && code <= 50947) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (50948 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code < 50976) {
                            if (50949 <= code && code <= 50975) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 50977) {
                              if (50976 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (50977 <= code && code <= 51003) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code < 51145) {
                      if (code < 51061) {
                        if (code < 51032) {
                          if (code < 51005) {
                            if (51004 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (51005 <= code && code <= 51031) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 51033) {
                            if (51032 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 51060) {
                              if (51033 <= code && code <= 51059) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (51060 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 51116) {
                          if (code < 51088) {
                            if (51061 <= code && code <= 51087) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 51089) {
                              if (51088 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (51089 <= code && code <= 51115) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code < 51117) {
                            if (51116 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 51144) {
                              if (51117 <= code && code <= 51143) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (51144 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 51228) {
                        if (code < 51173) {
                          if (code < 51172) {
                            if (51145 <= code && code <= 51171) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (51172 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 51200) {
                            if (51173 <= code && code <= 51199) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 51201) {
                              if (51200 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (51201 <= code && code <= 51227) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 51257) {
                          if (code < 51229) {
                            if (51228 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 51256) {
                              if (51229 <= code && code <= 51255) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (51256 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code < 51284) {
                            if (51257 <= code && code <= 51283) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 51285) {
                              if (51284 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (51285 <= code && code <= 51311) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            } else {
              if (code < 52516) {
                if (code < 51901) {
                  if (code < 51593) {
                    if (code < 51452) {
                      if (code < 51369) {
                        if (code < 51340) {
                          if (code < 51313) {
                            if (51312 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (51313 <= code && code <= 51339) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 51341) {
                            if (51340 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 51368) {
                              if (51341 <= code && code <= 51367) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (51368 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 51397) {
                          if (code < 51396) {
                            if (51369 <= code && code <= 51395) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (51396 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 51424) {
                            if (51397 <= code && code <= 51423) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 51425) {
                              if (51424 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (51425 <= code && code <= 51451) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 51509) {
                        if (code < 51480) {
                          if (code < 51453) {
                            if (51452 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (51453 <= code && code <= 51479) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 51481) {
                            if (51480 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 51508) {
                              if (51481 <= code && code <= 51507) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (51508 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 51564) {
                          if (code < 51536) {
                            if (51509 <= code && code <= 51535) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 51537) {
                              if (51536 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (51537 <= code && code <= 51563) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code < 51565) {
                            if (51564 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 51592) {
                              if (51565 <= code && code <= 51591) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (51592 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code < 51760) {
                      if (code < 51676) {
                        if (code < 51621) {
                          if (code < 51620) {
                            if (51593 <= code && code <= 51619) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (51620 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 51648) {
                            if (51621 <= code && code <= 51647) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 51649) {
                              if (51648 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (51649 <= code && code <= 51675) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 51705) {
                          if (code < 51677) {
                            if (51676 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 51704) {
                              if (51677 <= code && code <= 51703) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (51704 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code < 51732) {
                            if (51705 <= code && code <= 51731) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 51733) {
                              if (51732 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (51733 <= code && code <= 51759) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 51817) {
                        if (code < 51788) {
                          if (code < 51761) {
                            if (51760 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (51761 <= code && code <= 51787) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 51789) {
                            if (51788 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 51816) {
                              if (51789 <= code && code <= 51815) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (51816 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 51872) {
                          if (code < 51844) {
                            if (51817 <= code && code <= 51843) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 51845) {
                              if (51844 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (51845 <= code && code <= 51871) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code < 51873) {
                            if (51872 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 51900) {
                              if (51873 <= code && code <= 51899) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (51900 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  if (code < 52208) {
                    if (code < 52041) {
                      if (code < 51984) {
                        if (code < 51929) {
                          if (code < 51928) {
                            if (51901 <= code && code <= 51927) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (51928 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 51956) {
                            if (51929 <= code && code <= 51955) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 51957) {
                              if (51956 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (51957 <= code && code <= 51983) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 52012) {
                          if (code < 51985) {
                            if (51984 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (51985 <= code && code <= 52011) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 52013) {
                            if (52012 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 52040) {
                              if (52013 <= code && code <= 52039) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (52040 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 52124) {
                        if (code < 52069) {
                          if (code < 52068) {
                            if (52041 <= code && code <= 52067) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (52068 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 52096) {
                            if (52069 <= code && code <= 52095) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 52097) {
                              if (52096 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (52097 <= code && code <= 52123) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 52153) {
                          if (code < 52125) {
                            if (52124 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 52152) {
                              if (52125 <= code && code <= 52151) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (52152 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code < 52180) {
                            if (52153 <= code && code <= 52179) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 52181) {
                              if (52180 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (52181 <= code && code <= 52207) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code < 52349) {
                      if (code < 52265) {
                        if (code < 52236) {
                          if (code < 52209) {
                            if (52208 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (52209 <= code && code <= 52235) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 52237) {
                            if (52236 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 52264) {
                              if (52237 <= code && code <= 52263) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (52264 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 52320) {
                          if (code < 52292) {
                            if (52265 <= code && code <= 52291) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 52293) {
                              if (52292 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (52293 <= code && code <= 52319) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code < 52321) {
                            if (52320 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 52348) {
                              if (52321 <= code && code <= 52347) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (52348 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 52432) {
                        if (code < 52377) {
                          if (code < 52376) {
                            if (52349 <= code && code <= 52375) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (52376 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 52404) {
                            if (52377 <= code && code <= 52403) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 52405) {
                              if (52404 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (52405 <= code && code <= 52431) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 52461) {
                          if (code < 52433) {
                            if (52432 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 52460) {
                              if (52433 <= code && code <= 52459) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (52460 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code < 52488) {
                            if (52461 <= code && code <= 52487) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 52489) {
                              if (52488 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (52489 <= code && code <= 52515) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              } else {
                if (code < 53105) {
                  if (code < 52797) {
                    if (code < 52656) {
                      if (code < 52573) {
                        if (code < 52544) {
                          if (code < 52517) {
                            if (52516 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (52517 <= code && code <= 52543) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 52545) {
                            if (52544 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 52572) {
                              if (52545 <= code && code <= 52571) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (52572 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 52601) {
                          if (code < 52600) {
                            if (52573 <= code && code <= 52599) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (52600 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 52628) {
                            if (52601 <= code && code <= 52627) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 52629) {
                              if (52628 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (52629 <= code && code <= 52655) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 52713) {
                        if (code < 52684) {
                          if (code < 52657) {
                            if (52656 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (52657 <= code && code <= 52683) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 52685) {
                            if (52684 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 52712) {
                              if (52685 <= code && code <= 52711) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (52712 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 52768) {
                          if (code < 52740) {
                            if (52713 <= code && code <= 52739) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 52741) {
                              if (52740 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (52741 <= code && code <= 52767) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code < 52769) {
                            if (52768 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 52796) {
                              if (52769 <= code && code <= 52795) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (52796 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code < 52964) {
                      if (code < 52880) {
                        if (code < 52825) {
                          if (code < 52824) {
                            if (52797 <= code && code <= 52823) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (52824 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 52852) {
                            if (52825 <= code && code <= 52851) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 52853) {
                              if (52852 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (52853 <= code && code <= 52879) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 52909) {
                          if (code < 52881) {
                            if (52880 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 52908) {
                              if (52881 <= code && code <= 52907) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (52908 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code < 52936) {
                            if (52909 <= code && code <= 52935) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 52937) {
                              if (52936 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (52937 <= code && code <= 52963) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 53021) {
                        if (code < 52992) {
                          if (code < 52965) {
                            if (52964 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (52965 <= code && code <= 52991) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 52993) {
                            if (52992 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 53020) {
                              if (52993 <= code && code <= 53019) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (53020 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 53076) {
                          if (code < 53048) {
                            if (53021 <= code && code <= 53047) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 53049) {
                              if (53048 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (53049 <= code && code <= 53075) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code < 53077) {
                            if (53076 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 53104) {
                              if (53077 <= code && code <= 53103) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (53104 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  if (code < 53412) {
                    if (code < 53245) {
                      if (code < 53188) {
                        if (code < 53133) {
                          if (code < 53132) {
                            if (53105 <= code && code <= 53131) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (53132 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 53160) {
                            if (53133 <= code && code <= 53159) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 53161) {
                              if (53160 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (53161 <= code && code <= 53187) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 53216) {
                          if (code < 53189) {
                            if (53188 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (53189 <= code && code <= 53215) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 53217) {
                            if (53216 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 53244) {
                              if (53217 <= code && code <= 53243) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (53244 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 53328) {
                        if (code < 53273) {
                          if (code < 53272) {
                            if (53245 <= code && code <= 53271) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (53272 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 53300) {
                            if (53273 <= code && code <= 53299) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 53301) {
                              if (53300 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (53301 <= code && code <= 53327) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 53357) {
                          if (code < 53329) {
                            if (53328 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 53356) {
                              if (53329 <= code && code <= 53355) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (53356 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code < 53384) {
                            if (53357 <= code && code <= 53383) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 53385) {
                              if (53384 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (53385 <= code && code <= 53411) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code < 53553) {
                      if (code < 53469) {
                        if (code < 53440) {
                          if (code < 53413) {
                            if (53412 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (53413 <= code && code <= 53439) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 53441) {
                            if (53440 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 53468) {
                              if (53441 <= code && code <= 53467) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (53468 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 53524) {
                          if (code < 53496) {
                            if (53469 <= code && code <= 53495) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 53497) {
                              if (53496 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (53497 <= code && code <= 53523) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code < 53525) {
                            if (53524 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 53552) {
                              if (53525 <= code && code <= 53551) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (53552 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 53636) {
                        if (code < 53581) {
                          if (code < 53580) {
                            if (53553 <= code && code <= 53579) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (53580 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 53608) {
                            if (53581 <= code && code <= 53607) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 53609) {
                              if (53608 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (53609 <= code && code <= 53635) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 53665) {
                          if (code < 53637) {
                            if (53636 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 53664) {
                              if (53637 <= code && code <= 53663) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (53664 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code < 53692) {
                            if (53665 <= code && code <= 53691) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 53693) {
                              if (53692 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (53693 <= code && code <= 53719) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          } else {
            if (code < 70459) {
              if (code < 54897) {
                if (code < 54308) {
                  if (code < 54001) {
                    if (code < 53860) {
                      if (code < 53777) {
                        if (code < 53748) {
                          if (code < 53721) {
                            if (53720 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (53721 <= code && code <= 53747) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 53749) {
                            if (53748 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 53776) {
                              if (53749 <= code && code <= 53775) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (53776 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 53805) {
                          if (code < 53804) {
                            if (53777 <= code && code <= 53803) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (53804 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 53832) {
                            if (53805 <= code && code <= 53831) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 53833) {
                              if (53832 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (53833 <= code && code <= 53859) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 53917) {
                        if (code < 53888) {
                          if (code < 53861) {
                            if (53860 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (53861 <= code && code <= 53887) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 53889) {
                            if (53888 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 53916) {
                              if (53889 <= code && code <= 53915) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (53916 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 53972) {
                          if (code < 53944) {
                            if (53917 <= code && code <= 53943) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 53945) {
                              if (53944 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (53945 <= code && code <= 53971) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code < 53973) {
                            if (53972 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 54e3) {
                              if (53973 <= code && code <= 53999) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (54e3 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code < 54141) {
                      if (code < 54084) {
                        if (code < 54029) {
                          if (code < 54028) {
                            if (54001 <= code && code <= 54027) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (54028 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 54056) {
                            if (54029 <= code && code <= 54055) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 54057) {
                              if (54056 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (54057 <= code && code <= 54083) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 54112) {
                          if (code < 54085) {
                            if (54084 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (54085 <= code && code <= 54111) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 54113) {
                            if (54112 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 54140) {
                              if (54113 <= code && code <= 54139) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (54140 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 54224) {
                        if (code < 54169) {
                          if (code < 54168) {
                            if (54141 <= code && code <= 54167) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (54168 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 54196) {
                            if (54169 <= code && code <= 54195) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 54197) {
                              if (54196 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (54197 <= code && code <= 54223) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 54253) {
                          if (code < 54225) {
                            if (54224 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 54252) {
                              if (54225 <= code && code <= 54251) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (54252 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code < 54280) {
                            if (54253 <= code && code <= 54279) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 54281) {
                              if (54280 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (54281 <= code && code <= 54307) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  if (code < 54589) {
                    if (code < 54448) {
                      if (code < 54365) {
                        if (code < 54336) {
                          if (code < 54309) {
                            if (54308 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (54309 <= code && code <= 54335) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 54337) {
                            if (54336 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 54364) {
                              if (54337 <= code && code <= 54363) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (54364 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 54393) {
                          if (code < 54392) {
                            if (54365 <= code && code <= 54391) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (54392 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 54420) {
                            if (54393 <= code && code <= 54419) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 54421) {
                              if (54420 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (54421 <= code && code <= 54447) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 54505) {
                        if (code < 54476) {
                          if (code < 54449) {
                            if (54448 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (54449 <= code && code <= 54475) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 54477) {
                            if (54476 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 54504) {
                              if (54477 <= code && code <= 54503) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (54504 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 54560) {
                          if (code < 54532) {
                            if (54505 <= code && code <= 54531) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 54533) {
                              if (54532 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (54533 <= code && code <= 54559) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code < 54561) {
                            if (54560 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 54588) {
                              if (54561 <= code && code <= 54587) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (54588 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code < 54756) {
                      if (code < 54672) {
                        if (code < 54617) {
                          if (code < 54616) {
                            if (54589 <= code && code <= 54615) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (54616 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 54644) {
                            if (54617 <= code && code <= 54643) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 54645) {
                              if (54644 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (54645 <= code && code <= 54671) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 54701) {
                          if (code < 54673) {
                            if (54672 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 54700) {
                              if (54673 <= code && code <= 54699) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (54700 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code < 54728) {
                            if (54701 <= code && code <= 54727) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 54729) {
                              if (54728 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (54729 <= code && code <= 54755) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 54813) {
                        if (code < 54784) {
                          if (code < 54757) {
                            if (54756 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (54757 <= code && code <= 54783) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 54785) {
                            if (54784 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 54812) {
                              if (54785 <= code && code <= 54811) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (54812 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 54868) {
                          if (code < 54840) {
                            if (54813 <= code && code <= 54839) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 54841) {
                              if (54840 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (54841 <= code && code <= 54867) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code < 54869) {
                            if (54868 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 54896) {
                              if (54869 <= code && code <= 54895) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (54896 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              } else {
                if (code < 69632) {
                  if (code < 55216) {
                    if (code < 55037) {
                      if (code < 54980) {
                        if (code < 54925) {
                          if (code < 54924) {
                            if (54897 <= code && code <= 54923) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (54924 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 54952) {
                            if (54925 <= code && code <= 54951) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 54953) {
                              if (54952 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (54953 <= code && code <= 54979) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 55008) {
                          if (code < 54981) {
                            if (54980 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (54981 <= code && code <= 55007) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 55009) {
                            if (55008 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 55036) {
                              if (55009 <= code && code <= 55035) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (55036 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 55120) {
                        if (code < 55065) {
                          if (code < 55064) {
                            if (55037 <= code && code <= 55063) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (55064 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 55092) {
                            if (55065 <= code && code <= 55091) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 55093) {
                              if (55092 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (55093 <= code && code <= 55119) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 55149) {
                          if (code < 55121) {
                            if (55120 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 55148) {
                              if (55121 <= code && code <= 55147) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (55148 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code < 55176) {
                            if (55149 <= code && code <= 55175) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 55177) {
                              if (55176 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (55177 <= code && code <= 55203) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code < 68097) {
                      if (code < 65279) {
                        if (code < 64286) {
                          if (code < 55243) {
                            if (55216 <= code && code <= 55238) {
                              return boundaries_1.CLUSTER_BREAK.V;
                            }
                          } else {
                            if (55243 <= code && code <= 55291) {
                              return boundaries_1.CLUSTER_BREAK.T;
                            }
                          }
                        } else {
                          if (code < 65024) {
                            if (64286 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 65056) {
                              if (65024 <= code && code <= 65039) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (65056 <= code && code <= 65071) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 66045) {
                          if (code < 65438) {
                            if (65279 === code) {
                              return boundaries_1.CLUSTER_BREAK.CONTROL;
                            }
                          } else {
                            if (code < 65520) {
                              if (65438 <= code && code <= 65439) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (65520 <= code && code <= 65531) {
                                return boundaries_1.CLUSTER_BREAK.CONTROL;
                              }
                            }
                          }
                        } else {
                          if (code < 66272) {
                            if (66045 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 66422) {
                              if (66272 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (66422 <= code && code <= 66426) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 68325) {
                        if (code < 68108) {
                          if (code < 68101) {
                            if (68097 <= code && code <= 68099) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (68101 <= code && code <= 68102) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 68152) {
                            if (68108 <= code && code <= 68111) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 68159) {
                              if (68152 <= code && code <= 68154) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (68159 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 69373) {
                          if (code < 68900) {
                            if (68325 <= code && code <= 68326) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 69291) {
                              if (68900 <= code && code <= 68903) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (69291 <= code && code <= 69292) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        } else {
                          if (code < 69446) {
                            if (69373 <= code && code <= 69375) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 69506) {
                              if (69446 <= code && code <= 69456) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (69506 <= code && code <= 69509) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  if (code < 70016) {
                    if (code < 69815) {
                      if (code < 69747) {
                        if (code < 69634) {
                          if (69632 === code) {
                            return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                          }
                          if (69633 === code) {
                            return boundaries_1.CLUSTER_BREAK.EXTEND;
                          }
                        } else {
                          if (code < 69688) {
                            if (69634 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code < 69744) {
                              if (69688 <= code && code <= 69702) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (69744 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 69762) {
                          if (code < 69759) {
                            if (69747 <= code && code <= 69748) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (69759 <= code && code <= 69761) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 69808) {
                            if (69762 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code < 69811) {
                              if (69808 <= code && code <= 69810) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (69811 <= code && code <= 69814) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 69888) {
                        if (code < 69821) {
                          if (code < 69817) {
                            if (69815 <= code && code <= 69816) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (69817 <= code && code <= 69818) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 69826) {
                            if (69821 === code) {
                              return boundaries_1.CLUSTER_BREAK.PREPEND;
                            }
                          } else {
                            if (69826 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                            if (69837 === code) {
                              return boundaries_1.CLUSTER_BREAK.PREPEND;
                            }
                          }
                        }
                      } else {
                        if (code < 69933) {
                          if (code < 69927) {
                            if (69888 <= code && code <= 69890) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 69932) {
                              if (69927 <= code && code <= 69931) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (69932 === code) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        } else {
                          if (code < 69957) {
                            if (69933 <= code && code <= 69940) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 70003) {
                              if (69957 <= code && code <= 69958) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (70003 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code < 70194) {
                      if (code < 70082) {
                        if (code < 70067) {
                          if (code < 70018) {
                            if (70016 <= code && code <= 70017) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (70018 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          }
                        } else {
                          if (code < 70070) {
                            if (70067 <= code && code <= 70069) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code < 70079) {
                              if (70070 <= code && code <= 70078) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (70079 <= code && code <= 70080) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 70095) {
                          if (code < 70089) {
                            if (70082 <= code && code <= 70083) {
                              return boundaries_1.CLUSTER_BREAK.PREPEND;
                            }
                          } else {
                            if (code < 70094) {
                              if (70089 <= code && code <= 70092) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (70094 === code) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        } else {
                          if (code < 70188) {
                            if (70095 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 70191) {
                              if (70188 <= code && code <= 70190) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (70191 <= code && code <= 70193) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 70209) {
                        if (code < 70197) {
                          if (code < 70196) {
                            if (70194 <= code && code <= 70195) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (70196 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 70198) {
                            if (70197 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code < 70206) {
                              if (70198 <= code && code <= 70199) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (70206 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 70371) {
                          if (code < 70367) {
                            if (70209 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 70368) {
                              if (70367 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (70368 <= code && code <= 70370) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        } else {
                          if (code < 70400) {
                            if (70371 <= code && code <= 70378) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 70402) {
                              if (70400 <= code && code <= 70401) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (70402 <= code && code <= 70403) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            } else {
              if (code < 72343) {
                if (code < 71339) {
                  if (code < 70841) {
                    if (code < 70512) {
                      if (code < 70471) {
                        if (code < 70463) {
                          if (code < 70462) {
                            if (70459 <= code && code <= 70460) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (70462 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 70464) {
                            if (70463 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code < 70465) {
                              if (70464 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (70465 <= code && code <= 70468) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 70487) {
                          if (code < 70475) {
                            if (70471 <= code && code <= 70472) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (70475 <= code && code <= 70477) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          }
                        } else {
                          if (code < 70498) {
                            if (70487 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 70502) {
                              if (70498 <= code && code <= 70499) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (70502 <= code && code <= 70508) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 70725) {
                        if (code < 70712) {
                          if (code < 70709) {
                            if (70512 <= code && code <= 70516) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (70709 <= code && code <= 70711) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          }
                        } else {
                          if (code < 70720) {
                            if (70712 <= code && code <= 70719) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 70722) {
                              if (70720 <= code && code <= 70721) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (70722 <= code && code <= 70724) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 70832) {
                          if (code < 70726) {
                            if (70725 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (70726 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                            if (70750 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 70833) {
                            if (70832 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 70835) {
                              if (70833 <= code && code <= 70834) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (70835 <= code && code <= 70840) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code < 71096) {
                      if (code < 70847) {
                        if (code < 70843) {
                          if (70841 === code) {
                            return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                          }
                          if (70842 === code) {
                            return boundaries_1.CLUSTER_BREAK.EXTEND;
                          }
                        } else {
                          if (code < 70845) {
                            if (70843 <= code && code <= 70844) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (70845 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                            if (70846 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          }
                        }
                      } else {
                        if (code < 71087) {
                          if (code < 70849) {
                            if (70847 <= code && code <= 70848) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 70850) {
                              if (70849 === code) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (70850 <= code && code <= 70851) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        } else {
                          if (code < 71088) {
                            if (71087 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 71090) {
                              if (71088 <= code && code <= 71089) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (71090 <= code && code <= 71093) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 71216) {
                        if (code < 71102) {
                          if (code < 71100) {
                            if (71096 <= code && code <= 71099) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (71100 <= code && code <= 71101) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 71103) {
                            if (71102 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code < 71132) {
                              if (71103 <= code && code <= 71104) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (71132 <= code && code <= 71133) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 71229) {
                          if (code < 71219) {
                            if (71216 <= code && code <= 71218) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code < 71227) {
                              if (71219 <= code && code <= 71226) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (71227 <= code && code <= 71228) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        } else {
                          if (code < 71230) {
                            if (71229 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 71231) {
                              if (71230 === code) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (71231 <= code && code <= 71232) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  if (code < 71999) {
                    if (code < 71463) {
                      if (code < 71350) {
                        if (code < 71341) {
                          if (71339 === code) {
                            return boundaries_1.CLUSTER_BREAK.EXTEND;
                          }
                          if (71340 === code) {
                            return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                          }
                        } else {
                          if (code < 71342) {
                            if (71341 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 71344) {
                              if (71342 <= code && code <= 71343) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (71344 <= code && code <= 71349) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 71453) {
                          if (71350 === code) {
                            return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                          }
                          if (71351 === code) {
                            return boundaries_1.CLUSTER_BREAK.EXTEND;
                          }
                        } else {
                          if (code < 71458) {
                            if (71453 <= code && code <= 71455) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 71462) {
                              if (71458 <= code && code <= 71461) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (71462 === code) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 71984) {
                        if (code < 71727) {
                          if (code < 71724) {
                            if (71463 <= code && code <= 71467) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (71724 <= code && code <= 71726) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          }
                        } else {
                          if (code < 71736) {
                            if (71727 <= code && code <= 71735) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 71737) {
                              if (71736 === code) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (71737 <= code && code <= 71738) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 71995) {
                          if (code < 71985) {
                            if (71984 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 71991) {
                              if (71985 <= code && code <= 71989) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (71991 <= code && code <= 71992) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        } else {
                          if (code < 71997) {
                            if (71995 <= code && code <= 71996) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (71997 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                            if (71998 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code < 72193) {
                      if (code < 72145) {
                        if (code < 72001) {
                          if (71999 === code) {
                            return boundaries_1.CLUSTER_BREAK.PREPEND;
                          }
                          if (72e3 === code) {
                            return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                          }
                        } else {
                          if (code < 72002) {
                            if (72001 === code) {
                              return boundaries_1.CLUSTER_BREAK.PREPEND;
                            }
                          } else {
                            if (72002 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                            if (72003 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        }
                      } else {
                        if (code < 72156) {
                          if (code < 72148) {
                            if (72145 <= code && code <= 72147) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code < 72154) {
                              if (72148 <= code && code <= 72151) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (72154 <= code && code <= 72155) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        } else {
                          if (code < 72160) {
                            if (72156 <= code && code <= 72159) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (72160 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                            if (72164 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 72263) {
                        if (code < 72249) {
                          if (code < 72243) {
                            if (72193 <= code && code <= 72202) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (72243 <= code && code <= 72248) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 72250) {
                            if (72249 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code < 72251) {
                              if (72250 === code) {
                                return boundaries_1.CLUSTER_BREAK.PREPEND;
                              }
                            } else {
                              if (72251 <= code && code <= 72254) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 72281) {
                          if (code < 72273) {
                            if (72263 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 72279) {
                              if (72273 <= code && code <= 72278) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (72279 <= code && code <= 72280) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        } else {
                          if (code < 72324) {
                            if (72281 <= code && code <= 72283) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 72330) {
                              if (72324 <= code && code <= 72329) {
                                return boundaries_1.CLUSTER_BREAK.PREPEND;
                              }
                            } else {
                              if (72330 <= code && code <= 72342) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              } else {
                if (code < 94033) {
                  if (code < 73104) {
                    if (code < 72881) {
                      if (code < 72766) {
                        if (code < 72751) {
                          if (code < 72344) {
                            if (72343 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (72344 <= code && code <= 72345) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 72752) {
                            if (72751 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code < 72760) {
                              if (72752 <= code && code <= 72758) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (72760 <= code && code <= 72765) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 72850) {
                          if (72766 === code) {
                            return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                          }
                          if (72767 === code) {
                            return boundaries_1.CLUSTER_BREAK.EXTEND;
                          }
                        } else {
                          if (code < 72873) {
                            if (72850 <= code && code <= 72871) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 72874) {
                              if (72873 === code) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (72874 <= code && code <= 72880) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 73018) {
                        if (code < 72884) {
                          if (code < 72882) {
                            if (72881 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (72882 <= code && code <= 72883) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 72885) {
                            if (72884 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code < 73009) {
                              if (72885 <= code && code <= 72886) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (73009 <= code && code <= 73014) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 73030) {
                          if (code < 73020) {
                            if (73018 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 73023) {
                              if (73020 <= code && code <= 73021) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (73023 <= code && code <= 73029) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        } else {
                          if (code < 73031) {
                            if (73030 === code) {
                              return boundaries_1.CLUSTER_BREAK.PREPEND;
                            }
                          } else {
                            if (code < 73098) {
                              if (73031 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (73098 <= code && code <= 73102) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code < 73526) {
                      if (code < 73459) {
                        if (code < 73109) {
                          if (code < 73107) {
                            if (73104 <= code && code <= 73105) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (73107 <= code && code <= 73108) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          }
                        } else {
                          if (code < 73110) {
                            if (73109 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (73110 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                            if (73111 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        }
                      } else {
                        if (code < 73474) {
                          if (code < 73461) {
                            if (73459 <= code && code <= 73460) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 73472) {
                              if (73461 <= code && code <= 73462) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (73472 <= code && code <= 73473) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        } else {
                          if (code < 73475) {
                            if (73474 === code) {
                              return boundaries_1.CLUSTER_BREAK.PREPEND;
                            }
                          } else {
                            if (code < 73524) {
                              if (73475 === code) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (73524 <= code && code <= 73525) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 78896) {
                        if (code < 73536) {
                          if (code < 73534) {
                            if (73526 <= code && code <= 73530) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (73534 <= code && code <= 73535) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          }
                        } else {
                          if (code < 73537) {
                            if (73536 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (73537 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                            if (73538 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        }
                      } else {
                        if (code < 92912) {
                          if (code < 78912) {
                            if (78896 <= code && code <= 78911) {
                              return boundaries_1.CLUSTER_BREAK.CONTROL;
                            }
                          } else {
                            if (code < 78919) {
                              if (78912 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (78919 <= code && code <= 78933) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        } else {
                          if (code < 92976) {
                            if (92912 <= code && code <= 92916) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 94031) {
                              if (92976 <= code && code <= 92982) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (94031 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  if (code < 121476) {
                    if (code < 119143) {
                      if (code < 113824) {
                        if (code < 94180) {
                          if (code < 94095) {
                            if (94033 <= code && code <= 94087) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (94095 <= code && code <= 94098) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 94192) {
                            if (94180 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 113821) {
                              if (94192 <= code && code <= 94193) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (113821 <= code && code <= 113822) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 118576) {
                          if (code < 118528) {
                            if (113824 <= code && code <= 113827) {
                              return boundaries_1.CLUSTER_BREAK.CONTROL;
                            }
                          } else {
                            if (118528 <= code && code <= 118573) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 119141) {
                            if (118576 <= code && code <= 118598) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (119141 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                            if (119142 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 119173) {
                        if (code < 119150) {
                          if (code < 119149) {
                            if (119143 <= code && code <= 119145) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (119149 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          }
                        } else {
                          if (code < 119155) {
                            if (119150 <= code && code <= 119154) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 119163) {
                              if (119155 <= code && code <= 119162) {
                                return boundaries_1.CLUSTER_BREAK.CONTROL;
                              }
                            } else {
                              if (119163 <= code && code <= 119170) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 121344) {
                          if (code < 119210) {
                            if (119173 <= code && code <= 119179) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 119362) {
                              if (119210 <= code && code <= 119213) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (119362 <= code && code <= 119364) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        } else {
                          if (code < 121403) {
                            if (121344 <= code && code <= 121398) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 121461) {
                              if (121403 <= code && code <= 121452) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (121461 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code < 123628) {
                      if (code < 122907) {
                        if (code < 121505) {
                          if (code < 121499) {
                            if (121476 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (121499 <= code && code <= 121503) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 122880) {
                            if (121505 <= code && code <= 121519) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 122888) {
                              if (122880 <= code && code <= 122886) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (122888 <= code && code <= 122904) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 123023) {
                          if (code < 122915) {
                            if (122907 <= code && code <= 122913) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 122918) {
                              if (122915 <= code && code <= 122916) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (122918 <= code && code <= 122922) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        } else {
                          if (code < 123184) {
                            if (123023 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 123566) {
                              if (123184 <= code && code <= 123190) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (123566 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 127995) {
                        if (code < 125136) {
                          if (code < 124140) {
                            if (123628 <= code && code <= 123631) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (124140 <= code && code <= 124143) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 125252) {
                            if (125136 <= code && code <= 125142) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 127462) {
                              if (125252 <= code && code <= 125258) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (127462 <= code && code <= 127487) {
                                return boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 917632) {
                          if (code < 917504) {
                            if (127995 <= code && code <= 127999) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 917536) {
                              if (917504 <= code && code <= 917535) {
                                return boundaries_1.CLUSTER_BREAK.CONTROL;
                              }
                            } else {
                              if (917536 <= code && code <= 917631) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        } else {
                          if (code < 917760) {
                            if (917632 <= code && code <= 917759) {
                              return boundaries_1.CLUSTER_BREAK.CONTROL;
                            }
                          } else {
                            if (code < 918e3) {
                              if (917760 <= code && code <= 917999) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (918e3 <= code && code <= 921599) {
                                return boundaries_1.CLUSTER_BREAK.CONTROL;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        return boundaries_1.CLUSTER_BREAK.OTHER;
      }
      /**
       * Given a Unicode code point, returns if symbol is an extended pictographic or some other break
       * @param code {number} Unicode code point
       * @returns {number}
       */
      static getEmojiProperty(code) {
        if (code < 10160) {
          if (code < 9728) {
            if (code < 9e3) {
              if (code < 8482) {
                if (code < 8252) {
                  if (169 === code) {
                    return boundaries_1.EXTENDED_PICTOGRAPHIC;
                  }
                  if (174 === code) {
                    return boundaries_1.EXTENDED_PICTOGRAPHIC;
                  }
                } else {
                  if (8252 === code) {
                    return boundaries_1.EXTENDED_PICTOGRAPHIC;
                  }
                  if (8265 === code) {
                    return boundaries_1.EXTENDED_PICTOGRAPHIC;
                  }
                }
              } else {
                if (code < 8596) {
                  if (8482 === code) {
                    return boundaries_1.EXTENDED_PICTOGRAPHIC;
                  }
                  if (8505 === code) {
                    return boundaries_1.EXTENDED_PICTOGRAPHIC;
                  }
                } else {
                  if (code < 8617) {
                    if (8596 <= code && code <= 8601) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (code < 8986) {
                      if (8617 <= code && code <= 8618) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    } else {
                      if (8986 <= code && code <= 8987) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    }
                  }
                }
              }
            } else {
              if (code < 9410) {
                if (code < 9167) {
                  if (9e3 === code) {
                    return boundaries_1.EXTENDED_PICTOGRAPHIC;
                  }
                  if (9096 === code) {
                    return boundaries_1.EXTENDED_PICTOGRAPHIC;
                  }
                } else {
                  if (code < 9193) {
                    if (9167 === code) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (code < 9208) {
                      if (9193 <= code && code <= 9203) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    } else {
                      if (9208 <= code && code <= 9210) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    }
                  }
                }
              } else {
                if (code < 9654) {
                  if (code < 9642) {
                    if (9410 === code) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (9642 <= code && code <= 9643) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  }
                } else {
                  if (code < 9664) {
                    if (9654 === code) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (code < 9723) {
                      if (9664 === code) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    } else {
                      if (9723 <= code && code <= 9726) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    }
                  }
                }
              }
            }
          } else {
            if (code < 10035) {
              if (code < 10004) {
                if (code < 9748) {
                  if (code < 9735) {
                    if (9728 <= code && code <= 9733) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (9735 <= code && code <= 9746) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  }
                } else {
                  if (code < 9872) {
                    if (9748 <= code && code <= 9861) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (code < 9992) {
                      if (9872 <= code && code <= 9989) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    } else {
                      if (9992 <= code && code <= 10002) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    }
                  }
                }
              } else {
                if (code < 10013) {
                  if (10004 === code) {
                    return boundaries_1.EXTENDED_PICTOGRAPHIC;
                  }
                  if (10006 === code) {
                    return boundaries_1.EXTENDED_PICTOGRAPHIC;
                  }
                } else {
                  if (code < 10017) {
                    if (10013 === code) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (10017 === code) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                    if (10024 === code) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  }
                }
              }
            } else {
              if (code < 10067) {
                if (code < 10055) {
                  if (code < 10052) {
                    if (10035 <= code && code <= 10036) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (10052 === code) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  }
                } else {
                  if (code < 10060) {
                    if (10055 === code) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (10060 === code) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                    if (10062 === code) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  }
                }
              } else {
                if (code < 10083) {
                  if (code < 10071) {
                    if (10067 <= code && code <= 10069) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (10071 === code) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  }
                } else {
                  if (code < 10133) {
                    if (10083 <= code && code <= 10087) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (code < 10145) {
                      if (10133 <= code && code <= 10135) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    } else {
                      if (10145 === code) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    }
                  }
                }
              }
            }
          }
        } else {
          if (code < 127489) {
            if (code < 12951) {
              if (code < 11035) {
                if (code < 10548) {
                  if (10160 === code) {
                    return boundaries_1.EXTENDED_PICTOGRAPHIC;
                  }
                  if (10175 === code) {
                    return boundaries_1.EXTENDED_PICTOGRAPHIC;
                  }
                } else {
                  if (code < 11013) {
                    if (10548 <= code && code <= 10549) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (11013 <= code && code <= 11015) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  }
                }
              } else {
                if (code < 11093) {
                  if (code < 11088) {
                    if (11035 <= code && code <= 11036) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (11088 === code) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  }
                } else {
                  if (code < 12336) {
                    if (11093 === code) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (12336 === code) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                    if (12349 === code) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  }
                }
              }
            } else {
              if (code < 127340) {
                if (code < 126976) {
                  if (12951 === code) {
                    return boundaries_1.EXTENDED_PICTOGRAPHIC;
                  }
                  if (12953 === code) {
                    return boundaries_1.EXTENDED_PICTOGRAPHIC;
                  }
                } else {
                  if (code < 127245) {
                    if (126976 <= code && code <= 127231) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (code < 127279) {
                      if (127245 <= code && code <= 127247) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    } else {
                      if (127279 === code) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    }
                  }
                }
              } else {
                if (code < 127374) {
                  if (code < 127358) {
                    if (127340 <= code && code <= 127345) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (127358 <= code && code <= 127359) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  }
                } else {
                  if (code < 127377) {
                    if (127374 === code) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (code < 127405) {
                      if (127377 <= code && code <= 127386) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    } else {
                      if (127405 <= code && code <= 127461) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    }
                  }
                }
              }
            }
          } else {
            if (code < 128981) {
              if (code < 127561) {
                if (code < 127535) {
                  if (code < 127514) {
                    if (127489 <= code && code <= 127503) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (127514 === code) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  }
                } else {
                  if (code < 127538) {
                    if (127535 === code) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (code < 127548) {
                      if (127538 <= code && code <= 127546) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    } else {
                      if (127548 <= code && code <= 127551) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    }
                  }
                }
              } else {
                if (code < 128326) {
                  if (code < 128e3) {
                    if (127561 <= code && code <= 127994) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (128e3 <= code && code <= 128317) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  }
                } else {
                  if (code < 128640) {
                    if (128326 <= code && code <= 128591) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (code < 128884) {
                      if (128640 <= code && code <= 128767) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    } else {
                      if (128884 <= code && code <= 128895) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    }
                  }
                }
              }
            } else {
              if (code < 129198) {
                if (code < 129096) {
                  if (code < 129036) {
                    if (128981 <= code && code <= 129023) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (129036 <= code && code <= 129039) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  }
                } else {
                  if (code < 129114) {
                    if (129096 <= code && code <= 129103) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (code < 129160) {
                      if (129114 <= code && code <= 129119) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    } else {
                      if (129160 <= code && code <= 129167) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    }
                  }
                }
              } else {
                if (code < 129340) {
                  if (code < 129292) {
                    if (129198 <= code && code <= 129279) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (129292 <= code && code <= 129338) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  }
                } else {
                  if (code < 129351) {
                    if (129340 <= code && code <= 129349) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (code < 130048) {
                      if (129351 <= code && code <= 129791) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    } else {
                      if (130048 <= code && code <= 131069) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    }
                  }
                }
              }
            }
          }
        }
        return boundaries_1.CLUSTER_BREAK.OTHER;
      }
    };
    Graphemer.default = Graphemer$1;
    return Graphemer;
  }
  var hasRequiredLib;
  function requireLib() {
    if (hasRequiredLib) return lib;
    hasRequiredLib = 1;
    var __importDefault = lib && lib.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(lib, "__esModule", { value: true });
    const Graphemer_1 = __importDefault(requireGraphemer());
    lib.default = Graphemer_1.default;
    return lib;
  }
  var hasRequiredStrings;
  function requireStrings() {
    if (hasRequiredStrings) return strings;
    hasRequiredStrings = 1;
    var __createBinding = strings && strings.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = strings && strings.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = strings && strings.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = strings && strings.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(strings, "__esModule", { value: true });
    strings.validateLanguage = strings.parseLanguage = strings.b64UrlToUtf8 = strings.utf8ToB64Url = strings.graphemeLen = strings.utf8Len = void 0;
    const graphemer_1 = __importDefault(requireLib());
    const ui8 = __importStar(require$$1);
    const utf8Len = (str) => {
      return new TextEncoder().encode(str).byteLength;
    };
    strings.utf8Len = utf8Len;
    const graphemeLen = (str) => {
      const splitter = new graphemer_1.default();
      return splitter.countGraphemes(str);
    };
    strings.graphemeLen = graphemeLen;
    const utf8ToB64Url = (utf8) => {
      return ui8.toString(ui8.fromString(utf8, "utf8"), "base64url");
    };
    strings.utf8ToB64Url = utf8ToB64Url;
    const b64UrlToUtf8 = (b64) => {
      return ui8.toString(ui8.fromString(b64, "base64url"), "utf8");
    };
    strings.b64UrlToUtf8 = b64UrlToUtf8;
    const parseLanguage = (langTag) => {
      const parsed = langTag.match(bcp47Regexp);
      if (!parsed?.groups)
        return null;
      const parts = parsed.groups;
      return {
        grandfathered: parts.grandfathered,
        language: parts.language,
        extlang: parts.extlang,
        script: parts.script,
        region: parts.region,
        variant: parts.variant,
        extension: parts.extension,
        privateUse: parts.privateUseA || parts.privateUseB
      };
    };
    strings.parseLanguage = parseLanguage;
    const validateLanguage = (langTag) => {
      return bcp47Regexp.test(langTag);
    };
    strings.validateLanguage = validateLanguage;
    const bcp47Regexp = /^((?<grandfathered>(en-GB-oed|i-ami|i-bnn|i-default|i-enochian|i-hak|i-klingon|i-lux|i-mingo|i-navajo|i-pwn|i-tao|i-tay|i-tsu|sgn-BE-FR|sgn-BE-NL|sgn-CH-DE)|(art-lojban|cel-gaulish|no-bok|no-nyn|zh-guoyu|zh-hakka|zh-min|zh-min-nan|zh-xiang))|((?<language>([A-Za-z]{2,3}(-(?<extlang>[A-Za-z]{3}(-[A-Za-z]{3}){0,2}))?)|[A-Za-z]{4}|[A-Za-z]{5,8})(-(?<script>[A-Za-z]{4}))?(-(?<region>[A-Za-z]{2}|[0-9]{3}))?(-(?<variant>[A-Za-z0-9]{5,8}|[0-9][A-Za-z0-9]{3}))*(-(?<extension>[0-9A-WY-Za-wy-z](-[A-Za-z0-9]{2,8})+))*(-(?<privateUseA>x(-[A-Za-z0-9]{1,8})+))?)|(?<privateUseB>x(-[A-Za-z0-9]{1,8})+))$/;
    return strings;
  }
  var didDoc = {};
  var hasRequiredDidDoc;
  function requireDidDoc() {
    if (hasRequiredDidDoc) return didDoc;
    hasRequiredDidDoc = 1;
    (function(exports$1) {
      Object.defineProperty(exports$1, "__esModule", { value: true });
      exports$1.didDocument = exports$1.getServiceEndpoint = exports$1.getNotifEndpoint = exports$1.getFeedGenEndpoint = exports$1.getPdsEndpoint = exports$1.getSigningDidKey = exports$1.getVerificationMaterial = exports$1.getSigningKey = exports$1.getHandle = exports$1.getDid = exports$1.isValidDidDoc = void 0;
      const zod_1 = /* @__PURE__ */ requireLib$1();
      const isValidDidDoc = (doc) => {
        return exports$1.didDocument.safeParse(doc).success;
      };
      exports$1.isValidDidDoc = isValidDidDoc;
      const getDid = (doc) => {
        const id = doc.id;
        if (typeof id !== "string") {
          throw new Error("No `id` on document");
        }
        return id;
      };
      exports$1.getDid = getDid;
      const getHandle = (doc) => {
        const aka = doc.alsoKnownAs;
        if (aka) {
          for (let i = 0; i < aka.length; i++) {
            const alias = aka[i];
            if (alias.startsWith("at://")) {
              return alias.slice(5);
            }
          }
        }
        return void 0;
      };
      exports$1.getHandle = getHandle;
      const getSigningKey = (doc) => {
        return (0, exports$1.getVerificationMaterial)(doc, "atproto");
      };
      exports$1.getSigningKey = getSigningKey;
      const getVerificationMaterial = (doc, keyId) => {
        const key = findItemById(doc, "verificationMethod", `#${keyId}`);
        if (!key) {
          return void 0;
        }
        if (!key.publicKeyMultibase) {
          return void 0;
        }
        return {
          type: key.type,
          publicKeyMultibase: key.publicKeyMultibase
        };
      };
      exports$1.getVerificationMaterial = getVerificationMaterial;
      const getSigningDidKey = (doc) => {
        const parsed = (0, exports$1.getSigningKey)(doc);
        if (!parsed)
          return;
        return `did:key:${parsed.publicKeyMultibase}`;
      };
      exports$1.getSigningDidKey = getSigningDidKey;
      const getPdsEndpoint = (doc) => {
        return (0, exports$1.getServiceEndpoint)(doc, {
          id: "#atproto_pds",
          type: "AtprotoPersonalDataServer"
        });
      };
      exports$1.getPdsEndpoint = getPdsEndpoint;
      const getFeedGenEndpoint = (doc) => {
        return (0, exports$1.getServiceEndpoint)(doc, {
          id: "#bsky_fg",
          type: "BskyFeedGenerator"
        });
      };
      exports$1.getFeedGenEndpoint = getFeedGenEndpoint;
      const getNotifEndpoint = (doc) => {
        return (0, exports$1.getServiceEndpoint)(doc, {
          id: "#bsky_notif",
          type: "BskyNotificationService"
        });
      };
      exports$1.getNotifEndpoint = getNotifEndpoint;
      const getServiceEndpoint = (doc, opts) => {
        const service3 = findItemById(doc, "service", opts.id);
        if (!service3) {
          return void 0;
        }
        if (opts.type && service3.type !== opts.type) {
          return void 0;
        }
        if (typeof service3.serviceEndpoint !== "string") {
          return void 0;
        }
        return validateUrl(service3.serviceEndpoint);
      };
      exports$1.getServiceEndpoint = getServiceEndpoint;
      function findItemById(doc, type, id) {
        const items = doc[type];
        if (items) {
          for (let i = 0; i < items.length; i++) {
            const item = items[i];
            const itemId = item.id;
            if (itemId[0] === "#" ? itemId === id : (
              // Optimized version of: itemId === `${doc.id}${id}`
              itemId.length === doc.id.length + id.length && itemId[doc.id.length] === "#" && itemId.endsWith(id) && itemId.startsWith(doc.id)
            )) {
              return item;
            }
          }
        }
        return void 0;
      }
      const validateUrl = (urlStr) => {
        if (!urlStr.startsWith("http://") && !urlStr.startsWith("https://")) {
          return void 0;
        }
        if (!canParseUrl(urlStr)) {
          return void 0;
        }
        return urlStr;
      };
      const canParseUrl = URL.canParse ?? // URL.canParse is not available in Node.js < 18.17.0
      ((urlStr) => {
        try {
          new URL(urlStr);
          return true;
        } catch {
          return false;
        }
      });
      const verificationMethod = zod_1.z.object({
        id: zod_1.z.string(),
        type: zod_1.z.string(),
        controller: zod_1.z.string(),
        publicKeyMultibase: zod_1.z.string().optional()
      });
      const service2 = zod_1.z.object({
        id: zod_1.z.string(),
        type: zod_1.z.string(),
        serviceEndpoint: zod_1.z.union([zod_1.z.string(), zod_1.z.record(zod_1.z.unknown())])
      });
      exports$1.didDocument = zod_1.z.object({
        id: zod_1.z.string(),
        alsoKnownAs: zod_1.z.array(zod_1.z.string()).optional(),
        verificationMethod: zod_1.z.array(verificationMethod).optional(),
        service: zod_1.z.array(service2).optional()
      });
    })(didDoc);
    return didDoc;
  }
  var hasRequiredDist$4;
  function requireDist$4() {
    if (hasRequiredDist$4) return dist$2;
    hasRequiredDist$4 = 1;
    (function(exports$1) {
      var __createBinding = dist$2 && dist$2.__createBinding || (Object.create ? (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      }));
      var __setModuleDefault = dist$2 && dist$2.__setModuleDefault || (Object.create ? (function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      }) : function(o, v) {
        o["default"] = v;
      });
      var __importStar = dist$2 && dist$2.__importStar || function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      var __exportStar = dist$2 && dist$2.__exportStar || function(m, exports$12) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$12, p)) __createBinding(exports$12, m, p);
      };
      Object.defineProperty(exports$1, "__esModule", { value: true });
      exports$1.util = exports$1.check = void 0;
      exports$1.check = __importStar(requireCheck());
      exports$1.util = __importStar(requireUtil$6());
      __exportStar(requireArrays(), exports$1);
      __exportStar(requireAsync(), exports$1);
      __exportStar(requireUtil$6(), exports$1);
      __exportStar(requireTid(), exports$1);
      __exportStar(requireIpld(), exports$1);
      __exportStar(requireRetry(), exports$1);
      __exportStar(requireTypes$3(), exports$1);
      __exportStar(requireTimes(), exports$1);
      __exportStar(requireStrings(), exports$1);
      __exportStar(requireDidDoc(), exports$1);
    })(dist$2);
    return dist$2;
  }
  var hasRequiredBlobRefs;
  function requireBlobRefs() {
    if (hasRequiredBlobRefs) return blobRefs;
    hasRequiredBlobRefs = 1;
    (function(exports$1) {
      Object.defineProperty(exports$1, "__esModule", { value: true });
      exports$1.BlobRef = exports$1.jsonBlobRef = exports$1.untypedJsonBlobRef = exports$1.typedJsonBlobRef = void 0;
      const cid_1 = require$$0$1;
      const zod_1 = /* @__PURE__ */ requireLib$1();
      const common_web_1 = requireDist$4();
      exports$1.typedJsonBlobRef = zod_1.z.object({
        $type: zod_1.z.literal("blob"),
        ref: common_web_1.schema.cid,
        mimeType: zod_1.z.string(),
        size: zod_1.z.number()
      }).strict();
      exports$1.untypedJsonBlobRef = zod_1.z.object({
        cid: zod_1.z.string(),
        mimeType: zod_1.z.string()
      }).strict();
      exports$1.jsonBlobRef = zod_1.z.union([exports$1.typedJsonBlobRef, exports$1.untypedJsonBlobRef]);
      class BlobRef {
        constructor(ref, mimeType, size, original) {
          Object.defineProperty(this, "ref", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: ref
          });
          Object.defineProperty(this, "mimeType", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: mimeType
          });
          Object.defineProperty(this, "size", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: size
          });
          Object.defineProperty(this, "original", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          this.original = original ?? {
            $type: "blob",
            ref,
            mimeType,
            size
          };
        }
        static asBlobRef(obj) {
          if (common_web_1.check.is(obj, exports$1.jsonBlobRef)) {
            return BlobRef.fromJsonRef(obj);
          }
          return null;
        }
        static fromJsonRef(json) {
          if (common_web_1.check.is(json, exports$1.typedJsonBlobRef)) {
            return new BlobRef(json.ref, json.mimeType, json.size);
          } else {
            return new BlobRef(cid_1.CID.parse(json.cid), json.mimeType, -1, json);
          }
        }
        ipld() {
          return {
            $type: "blob",
            ref: this.ref,
            mimeType: this.mimeType,
            size: this.size
          };
        }
        toJSON() {
          return (0, common_web_1.ipldToJson)(this.ipld());
        }
      }
      exports$1.BlobRef = BlobRef;
    })(blobRefs);
    return blobRefs;
  }
  var hasRequiredBlob;
  function requireBlob() {
    if (hasRequiredBlob) return blob;
    hasRequiredBlob = 1;
    Object.defineProperty(blob, "__esModule", { value: true });
    blob.blob = blob$1;
    const blob_refs_1 = requireBlobRefs();
    const types_1 = requireTypes$4();
    function blob$1(lexicons2, path, def, value) {
      if (!value || !(value instanceof blob_refs_1.BlobRef)) {
        return {
          success: false,
          error: new types_1.ValidationError(`${path} should be a blob ref`)
        };
      }
      return { success: true, value };
    }
    return blob;
  }
  var primitives = {};
  var formats = {};
  var dist$1 = {};
  var hasRequiredDist$3;
  function requireDist$3() {
    if (hasRequiredDist$3) return dist$1;
    hasRequiredDist$3 = 1;
    (function(exports$1) {
      (() => {
        var e = { d: (t2, r2) => {
          for (var n2 in r2) e.o(r2, n2) && !e.o(t2, n2) && Object.defineProperty(t2, n2, { enumerable: true, get: r2[n2] });
        }, o: (e2, t2) => Object.prototype.hasOwnProperty.call(e2, t2), r: (e2) => {
          "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e2, "__esModule", { value: true });
        } }, t = {};
        function r(e2, t2) {
          return void 0 === t2 && (t2 = "-"), new RegExp("^(?!0{4}" + t2 + "0{2}" + t2 + "0{2})((?=[0-9]{4}" + t2 + "(((0[^2])|1[0-2])|02(?=" + t2 + "(([0-1][0-9])|2[0-8])))" + t2 + "[0-9]{2})|(?=((([13579][26])|([2468][048])|(0[48]))0{2})|([0-9]{2}((((0|[2468])[48])|[2468][048])|([13579][26])))" + t2 + "02" + t2 + "29))([0-9]{4})" + t2 + "(?!((0[469])|11)" + t2 + "31)((0[1,3-9]|1[0-2])|(02(?!" + t2 + "3)))" + t2 + "(0[1-9]|[1-2][0-9]|3[0-1])$").test(e2);
        }
        function n(e2) {
          var t2 = /\D/.exec(e2);
          return t2 ? t2[0] : "";
        }
        function i(e2, t2, r2) {
          void 0 === t2 && (t2 = ":"), void 0 === r2 && (r2 = false);
          var i2 = new RegExp("^([0-1]|2(?=([0-3])|4" + t2 + "00))[0-9]" + t2 + "[0-5][0-9](" + t2 + "([0-5]|6(?=0))[0-9])?(.[0-9]{1,9})?$");
          if (!r2 || !/[Z+\-]/.test(e2)) return i2.test(e2);
          if (/Z$/.test(e2)) return i2.test(e2.replace("Z", ""));
          var o2 = e2.includes("+"), a2 = e2.split(/[+-]/), u2 = a2[0], d2 = a2[1];
          return i2.test(u2) && (function(e3, t3, r3) {
            return void 0 === r3 && (r3 = ":"), new RegExp(t3 ? "^(0(?!(2" + r3 + "4)|0" + r3 + "3)|1(?=([0-1]|2(?=" + r3 + "[04])|[34](?=" + r3 + "0))))([03469](?=" + r3 + "[03])|[17](?=" + r3 + "0)|2(?=" + r3 + "[04])|5(?=" + r3 + "[034])|8(?=" + r3 + "[04]))" + r3 + "([03](?=0)|4(?=5))[05]$" : "^(0(?=[^0])|1(?=[0-2]))([39](?=" + r3 + "[03])|[0-24-8](?=" + r3 + "00))" + r3 + "[03]0$").test(e3);
          })(d2, o2, n(d2));
        }
        function o(e2) {
          var t2 = e2.split("T"), o2 = t2[0], a2 = t2[1], u2 = r(o2, n(o2));
          if (!a2) return false;
          var d2, s = (d2 = a2.match(/([^Z+\-\d])(?=\d+\1)/), Array.isArray(d2) ? d2[0] : "");
          return u2 && i(a2, s, true);
        }
        function a(e2, t2) {
          return void 0 === t2 && (t2 = "-"), new RegExp("^[0-9]{4}" + t2 + "(0(?=[^0])|1(?=[0-2]))[0-9]$").test(e2);
        }
        e.r(t), e.d(t, { isValidDate: () => r, isValidISODateString: () => o, isValidTime: () => i, isValidYearMonth: () => a });
        var u = exports$1;
        for (var d in t) u[d] = t[d];
        t.__esModule && Object.defineProperty(u, "__esModule", { value: true });
      })();
    })(dist$1);
    return dist$1;
  }
  var hasRequiredFormats;
  function requireFormats() {
    if (hasRequiredFormats) return formats;
    hasRequiredFormats = 1;
    Object.defineProperty(formats, "__esModule", { value: true });
    formats.datetime = datetime2;
    formats.uri = uri;
    formats.atUri = atUri;
    formats.did = did2;
    formats.handle = handle2;
    formats.atIdentifier = atIdentifier;
    formats.nsid = nsid2;
    formats.cid = cid2;
    formats.language = language;
    formats.tid = tid2;
    formats.recordKey = recordKey;
    const iso_datestring_validator_1 = requireDist$3();
    const cid_1 = require$$0$1;
    const common_web_1 = requireDist$4();
    const syntax_1 = requireDist$5();
    const types_1 = requireTypes$4();
    function datetime2(path, value) {
      try {
        if (!(0, iso_datestring_validator_1.isValidISODateString)(value)) {
          throw new Error();
        }
      } catch {
        return {
          success: false,
          error: new types_1.ValidationError(`${path} must be an valid atproto datetime (both RFC-3339 and ISO-8601)`)
        };
      }
      return { success: true, value };
    }
    function uri(path, value) {
      const isUri = value.match(/^\w+:(?:\/\/)?[^\s/][^\s]*$/) !== null;
      if (!isUri) {
        return {
          success: false,
          error: new types_1.ValidationError(`${path} must be a uri`)
        };
      }
      return { success: true, value };
    }
    function atUri(path, value) {
      try {
        (0, syntax_1.ensureValidAtUri)(value);
      } catch {
        return {
          success: false,
          error: new types_1.ValidationError(`${path} must be a valid at-uri`)
        };
      }
      return { success: true, value };
    }
    function did2(path, value) {
      try {
        (0, syntax_1.ensureValidDid)(value);
      } catch {
        return {
          success: false,
          error: new types_1.ValidationError(`${path} must be a valid did`)
        };
      }
      return { success: true, value };
    }
    function handle2(path, value) {
      try {
        (0, syntax_1.ensureValidHandle)(value);
      } catch {
        return {
          success: false,
          error: new types_1.ValidationError(`${path} must be a valid handle`)
        };
      }
      return { success: true, value };
    }
    function atIdentifier(path, value) {
      if (value.startsWith("did:")) {
        const didResult = did2(path, value);
        if (didResult.success)
          return didResult;
      } else {
        const handleResult = handle2(path, value);
        if (handleResult.success)
          return handleResult;
      }
      return {
        success: false,
        error: new types_1.ValidationError(`${path} must be a valid did or a handle`)
      };
    }
    function nsid2(path, value) {
      try {
        (0, syntax_1.ensureValidNsid)(value);
      } catch {
        return {
          success: false,
          error: new types_1.ValidationError(`${path} must be a valid nsid`)
        };
      }
      return { success: true, value };
    }
    function cid2(path, value) {
      try {
        cid_1.CID.parse(value);
      } catch {
        return {
          success: false,
          error: new types_1.ValidationError(`${path} must be a cid string`)
        };
      }
      return { success: true, value };
    }
    function language(path, value) {
      if ((0, common_web_1.validateLanguage)(value)) {
        return { success: true, value };
      }
      return {
        success: false,
        error: new types_1.ValidationError(`${path} must be a well-formed BCP 47 language tag`)
      };
    }
    function tid2(path, value) {
      if ((0, syntax_1.isValidTid)(value)) {
        return { success: true, value };
      }
      return {
        success: false,
        error: new types_1.ValidationError(`${path} must be a valid TID`)
      };
    }
    function recordKey(path, value) {
      try {
        (0, syntax_1.ensureValidRecordKey)(value);
      } catch {
        return {
          success: false,
          error: new types_1.ValidationError(`${path} must be a valid Record Key`)
        };
      }
      return { success: true, value };
    }
    return formats;
  }
  var hasRequiredPrimitives;
  function requirePrimitives() {
    if (hasRequiredPrimitives) return primitives;
    hasRequiredPrimitives = 1;
    var __createBinding = primitives && primitives.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = primitives && primitives.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = primitives && primitives.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(primitives, "__esModule", { value: true });
    primitives.validate = validate;
    const cid_1 = require$$0$1;
    const common_web_1 = requireDist$4();
    const types_1 = requireTypes$4();
    const formats2 = __importStar(requireFormats());
    function validate(lexicons2, path, def, value) {
      switch (def.type) {
        case "boolean":
          return boolean(lexicons2, path, def, value);
        case "integer":
          return integer(lexicons2, path, def, value);
        case "string":
          return string2(lexicons2, path, def, value);
        case "bytes":
          return bytes(lexicons2, path, def, value);
        case "cid-link":
          return cidLink(lexicons2, path, def, value);
        case "unknown":
          return unknown(lexicons2, path, def, value);
        default:
          return {
            success: false,
            error: new types_1.ValidationError(`Unexpected lexicon type: ${def.type}`)
          };
      }
    }
    function boolean(lexicons2, path, def, value) {
      def = def;
      const type = typeof value;
      if (type === "undefined") {
        if (typeof def.default === "boolean") {
          return { success: true, value: def.default };
        }
        return {
          success: false,
          error: new types_1.ValidationError(`${path} must be a boolean`)
        };
      } else if (type !== "boolean") {
        return {
          success: false,
          error: new types_1.ValidationError(`${path} must be a boolean`)
        };
      }
      if (typeof def.const === "boolean") {
        if (value !== def.const) {
          return {
            success: false,
            error: new types_1.ValidationError(`${path} must be ${def.const}`)
          };
        }
      }
      return { success: true, value };
    }
    function integer(lexicons2, path, def, value) {
      def = def;
      const type = typeof value;
      if (type === "undefined") {
        if (typeof def.default === "number") {
          return { success: true, value: def.default };
        }
        return {
          success: false,
          error: new types_1.ValidationError(`${path} must be an integer`)
        };
      } else if (!Number.isInteger(value)) {
        return {
          success: false,
          error: new types_1.ValidationError(`${path} must be an integer`)
        };
      }
      if (typeof def.const === "number") {
        if (value !== def.const) {
          return {
            success: false,
            error: new types_1.ValidationError(`${path} must be ${def.const}`)
          };
        }
      }
      if (Array.isArray(def.enum)) {
        if (!def.enum.includes(value)) {
          return {
            success: false,
            error: new types_1.ValidationError(`${path} must be one of (${def.enum.join("|")})`)
          };
        }
      }
      if (typeof def.maximum === "number") {
        if (value > def.maximum) {
          return {
            success: false,
            error: new types_1.ValidationError(`${path} can not be greater than ${def.maximum}`)
          };
        }
      }
      if (typeof def.minimum === "number") {
        if (value < def.minimum) {
          return {
            success: false,
            error: new types_1.ValidationError(`${path} can not be less than ${def.minimum}`)
          };
        }
      }
      return { success: true, value };
    }
    function string2(lexicons2, path, def, value) {
      def = def;
      if (typeof value === "undefined") {
        if (typeof def.default === "string") {
          return { success: true, value: def.default };
        }
        return {
          success: false,
          error: new types_1.ValidationError(`${path} must be a string`)
        };
      } else if (typeof value !== "string") {
        return {
          success: false,
          error: new types_1.ValidationError(`${path} must be a string`)
        };
      }
      if (typeof def.const === "string") {
        if (value !== def.const) {
          return {
            success: false,
            error: new types_1.ValidationError(`${path} must be ${def.const}`)
          };
        }
      }
      if (Array.isArray(def.enum)) {
        if (!def.enum.includes(value)) {
          return {
            success: false,
            error: new types_1.ValidationError(`${path} must be one of (${def.enum.join("|")})`)
          };
        }
      }
      if (typeof def.minLength === "number" || typeof def.maxLength === "number") {
        if (typeof def.minLength === "number" && value.length * 3 < def.minLength) {
          return {
            success: false,
            error: new types_1.ValidationError(`${path} must not be shorter than ${def.minLength} characters`)
          };
        }
        let canSkipUtf8LenChecks = false;
        if (typeof def.minLength === "undefined" && typeof def.maxLength === "number" && value.length * 3 <= def.maxLength) {
          canSkipUtf8LenChecks = true;
        }
        if (!canSkipUtf8LenChecks) {
          const len = (0, common_web_1.utf8Len)(value);
          if (typeof def.maxLength === "number") {
            if (len > def.maxLength) {
              return {
                success: false,
                error: new types_1.ValidationError(`${path} must not be longer than ${def.maxLength} characters`)
              };
            }
          }
          if (typeof def.minLength === "number") {
            if (len < def.minLength) {
              return {
                success: false,
                error: new types_1.ValidationError(`${path} must not be shorter than ${def.minLength} characters`)
              };
            }
          }
        }
      }
      if (typeof def.maxGraphemes === "number" || typeof def.minGraphemes === "number") {
        let needsMaxGraphemesCheck = false;
        let needsMinGraphemesCheck = false;
        if (typeof def.maxGraphemes === "number") {
          if (value.length <= def.maxGraphemes) {
            needsMaxGraphemesCheck = false;
          } else {
            needsMaxGraphemesCheck = true;
          }
        }
        if (typeof def.minGraphemes === "number") {
          if (value.length < def.minGraphemes) {
            return {
              success: false,
              error: new types_1.ValidationError(`${path} must not be shorter than ${def.minGraphemes} graphemes`)
            };
          } else {
            needsMinGraphemesCheck = true;
          }
        }
        if (needsMaxGraphemesCheck || needsMinGraphemesCheck) {
          const len = (0, common_web_1.graphemeLen)(value);
          if (typeof def.maxGraphemes === "number") {
            if (len > def.maxGraphemes) {
              return {
                success: false,
                error: new types_1.ValidationError(`${path} must not be longer than ${def.maxGraphemes} graphemes`)
              };
            }
          }
          if (typeof def.minGraphemes === "number") {
            if (len < def.minGraphemes) {
              return {
                success: false,
                error: new types_1.ValidationError(`${path} must not be shorter than ${def.minGraphemes} graphemes`)
              };
            }
          }
        }
      }
      if (typeof def.format === "string") {
        switch (def.format) {
          case "datetime":
            return formats2.datetime(path, value);
          case "uri":
            return formats2.uri(path, value);
          case "at-uri":
            return formats2.atUri(path, value);
          case "did":
            return formats2.did(path, value);
          case "handle":
            return formats2.handle(path, value);
          case "at-identifier":
            return formats2.atIdentifier(path, value);
          case "nsid":
            return formats2.nsid(path, value);
          case "cid":
            return formats2.cid(path, value);
          case "language":
            return formats2.language(path, value);
          case "tid":
            return formats2.tid(path, value);
          case "record-key":
            return formats2.recordKey(path, value);
        }
      }
      return { success: true, value };
    }
    function bytes(lexicons2, path, def, value) {
      def = def;
      if (!value || !(value instanceof Uint8Array)) {
        return {
          success: false,
          error: new types_1.ValidationError(`${path} must be a byte array`)
        };
      }
      if (typeof def.maxLength === "number") {
        if (value.byteLength > def.maxLength) {
          return {
            success: false,
            error: new types_1.ValidationError(`${path} must not be larger than ${def.maxLength} bytes`)
          };
        }
      }
      if (typeof def.minLength === "number") {
        if (value.byteLength < def.minLength) {
          return {
            success: false,
            error: new types_1.ValidationError(`${path} must not be smaller than ${def.minLength} bytes`)
          };
        }
      }
      return { success: true, value };
    }
    function cidLink(lexicons2, path, def, value) {
      if (cid_1.CID.asCID(value) === null) {
        return {
          success: false,
          error: new types_1.ValidationError(`${path} must be a CID`)
        };
      }
      return { success: true, value };
    }
    function unknown(lexicons2, path, def, value) {
      if (!value || typeof value !== "object") {
        return {
          success: false,
          error: new types_1.ValidationError(`${path} must be an object`)
        };
      }
      return { success: true, value };
    }
    return primitives;
  }
  var hasRequiredComplex;
  function requireComplex() {
    if (hasRequiredComplex) return complex;
    hasRequiredComplex = 1;
    Object.defineProperty(complex, "__esModule", { value: true });
    complex.validate = validate;
    complex.array = array;
    complex.object = object;
    complex.validateOneOf = validateOneOf;
    const types_1 = requireTypes$4();
    const util_1 = requireUtil$7();
    const blob_1 = requireBlob();
    const primitives_1 = requirePrimitives();
    function validate(lexicons2, path, def, value) {
      switch (def.type) {
        case "object":
          return object(lexicons2, path, def, value);
        case "array":
          return array(lexicons2, path, def, value);
        case "blob":
          return (0, blob_1.blob)(lexicons2, path, def, value);
        default:
          return (0, primitives_1.validate)(lexicons2, path, def, value);
      }
    }
    function array(lexicons2, path, def, value) {
      if (!Array.isArray(value)) {
        return {
          success: false,
          error: new types_1.ValidationError(`${path} must be an array`)
        };
      }
      if (typeof def.maxLength === "number") {
        if (value.length > def.maxLength) {
          return {
            success: false,
            error: new types_1.ValidationError(`${path} must not have more than ${def.maxLength} elements`)
          };
        }
      }
      if (typeof def.minLength === "number") {
        if (value.length < def.minLength) {
          return {
            success: false,
            error: new types_1.ValidationError(`${path} must not have fewer than ${def.minLength} elements`)
          };
        }
      }
      const itemsDef = def.items;
      for (let i = 0; i < value.length; i++) {
        const itemValue = value[i];
        const itemPath = `${path}/${i}`;
        const res = validateOneOf(lexicons2, itemPath, itemsDef, itemValue);
        if (!res.success) {
          return res;
        }
      }
      return { success: true, value };
    }
    function object(lexicons2, path, def, value) {
      if (!(0, types_1.isObj)(value)) {
        return {
          success: false,
          error: new types_1.ValidationError(`${path} must be an object`)
        };
      }
      let resultValue = value;
      if ("properties" in def && def.properties != null) {
        for (const key in def.properties) {
          const keyValue = value[key];
          if (keyValue === null && def.nullable?.includes(key)) {
            continue;
          }
          const propDef = def.properties[key];
          if (keyValue === void 0 && !def.required?.includes(key)) {
            if (propDef.type === "integer" || propDef.type === "boolean" || propDef.type === "string") {
              if (propDef.default === void 0) {
                continue;
              }
            } else {
              continue;
            }
          }
          const propPath = `${path}/${key}`;
          const validated = validateOneOf(lexicons2, propPath, propDef, keyValue);
          const propValue = validated.success ? validated.value : keyValue;
          if (propValue === void 0) {
            if (def.required?.includes(key)) {
              return {
                success: false,
                error: new types_1.ValidationError(`${path} must have the property "${key}"`)
              };
            }
          } else {
            if (!validated.success) {
              return validated;
            }
          }
          if (propValue !== keyValue) {
            if (resultValue === value) {
              resultValue = { ...value };
            }
            resultValue[key] = propValue;
          }
        }
      }
      return { success: true, value: resultValue };
    }
    function validateOneOf(lexicons2, path, def, value, mustBeObj = false) {
      let concreteDef;
      if (def.type === "union") {
        if (!(0, types_1.isDiscriminatedObject)(value)) {
          return {
            success: false,
            error: new types_1.ValidationError(`${path} must be an object which includes the "$type" property`)
          };
        }
        if (!refsContainType(def.refs, value.$type)) {
          if (def.closed) {
            return {
              success: false,
              error: new types_1.ValidationError(`${path} $type must be one of ${def.refs.join(", ")}`)
            };
          }
          return { success: true, value };
        } else {
          concreteDef = lexicons2.getDefOrThrow(value.$type);
        }
      } else if (def.type === "ref") {
        concreteDef = lexicons2.getDefOrThrow(def.ref);
      } else {
        concreteDef = def;
      }
      return mustBeObj ? object(lexicons2, path, concreteDef, value) : validate(lexicons2, path, concreteDef, value);
    }
    const refsContainType = (refs, type) => {
      const lexUri = (0, util_1.toLexUri)(type);
      if (refs.includes(lexUri)) {
        return true;
      }
      if (lexUri.endsWith("#main")) {
        return refs.includes(lexUri.slice(0, -5));
      } else {
        return !lexUri.includes("#") && refs.includes(`${lexUri}#main`);
      }
    };
    return complex;
  }
  var xrpc = {};
  var hasRequiredXrpc;
  function requireXrpc() {
    if (hasRequiredXrpc) return xrpc;
    hasRequiredXrpc = 1;
    var __createBinding = xrpc && xrpc.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = xrpc && xrpc.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = xrpc && xrpc.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(xrpc, "__esModule", { value: true });
    xrpc.params = params;
    const types_1 = requireTypes$4();
    const complex_1 = requireComplex();
    const PrimitiveValidators = __importStar(requirePrimitives());
    function params(lexicons2, path, def, val) {
      const value = val && typeof val === "object" ? val : {};
      const requiredProps = new Set(def.required ?? []);
      let resultValue = value;
      if (typeof def.properties === "object") {
        for (const key in def.properties) {
          const propDef = def.properties[key];
          const validated = propDef.type === "array" ? (0, complex_1.array)(lexicons2, key, propDef, value[key]) : PrimitiveValidators.validate(lexicons2, key, propDef, value[key]);
          const propValue = validated.success ? validated.value : value[key];
          const propIsUndefined = typeof propValue === "undefined";
          if (propIsUndefined && requiredProps.has(key)) {
            return {
              success: false,
              error: new types_1.ValidationError(`${path} must have the property "${key}"`)
            };
          } else if (!propIsUndefined && !validated.success) {
            return validated;
          }
          if (propValue !== value[key]) {
            if (resultValue === value) {
              resultValue = { ...value };
            }
            resultValue[key] = propValue;
          }
        }
      }
      return { success: true, value: resultValue };
    }
    return xrpc;
  }
  var hasRequiredValidation;
  function requireValidation() {
    if (hasRequiredValidation) return validation;
    hasRequiredValidation = 1;
    Object.defineProperty(validation, "__esModule", { value: true });
    validation.assertValidRecord = assertValidRecord;
    validation.assertValidXrpcParams = assertValidXrpcParams;
    validation.assertValidXrpcInput = assertValidXrpcInput;
    validation.assertValidXrpcOutput = assertValidXrpcOutput;
    validation.assertValidXrpcMessage = assertValidXrpcMessage;
    const complex_1 = requireComplex();
    const xrpc_1 = requireXrpc();
    function assertValidRecord(lexicons2, def, value) {
      const res = (0, complex_1.object)(lexicons2, "Record", def.record, value);
      if (!res.success)
        throw res.error;
      return res.value;
    }
    function assertValidXrpcParams(lexicons2, def, value) {
      if (def.parameters) {
        const res = (0, xrpc_1.params)(lexicons2, "Params", def.parameters, value);
        if (!res.success)
          throw res.error;
        return res.value;
      }
    }
    function assertValidXrpcInput(lexicons2, def, value) {
      if (def.input?.schema) {
        return assertValidOneOf(lexicons2, "Input", def.input.schema, value, true);
      }
    }
    function assertValidXrpcOutput(lexicons2, def, value) {
      if (def.output?.schema) {
        return assertValidOneOf(lexicons2, "Output", def.output.schema, value, true);
      }
    }
    function assertValidXrpcMessage(lexicons2, def, value) {
      if (def.message?.schema) {
        return assertValidOneOf(lexicons2, "Message", def.message.schema, value, true);
      }
    }
    function assertValidOneOf(lexicons2, path, def, value, mustBeObj = false) {
      const res = (0, complex_1.validateOneOf)(lexicons2, path, def, value, mustBeObj);
      if (!res.success)
        throw res.error;
      return res.value;
    }
    return validation;
  }
  var hasRequiredLexicons$1;
  function requireLexicons$1() {
    if (hasRequiredLexicons$1) return lexicons$1;
    hasRequiredLexicons$1 = 1;
    Object.defineProperty(lexicons$1, "__esModule", { value: true });
    lexicons$1.Lexicons = void 0;
    const types_1 = requireTypes$4();
    const util_1 = requireUtil$7();
    const validation_1 = requireValidation();
    const complex_1 = requireComplex();
    class Lexicons {
      constructor(docs) {
        Object.defineProperty(this, "docs", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: /* @__PURE__ */ new Map()
        });
        Object.defineProperty(this, "defs", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: /* @__PURE__ */ new Map()
        });
        if (docs) {
          for (const doc of docs) {
            this.add(doc);
          }
        }
      }
      /**
       * @example clone a lexicon:
       * ```ts
       * const clone = new Lexicons(originalLexicon)
       * ```
       *
       * @example get docs array:
       * ```ts
       * const docs = Array.from(lexicons)
       * ```
       */
      [Symbol.iterator]() {
        return this.docs.values();
      }
      /**
       * Add a lexicon doc.
       */
      add(doc) {
        const uri = (0, util_1.toLexUri)(doc.id);
        if (this.docs.has(uri)) {
          throw new Error(`${uri} has already been registered`);
        }
        resolveRefUris(doc, uri);
        this.docs.set(uri, doc);
        for (const [defUri, def] of iterDefs(doc)) {
          this.defs.set(defUri, def);
        }
      }
      /**
       * Remove a lexicon doc.
       */
      remove(uri) {
        uri = (0, util_1.toLexUri)(uri);
        const doc = this.docs.get(uri);
        if (!doc) {
          throw new Error(`Unable to remove "${uri}": does not exist`);
        }
        for (const [defUri, _def] of iterDefs(doc)) {
          this.defs.delete(defUri);
        }
        this.docs.delete(uri);
      }
      /**
       * Get a lexicon doc.
       */
      get(uri) {
        uri = (0, util_1.toLexUri)(uri);
        return this.docs.get(uri);
      }
      /**
       * Get a definition.
       */
      getDef(uri) {
        uri = (0, util_1.toLexUri)(uri);
        return this.defs.get(uri);
      }
      getDefOrThrow(uri, types2) {
        const def = this.getDef(uri);
        if (!def) {
          throw new types_1.LexiconDefNotFoundError(`Lexicon not found: ${uri}`);
        }
        if (types2 && !types2.includes(def.type)) {
          throw new types_1.InvalidLexiconError(`Not a ${types2.join(" or ")} lexicon: ${uri}`);
        }
        return def;
      }
      /**
       * Validate a record or object.
       */
      validate(lexUri, value) {
        if (!(0, types_1.isObj)(value)) {
          throw new types_1.ValidationError(`Value must be an object`);
        }
        const lexUriNormalized = (0, util_1.toLexUri)(lexUri);
        const def = this.getDefOrThrow(lexUriNormalized, ["record", "object"]);
        if (def.type === "record") {
          return (0, complex_1.object)(this, "Record", def.record, value);
        } else if (def.type === "object") {
          return (0, complex_1.object)(this, "Object", def, value);
        } else {
          throw new types_1.InvalidLexiconError("Definition must be a record or object");
        }
      }
      /**
       * Validate a record and throw on any error.
       */
      assertValidRecord(lexUri, value) {
        if (!(0, types_1.isObj)(value)) {
          throw new types_1.ValidationError(`Record must be an object`);
        }
        if (!("$type" in value)) {
          throw new types_1.ValidationError(`Record/$type must be a string`);
        }
        const { $type } = value;
        if (typeof $type !== "string") {
          throw new types_1.ValidationError(`Record/$type must be a string`);
        }
        const lexUriNormalized = (0, util_1.toLexUri)(lexUri);
        if ((0, util_1.toLexUri)($type) !== lexUriNormalized) {
          throw new types_1.ValidationError(`Invalid $type: must be ${lexUriNormalized}, got ${$type}`);
        }
        const def = this.getDefOrThrow(lexUriNormalized, ["record"]);
        return (0, validation_1.assertValidRecord)(this, def, value);
      }
      /**
       * Validate xrpc query params and throw on any error.
       */
      assertValidXrpcParams(lexUri, value) {
        lexUri = (0, util_1.toLexUri)(lexUri);
        const def = this.getDefOrThrow(lexUri, [
          "query",
          "procedure",
          "subscription"
        ]);
        return (0, validation_1.assertValidXrpcParams)(this, def, value);
      }
      /**
       * Validate xrpc input body and throw on any error.
       */
      assertValidXrpcInput(lexUri, value) {
        lexUri = (0, util_1.toLexUri)(lexUri);
        const def = this.getDefOrThrow(lexUri, ["procedure"]);
        return (0, validation_1.assertValidXrpcInput)(this, def, value);
      }
      /**
       * Validate xrpc output body and throw on any error.
       */
      assertValidXrpcOutput(lexUri, value) {
        lexUri = (0, util_1.toLexUri)(lexUri);
        const def = this.getDefOrThrow(lexUri, ["query", "procedure"]);
        return (0, validation_1.assertValidXrpcOutput)(this, def, value);
      }
      /**
       * Validate xrpc subscription message and throw on any error.
       */
      assertValidXrpcMessage(lexUri, value) {
        lexUri = (0, util_1.toLexUri)(lexUri);
        const def = this.getDefOrThrow(lexUri, ["subscription"]);
        return (0, validation_1.assertValidXrpcMessage)(this, def, value);
      }
      /**
       * Resolve a lex uri given a ref
       */
      resolveLexUri(lexUri, ref) {
        lexUri = (0, util_1.toLexUri)(lexUri);
        return (0, util_1.toLexUri)(ref, lexUri);
      }
    }
    lexicons$1.Lexicons = Lexicons;
    function* iterDefs(doc) {
      for (const defId in doc.defs) {
        yield [`lex:${doc.id}#${defId}`, doc.defs[defId]];
        if (defId === "main") {
          yield [`lex:${doc.id}`, doc.defs[defId]];
        }
      }
    }
    function resolveRefUris(obj, baseUri) {
      for (const k in obj) {
        if (obj.type === "ref") {
          obj.ref = (0, util_1.toLexUri)(obj.ref, baseUri);
        } else if (obj.type === "union") {
          obj.refs = obj.refs.map((ref) => (0, util_1.toLexUri)(ref, baseUri));
        } else if (Array.isArray(obj[k])) {
          obj[k] = obj[k].map((item) => {
            if (typeof item === "string") {
              return item.startsWith("#") ? (0, util_1.toLexUri)(item, baseUri) : item;
            } else if (item && typeof item === "object") {
              return resolveRefUris(item, baseUri);
            }
            return item;
          });
        } else if (obj[k] && typeof obj[k] === "object") {
          obj[k] = resolveRefUris(obj[k], baseUri);
        }
      }
      return obj;
    }
    return lexicons$1;
  }
  var serialize = {};
  var hasRequiredSerialize;
  function requireSerialize() {
    if (hasRequiredSerialize) return serialize;
    hasRequiredSerialize = 1;
    (function(exports$1) {
      Object.defineProperty(exports$1, "__esModule", { value: true });
      exports$1.jsonStringToLex = exports$1.jsonToLex = exports$1.stringifyLex = exports$1.lexToJson = exports$1.ipldToLex = exports$1.lexToIpld = void 0;
      const cid_1 = require$$0$1;
      const common_web_1 = requireDist$4();
      const blob_refs_1 = requireBlobRefs();
      const lexToIpld = (val) => {
        if (Array.isArray(val)) {
          return val.map((item) => (0, exports$1.lexToIpld)(item));
        }
        if (val && typeof val === "object") {
          if (val instanceof blob_refs_1.BlobRef) {
            return val.original;
          }
          if (cid_1.CID.asCID(val) || val instanceof Uint8Array) {
            return val;
          }
          const toReturn = {};
          for (const key of Object.keys(val)) {
            toReturn[key] = (0, exports$1.lexToIpld)(val[key]);
          }
          return toReturn;
        }
        return val;
      };
      exports$1.lexToIpld = lexToIpld;
      const ipldToLex = (val) => {
        if (Array.isArray(val)) {
          return val.map((item) => (0, exports$1.ipldToLex)(item));
        }
        if (val && typeof val === "object") {
          if ((val["$type"] === "blob" || typeof val["cid"] === "string" && typeof val["mimeType"] === "string") && common_web_1.check.is(val, blob_refs_1.jsonBlobRef)) {
            return blob_refs_1.BlobRef.fromJsonRef(val);
          }
          if (cid_1.CID.asCID(val) || val instanceof Uint8Array) {
            return val;
          }
          const toReturn = {};
          for (const key of Object.keys(val)) {
            toReturn[key] = (0, exports$1.ipldToLex)(val[key]);
          }
          return toReturn;
        }
        return val;
      };
      exports$1.ipldToLex = ipldToLex;
      const lexToJson = (val) => {
        return (0, common_web_1.ipldToJson)((0, exports$1.lexToIpld)(val));
      };
      exports$1.lexToJson = lexToJson;
      const stringifyLex = (val) => {
        return JSON.stringify((0, exports$1.lexToJson)(val));
      };
      exports$1.stringifyLex = stringifyLex;
      const jsonToLex = (val) => {
        return (0, exports$1.ipldToLex)((0, common_web_1.jsonToIpld)(val));
      };
      exports$1.jsonToLex = jsonToLex;
      const jsonStringToLex = (val) => {
        return (0, exports$1.jsonToLex)(JSON.parse(val));
      };
      exports$1.jsonStringToLex = jsonStringToLex;
    })(serialize);
    return serialize;
  }
  var hasRequiredDist$2;
  function requireDist$2() {
    if (hasRequiredDist$2) return dist$4;
    hasRequiredDist$2 = 1;
    (function(exports$1) {
      var __createBinding = dist$4 && dist$4.__createBinding || (Object.create ? (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      }));
      var __exportStar = dist$4 && dist$4.__exportStar || function(m, exports$12) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$12, p)) __createBinding(exports$12, m, p);
      };
      Object.defineProperty(exports$1, "__esModule", { value: true });
      __exportStar(requireTypes$4(), exports$1);
      __exportStar(requireLexicons$1(), exports$1);
      __exportStar(requireBlobRefs(), exports$1);
      __exportStar(requireSerialize(), exports$1);
    })(dist$4);
    return dist$4;
  }
  var lexicons = {};
  var util$5 = {};
  var hasRequiredUtil$5;
  function requireUtil$5() {
    if (hasRequiredUtil$5) return util$5;
    hasRequiredUtil$5 = 1;
    Object.defineProperty(util$5, "__esModule", { value: true });
    util$5.is$typed = is$typed;
    util$5.maybe$typed = maybe$typed;
    util$5.asPredicate = asPredicate;
    function isObject(v) {
      return v != null && typeof v === "object";
    }
    function is$type($type, id, hash) {
      return hash === "main" ? $type === id : (
        // $type === `${id}#${hash}`
        typeof $type === "string" && $type.length === id.length + 1 + hash.length && $type.charCodeAt(id.length) === 35 && $type.startsWith(id) && $type.endsWith(hash)
      );
    }
    function is$typed(v, id, hash) {
      return isObject(v) && "$type" in v && is$type(v.$type, id, hash);
    }
    function maybe$typed(v, id, hash) {
      return isObject(v) && ("$type" in v ? v.$type === void 0 || is$type(v.$type, id, hash) : true);
    }
    function asPredicate(validate) {
      return function(v) {
        return validate(v).success;
      };
    }
    return util$5;
  }
  var hasRequiredLexicons;
  function requireLexicons() {
    if (hasRequiredLexicons) return lexicons;
    hasRequiredLexicons = 1;
    (function(exports$1) {
      Object.defineProperty(exports$1, "__esModule", { value: true });
      exports$1.ids = exports$1.lexicons = exports$1.schemas = exports$1.schemaDict = void 0;
      exports$1.validate = validate;
      const lexicon_1 = requireDist$2();
      const util_js_1 = requireUtil$5();
      exports$1.schemaDict = {
        ComAtprotoAdminDefs: {
          lexicon: 1,
          id: "com.atproto.admin.defs",
          defs: {
            statusAttr: {
              type: "object",
              required: ["applied"],
              properties: {
                applied: {
                  type: "boolean"
                },
                ref: {
                  type: "string"
                }
              }
            },
            accountView: {
              type: "object",
              required: ["did", "handle", "indexedAt"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                },
                handle: {
                  type: "string",
                  format: "handle"
                },
                email: {
                  type: "string"
                },
                relatedRecords: {
                  type: "array",
                  items: {
                    type: "unknown"
                  }
                },
                indexedAt: {
                  type: "string",
                  format: "datetime"
                },
                invitedBy: {
                  type: "ref",
                  ref: "lex:com.atproto.server.defs#inviteCode"
                },
                invites: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.server.defs#inviteCode"
                  }
                },
                invitesDisabled: {
                  type: "boolean"
                },
                emailConfirmedAt: {
                  type: "string",
                  format: "datetime"
                },
                inviteNote: {
                  type: "string"
                },
                deactivatedAt: {
                  type: "string",
                  format: "datetime"
                },
                threatSignatures: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.admin.defs#threatSignature"
                  }
                }
              }
            },
            repoRef: {
              type: "object",
              required: ["did"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                }
              }
            },
            repoBlobRef: {
              type: "object",
              required: ["did", "cid"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                },
                cid: {
                  type: "string",
                  format: "cid"
                },
                recordUri: {
                  type: "string",
                  format: "at-uri"
                }
              }
            },
            threatSignature: {
              type: "object",
              required: ["property", "value"],
              properties: {
                property: {
                  type: "string"
                },
                value: {
                  type: "string"
                }
              }
            }
          }
        },
        ComAtprotoAdminDeleteAccount: {
          lexicon: 1,
          id: "com.atproto.admin.deleteAccount",
          defs: {
            main: {
              type: "procedure",
              description: "Delete a user account as an administrator.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["did"],
                  properties: {
                    did: {
                      type: "string",
                      format: "did"
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoAdminDisableAccountInvites: {
          lexicon: 1,
          id: "com.atproto.admin.disableAccountInvites",
          defs: {
            main: {
              type: "procedure",
              description: "Disable an account from receiving new invite codes, but does not invalidate existing codes.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["account"],
                  properties: {
                    account: {
                      type: "string",
                      format: "did"
                    },
                    note: {
                      type: "string",
                      description: "Optional reason for disabled invites."
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoAdminDisableInviteCodes: {
          lexicon: 1,
          id: "com.atproto.admin.disableInviteCodes",
          defs: {
            main: {
              type: "procedure",
              description: "Disable some set of codes and/or all codes associated with a set of users.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  properties: {
                    codes: {
                      type: "array",
                      items: {
                        type: "string"
                      }
                    },
                    accounts: {
                      type: "array",
                      items: {
                        type: "string"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoAdminEnableAccountInvites: {
          lexicon: 1,
          id: "com.atproto.admin.enableAccountInvites",
          defs: {
            main: {
              type: "procedure",
              description: "Re-enable an account's ability to receive invite codes.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["account"],
                  properties: {
                    account: {
                      type: "string",
                      format: "did"
                    },
                    note: {
                      type: "string",
                      description: "Optional reason for enabled invites."
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoAdminGetAccountInfo: {
          lexicon: 1,
          id: "com.atproto.admin.getAccountInfo",
          defs: {
            main: {
              type: "query",
              description: "Get details about an account.",
              parameters: {
                type: "params",
                required: ["did"],
                properties: {
                  did: {
                    type: "string",
                    format: "did"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "ref",
                  ref: "lex:com.atproto.admin.defs#accountView"
                }
              }
            }
          }
        },
        ComAtprotoAdminGetAccountInfos: {
          lexicon: 1,
          id: "com.atproto.admin.getAccountInfos",
          defs: {
            main: {
              type: "query",
              description: "Get details about some accounts.",
              parameters: {
                type: "params",
                required: ["dids"],
                properties: {
                  dids: {
                    type: "array",
                    items: {
                      type: "string",
                      format: "did"
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["infos"],
                  properties: {
                    infos: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:com.atproto.admin.defs#accountView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoAdminGetInviteCodes: {
          lexicon: 1,
          id: "com.atproto.admin.getInviteCodes",
          defs: {
            main: {
              type: "query",
              description: "Get an admin view of invite codes.",
              parameters: {
                type: "params",
                properties: {
                  sort: {
                    type: "string",
                    knownValues: ["recent", "usage"],
                    default: "recent"
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 500,
                    default: 100
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["codes"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    codes: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:com.atproto.server.defs#inviteCode"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoAdminGetSubjectStatus: {
          lexicon: 1,
          id: "com.atproto.admin.getSubjectStatus",
          defs: {
            main: {
              type: "query",
              description: "Get the service-specific admin status of a subject (account, record, or blob).",
              parameters: {
                type: "params",
                properties: {
                  did: {
                    type: "string",
                    format: "did"
                  },
                  uri: {
                    type: "string",
                    format: "at-uri"
                  },
                  blob: {
                    type: "string",
                    format: "cid"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["subject"],
                  properties: {
                    subject: {
                      type: "union",
                      refs: [
                        "lex:com.atproto.admin.defs#repoRef",
                        "lex:com.atproto.repo.strongRef",
                        "lex:com.atproto.admin.defs#repoBlobRef"
                      ]
                    },
                    takedown: {
                      type: "ref",
                      ref: "lex:com.atproto.admin.defs#statusAttr"
                    },
                    deactivated: {
                      type: "ref",
                      ref: "lex:com.atproto.admin.defs#statusAttr"
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoAdminSearchAccounts: {
          lexicon: 1,
          id: "com.atproto.admin.searchAccounts",
          defs: {
            main: {
              type: "query",
              description: "Get list of accounts that matches your search query.",
              parameters: {
                type: "params",
                properties: {
                  email: {
                    type: "string"
                  },
                  cursor: {
                    type: "string"
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["accounts"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    accounts: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:com.atproto.admin.defs#accountView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoAdminSendEmail: {
          lexicon: 1,
          id: "com.atproto.admin.sendEmail",
          defs: {
            main: {
              type: "procedure",
              description: "Send email to a user's account email address.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["recipientDid", "content", "senderDid"],
                  properties: {
                    recipientDid: {
                      type: "string",
                      format: "did"
                    },
                    content: {
                      type: "string"
                    },
                    subject: {
                      type: "string"
                    },
                    senderDid: {
                      type: "string",
                      format: "did"
                    },
                    comment: {
                      type: "string",
                      description: "Additional comment by the sender that won't be used in the email itself but helpful to provide more context for moderators/reviewers"
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["sent"],
                  properties: {
                    sent: {
                      type: "boolean"
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoAdminUpdateAccountEmail: {
          lexicon: 1,
          id: "com.atproto.admin.updateAccountEmail",
          defs: {
            main: {
              type: "procedure",
              description: "Administrative action to update an account's email.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["account", "email"],
                  properties: {
                    account: {
                      type: "string",
                      format: "at-identifier",
                      description: "The handle or DID of the repo."
                    },
                    email: {
                      type: "string"
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoAdminUpdateAccountHandle: {
          lexicon: 1,
          id: "com.atproto.admin.updateAccountHandle",
          defs: {
            main: {
              type: "procedure",
              description: "Administrative action to update an account's handle.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["did", "handle"],
                  properties: {
                    did: {
                      type: "string",
                      format: "did"
                    },
                    handle: {
                      type: "string",
                      format: "handle"
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoAdminUpdateAccountPassword: {
          lexicon: 1,
          id: "com.atproto.admin.updateAccountPassword",
          defs: {
            main: {
              type: "procedure",
              description: "Update the password for a user account as an administrator.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["did", "password"],
                  properties: {
                    did: {
                      type: "string",
                      format: "did"
                    },
                    password: {
                      type: "string"
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoAdminUpdateSubjectStatus: {
          lexicon: 1,
          id: "com.atproto.admin.updateSubjectStatus",
          defs: {
            main: {
              type: "procedure",
              description: "Update the service-specific admin status of a subject (account, record, or blob).",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["subject"],
                  properties: {
                    subject: {
                      type: "union",
                      refs: [
                        "lex:com.atproto.admin.defs#repoRef",
                        "lex:com.atproto.repo.strongRef",
                        "lex:com.atproto.admin.defs#repoBlobRef"
                      ]
                    },
                    takedown: {
                      type: "ref",
                      ref: "lex:com.atproto.admin.defs#statusAttr"
                    },
                    deactivated: {
                      type: "ref",
                      ref: "lex:com.atproto.admin.defs#statusAttr"
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["subject"],
                  properties: {
                    subject: {
                      type: "union",
                      refs: [
                        "lex:com.atproto.admin.defs#repoRef",
                        "lex:com.atproto.repo.strongRef",
                        "lex:com.atproto.admin.defs#repoBlobRef"
                      ]
                    },
                    takedown: {
                      type: "ref",
                      ref: "lex:com.atproto.admin.defs#statusAttr"
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoIdentityGetRecommendedDidCredentials: {
          lexicon: 1,
          id: "com.atproto.identity.getRecommendedDidCredentials",
          defs: {
            main: {
              type: "query",
              description: "Describe the credentials that should be included in the DID doc of an account that is migrating to this service.",
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  properties: {
                    rotationKeys: {
                      description: "Recommended rotation keys for PLC dids. Should be undefined (or ignored) for did:webs.",
                      type: "array",
                      items: {
                        type: "string"
                      }
                    },
                    alsoKnownAs: {
                      type: "array",
                      items: {
                        type: "string"
                      }
                    },
                    verificationMethods: {
                      type: "unknown"
                    },
                    services: {
                      type: "unknown"
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoIdentityRequestPlcOperationSignature: {
          lexicon: 1,
          id: "com.atproto.identity.requestPlcOperationSignature",
          defs: {
            main: {
              type: "procedure",
              description: "Request an email with a code to in order to request a signed PLC operation. Requires Auth."
            }
          }
        },
        ComAtprotoIdentityResolveHandle: {
          lexicon: 1,
          id: "com.atproto.identity.resolveHandle",
          defs: {
            main: {
              type: "query",
              description: "Resolves a handle (domain name) to a DID.",
              parameters: {
                type: "params",
                required: ["handle"],
                properties: {
                  handle: {
                    type: "string",
                    format: "handle",
                    description: "The handle to resolve."
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["did"],
                  properties: {
                    did: {
                      type: "string",
                      format: "did"
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoIdentitySignPlcOperation: {
          lexicon: 1,
          id: "com.atproto.identity.signPlcOperation",
          defs: {
            main: {
              type: "procedure",
              description: "Signs a PLC operation to update some value(s) in the requesting DID's document.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  properties: {
                    token: {
                      description: "A token received through com.atproto.identity.requestPlcOperationSignature",
                      type: "string"
                    },
                    rotationKeys: {
                      type: "array",
                      items: {
                        type: "string"
                      }
                    },
                    alsoKnownAs: {
                      type: "array",
                      items: {
                        type: "string"
                      }
                    },
                    verificationMethods: {
                      type: "unknown"
                    },
                    services: {
                      type: "unknown"
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["operation"],
                  properties: {
                    operation: {
                      type: "unknown",
                      description: "A signed DID PLC operation."
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoIdentitySubmitPlcOperation: {
          lexicon: 1,
          id: "com.atproto.identity.submitPlcOperation",
          defs: {
            main: {
              type: "procedure",
              description: "Validates a PLC operation to ensure that it doesn't violate a service's constraints or get the identity into a bad state, then submits it to the PLC registry",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["operation"],
                  properties: {
                    operation: {
                      type: "unknown"
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoIdentityUpdateHandle: {
          lexicon: 1,
          id: "com.atproto.identity.updateHandle",
          defs: {
            main: {
              type: "procedure",
              description: "Updates the current account's handle. Verifies handle validity, and updates did:plc document if necessary. Implemented by PDS, and requires auth.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["handle"],
                  properties: {
                    handle: {
                      type: "string",
                      format: "handle",
                      description: "The new handle."
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoLabelDefs: {
          lexicon: 1,
          id: "com.atproto.label.defs",
          defs: {
            label: {
              type: "object",
              description: "Metadata tag on an atproto resource (eg, repo or record).",
              required: ["src", "uri", "val", "cts"],
              properties: {
                ver: {
                  type: "integer",
                  description: "The AT Protocol version of the label object."
                },
                src: {
                  type: "string",
                  format: "did",
                  description: "DID of the actor who created this label."
                },
                uri: {
                  type: "string",
                  format: "uri",
                  description: "AT URI of the record, repository (account), or other resource that this label applies to."
                },
                cid: {
                  type: "string",
                  format: "cid",
                  description: "Optionally, CID specifying the specific version of 'uri' resource this label applies to."
                },
                val: {
                  type: "string",
                  maxLength: 128,
                  description: "The short string name of the value or type of this label."
                },
                neg: {
                  type: "boolean",
                  description: "If true, this is a negation label, overwriting a previous label."
                },
                cts: {
                  type: "string",
                  format: "datetime",
                  description: "Timestamp when this label was created."
                },
                exp: {
                  type: "string",
                  format: "datetime",
                  description: "Timestamp at which this label expires (no longer applies)."
                },
                sig: {
                  type: "bytes",
                  description: "Signature of dag-cbor encoded label."
                }
              }
            },
            selfLabels: {
              type: "object",
              description: "Metadata tags on an atproto record, published by the author within the record.",
              required: ["values"],
              properties: {
                values: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.label.defs#selfLabel"
                  },
                  maxLength: 10
                }
              }
            },
            selfLabel: {
              type: "object",
              description: "Metadata tag on an atproto record, published by the author within the record. Note that schemas should use #selfLabels, not #selfLabel.",
              required: ["val"],
              properties: {
                val: {
                  type: "string",
                  maxLength: 128,
                  description: "The short string name of the value or type of this label."
                }
              }
            },
            labelValueDefinition: {
              type: "object",
              description: "Declares a label value and its expected interpretations and behaviors.",
              required: ["identifier", "severity", "blurs", "locales"],
              properties: {
                identifier: {
                  type: "string",
                  description: "The value of the label being defined. Must only include lowercase ascii and the '-' character ([a-z-]+).",
                  maxLength: 100,
                  maxGraphemes: 100
                },
                severity: {
                  type: "string",
                  description: "How should a client visually convey this label? 'inform' means neutral and informational; 'alert' means negative and warning; 'none' means show nothing.",
                  knownValues: ["inform", "alert", "none"]
                },
                blurs: {
                  type: "string",
                  description: "What should this label hide in the UI, if applied? 'content' hides all of the target; 'media' hides the images/video/audio; 'none' hides nothing.",
                  knownValues: ["content", "media", "none"]
                },
                defaultSetting: {
                  type: "string",
                  description: "The default setting for this label.",
                  knownValues: ["ignore", "warn", "hide"],
                  default: "warn"
                },
                adultOnly: {
                  type: "boolean",
                  description: "Does the user need to have adult content enabled in order to configure this label?"
                },
                locales: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.label.defs#labelValueDefinitionStrings"
                  }
                }
              }
            },
            labelValueDefinitionStrings: {
              type: "object",
              description: "Strings which describe the label in the UI, localized into a specific language.",
              required: ["lang", "name", "description"],
              properties: {
                lang: {
                  type: "string",
                  description: "The code of the language these strings are written in.",
                  format: "language"
                },
                name: {
                  type: "string",
                  description: "A short human-readable name for the label.",
                  maxGraphemes: 64,
                  maxLength: 640
                },
                description: {
                  type: "string",
                  description: "A longer description of what the label means and why it might be applied.",
                  maxGraphemes: 1e4,
                  maxLength: 1e5
                }
              }
            },
            labelValue: {
              type: "string",
              knownValues: [
                "!hide",
                "!no-promote",
                "!warn",
                "!no-unauthenticated",
                "dmca-violation",
                "doxxing",
                "porn",
                "sexual",
                "nudity",
                "nsfl",
                "gore"
              ]
            }
          }
        },
        ComAtprotoLabelQueryLabels: {
          lexicon: 1,
          id: "com.atproto.label.queryLabels",
          defs: {
            main: {
              type: "query",
              description: "Find labels relevant to the provided AT-URI patterns. Public endpoint for moderation services, though may return different or additional results with auth.",
              parameters: {
                type: "params",
                required: ["uriPatterns"],
                properties: {
                  uriPatterns: {
                    type: "array",
                    items: {
                      type: "string"
                    },
                    description: "List of AT URI patterns to match (boolean 'OR'). Each may be a prefix (ending with '*'; will match inclusive of the string leading to '*'), or a full URI."
                  },
                  sources: {
                    type: "array",
                    items: {
                      type: "string",
                      format: "did"
                    },
                    description: "Optional list of label sources (DIDs) to filter on."
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 250,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["labels"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    labels: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:com.atproto.label.defs#label"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoLabelSubscribeLabels: {
          lexicon: 1,
          id: "com.atproto.label.subscribeLabels",
          defs: {
            main: {
              type: "subscription",
              description: "Subscribe to stream of labels (and negations). Public endpoint implemented by mod services. Uses same sequencing scheme as repo event stream.",
              parameters: {
                type: "params",
                properties: {
                  cursor: {
                    type: "integer",
                    description: "The last known event seq number to backfill from."
                  }
                }
              },
              message: {
                schema: {
                  type: "union",
                  refs: [
                    "lex:com.atproto.label.subscribeLabels#labels",
                    "lex:com.atproto.label.subscribeLabels#info"
                  ]
                }
              },
              errors: [
                {
                  name: "FutureCursor"
                }
              ]
            },
            labels: {
              type: "object",
              required: ["seq", "labels"],
              properties: {
                seq: {
                  type: "integer"
                },
                labels: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.label.defs#label"
                  }
                }
              }
            },
            info: {
              type: "object",
              required: ["name"],
              properties: {
                name: {
                  type: "string",
                  knownValues: ["OutdatedCursor"]
                },
                message: {
                  type: "string"
                }
              }
            }
          }
        },
        ComAtprotoLexiconSchema: {
          lexicon: 1,
          id: "com.atproto.lexicon.schema",
          defs: {
            main: {
              type: "record",
              description: "Representation of Lexicon schemas themselves, when published as atproto records. Note that the schema language is not defined in Lexicon; this meta schema currently only includes a single version field ('lexicon'). See the atproto specifications for description of the other expected top-level fields ('id', 'defs', etc).",
              key: "nsid",
              record: {
                type: "object",
                required: ["lexicon"],
                properties: {
                  lexicon: {
                    type: "integer",
                    description: "Indicates the 'version' of the Lexicon language. Must be '1' for the current atproto/Lexicon schema system."
                  }
                }
              }
            }
          }
        },
        ComAtprotoModerationCreateReport: {
          lexicon: 1,
          id: "com.atproto.moderation.createReport",
          defs: {
            main: {
              type: "procedure",
              description: "Submit a moderation report regarding an atproto account or record. Implemented by moderation services (with PDS proxying), and requires auth.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["reasonType", "subject"],
                  properties: {
                    reasonType: {
                      type: "ref",
                      description: "Indicates the broad category of violation the report is for.",
                      ref: "lex:com.atproto.moderation.defs#reasonType"
                    },
                    reason: {
                      type: "string",
                      maxGraphemes: 2e3,
                      maxLength: 2e4,
                      description: "Additional context about the content and violation."
                    },
                    subject: {
                      type: "union",
                      refs: [
                        "lex:com.atproto.admin.defs#repoRef",
                        "lex:com.atproto.repo.strongRef"
                      ]
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: [
                    "id",
                    "reasonType",
                    "subject",
                    "reportedBy",
                    "createdAt"
                  ],
                  properties: {
                    id: {
                      type: "integer"
                    },
                    reasonType: {
                      type: "ref",
                      ref: "lex:com.atproto.moderation.defs#reasonType"
                    },
                    reason: {
                      type: "string",
                      maxGraphemes: 2e3,
                      maxLength: 2e4
                    },
                    subject: {
                      type: "union",
                      refs: [
                        "lex:com.atproto.admin.defs#repoRef",
                        "lex:com.atproto.repo.strongRef"
                      ]
                    },
                    reportedBy: {
                      type: "string",
                      format: "did"
                    },
                    createdAt: {
                      type: "string",
                      format: "datetime"
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoModerationDefs: {
          lexicon: 1,
          id: "com.atproto.moderation.defs",
          defs: {
            reasonType: {
              type: "string",
              knownValues: [
                "com.atproto.moderation.defs#reasonSpam",
                "com.atproto.moderation.defs#reasonViolation",
                "com.atproto.moderation.defs#reasonMisleading",
                "com.atproto.moderation.defs#reasonSexual",
                "com.atproto.moderation.defs#reasonRude",
                "com.atproto.moderation.defs#reasonOther",
                "com.atproto.moderation.defs#reasonAppeal"
              ]
            },
            reasonSpam: {
              type: "token",
              description: "Spam: frequent unwanted promotion, replies, mentions"
            },
            reasonViolation: {
              type: "token",
              description: "Direct violation of server rules, laws, terms of service"
            },
            reasonMisleading: {
              type: "token",
              description: "Misleading identity, affiliation, or content"
            },
            reasonSexual: {
              type: "token",
              description: "Unwanted or mislabeled sexual content"
            },
            reasonRude: {
              type: "token",
              description: "Rude, harassing, explicit, or otherwise unwelcoming behavior"
            },
            reasonOther: {
              type: "token",
              description: "Other: reports not falling under another report category"
            },
            reasonAppeal: {
              type: "token",
              description: "Appeal: appeal a previously taken moderation action"
            }
          }
        },
        ComAtprotoRepoApplyWrites: {
          lexicon: 1,
          id: "com.atproto.repo.applyWrites",
          defs: {
            main: {
              type: "procedure",
              description: "Apply a batch transaction of repository creates, updates, and deletes. Requires auth, implemented by PDS.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["repo", "writes"],
                  properties: {
                    repo: {
                      type: "string",
                      format: "at-identifier",
                      description: "The handle or DID of the repo (aka, current account)."
                    },
                    validate: {
                      type: "boolean",
                      description: "Can be set to 'false' to skip Lexicon schema validation of record data across all operations, 'true' to require it, or leave unset to validate only for known Lexicons."
                    },
                    writes: {
                      type: "array",
                      items: {
                        type: "union",
                        refs: [
                          "lex:com.atproto.repo.applyWrites#create",
                          "lex:com.atproto.repo.applyWrites#update",
                          "lex:com.atproto.repo.applyWrites#delete"
                        ],
                        closed: true
                      }
                    },
                    swapCommit: {
                      type: "string",
                      description: "If provided, the entire operation will fail if the current repo commit CID does not match this value. Used to prevent conflicting repo mutations.",
                      format: "cid"
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: [],
                  properties: {
                    commit: {
                      type: "ref",
                      ref: "lex:com.atproto.repo.defs#commitMeta"
                    },
                    results: {
                      type: "array",
                      items: {
                        type: "union",
                        refs: [
                          "lex:com.atproto.repo.applyWrites#createResult",
                          "lex:com.atproto.repo.applyWrites#updateResult",
                          "lex:com.atproto.repo.applyWrites#deleteResult"
                        ],
                        closed: true
                      }
                    }
                  }
                }
              },
              errors: [
                {
                  name: "InvalidSwap",
                  description: "Indicates that the 'swapCommit' parameter did not match current commit."
                }
              ]
            },
            create: {
              type: "object",
              description: "Operation which creates a new record.",
              required: ["collection", "value"],
              properties: {
                collection: {
                  type: "string",
                  format: "nsid"
                },
                rkey: {
                  type: "string",
                  maxLength: 512
                },
                value: {
                  type: "unknown"
                }
              }
            },
            update: {
              type: "object",
              description: "Operation which updates an existing record.",
              required: ["collection", "rkey", "value"],
              properties: {
                collection: {
                  type: "string",
                  format: "nsid"
                },
                rkey: {
                  type: "string"
                },
                value: {
                  type: "unknown"
                }
              }
            },
            delete: {
              type: "object",
              description: "Operation which deletes an existing record.",
              required: ["collection", "rkey"],
              properties: {
                collection: {
                  type: "string",
                  format: "nsid"
                },
                rkey: {
                  type: "string"
                }
              }
            },
            createResult: {
              type: "object",
              required: ["uri", "cid"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                cid: {
                  type: "string",
                  format: "cid"
                },
                validationStatus: {
                  type: "string",
                  knownValues: ["valid", "unknown"]
                }
              }
            },
            updateResult: {
              type: "object",
              required: ["uri", "cid"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                cid: {
                  type: "string",
                  format: "cid"
                },
                validationStatus: {
                  type: "string",
                  knownValues: ["valid", "unknown"]
                }
              }
            },
            deleteResult: {
              type: "object",
              required: [],
              properties: {}
            }
          }
        },
        ComAtprotoRepoCreateRecord: {
          lexicon: 1,
          id: "com.atproto.repo.createRecord",
          defs: {
            main: {
              type: "procedure",
              description: "Create a single new repository record. Requires auth, implemented by PDS.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["repo", "collection", "record"],
                  properties: {
                    repo: {
                      type: "string",
                      format: "at-identifier",
                      description: "The handle or DID of the repo (aka, current account)."
                    },
                    collection: {
                      type: "string",
                      format: "nsid",
                      description: "The NSID of the record collection."
                    },
                    rkey: {
                      type: "string",
                      description: "The Record Key.",
                      maxLength: 512
                    },
                    validate: {
                      type: "boolean",
                      description: "Can be set to 'false' to skip Lexicon schema validation of record data, 'true' to require it, or leave unset to validate only for known Lexicons."
                    },
                    record: {
                      type: "unknown",
                      description: "The record itself. Must contain a $type field."
                    },
                    swapCommit: {
                      type: "string",
                      format: "cid",
                      description: "Compare and swap with the previous commit by CID."
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["uri", "cid"],
                  properties: {
                    uri: {
                      type: "string",
                      format: "at-uri"
                    },
                    cid: {
                      type: "string",
                      format: "cid"
                    },
                    commit: {
                      type: "ref",
                      ref: "lex:com.atproto.repo.defs#commitMeta"
                    },
                    validationStatus: {
                      type: "string",
                      knownValues: ["valid", "unknown"]
                    }
                  }
                }
              },
              errors: [
                {
                  name: "InvalidSwap",
                  description: "Indicates that 'swapCommit' didn't match current repo commit."
                }
              ]
            }
          }
        },
        ComAtprotoRepoDefs: {
          lexicon: 1,
          id: "com.atproto.repo.defs",
          defs: {
            commitMeta: {
              type: "object",
              required: ["cid", "rev"],
              properties: {
                cid: {
                  type: "string",
                  format: "cid"
                },
                rev: {
                  type: "string"
                }
              }
            }
          }
        },
        ComAtprotoRepoDeleteRecord: {
          lexicon: 1,
          id: "com.atproto.repo.deleteRecord",
          defs: {
            main: {
              type: "procedure",
              description: "Delete a repository record, or ensure it doesn't exist. Requires auth, implemented by PDS.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["repo", "collection", "rkey"],
                  properties: {
                    repo: {
                      type: "string",
                      format: "at-identifier",
                      description: "The handle or DID of the repo (aka, current account)."
                    },
                    collection: {
                      type: "string",
                      format: "nsid",
                      description: "The NSID of the record collection."
                    },
                    rkey: {
                      type: "string",
                      description: "The Record Key."
                    },
                    swapRecord: {
                      type: "string",
                      format: "cid",
                      description: "Compare and swap with the previous record by CID."
                    },
                    swapCommit: {
                      type: "string",
                      format: "cid",
                      description: "Compare and swap with the previous commit by CID."
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  properties: {
                    commit: {
                      type: "ref",
                      ref: "lex:com.atproto.repo.defs#commitMeta"
                    }
                  }
                }
              },
              errors: [
                {
                  name: "InvalidSwap"
                }
              ]
            }
          }
        },
        ComAtprotoRepoDescribeRepo: {
          lexicon: 1,
          id: "com.atproto.repo.describeRepo",
          defs: {
            main: {
              type: "query",
              description: "Get information about an account and repository, including the list of collections. Does not require auth.",
              parameters: {
                type: "params",
                required: ["repo"],
                properties: {
                  repo: {
                    type: "string",
                    format: "at-identifier",
                    description: "The handle or DID of the repo."
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: [
                    "handle",
                    "did",
                    "didDoc",
                    "collections",
                    "handleIsCorrect"
                  ],
                  properties: {
                    handle: {
                      type: "string",
                      format: "handle"
                    },
                    did: {
                      type: "string",
                      format: "did"
                    },
                    didDoc: {
                      type: "unknown",
                      description: "The complete DID document for this account."
                    },
                    collections: {
                      type: "array",
                      description: "List of all the collections (NSIDs) for which this repo contains at least one record.",
                      items: {
                        type: "string",
                        format: "nsid"
                      }
                    },
                    handleIsCorrect: {
                      type: "boolean",
                      description: "Indicates if handle is currently valid (resolves bi-directionally)"
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoRepoGetRecord: {
          lexicon: 1,
          id: "com.atproto.repo.getRecord",
          defs: {
            main: {
              type: "query",
              description: "Get a single record from a repository. Does not require auth.",
              parameters: {
                type: "params",
                required: ["repo", "collection", "rkey"],
                properties: {
                  repo: {
                    type: "string",
                    format: "at-identifier",
                    description: "The handle or DID of the repo."
                  },
                  collection: {
                    type: "string",
                    format: "nsid",
                    description: "The NSID of the record collection."
                  },
                  rkey: {
                    type: "string",
                    description: "The Record Key."
                  },
                  cid: {
                    type: "string",
                    format: "cid",
                    description: "The CID of the version of the record. If not specified, then return the most recent version."
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["uri", "value"],
                  properties: {
                    uri: {
                      type: "string",
                      format: "at-uri"
                    },
                    cid: {
                      type: "string",
                      format: "cid"
                    },
                    value: {
                      type: "unknown"
                    }
                  }
                }
              },
              errors: [
                {
                  name: "RecordNotFound"
                }
              ]
            }
          }
        },
        ComAtprotoRepoImportRepo: {
          lexicon: 1,
          id: "com.atproto.repo.importRepo",
          defs: {
            main: {
              type: "procedure",
              description: "Import a repo in the form of a CAR file. Requires Content-Length HTTP header to be set.",
              input: {
                encoding: "application/vnd.ipld.car"
              }
            }
          }
        },
        ComAtprotoRepoListMissingBlobs: {
          lexicon: 1,
          id: "com.atproto.repo.listMissingBlobs",
          defs: {
            main: {
              type: "query",
              description: "Returns a list of missing blobs for the requesting account. Intended to be used in the account migration flow.",
              parameters: {
                type: "params",
                properties: {
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 1e3,
                    default: 500
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["blobs"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    blobs: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:com.atproto.repo.listMissingBlobs#recordBlob"
                      }
                    }
                  }
                }
              }
            },
            recordBlob: {
              type: "object",
              required: ["cid", "recordUri"],
              properties: {
                cid: {
                  type: "string",
                  format: "cid"
                },
                recordUri: {
                  type: "string",
                  format: "at-uri"
                }
              }
            }
          }
        },
        ComAtprotoRepoListRecords: {
          lexicon: 1,
          id: "com.atproto.repo.listRecords",
          defs: {
            main: {
              type: "query",
              description: "List a range of records in a repository, matching a specific collection. Does not require auth.",
              parameters: {
                type: "params",
                required: ["repo", "collection"],
                properties: {
                  repo: {
                    type: "string",
                    format: "at-identifier",
                    description: "The handle or DID of the repo."
                  },
                  collection: {
                    type: "string",
                    format: "nsid",
                    description: "The NSID of the record type."
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50,
                    description: "The number of records to return."
                  },
                  cursor: {
                    type: "string"
                  },
                  rkeyStart: {
                    type: "string",
                    description: "DEPRECATED: The lowest sort-ordered rkey to start from (exclusive)"
                  },
                  rkeyEnd: {
                    type: "string",
                    description: "DEPRECATED: The highest sort-ordered rkey to stop at (exclusive)"
                  },
                  reverse: {
                    type: "boolean",
                    description: "Flag to reverse the order of the returned records."
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["records"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    records: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:com.atproto.repo.listRecords#record"
                      }
                    }
                  }
                }
              }
            },
            record: {
              type: "object",
              required: ["uri", "cid", "value"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                cid: {
                  type: "string",
                  format: "cid"
                },
                value: {
                  type: "unknown"
                }
              }
            }
          }
        },
        ComAtprotoRepoPutRecord: {
          lexicon: 1,
          id: "com.atproto.repo.putRecord",
          defs: {
            main: {
              type: "procedure",
              description: "Write a repository record, creating or updating it as needed. Requires auth, implemented by PDS.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["repo", "collection", "rkey", "record"],
                  nullable: ["swapRecord"],
                  properties: {
                    repo: {
                      type: "string",
                      format: "at-identifier",
                      description: "The handle or DID of the repo (aka, current account)."
                    },
                    collection: {
                      type: "string",
                      format: "nsid",
                      description: "The NSID of the record collection."
                    },
                    rkey: {
                      type: "string",
                      description: "The Record Key.",
                      maxLength: 512
                    },
                    validate: {
                      type: "boolean",
                      description: "Can be set to 'false' to skip Lexicon schema validation of record data, 'true' to require it, or leave unset to validate only for known Lexicons."
                    },
                    record: {
                      type: "unknown",
                      description: "The record to write."
                    },
                    swapRecord: {
                      type: "string",
                      format: "cid",
                      description: "Compare and swap with the previous record by CID. WARNING: nullable and optional field; may cause problems with golang implementation"
                    },
                    swapCommit: {
                      type: "string",
                      format: "cid",
                      description: "Compare and swap with the previous commit by CID."
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["uri", "cid"],
                  properties: {
                    uri: {
                      type: "string",
                      format: "at-uri"
                    },
                    cid: {
                      type: "string",
                      format: "cid"
                    },
                    commit: {
                      type: "ref",
                      ref: "lex:com.atproto.repo.defs#commitMeta"
                    },
                    validationStatus: {
                      type: "string",
                      knownValues: ["valid", "unknown"]
                    }
                  }
                }
              },
              errors: [
                {
                  name: "InvalidSwap"
                }
              ]
            }
          }
        },
        ComAtprotoRepoStrongRef: {
          lexicon: 1,
          id: "com.atproto.repo.strongRef",
          description: "A URI with a content-hash fingerprint.",
          defs: {
            main: {
              type: "object",
              required: ["uri", "cid"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                cid: {
                  type: "string",
                  format: "cid"
                }
              }
            }
          }
        },
        ComAtprotoRepoUploadBlob: {
          lexicon: 1,
          id: "com.atproto.repo.uploadBlob",
          defs: {
            main: {
              type: "procedure",
              description: "Upload a new blob, to be referenced from a repository record. The blob will be deleted if it is not referenced within a time window (eg, minutes). Blob restrictions (mimetype, size, etc) are enforced when the reference is created. Requires auth, implemented by PDS.",
              input: {
                encoding: "*/*"
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["blob"],
                  properties: {
                    blob: {
                      type: "blob"
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoServerActivateAccount: {
          lexicon: 1,
          id: "com.atproto.server.activateAccount",
          defs: {
            main: {
              type: "procedure",
              description: "Activates a currently deactivated account. Used to finalize account migration after the account's repo is imported and identity is setup."
            }
          }
        },
        ComAtprotoServerCheckAccountStatus: {
          lexicon: 1,
          id: "com.atproto.server.checkAccountStatus",
          defs: {
            main: {
              type: "query",
              description: "Returns the status of an account, especially as pertaining to import or recovery. Can be called many times over the course of an account migration. Requires auth and can only be called pertaining to oneself.",
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: [
                    "activated",
                    "validDid",
                    "repoCommit",
                    "repoRev",
                    "repoBlocks",
                    "indexedRecords",
                    "privateStateValues",
                    "expectedBlobs",
                    "importedBlobs"
                  ],
                  properties: {
                    activated: {
                      type: "boolean"
                    },
                    validDid: {
                      type: "boolean"
                    },
                    repoCommit: {
                      type: "string",
                      format: "cid"
                    },
                    repoRev: {
                      type: "string"
                    },
                    repoBlocks: {
                      type: "integer"
                    },
                    indexedRecords: {
                      type: "integer"
                    },
                    privateStateValues: {
                      type: "integer"
                    },
                    expectedBlobs: {
                      type: "integer"
                    },
                    importedBlobs: {
                      type: "integer"
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoServerConfirmEmail: {
          lexicon: 1,
          id: "com.atproto.server.confirmEmail",
          defs: {
            main: {
              type: "procedure",
              description: "Confirm an email using a token from com.atproto.server.requestEmailConfirmation.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["email", "token"],
                  properties: {
                    email: {
                      type: "string"
                    },
                    token: {
                      type: "string"
                    }
                  }
                }
              },
              errors: [
                {
                  name: "AccountNotFound"
                },
                {
                  name: "ExpiredToken"
                },
                {
                  name: "InvalidToken"
                },
                {
                  name: "InvalidEmail"
                }
              ]
            }
          }
        },
        ComAtprotoServerCreateAccount: {
          lexicon: 1,
          id: "com.atproto.server.createAccount",
          defs: {
            main: {
              type: "procedure",
              description: "Create an account. Implemented by PDS.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["handle"],
                  properties: {
                    email: {
                      type: "string"
                    },
                    handle: {
                      type: "string",
                      format: "handle",
                      description: "Requested handle for the account."
                    },
                    did: {
                      type: "string",
                      format: "did",
                      description: "Pre-existing atproto DID, being imported to a new account."
                    },
                    inviteCode: {
                      type: "string"
                    },
                    verificationCode: {
                      type: "string"
                    },
                    verificationPhone: {
                      type: "string"
                    },
                    password: {
                      type: "string",
                      description: "Initial account password. May need to meet instance-specific password strength requirements."
                    },
                    recoveryKey: {
                      type: "string",
                      description: "DID PLC rotation key (aka, recovery key) to be included in PLC creation operation."
                    },
                    plcOp: {
                      type: "unknown",
                      description: "A signed DID PLC operation to be submitted as part of importing an existing account to this instance. NOTE: this optional field may be updated when full account migration is implemented."
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  description: "Account login session returned on successful account creation.",
                  required: ["accessJwt", "refreshJwt", "handle", "did"],
                  properties: {
                    accessJwt: {
                      type: "string"
                    },
                    refreshJwt: {
                      type: "string"
                    },
                    handle: {
                      type: "string",
                      format: "handle"
                    },
                    did: {
                      type: "string",
                      format: "did",
                      description: "The DID of the new account."
                    },
                    didDoc: {
                      type: "unknown",
                      description: "Complete DID document."
                    }
                  }
                }
              },
              errors: [
                {
                  name: "InvalidHandle"
                },
                {
                  name: "InvalidPassword"
                },
                {
                  name: "InvalidInviteCode"
                },
                {
                  name: "HandleNotAvailable"
                },
                {
                  name: "UnsupportedDomain"
                },
                {
                  name: "UnresolvableDid"
                },
                {
                  name: "IncompatibleDidDoc"
                }
              ]
            }
          }
        },
        ComAtprotoServerCreateAppPassword: {
          lexicon: 1,
          id: "com.atproto.server.createAppPassword",
          defs: {
            main: {
              type: "procedure",
              description: "Create an App Password.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["name"],
                  properties: {
                    name: {
                      type: "string",
                      description: "A short name for the App Password, to help distinguish them."
                    },
                    privileged: {
                      type: "boolean",
                      description: "If an app password has 'privileged' access to possibly sensitive account state. Meant for use with trusted clients."
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "ref",
                  ref: "lex:com.atproto.server.createAppPassword#appPassword"
                }
              },
              errors: [
                {
                  name: "AccountTakedown"
                }
              ]
            },
            appPassword: {
              type: "object",
              required: ["name", "password", "createdAt"],
              properties: {
                name: {
                  type: "string"
                },
                password: {
                  type: "string"
                },
                createdAt: {
                  type: "string",
                  format: "datetime"
                },
                privileged: {
                  type: "boolean"
                }
              }
            }
          }
        },
        ComAtprotoServerCreateInviteCode: {
          lexicon: 1,
          id: "com.atproto.server.createInviteCode",
          defs: {
            main: {
              type: "procedure",
              description: "Create an invite code.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["useCount"],
                  properties: {
                    useCount: {
                      type: "integer"
                    },
                    forAccount: {
                      type: "string",
                      format: "did"
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["code"],
                  properties: {
                    code: {
                      type: "string"
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoServerCreateInviteCodes: {
          lexicon: 1,
          id: "com.atproto.server.createInviteCodes",
          defs: {
            main: {
              type: "procedure",
              description: "Create invite codes.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["codeCount", "useCount"],
                  properties: {
                    codeCount: {
                      type: "integer",
                      default: 1
                    },
                    useCount: {
                      type: "integer"
                    },
                    forAccounts: {
                      type: "array",
                      items: {
                        type: "string",
                        format: "did"
                      }
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["codes"],
                  properties: {
                    codes: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:com.atproto.server.createInviteCodes#accountCodes"
                      }
                    }
                  }
                }
              }
            },
            accountCodes: {
              type: "object",
              required: ["account", "codes"],
              properties: {
                account: {
                  type: "string"
                },
                codes: {
                  type: "array",
                  items: {
                    type: "string"
                  }
                }
              }
            }
          }
        },
        ComAtprotoServerCreateSession: {
          lexicon: 1,
          id: "com.atproto.server.createSession",
          defs: {
            main: {
              type: "procedure",
              description: "Create an authentication session.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["identifier", "password"],
                  properties: {
                    identifier: {
                      type: "string",
                      description: "Handle or other identifier supported by the server for the authenticating user."
                    },
                    password: {
                      type: "string"
                    },
                    authFactorToken: {
                      type: "string"
                    },
                    allowTakendown: {
                      type: "boolean",
                      description: "When true, instead of throwing error for takendown accounts, a valid response with a narrow scoped token will be returned"
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["accessJwt", "refreshJwt", "handle", "did"],
                  properties: {
                    accessJwt: {
                      type: "string"
                    },
                    refreshJwt: {
                      type: "string"
                    },
                    handle: {
                      type: "string",
                      format: "handle"
                    },
                    did: {
                      type: "string",
                      format: "did"
                    },
                    didDoc: {
                      type: "unknown"
                    },
                    email: {
                      type: "string"
                    },
                    emailConfirmed: {
                      type: "boolean"
                    },
                    emailAuthFactor: {
                      type: "boolean"
                    },
                    active: {
                      type: "boolean"
                    },
                    status: {
                      type: "string",
                      description: "If active=false, this optional field indicates a possible reason for why the account is not active. If active=false and no status is supplied, then the host makes no claim for why the repository is no longer being hosted.",
                      knownValues: ["takendown", "suspended", "deactivated"]
                    }
                  }
                }
              },
              errors: [
                {
                  name: "AccountTakedown"
                },
                {
                  name: "AuthFactorTokenRequired"
                }
              ]
            }
          }
        },
        ComAtprotoServerDeactivateAccount: {
          lexicon: 1,
          id: "com.atproto.server.deactivateAccount",
          defs: {
            main: {
              type: "procedure",
              description: "Deactivates a currently active account. Stops serving of repo, and future writes to repo until reactivated. Used to finalize account migration with the old host after the account has been activated on the new host.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  properties: {
                    deleteAfter: {
                      type: "string",
                      format: "datetime",
                      description: "A recommendation to server as to how long they should hold onto the deactivated account before deleting."
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoServerDefs: {
          lexicon: 1,
          id: "com.atproto.server.defs",
          defs: {
            inviteCode: {
              type: "object",
              required: [
                "code",
                "available",
                "disabled",
                "forAccount",
                "createdBy",
                "createdAt",
                "uses"
              ],
              properties: {
                code: {
                  type: "string"
                },
                available: {
                  type: "integer"
                },
                disabled: {
                  type: "boolean"
                },
                forAccount: {
                  type: "string"
                },
                createdBy: {
                  type: "string"
                },
                createdAt: {
                  type: "string",
                  format: "datetime"
                },
                uses: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.server.defs#inviteCodeUse"
                  }
                }
              }
            },
            inviteCodeUse: {
              type: "object",
              required: ["usedBy", "usedAt"],
              properties: {
                usedBy: {
                  type: "string",
                  format: "did"
                },
                usedAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            }
          }
        },
        ComAtprotoServerDeleteAccount: {
          lexicon: 1,
          id: "com.atproto.server.deleteAccount",
          defs: {
            main: {
              type: "procedure",
              description: "Delete an actor's account with a token and password. Can only be called after requesting a deletion token. Requires auth.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["did", "password", "token"],
                  properties: {
                    did: {
                      type: "string",
                      format: "did"
                    },
                    password: {
                      type: "string"
                    },
                    token: {
                      type: "string"
                    }
                  }
                }
              },
              errors: [
                {
                  name: "ExpiredToken"
                },
                {
                  name: "InvalidToken"
                }
              ]
            }
          }
        },
        ComAtprotoServerDeleteSession: {
          lexicon: 1,
          id: "com.atproto.server.deleteSession",
          defs: {
            main: {
              type: "procedure",
              description: "Delete the current session. Requires auth."
            }
          }
        },
        ComAtprotoServerDescribeServer: {
          lexicon: 1,
          id: "com.atproto.server.describeServer",
          defs: {
            main: {
              type: "query",
              description: "Describes the server's account creation requirements and capabilities. Implemented by PDS.",
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["did", "availableUserDomains"],
                  properties: {
                    inviteCodeRequired: {
                      type: "boolean",
                      description: "If true, an invite code must be supplied to create an account on this instance."
                    },
                    phoneVerificationRequired: {
                      type: "boolean",
                      description: "If true, a phone verification token must be supplied to create an account on this instance."
                    },
                    availableUserDomains: {
                      type: "array",
                      description: "List of domain suffixes that can be used in account handles.",
                      items: {
                        type: "string"
                      }
                    },
                    links: {
                      type: "ref",
                      description: "URLs of service policy documents.",
                      ref: "lex:com.atproto.server.describeServer#links"
                    },
                    contact: {
                      type: "ref",
                      description: "Contact information",
                      ref: "lex:com.atproto.server.describeServer#contact"
                    },
                    did: {
                      type: "string",
                      format: "did"
                    }
                  }
                }
              }
            },
            links: {
              type: "object",
              properties: {
                privacyPolicy: {
                  type: "string",
                  format: "uri"
                },
                termsOfService: {
                  type: "string",
                  format: "uri"
                }
              }
            },
            contact: {
              type: "object",
              properties: {
                email: {
                  type: "string"
                }
              }
            }
          }
        },
        ComAtprotoServerGetAccountInviteCodes: {
          lexicon: 1,
          id: "com.atproto.server.getAccountInviteCodes",
          defs: {
            main: {
              type: "query",
              description: "Get all invite codes for the current account. Requires auth.",
              parameters: {
                type: "params",
                properties: {
                  includeUsed: {
                    type: "boolean",
                    default: true
                  },
                  createAvailable: {
                    type: "boolean",
                    default: true,
                    description: "Controls whether any new 'earned' but not 'created' invites should be created."
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["codes"],
                  properties: {
                    codes: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:com.atproto.server.defs#inviteCode"
                      }
                    }
                  }
                }
              },
              errors: [
                {
                  name: "DuplicateCreate"
                }
              ]
            }
          }
        },
        ComAtprotoServerGetServiceAuth: {
          lexicon: 1,
          id: "com.atproto.server.getServiceAuth",
          defs: {
            main: {
              type: "query",
              description: "Get a signed token on behalf of the requesting DID for the requested service.",
              parameters: {
                type: "params",
                required: ["aud"],
                properties: {
                  aud: {
                    type: "string",
                    format: "did",
                    description: "The DID of the service that the token will be used to authenticate with"
                  },
                  exp: {
                    type: "integer",
                    description: "The time in Unix Epoch seconds that the JWT expires. Defaults to 60 seconds in the future. The service may enforce certain time bounds on tokens depending on the requested scope."
                  },
                  lxm: {
                    type: "string",
                    format: "nsid",
                    description: "Lexicon (XRPC) method to bind the requested token to"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["token"],
                  properties: {
                    token: {
                      type: "string"
                    }
                  }
                }
              },
              errors: [
                {
                  name: "BadExpiration",
                  description: "Indicates that the requested expiration date is not a valid. May be in the past or may be reliant on the requested scopes."
                }
              ]
            }
          }
        },
        ComAtprotoServerGetSession: {
          lexicon: 1,
          id: "com.atproto.server.getSession",
          defs: {
            main: {
              type: "query",
              description: "Get information about the current auth session. Requires auth.",
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["handle", "did"],
                  properties: {
                    handle: {
                      type: "string",
                      format: "handle"
                    },
                    did: {
                      type: "string",
                      format: "did"
                    },
                    email: {
                      type: "string"
                    },
                    emailConfirmed: {
                      type: "boolean"
                    },
                    emailAuthFactor: {
                      type: "boolean"
                    },
                    didDoc: {
                      type: "unknown"
                    },
                    active: {
                      type: "boolean"
                    },
                    status: {
                      type: "string",
                      description: "If active=false, this optional field indicates a possible reason for why the account is not active. If active=false and no status is supplied, then the host makes no claim for why the repository is no longer being hosted.",
                      knownValues: ["takendown", "suspended", "deactivated"]
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoServerListAppPasswords: {
          lexicon: 1,
          id: "com.atproto.server.listAppPasswords",
          defs: {
            main: {
              type: "query",
              description: "List all App Passwords.",
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["passwords"],
                  properties: {
                    passwords: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:com.atproto.server.listAppPasswords#appPassword"
                      }
                    }
                  }
                }
              },
              errors: [
                {
                  name: "AccountTakedown"
                }
              ]
            },
            appPassword: {
              type: "object",
              required: ["name", "createdAt"],
              properties: {
                name: {
                  type: "string"
                },
                createdAt: {
                  type: "string",
                  format: "datetime"
                },
                privileged: {
                  type: "boolean"
                }
              }
            }
          }
        },
        ComAtprotoServerRefreshSession: {
          lexicon: 1,
          id: "com.atproto.server.refreshSession",
          defs: {
            main: {
              type: "procedure",
              description: "Refresh an authentication session. Requires auth using the 'refreshJwt' (not the 'accessJwt').",
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["accessJwt", "refreshJwt", "handle", "did"],
                  properties: {
                    accessJwt: {
                      type: "string"
                    },
                    refreshJwt: {
                      type: "string"
                    },
                    handle: {
                      type: "string",
                      format: "handle"
                    },
                    did: {
                      type: "string",
                      format: "did"
                    },
                    didDoc: {
                      type: "unknown"
                    },
                    active: {
                      type: "boolean"
                    },
                    status: {
                      type: "string",
                      description: "Hosting status of the account. If not specified, then assume 'active'.",
                      knownValues: ["takendown", "suspended", "deactivated"]
                    }
                  }
                }
              },
              errors: [
                {
                  name: "AccountTakedown"
                }
              ]
            }
          }
        },
        ComAtprotoServerRequestAccountDelete: {
          lexicon: 1,
          id: "com.atproto.server.requestAccountDelete",
          defs: {
            main: {
              type: "procedure",
              description: "Initiate a user account deletion via email."
            }
          }
        },
        ComAtprotoServerRequestEmailConfirmation: {
          lexicon: 1,
          id: "com.atproto.server.requestEmailConfirmation",
          defs: {
            main: {
              type: "procedure",
              description: "Request an email with a code to confirm ownership of email."
            }
          }
        },
        ComAtprotoServerRequestEmailUpdate: {
          lexicon: 1,
          id: "com.atproto.server.requestEmailUpdate",
          defs: {
            main: {
              type: "procedure",
              description: "Request a token in order to update email.",
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["tokenRequired"],
                  properties: {
                    tokenRequired: {
                      type: "boolean"
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoServerRequestPasswordReset: {
          lexicon: 1,
          id: "com.atproto.server.requestPasswordReset",
          defs: {
            main: {
              type: "procedure",
              description: "Initiate a user account password reset via email.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["email"],
                  properties: {
                    email: {
                      type: "string"
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoServerReserveSigningKey: {
          lexicon: 1,
          id: "com.atproto.server.reserveSigningKey",
          defs: {
            main: {
              type: "procedure",
              description: "Reserve a repo signing key, for use with account creation. Necessary so that a DID PLC update operation can be constructed during an account migraiton. Public and does not require auth; implemented by PDS. NOTE: this endpoint may change when full account migration is implemented.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  properties: {
                    did: {
                      type: "string",
                      format: "did",
                      description: "The DID to reserve a key for."
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["signingKey"],
                  properties: {
                    signingKey: {
                      type: "string",
                      description: "The public key for the reserved signing key, in did:key serialization."
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoServerResetPassword: {
          lexicon: 1,
          id: "com.atproto.server.resetPassword",
          defs: {
            main: {
              type: "procedure",
              description: "Reset a user account password using a token.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["token", "password"],
                  properties: {
                    token: {
                      type: "string"
                    },
                    password: {
                      type: "string"
                    }
                  }
                }
              },
              errors: [
                {
                  name: "ExpiredToken"
                },
                {
                  name: "InvalidToken"
                }
              ]
            }
          }
        },
        ComAtprotoServerRevokeAppPassword: {
          lexicon: 1,
          id: "com.atproto.server.revokeAppPassword",
          defs: {
            main: {
              type: "procedure",
              description: "Revoke an App Password by name.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["name"],
                  properties: {
                    name: {
                      type: "string"
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoServerUpdateEmail: {
          lexicon: 1,
          id: "com.atproto.server.updateEmail",
          defs: {
            main: {
              type: "procedure",
              description: "Update an account's email.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["email"],
                  properties: {
                    email: {
                      type: "string"
                    },
                    emailAuthFactor: {
                      type: "boolean"
                    },
                    token: {
                      type: "string",
                      description: "Requires a token from com.atproto.sever.requestEmailUpdate if the account's email has been confirmed."
                    }
                  }
                }
              },
              errors: [
                {
                  name: "ExpiredToken"
                },
                {
                  name: "InvalidToken"
                },
                {
                  name: "TokenRequired"
                }
              ]
            }
          }
        },
        ComAtprotoSyncGetBlob: {
          lexicon: 1,
          id: "com.atproto.sync.getBlob",
          defs: {
            main: {
              type: "query",
              description: "Get a blob associated with a given account. Returns the full blob as originally uploaded. Does not require auth; implemented by PDS.",
              parameters: {
                type: "params",
                required: ["did", "cid"],
                properties: {
                  did: {
                    type: "string",
                    format: "did",
                    description: "The DID of the account."
                  },
                  cid: {
                    type: "string",
                    format: "cid",
                    description: "The CID of the blob to fetch"
                  }
                }
              },
              output: {
                encoding: "*/*"
              },
              errors: [
                {
                  name: "BlobNotFound"
                },
                {
                  name: "RepoNotFound"
                },
                {
                  name: "RepoTakendown"
                },
                {
                  name: "RepoSuspended"
                },
                {
                  name: "RepoDeactivated"
                }
              ]
            }
          }
        },
        ComAtprotoSyncGetBlocks: {
          lexicon: 1,
          id: "com.atproto.sync.getBlocks",
          defs: {
            main: {
              type: "query",
              description: "Get data blocks from a given repo, by CID. For example, intermediate MST nodes, or records. Does not require auth; implemented by PDS.",
              parameters: {
                type: "params",
                required: ["did", "cids"],
                properties: {
                  did: {
                    type: "string",
                    format: "did",
                    description: "The DID of the repo."
                  },
                  cids: {
                    type: "array",
                    items: {
                      type: "string",
                      format: "cid"
                    }
                  }
                }
              },
              output: {
                encoding: "application/vnd.ipld.car"
              },
              errors: [
                {
                  name: "BlockNotFound"
                },
                {
                  name: "RepoNotFound"
                },
                {
                  name: "RepoTakendown"
                },
                {
                  name: "RepoSuspended"
                },
                {
                  name: "RepoDeactivated"
                }
              ]
            }
          }
        },
        ComAtprotoSyncGetCheckout: {
          lexicon: 1,
          id: "com.atproto.sync.getCheckout",
          defs: {
            main: {
              type: "query",
              description: "DEPRECATED - please use com.atproto.sync.getRepo instead",
              parameters: {
                type: "params",
                required: ["did"],
                properties: {
                  did: {
                    type: "string",
                    format: "did",
                    description: "The DID of the repo."
                  }
                }
              },
              output: {
                encoding: "application/vnd.ipld.car"
              }
            }
          }
        },
        ComAtprotoSyncGetHead: {
          lexicon: 1,
          id: "com.atproto.sync.getHead",
          defs: {
            main: {
              type: "query",
              description: "DEPRECATED - please use com.atproto.sync.getLatestCommit instead",
              parameters: {
                type: "params",
                required: ["did"],
                properties: {
                  did: {
                    type: "string",
                    format: "did",
                    description: "The DID of the repo."
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["root"],
                  properties: {
                    root: {
                      type: "string",
                      format: "cid"
                    }
                  }
                }
              },
              errors: [
                {
                  name: "HeadNotFound"
                }
              ]
            }
          }
        },
        ComAtprotoSyncGetLatestCommit: {
          lexicon: 1,
          id: "com.atproto.sync.getLatestCommit",
          defs: {
            main: {
              type: "query",
              description: "Get the current commit CID & revision of the specified repo. Does not require auth.",
              parameters: {
                type: "params",
                required: ["did"],
                properties: {
                  did: {
                    type: "string",
                    format: "did",
                    description: "The DID of the repo."
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["cid", "rev"],
                  properties: {
                    cid: {
                      type: "string",
                      format: "cid"
                    },
                    rev: {
                      type: "string"
                    }
                  }
                }
              },
              errors: [
                {
                  name: "RepoNotFound"
                },
                {
                  name: "RepoTakendown"
                },
                {
                  name: "RepoSuspended"
                },
                {
                  name: "RepoDeactivated"
                }
              ]
            }
          }
        },
        ComAtprotoSyncGetRecord: {
          lexicon: 1,
          id: "com.atproto.sync.getRecord",
          defs: {
            main: {
              type: "query",
              description: "Get data blocks needed to prove the existence or non-existence of record in the current version of repo. Does not require auth.",
              parameters: {
                type: "params",
                required: ["did", "collection", "rkey"],
                properties: {
                  did: {
                    type: "string",
                    format: "did",
                    description: "The DID of the repo."
                  },
                  collection: {
                    type: "string",
                    format: "nsid"
                  },
                  rkey: {
                    type: "string",
                    description: "Record Key"
                  },
                  commit: {
                    type: "string",
                    format: "cid",
                    description: "DEPRECATED: referenced a repo commit by CID, and retrieved record as of that commit"
                  }
                }
              },
              output: {
                encoding: "application/vnd.ipld.car"
              },
              errors: [
                {
                  name: "RecordNotFound"
                },
                {
                  name: "RepoNotFound"
                },
                {
                  name: "RepoTakendown"
                },
                {
                  name: "RepoSuspended"
                },
                {
                  name: "RepoDeactivated"
                }
              ]
            }
          }
        },
        ComAtprotoSyncGetRepo: {
          lexicon: 1,
          id: "com.atproto.sync.getRepo",
          defs: {
            main: {
              type: "query",
              description: "Download a repository export as CAR file. Optionally only a 'diff' since a previous revision. Does not require auth; implemented by PDS.",
              parameters: {
                type: "params",
                required: ["did"],
                properties: {
                  did: {
                    type: "string",
                    format: "did",
                    description: "The DID of the repo."
                  },
                  since: {
                    type: "string",
                    description: "The revision ('rev') of the repo to create a diff from."
                  }
                }
              },
              output: {
                encoding: "application/vnd.ipld.car"
              },
              errors: [
                {
                  name: "RepoNotFound"
                },
                {
                  name: "RepoTakendown"
                },
                {
                  name: "RepoSuspended"
                },
                {
                  name: "RepoDeactivated"
                }
              ]
            }
          }
        },
        ComAtprotoSyncGetRepoStatus: {
          lexicon: 1,
          id: "com.atproto.sync.getRepoStatus",
          defs: {
            main: {
              type: "query",
              description: "Get the hosting status for a repository, on this server. Expected to be implemented by PDS and Relay.",
              parameters: {
                type: "params",
                required: ["did"],
                properties: {
                  did: {
                    type: "string",
                    format: "did",
                    description: "The DID of the repo."
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["did", "active"],
                  properties: {
                    did: {
                      type: "string",
                      format: "did"
                    },
                    active: {
                      type: "boolean"
                    },
                    status: {
                      type: "string",
                      description: "If active=false, this optional field indicates a possible reason for why the account is not active. If active=false and no status is supplied, then the host makes no claim for why the repository is no longer being hosted.",
                      knownValues: ["takendown", "suspended", "deactivated"]
                    },
                    rev: {
                      type: "string",
                      description: "Optional field, the current rev of the repo, if active=true"
                    }
                  }
                }
              },
              errors: [
                {
                  name: "RepoNotFound"
                }
              ]
            }
          }
        },
        ComAtprotoSyncListBlobs: {
          lexicon: 1,
          id: "com.atproto.sync.listBlobs",
          defs: {
            main: {
              type: "query",
              description: "List blob CIDs for an account, since some repo revision. Does not require auth; implemented by PDS.",
              parameters: {
                type: "params",
                required: ["did"],
                properties: {
                  did: {
                    type: "string",
                    format: "did",
                    description: "The DID of the repo."
                  },
                  since: {
                    type: "string",
                    description: "Optional revision of the repo to list blobs since."
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 1e3,
                    default: 500
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["cids"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    cids: {
                      type: "array",
                      items: {
                        type: "string",
                        format: "cid"
                      }
                    }
                  }
                }
              },
              errors: [
                {
                  name: "RepoNotFound"
                },
                {
                  name: "RepoTakendown"
                },
                {
                  name: "RepoSuspended"
                },
                {
                  name: "RepoDeactivated"
                }
              ]
            }
          }
        },
        ComAtprotoSyncListRepos: {
          lexicon: 1,
          id: "com.atproto.sync.listRepos",
          defs: {
            main: {
              type: "query",
              description: "Enumerates all the DID, rev, and commit CID for all repos hosted by this service. Does not require auth; implemented by PDS and Relay.",
              parameters: {
                type: "params",
                properties: {
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 1e3,
                    default: 500
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["repos"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    repos: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:com.atproto.sync.listRepos#repo"
                      }
                    }
                  }
                }
              }
            },
            repo: {
              type: "object",
              required: ["did", "head", "rev"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                },
                head: {
                  type: "string",
                  format: "cid",
                  description: "Current repo commit CID"
                },
                rev: {
                  type: "string"
                },
                active: {
                  type: "boolean"
                },
                status: {
                  type: "string",
                  description: "If active=false, this optional field indicates a possible reason for why the account is not active. If active=false and no status is supplied, then the host makes no claim for why the repository is no longer being hosted.",
                  knownValues: ["takendown", "suspended", "deactivated"]
                }
              }
            }
          }
        },
        ComAtprotoSyncNotifyOfUpdate: {
          lexicon: 1,
          id: "com.atproto.sync.notifyOfUpdate",
          defs: {
            main: {
              type: "procedure",
              description: "Notify a crawling service of a recent update, and that crawling should resume. Intended use is after a gap between repo stream events caused the crawling service to disconnect. Does not require auth; implemented by Relay.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["hostname"],
                  properties: {
                    hostname: {
                      type: "string",
                      description: "Hostname of the current service (usually a PDS) that is notifying of update."
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoSyncRequestCrawl: {
          lexicon: 1,
          id: "com.atproto.sync.requestCrawl",
          defs: {
            main: {
              type: "procedure",
              description: "Request a service to persistently crawl hosted repos. Expected use is new PDS instances declaring their existence to Relays. Does not require auth.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["hostname"],
                  properties: {
                    hostname: {
                      type: "string",
                      description: "Hostname of the current service (eg, PDS) that is requesting to be crawled."
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoSyncSubscribeRepos: {
          lexicon: 1,
          id: "com.atproto.sync.subscribeRepos",
          defs: {
            main: {
              type: "subscription",
              description: "Repository event stream, aka Firehose endpoint. Outputs repo commits with diff data, and identity update events, for all repositories on the current server. See the atproto specifications for details around stream sequencing, repo versioning, CAR diff format, and more. Public and does not require auth; implemented by PDS and Relay.",
              parameters: {
                type: "params",
                properties: {
                  cursor: {
                    type: "integer",
                    description: "The last known event seq number to backfill from."
                  }
                }
              },
              message: {
                schema: {
                  type: "union",
                  refs: [
                    "lex:com.atproto.sync.subscribeRepos#commit",
                    "lex:com.atproto.sync.subscribeRepos#identity",
                    "lex:com.atproto.sync.subscribeRepos#account",
                    "lex:com.atproto.sync.subscribeRepos#handle",
                    "lex:com.atproto.sync.subscribeRepos#migrate",
                    "lex:com.atproto.sync.subscribeRepos#tombstone",
                    "lex:com.atproto.sync.subscribeRepos#info"
                  ]
                }
              },
              errors: [
                {
                  name: "FutureCursor"
                },
                {
                  name: "ConsumerTooSlow",
                  description: "If the consumer of the stream can not keep up with events, and a backlog gets too large, the server will drop the connection."
                }
              ]
            },
            commit: {
              type: "object",
              description: "Represents an update of repository state. Note that empty commits are allowed, which include no repo data changes, but an update to rev and signature.",
              required: [
                "seq",
                "rebase",
                "tooBig",
                "repo",
                "commit",
                "rev",
                "since",
                "blocks",
                "ops",
                "blobs",
                "time"
              ],
              nullable: ["prev", "since"],
              properties: {
                seq: {
                  type: "integer",
                  description: "The stream sequence number of this message."
                },
                rebase: {
                  type: "boolean",
                  description: "DEPRECATED -- unused"
                },
                tooBig: {
                  type: "boolean",
                  description: "Indicates that this commit contained too many ops, or data size was too large. Consumers will need to make a separate request to get missing data."
                },
                repo: {
                  type: "string",
                  format: "did",
                  description: "The repo this event comes from."
                },
                commit: {
                  type: "cid-link",
                  description: "Repo commit object CID."
                },
                prev: {
                  type: "cid-link",
                  description: "DEPRECATED -- unused. WARNING -- nullable and optional; stick with optional to ensure golang interoperability."
                },
                rev: {
                  type: "string",
                  description: "The rev of the emitted commit. Note that this information is also in the commit object included in blocks, unless this is a tooBig event."
                },
                since: {
                  type: "string",
                  description: "The rev of the last emitted commit from this repo (if any)."
                },
                blocks: {
                  type: "bytes",
                  description: "CAR file containing relevant blocks, as a diff since the previous repo state.",
                  maxLength: 1e6
                },
                ops: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.sync.subscribeRepos#repoOp",
                    description: "List of repo mutation operations in this commit (eg, records created, updated, or deleted)."
                  },
                  maxLength: 200
                },
                blobs: {
                  type: "array",
                  items: {
                    type: "cid-link",
                    description: "List of new blobs (by CID) referenced by records in this commit."
                  }
                },
                time: {
                  type: "string",
                  format: "datetime",
                  description: "Timestamp of when this message was originally broadcast."
                }
              }
            },
            identity: {
              type: "object",
              description: "Represents a change to an account's identity. Could be an updated handle, signing key, or pds hosting endpoint. Serves as a prod to all downstream services to refresh their identity cache.",
              required: ["seq", "did", "time"],
              properties: {
                seq: {
                  type: "integer"
                },
                did: {
                  type: "string",
                  format: "did"
                },
                time: {
                  type: "string",
                  format: "datetime"
                },
                handle: {
                  type: "string",
                  format: "handle",
                  description: "The current handle for the account, or 'handle.invalid' if validation fails. This field is optional, might have been validated or passed-through from an upstream source. Semantics and behaviors for PDS vs Relay may evolve in the future; see atproto specs for more details."
                }
              }
            },
            account: {
              type: "object",
              description: "Represents a change to an account's status on a host (eg, PDS or Relay). The semantics of this event are that the status is at the host which emitted the event, not necessarily that at the currently active PDS. Eg, a Relay takedown would emit a takedown with active=false, even if the PDS is still active.",
              required: ["seq", "did", "time", "active"],
              properties: {
                seq: {
                  type: "integer"
                },
                did: {
                  type: "string",
                  format: "did"
                },
                time: {
                  type: "string",
                  format: "datetime"
                },
                active: {
                  type: "boolean",
                  description: "Indicates that the account has a repository which can be fetched from the host that emitted this event."
                },
                status: {
                  type: "string",
                  description: "If active=false, this optional field indicates a reason for why the account is not active.",
                  knownValues: ["takendown", "suspended", "deleted", "deactivated"]
                }
              }
            },
            handle: {
              type: "object",
              description: "DEPRECATED -- Use #identity event instead",
              required: ["seq", "did", "handle", "time"],
              properties: {
                seq: {
                  type: "integer"
                },
                did: {
                  type: "string",
                  format: "did"
                },
                handle: {
                  type: "string",
                  format: "handle"
                },
                time: {
                  type: "string",
                  format: "datetime"
                }
              }
            },
            migrate: {
              type: "object",
              description: "DEPRECATED -- Use #account event instead",
              required: ["seq", "did", "migrateTo", "time"],
              nullable: ["migrateTo"],
              properties: {
                seq: {
                  type: "integer"
                },
                did: {
                  type: "string",
                  format: "did"
                },
                migrateTo: {
                  type: "string"
                },
                time: {
                  type: "string",
                  format: "datetime"
                }
              }
            },
            tombstone: {
              type: "object",
              description: "DEPRECATED -- Use #account event instead",
              required: ["seq", "did", "time"],
              properties: {
                seq: {
                  type: "integer"
                },
                did: {
                  type: "string",
                  format: "did"
                },
                time: {
                  type: "string",
                  format: "datetime"
                }
              }
            },
            info: {
              type: "object",
              required: ["name"],
              properties: {
                name: {
                  type: "string",
                  knownValues: ["OutdatedCursor"]
                },
                message: {
                  type: "string"
                }
              }
            },
            repoOp: {
              type: "object",
              description: "A repo operation, ie a mutation of a single record.",
              required: ["action", "path", "cid"],
              nullable: ["cid"],
              properties: {
                action: {
                  type: "string",
                  knownValues: ["create", "update", "delete"]
                },
                path: {
                  type: "string"
                },
                cid: {
                  type: "cid-link",
                  description: "For creates and updates, the new record CID. For deletions, null."
                }
              }
            }
          }
        },
        ComAtprotoTempAddReservedHandle: {
          lexicon: 1,
          id: "com.atproto.temp.addReservedHandle",
          defs: {
            main: {
              type: "procedure",
              description: "Add a handle to the set of reserved handles.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["handle"],
                  properties: {
                    handle: {
                      type: "string"
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  properties: {}
                }
              }
            }
          }
        },
        ComAtprotoTempCheckSignupQueue: {
          lexicon: 1,
          id: "com.atproto.temp.checkSignupQueue",
          defs: {
            main: {
              type: "query",
              description: "Check accounts location in signup queue.",
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["activated"],
                  properties: {
                    activated: {
                      type: "boolean"
                    },
                    placeInQueue: {
                      type: "integer"
                    },
                    estimatedTimeMs: {
                      type: "integer"
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoTempFetchLabels: {
          lexicon: 1,
          id: "com.atproto.temp.fetchLabels",
          defs: {
            main: {
              type: "query",
              description: "DEPRECATED: use queryLabels or subscribeLabels instead -- Fetch all labels from a labeler created after a certain date.",
              parameters: {
                type: "params",
                properties: {
                  since: {
                    type: "integer"
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 250,
                    default: 50
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["labels"],
                  properties: {
                    labels: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:com.atproto.label.defs#label"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        ComAtprotoTempRequestPhoneVerification: {
          lexicon: 1,
          id: "com.atproto.temp.requestPhoneVerification",
          defs: {
            main: {
              type: "procedure",
              description: "Request a verification code to be sent to the supplied phone number",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["phoneNumber"],
                  properties: {
                    phoneNumber: {
                      type: "string"
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyActorDefs: {
          lexicon: 1,
          id: "app.bsky.actor.defs",
          defs: {
            profileViewBasic: {
              type: "object",
              required: ["did", "handle"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                },
                handle: {
                  type: "string",
                  format: "handle"
                },
                displayName: {
                  type: "string",
                  maxGraphemes: 64,
                  maxLength: 640
                },
                avatar: {
                  type: "string",
                  format: "uri"
                },
                associated: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#profileAssociated"
                },
                viewer: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#viewerState"
                },
                labels: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.label.defs#label"
                  }
                },
                createdAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            },
            profileView: {
              type: "object",
              required: ["did", "handle"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                },
                handle: {
                  type: "string",
                  format: "handle"
                },
                displayName: {
                  type: "string",
                  maxGraphemes: 64,
                  maxLength: 640
                },
                description: {
                  type: "string",
                  maxGraphemes: 256,
                  maxLength: 2560
                },
                avatar: {
                  type: "string",
                  format: "uri"
                },
                associated: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#profileAssociated"
                },
                indexedAt: {
                  type: "string",
                  format: "datetime"
                },
                createdAt: {
                  type: "string",
                  format: "datetime"
                },
                viewer: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#viewerState"
                },
                labels: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.label.defs#label"
                  }
                }
              }
            },
            profileViewDetailed: {
              type: "object",
              required: ["did", "handle"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                },
                handle: {
                  type: "string",
                  format: "handle"
                },
                displayName: {
                  type: "string",
                  maxGraphemes: 64,
                  maxLength: 640
                },
                description: {
                  type: "string",
                  maxGraphemes: 256,
                  maxLength: 2560
                },
                avatar: {
                  type: "string",
                  format: "uri"
                },
                banner: {
                  type: "string",
                  format: "uri"
                },
                followersCount: {
                  type: "integer"
                },
                followsCount: {
                  type: "integer"
                },
                postsCount: {
                  type: "integer"
                },
                associated: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#profileAssociated"
                },
                joinedViaStarterPack: {
                  type: "ref",
                  ref: "lex:app.bsky.graph.defs#starterPackViewBasic"
                },
                indexedAt: {
                  type: "string",
                  format: "datetime"
                },
                createdAt: {
                  type: "string",
                  format: "datetime"
                },
                viewer: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#viewerState"
                },
                labels: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.label.defs#label"
                  }
                },
                pinnedPost: {
                  type: "ref",
                  ref: "lex:com.atproto.repo.strongRef"
                }
              }
            },
            profileAssociated: {
              type: "object",
              properties: {
                lists: {
                  type: "integer"
                },
                feedgens: {
                  type: "integer"
                },
                starterPacks: {
                  type: "integer"
                },
                labeler: {
                  type: "boolean"
                },
                chat: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#profileAssociatedChat"
                }
              }
            },
            profileAssociatedChat: {
              type: "object",
              required: ["allowIncoming"],
              properties: {
                allowIncoming: {
                  type: "string",
                  knownValues: ["all", "none", "following"]
                }
              }
            },
            viewerState: {
              type: "object",
              description: "Metadata about the requesting account's relationship with the subject account. Only has meaningful content for authed requests.",
              properties: {
                muted: {
                  type: "boolean"
                },
                mutedByList: {
                  type: "ref",
                  ref: "lex:app.bsky.graph.defs#listViewBasic"
                },
                blockedBy: {
                  type: "boolean"
                },
                blocking: {
                  type: "string",
                  format: "at-uri"
                },
                blockingByList: {
                  type: "ref",
                  ref: "lex:app.bsky.graph.defs#listViewBasic"
                },
                following: {
                  type: "string",
                  format: "at-uri"
                },
                followedBy: {
                  type: "string",
                  format: "at-uri"
                },
                knownFollowers: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#knownFollowers"
                }
              }
            },
            knownFollowers: {
              type: "object",
              description: "The subject's followers whom you also follow",
              required: ["count", "followers"],
              properties: {
                count: {
                  type: "integer"
                },
                followers: {
                  type: "array",
                  minLength: 0,
                  maxLength: 5,
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.actor.defs#profileViewBasic"
                  }
                }
              }
            },
            preferences: {
              type: "array",
              items: {
                type: "union",
                refs: [
                  "lex:app.bsky.actor.defs#adultContentPref",
                  "lex:app.bsky.actor.defs#contentLabelPref",
                  "lex:app.bsky.actor.defs#savedFeedsPref",
                  "lex:app.bsky.actor.defs#savedFeedsPrefV2",
                  "lex:app.bsky.actor.defs#personalDetailsPref",
                  "lex:app.bsky.actor.defs#feedViewPref",
                  "lex:app.bsky.actor.defs#threadViewPref",
                  "lex:app.bsky.actor.defs#interestsPref",
                  "lex:app.bsky.actor.defs#mutedWordsPref",
                  "lex:app.bsky.actor.defs#hiddenPostsPref",
                  "lex:app.bsky.actor.defs#bskyAppStatePref",
                  "lex:app.bsky.actor.defs#labelersPref",
                  "lex:app.bsky.actor.defs#postInteractionSettingsPref"
                ]
              }
            },
            adultContentPref: {
              type: "object",
              required: ["enabled"],
              properties: {
                enabled: {
                  type: "boolean",
                  default: false
                }
              }
            },
            contentLabelPref: {
              type: "object",
              required: ["label", "visibility"],
              properties: {
                labelerDid: {
                  type: "string",
                  description: "Which labeler does this preference apply to? If undefined, applies globally.",
                  format: "did"
                },
                label: {
                  type: "string"
                },
                visibility: {
                  type: "string",
                  knownValues: ["ignore", "show", "warn", "hide"]
                }
              }
            },
            savedFeed: {
              type: "object",
              required: ["id", "type", "value", "pinned"],
              properties: {
                id: {
                  type: "string"
                },
                type: {
                  type: "string",
                  knownValues: ["feed", "list", "timeline"]
                },
                value: {
                  type: "string"
                },
                pinned: {
                  type: "boolean"
                }
              }
            },
            savedFeedsPrefV2: {
              type: "object",
              required: ["items"],
              properties: {
                items: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.actor.defs#savedFeed"
                  }
                }
              }
            },
            savedFeedsPref: {
              type: "object",
              required: ["pinned", "saved"],
              properties: {
                pinned: {
                  type: "array",
                  items: {
                    type: "string",
                    format: "at-uri"
                  }
                },
                saved: {
                  type: "array",
                  items: {
                    type: "string",
                    format: "at-uri"
                  }
                },
                timelineIndex: {
                  type: "integer"
                }
              }
            },
            personalDetailsPref: {
              type: "object",
              properties: {
                birthDate: {
                  type: "string",
                  format: "datetime",
                  description: "The birth date of account owner."
                }
              }
            },
            feedViewPref: {
              type: "object",
              required: ["feed"],
              properties: {
                feed: {
                  type: "string",
                  description: "The URI of the feed, or an identifier which describes the feed."
                },
                hideReplies: {
                  type: "boolean",
                  description: "Hide replies in the feed."
                },
                hideRepliesByUnfollowed: {
                  type: "boolean",
                  description: "Hide replies in the feed if they are not by followed users.",
                  default: true
                },
                hideRepliesByLikeCount: {
                  type: "integer",
                  description: "Hide replies in the feed if they do not have this number of likes."
                },
                hideReposts: {
                  type: "boolean",
                  description: "Hide reposts in the feed."
                },
                hideQuotePosts: {
                  type: "boolean",
                  description: "Hide quote posts in the feed."
                }
              }
            },
            threadViewPref: {
              type: "object",
              properties: {
                sort: {
                  type: "string",
                  description: "Sorting mode for threads.",
                  knownValues: [
                    "oldest",
                    "newest",
                    "most-likes",
                    "random",
                    "hotness"
                  ]
                },
                prioritizeFollowedUsers: {
                  type: "boolean",
                  description: "Show followed users at the top of all replies."
                }
              }
            },
            interestsPref: {
              type: "object",
              required: ["tags"],
              properties: {
                tags: {
                  type: "array",
                  maxLength: 100,
                  items: {
                    type: "string",
                    maxLength: 640,
                    maxGraphemes: 64
                  },
                  description: "A list of tags which describe the account owner's interests gathered during onboarding."
                }
              }
            },
            mutedWordTarget: {
              type: "string",
              knownValues: ["content", "tag"],
              maxLength: 640,
              maxGraphemes: 64
            },
            mutedWord: {
              type: "object",
              description: "A word that the account owner has muted.",
              required: ["value", "targets"],
              properties: {
                id: {
                  type: "string"
                },
                value: {
                  type: "string",
                  description: "The muted word itself.",
                  maxLength: 1e4,
                  maxGraphemes: 1e3
                },
                targets: {
                  type: "array",
                  description: "The intended targets of the muted word.",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.actor.defs#mutedWordTarget"
                  }
                },
                actorTarget: {
                  type: "string",
                  description: "Groups of users to apply the muted word to. If undefined, applies to all users.",
                  knownValues: ["all", "exclude-following"],
                  default: "all"
                },
                expiresAt: {
                  type: "string",
                  format: "datetime",
                  description: "The date and time at which the muted word will expire and no longer be applied."
                }
              }
            },
            mutedWordsPref: {
              type: "object",
              required: ["items"],
              properties: {
                items: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.actor.defs#mutedWord"
                  },
                  description: "A list of words the account owner has muted."
                }
              }
            },
            hiddenPostsPref: {
              type: "object",
              required: ["items"],
              properties: {
                items: {
                  type: "array",
                  items: {
                    type: "string",
                    format: "at-uri"
                  },
                  description: "A list of URIs of posts the account owner has hidden."
                }
              }
            },
            labelersPref: {
              type: "object",
              required: ["labelers"],
              properties: {
                labelers: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.actor.defs#labelerPrefItem"
                  }
                }
              }
            },
            labelerPrefItem: {
              type: "object",
              required: ["did"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                }
              }
            },
            bskyAppStatePref: {
              description: "A grab bag of state that's specific to the bsky.app program. Third-party apps shouldn't use this.",
              type: "object",
              properties: {
                activeProgressGuide: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#bskyAppProgressGuide"
                },
                queuedNudges: {
                  description: "An array of tokens which identify nudges (modals, popups, tours, highlight dots) that should be shown to the user.",
                  type: "array",
                  maxLength: 1e3,
                  items: {
                    type: "string",
                    maxLength: 100
                  }
                },
                nuxs: {
                  description: "Storage for NUXs the user has encountered.",
                  type: "array",
                  maxLength: 100,
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.actor.defs#nux"
                  }
                }
              }
            },
            bskyAppProgressGuide: {
              description: "If set, an active progress guide. Once completed, can be set to undefined. Should have unspecced fields tracking progress.",
              type: "object",
              required: ["guide"],
              properties: {
                guide: {
                  type: "string",
                  maxLength: 100
                }
              }
            },
            nux: {
              type: "object",
              description: "A new user experiences (NUX) storage object",
              required: ["id", "completed"],
              properties: {
                id: {
                  type: "string",
                  maxLength: 100
                },
                completed: {
                  type: "boolean",
                  default: false
                },
                data: {
                  description: "Arbitrary data for the NUX. The structure is defined by the NUX itself. Limited to 300 characters.",
                  type: "string",
                  maxLength: 3e3,
                  maxGraphemes: 300
                },
                expiresAt: {
                  type: "string",
                  format: "datetime",
                  description: "The date and time at which the NUX will expire and should be considered completed."
                }
              }
            },
            postInteractionSettingsPref: {
              type: "object",
              description: "Default post interaction settings for the account. These values should be applied as default values when creating new posts. These refs should mirror the threadgate and postgate records exactly.",
              required: [],
              properties: {
                threadgateAllowRules: {
                  description: "Matches threadgate record. List of rules defining who can reply to this users posts. If value is an empty array, no one can reply. If value is undefined, anyone can reply.",
                  type: "array",
                  maxLength: 5,
                  items: {
                    type: "union",
                    refs: [
                      "lex:app.bsky.feed.threadgate#mentionRule",
                      "lex:app.bsky.feed.threadgate#followerRule",
                      "lex:app.bsky.feed.threadgate#followingRule",
                      "lex:app.bsky.feed.threadgate#listRule"
                    ]
                  }
                },
                postgateEmbeddingRules: {
                  description: "Matches postgate record. List of rules defining who can embed this users posts. If value is an empty array or is undefined, no particular rules apply and anyone can embed.",
                  type: "array",
                  maxLength: 5,
                  items: {
                    type: "union",
                    refs: ["lex:app.bsky.feed.postgate#disableRule"]
                  }
                }
              }
            }
          }
        },
        AppBskyActorGetPreferences: {
          lexicon: 1,
          id: "app.bsky.actor.getPreferences",
          defs: {
            main: {
              type: "query",
              description: "Get private preferences attached to the current account. Expected use is synchronization between multiple devices, and import/export during account migration. Requires auth.",
              parameters: {
                type: "params",
                properties: {}
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["preferences"],
                  properties: {
                    preferences: {
                      type: "ref",
                      ref: "lex:app.bsky.actor.defs#preferences"
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyActorGetProfile: {
          lexicon: 1,
          id: "app.bsky.actor.getProfile",
          defs: {
            main: {
              type: "query",
              description: "Get detailed profile view of an actor. Does not require auth, but contains relevant metadata with auth.",
              parameters: {
                type: "params",
                required: ["actor"],
                properties: {
                  actor: {
                    type: "string",
                    format: "at-identifier",
                    description: "Handle or DID of account to fetch profile of."
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#profileViewDetailed"
                }
              }
            }
          }
        },
        AppBskyActorGetProfiles: {
          lexicon: 1,
          id: "app.bsky.actor.getProfiles",
          defs: {
            main: {
              type: "query",
              description: "Get detailed profile views of multiple actors.",
              parameters: {
                type: "params",
                required: ["actors"],
                properties: {
                  actors: {
                    type: "array",
                    items: {
                      type: "string",
                      format: "at-identifier"
                    },
                    maxLength: 25
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["profiles"],
                  properties: {
                    profiles: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.actor.defs#profileViewDetailed"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyActorGetSuggestions: {
          lexicon: 1,
          id: "app.bsky.actor.getSuggestions",
          defs: {
            main: {
              type: "query",
              description: "Get a list of suggested actors. Expected use is discovery of accounts to follow during new account onboarding.",
              parameters: {
                type: "params",
                properties: {
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["actors"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    actors: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.actor.defs#profileView"
                      }
                    },
                    recId: {
                      type: "integer",
                      description: "Snowflake for this recommendation, use when submitting recommendation events."
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyActorProfile: {
          lexicon: 1,
          id: "app.bsky.actor.profile",
          defs: {
            main: {
              type: "record",
              description: "A declaration of a Bluesky account profile.",
              key: "literal:self",
              record: {
                type: "object",
                properties: {
                  displayName: {
                    type: "string",
                    maxGraphemes: 64,
                    maxLength: 640
                  },
                  description: {
                    type: "string",
                    description: "Free-form profile description text.",
                    maxGraphemes: 256,
                    maxLength: 2560
                  },
                  avatar: {
                    type: "blob",
                    description: "Small image to be displayed next to posts from account. AKA, 'profile picture'",
                    accept: ["image/png", "image/jpeg"],
                    maxSize: 1e6
                  },
                  banner: {
                    type: "blob",
                    description: "Larger horizontal image to display behind profile view.",
                    accept: ["image/png", "image/jpeg"],
                    maxSize: 1e6
                  },
                  labels: {
                    type: "union",
                    description: "Self-label values, specific to the Bluesky application, on the overall account.",
                    refs: ["lex:com.atproto.label.defs#selfLabels"]
                  },
                  joinedViaStarterPack: {
                    type: "ref",
                    ref: "lex:com.atproto.repo.strongRef"
                  },
                  pinnedPost: {
                    type: "ref",
                    ref: "lex:com.atproto.repo.strongRef"
                  },
                  createdAt: {
                    type: "string",
                    format: "datetime"
                  }
                }
              }
            }
          }
        },
        AppBskyActorPutPreferences: {
          lexicon: 1,
          id: "app.bsky.actor.putPreferences",
          defs: {
            main: {
              type: "procedure",
              description: "Set the private preferences attached to the account.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["preferences"],
                  properties: {
                    preferences: {
                      type: "ref",
                      ref: "lex:app.bsky.actor.defs#preferences"
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyActorSearchActors: {
          lexicon: 1,
          id: "app.bsky.actor.searchActors",
          defs: {
            main: {
              type: "query",
              description: "Find actors (profiles) matching search criteria. Does not require auth.",
              parameters: {
                type: "params",
                properties: {
                  term: {
                    type: "string",
                    description: "DEPRECATED: use 'q' instead."
                  },
                  q: {
                    type: "string",
                    description: "Search query string. Syntax, phrase, boolean, and faceting is unspecified, but Lucene query syntax is recommended."
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 25
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["actors"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    actors: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.actor.defs#profileView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyActorSearchActorsTypeahead: {
          lexicon: 1,
          id: "app.bsky.actor.searchActorsTypeahead",
          defs: {
            main: {
              type: "query",
              description: "Find actor suggestions for a prefix search term. Expected use is for auto-completion during text field entry. Does not require auth.",
              parameters: {
                type: "params",
                properties: {
                  term: {
                    type: "string",
                    description: "DEPRECATED: use 'q' instead."
                  },
                  q: {
                    type: "string",
                    description: "Search query prefix; not a full query string."
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 10
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["actors"],
                  properties: {
                    actors: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.actor.defs#profileViewBasic"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyEmbedDefs: {
          lexicon: 1,
          id: "app.bsky.embed.defs",
          defs: {
            aspectRatio: {
              type: "object",
              description: "width:height represents an aspect ratio. It may be approximate, and may not correspond to absolute dimensions in any given unit.",
              required: ["width", "height"],
              properties: {
                width: {
                  type: "integer",
                  minimum: 1
                },
                height: {
                  type: "integer",
                  minimum: 1
                }
              }
            }
          }
        },
        AppBskyEmbedExternal: {
          lexicon: 1,
          id: "app.bsky.embed.external",
          defs: {
            main: {
              type: "object",
              description: "A representation of some externally linked content (eg, a URL and 'card'), embedded in a Bluesky record (eg, a post).",
              required: ["external"],
              properties: {
                external: {
                  type: "ref",
                  ref: "lex:app.bsky.embed.external#external"
                }
              }
            },
            external: {
              type: "object",
              required: ["uri", "title", "description"],
              properties: {
                uri: {
                  type: "string",
                  format: "uri"
                },
                title: {
                  type: "string"
                },
                description: {
                  type: "string"
                },
                thumb: {
                  type: "blob",
                  accept: ["image/*"],
                  maxSize: 1e6
                }
              }
            },
            view: {
              type: "object",
              required: ["external"],
              properties: {
                external: {
                  type: "ref",
                  ref: "lex:app.bsky.embed.external#viewExternal"
                }
              }
            },
            viewExternal: {
              type: "object",
              required: ["uri", "title", "description"],
              properties: {
                uri: {
                  type: "string",
                  format: "uri"
                },
                title: {
                  type: "string"
                },
                description: {
                  type: "string"
                },
                thumb: {
                  type: "string",
                  format: "uri"
                }
              }
            }
          }
        },
        AppBskyEmbedImages: {
          lexicon: 1,
          id: "app.bsky.embed.images",
          description: "A set of images embedded in a Bluesky record (eg, a post).",
          defs: {
            main: {
              type: "object",
              required: ["images"],
              properties: {
                images: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.embed.images#image"
                  },
                  maxLength: 4
                }
              }
            },
            image: {
              type: "object",
              required: ["image", "alt"],
              properties: {
                image: {
                  type: "blob",
                  accept: ["image/*"],
                  maxSize: 1e6
                },
                alt: {
                  type: "string",
                  description: "Alt text description of the image, for accessibility."
                },
                aspectRatio: {
                  type: "ref",
                  ref: "lex:app.bsky.embed.defs#aspectRatio"
                }
              }
            },
            view: {
              type: "object",
              required: ["images"],
              properties: {
                images: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.embed.images#viewImage"
                  },
                  maxLength: 4
                }
              }
            },
            viewImage: {
              type: "object",
              required: ["thumb", "fullsize", "alt"],
              properties: {
                thumb: {
                  type: "string",
                  format: "uri",
                  description: "Fully-qualified URL where a thumbnail of the image can be fetched. For example, CDN location provided by the App View."
                },
                fullsize: {
                  type: "string",
                  format: "uri",
                  description: "Fully-qualified URL where a large version of the image can be fetched. May or may not be the exact original blob. For example, CDN location provided by the App View."
                },
                alt: {
                  type: "string",
                  description: "Alt text description of the image, for accessibility."
                },
                aspectRatio: {
                  type: "ref",
                  ref: "lex:app.bsky.embed.defs#aspectRatio"
                }
              }
            }
          }
        },
        AppBskyEmbedRecord: {
          lexicon: 1,
          id: "app.bsky.embed.record",
          description: "A representation of a record embedded in a Bluesky record (eg, a post). For example, a quote-post, or sharing a feed generator record.",
          defs: {
            main: {
              type: "object",
              required: ["record"],
              properties: {
                record: {
                  type: "ref",
                  ref: "lex:com.atproto.repo.strongRef"
                }
              }
            },
            view: {
              type: "object",
              required: ["record"],
              properties: {
                record: {
                  type: "union",
                  refs: [
                    "lex:app.bsky.embed.record#viewRecord",
                    "lex:app.bsky.embed.record#viewNotFound",
                    "lex:app.bsky.embed.record#viewBlocked",
                    "lex:app.bsky.embed.record#viewDetached",
                    "lex:app.bsky.feed.defs#generatorView",
                    "lex:app.bsky.graph.defs#listView",
                    "lex:app.bsky.labeler.defs#labelerView",
                    "lex:app.bsky.graph.defs#starterPackViewBasic"
                  ]
                }
              }
            },
            viewRecord: {
              type: "object",
              required: ["uri", "cid", "author", "value", "indexedAt"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                cid: {
                  type: "string",
                  format: "cid"
                },
                author: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#profileViewBasic"
                },
                value: {
                  type: "unknown",
                  description: "The record data itself."
                },
                labels: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.label.defs#label"
                  }
                },
                replyCount: {
                  type: "integer"
                },
                repostCount: {
                  type: "integer"
                },
                likeCount: {
                  type: "integer"
                },
                quoteCount: {
                  type: "integer"
                },
                embeds: {
                  type: "array",
                  items: {
                    type: "union",
                    refs: [
                      "lex:app.bsky.embed.images#view",
                      "lex:app.bsky.embed.video#view",
                      "lex:app.bsky.embed.external#view",
                      "lex:app.bsky.embed.record#view",
                      "lex:app.bsky.embed.recordWithMedia#view"
                    ]
                  }
                },
                indexedAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            },
            viewNotFound: {
              type: "object",
              required: ["uri", "notFound"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                notFound: {
                  type: "boolean",
                  const: true
                }
              }
            },
            viewBlocked: {
              type: "object",
              required: ["uri", "blocked", "author"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                blocked: {
                  type: "boolean",
                  const: true
                },
                author: {
                  type: "ref",
                  ref: "lex:app.bsky.feed.defs#blockedAuthor"
                }
              }
            },
            viewDetached: {
              type: "object",
              required: ["uri", "detached"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                detached: {
                  type: "boolean",
                  const: true
                }
              }
            }
          }
        },
        AppBskyEmbedRecordWithMedia: {
          lexicon: 1,
          id: "app.bsky.embed.recordWithMedia",
          description: "A representation of a record embedded in a Bluesky record (eg, a post), alongside other compatible embeds. For example, a quote post and image, or a quote post and external URL card.",
          defs: {
            main: {
              type: "object",
              required: ["record", "media"],
              properties: {
                record: {
                  type: "ref",
                  ref: "lex:app.bsky.embed.record"
                },
                media: {
                  type: "union",
                  refs: [
                    "lex:app.bsky.embed.images",
                    "lex:app.bsky.embed.video",
                    "lex:app.bsky.embed.external"
                  ]
                }
              }
            },
            view: {
              type: "object",
              required: ["record", "media"],
              properties: {
                record: {
                  type: "ref",
                  ref: "lex:app.bsky.embed.record#view"
                },
                media: {
                  type: "union",
                  refs: [
                    "lex:app.bsky.embed.images#view",
                    "lex:app.bsky.embed.video#view",
                    "lex:app.bsky.embed.external#view"
                  ]
                }
              }
            }
          }
        },
        AppBskyEmbedVideo: {
          lexicon: 1,
          id: "app.bsky.embed.video",
          description: "A video embedded in a Bluesky record (eg, a post).",
          defs: {
            main: {
              type: "object",
              required: ["video"],
              properties: {
                video: {
                  type: "blob",
                  accept: ["video/mp4"],
                  maxSize: 5e7
                },
                captions: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.embed.video#caption"
                  },
                  maxLength: 20
                },
                alt: {
                  type: "string",
                  description: "Alt text description of the video, for accessibility.",
                  maxGraphemes: 1e3,
                  maxLength: 1e4
                },
                aspectRatio: {
                  type: "ref",
                  ref: "lex:app.bsky.embed.defs#aspectRatio"
                }
              }
            },
            caption: {
              type: "object",
              required: ["lang", "file"],
              properties: {
                lang: {
                  type: "string",
                  format: "language"
                },
                file: {
                  type: "blob",
                  accept: ["text/vtt"],
                  maxSize: 2e4
                }
              }
            },
            view: {
              type: "object",
              required: ["cid", "playlist"],
              properties: {
                cid: {
                  type: "string",
                  format: "cid"
                },
                playlist: {
                  type: "string",
                  format: "uri"
                },
                thumbnail: {
                  type: "string",
                  format: "uri"
                },
                alt: {
                  type: "string",
                  maxGraphemes: 1e3,
                  maxLength: 1e4
                },
                aspectRatio: {
                  type: "ref",
                  ref: "lex:app.bsky.embed.defs#aspectRatio"
                }
              }
            }
          }
        },
        AppBskyFeedDefs: {
          lexicon: 1,
          id: "app.bsky.feed.defs",
          defs: {
            postView: {
              type: "object",
              required: ["uri", "cid", "author", "record", "indexedAt"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                cid: {
                  type: "string",
                  format: "cid"
                },
                author: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#profileViewBasic"
                },
                record: {
                  type: "unknown"
                },
                embed: {
                  type: "union",
                  refs: [
                    "lex:app.bsky.embed.images#view",
                    "lex:app.bsky.embed.video#view",
                    "lex:app.bsky.embed.external#view",
                    "lex:app.bsky.embed.record#view",
                    "lex:app.bsky.embed.recordWithMedia#view"
                  ]
                },
                replyCount: {
                  type: "integer"
                },
                repostCount: {
                  type: "integer"
                },
                likeCount: {
                  type: "integer"
                },
                quoteCount: {
                  type: "integer"
                },
                indexedAt: {
                  type: "string",
                  format: "datetime"
                },
                viewer: {
                  type: "ref",
                  ref: "lex:app.bsky.feed.defs#viewerState"
                },
                labels: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.label.defs#label"
                  }
                },
                threadgate: {
                  type: "ref",
                  ref: "lex:app.bsky.feed.defs#threadgateView"
                }
              }
            },
            viewerState: {
              type: "object",
              description: "Metadata about the requesting account's relationship with the subject content. Only has meaningful content for authed requests.",
              properties: {
                repost: {
                  type: "string",
                  format: "at-uri"
                },
                like: {
                  type: "string",
                  format: "at-uri"
                },
                threadMuted: {
                  type: "boolean"
                },
                replyDisabled: {
                  type: "boolean"
                },
                embeddingDisabled: {
                  type: "boolean"
                },
                pinned: {
                  type: "boolean"
                }
              }
            },
            threadContext: {
              type: "object",
              description: "Metadata about this post within the context of the thread it is in.",
              properties: {
                rootAuthorLike: {
                  type: "string",
                  format: "at-uri"
                }
              }
            },
            feedViewPost: {
              type: "object",
              required: ["post"],
              properties: {
                post: {
                  type: "ref",
                  ref: "lex:app.bsky.feed.defs#postView"
                },
                reply: {
                  type: "ref",
                  ref: "lex:app.bsky.feed.defs#replyRef"
                },
                reason: {
                  type: "union",
                  refs: [
                    "lex:app.bsky.feed.defs#reasonRepost",
                    "lex:app.bsky.feed.defs#reasonPin"
                  ]
                },
                feedContext: {
                  type: "string",
                  description: "Context provided by feed generator that may be passed back alongside interactions.",
                  maxLength: 2e3
                }
              }
            },
            replyRef: {
              type: "object",
              required: ["root", "parent"],
              properties: {
                root: {
                  type: "union",
                  refs: [
                    "lex:app.bsky.feed.defs#postView",
                    "lex:app.bsky.feed.defs#notFoundPost",
                    "lex:app.bsky.feed.defs#blockedPost"
                  ]
                },
                parent: {
                  type: "union",
                  refs: [
                    "lex:app.bsky.feed.defs#postView",
                    "lex:app.bsky.feed.defs#notFoundPost",
                    "lex:app.bsky.feed.defs#blockedPost"
                  ]
                },
                grandparentAuthor: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#profileViewBasic",
                  description: "When parent is a reply to another post, this is the author of that post."
                }
              }
            },
            reasonRepost: {
              type: "object",
              required: ["by", "indexedAt"],
              properties: {
                by: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#profileViewBasic"
                },
                indexedAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            },
            reasonPin: {
              type: "object",
              properties: {}
            },
            threadViewPost: {
              type: "object",
              required: ["post"],
              properties: {
                post: {
                  type: "ref",
                  ref: "lex:app.bsky.feed.defs#postView"
                },
                parent: {
                  type: "union",
                  refs: [
                    "lex:app.bsky.feed.defs#threadViewPost",
                    "lex:app.bsky.feed.defs#notFoundPost",
                    "lex:app.bsky.feed.defs#blockedPost"
                  ]
                },
                replies: {
                  type: "array",
                  items: {
                    type: "union",
                    refs: [
                      "lex:app.bsky.feed.defs#threadViewPost",
                      "lex:app.bsky.feed.defs#notFoundPost",
                      "lex:app.bsky.feed.defs#blockedPost"
                    ]
                  }
                },
                threadContext: {
                  type: "ref",
                  ref: "lex:app.bsky.feed.defs#threadContext"
                }
              }
            },
            notFoundPost: {
              type: "object",
              required: ["uri", "notFound"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                notFound: {
                  type: "boolean",
                  const: true
                }
              }
            },
            blockedPost: {
              type: "object",
              required: ["uri", "blocked", "author"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                blocked: {
                  type: "boolean",
                  const: true
                },
                author: {
                  type: "ref",
                  ref: "lex:app.bsky.feed.defs#blockedAuthor"
                }
              }
            },
            blockedAuthor: {
              type: "object",
              required: ["did"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                },
                viewer: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#viewerState"
                }
              }
            },
            generatorView: {
              type: "object",
              required: ["uri", "cid", "did", "creator", "displayName", "indexedAt"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                cid: {
                  type: "string",
                  format: "cid"
                },
                did: {
                  type: "string",
                  format: "did"
                },
                creator: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#profileView"
                },
                displayName: {
                  type: "string"
                },
                description: {
                  type: "string",
                  maxGraphemes: 300,
                  maxLength: 3e3
                },
                descriptionFacets: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.richtext.facet"
                  }
                },
                avatar: {
                  type: "string",
                  format: "uri"
                },
                likeCount: {
                  type: "integer",
                  minimum: 0
                },
                acceptsInteractions: {
                  type: "boolean"
                },
                labels: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.label.defs#label"
                  }
                },
                viewer: {
                  type: "ref",
                  ref: "lex:app.bsky.feed.defs#generatorViewerState"
                },
                contentMode: {
                  type: "string",
                  knownValues: [
                    "app.bsky.feed.defs#contentModeUnspecified",
                    "app.bsky.feed.defs#contentModeVideo"
                  ]
                },
                indexedAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            },
            generatorViewerState: {
              type: "object",
              properties: {
                like: {
                  type: "string",
                  format: "at-uri"
                }
              }
            },
            skeletonFeedPost: {
              type: "object",
              required: ["post"],
              properties: {
                post: {
                  type: "string",
                  format: "at-uri"
                },
                reason: {
                  type: "union",
                  refs: [
                    "lex:app.bsky.feed.defs#skeletonReasonRepost",
                    "lex:app.bsky.feed.defs#skeletonReasonPin"
                  ]
                },
                feedContext: {
                  type: "string",
                  description: "Context that will be passed through to client and may be passed to feed generator back alongside interactions.",
                  maxLength: 2e3
                }
              }
            },
            skeletonReasonRepost: {
              type: "object",
              required: ["repost"],
              properties: {
                repost: {
                  type: "string",
                  format: "at-uri"
                }
              }
            },
            skeletonReasonPin: {
              type: "object",
              properties: {}
            },
            threadgateView: {
              type: "object",
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                cid: {
                  type: "string",
                  format: "cid"
                },
                record: {
                  type: "unknown"
                },
                lists: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.graph.defs#listViewBasic"
                  }
                }
              }
            },
            interaction: {
              type: "object",
              properties: {
                item: {
                  type: "string",
                  format: "at-uri"
                },
                event: {
                  type: "string",
                  knownValues: [
                    "app.bsky.feed.defs#requestLess",
                    "app.bsky.feed.defs#requestMore",
                    "app.bsky.feed.defs#clickthroughItem",
                    "app.bsky.feed.defs#clickthroughAuthor",
                    "app.bsky.feed.defs#clickthroughReposter",
                    "app.bsky.feed.defs#clickthroughEmbed",
                    "app.bsky.feed.defs#interactionSeen",
                    "app.bsky.feed.defs#interactionLike",
                    "app.bsky.feed.defs#interactionRepost",
                    "app.bsky.feed.defs#interactionReply",
                    "app.bsky.feed.defs#interactionQuote",
                    "app.bsky.feed.defs#interactionShare"
                  ]
                },
                feedContext: {
                  type: "string",
                  description: "Context on a feed item that was originally supplied by the feed generator on getFeedSkeleton.",
                  maxLength: 2e3
                }
              }
            },
            requestLess: {
              type: "token",
              description: "Request that less content like the given feed item be shown in the feed"
            },
            requestMore: {
              type: "token",
              description: "Request that more content like the given feed item be shown in the feed"
            },
            clickthroughItem: {
              type: "token",
              description: "User clicked through to the feed item"
            },
            clickthroughAuthor: {
              type: "token",
              description: "User clicked through to the author of the feed item"
            },
            clickthroughReposter: {
              type: "token",
              description: "User clicked through to the reposter of the feed item"
            },
            clickthroughEmbed: {
              type: "token",
              description: "User clicked through to the embedded content of the feed item"
            },
            contentModeUnspecified: {
              type: "token",
              description: "Declares the feed generator returns any types of posts."
            },
            contentModeVideo: {
              type: "token",
              description: "Declares the feed generator returns posts containing app.bsky.embed.video embeds."
            },
            interactionSeen: {
              type: "token",
              description: "Feed item was seen by user"
            },
            interactionLike: {
              type: "token",
              description: "User liked the feed item"
            },
            interactionRepost: {
              type: "token",
              description: "User reposted the feed item"
            },
            interactionReply: {
              type: "token",
              description: "User replied to the feed item"
            },
            interactionQuote: {
              type: "token",
              description: "User quoted the feed item"
            },
            interactionShare: {
              type: "token",
              description: "User shared the feed item"
            }
          }
        },
        AppBskyFeedDescribeFeedGenerator: {
          lexicon: 1,
          id: "app.bsky.feed.describeFeedGenerator",
          defs: {
            main: {
              type: "query",
              description: "Get information about a feed generator, including policies and offered feed URIs. Does not require auth; implemented by Feed Generator services (not App View).",
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["did", "feeds"],
                  properties: {
                    did: {
                      type: "string",
                      format: "did"
                    },
                    feeds: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.feed.describeFeedGenerator#feed"
                      }
                    },
                    links: {
                      type: "ref",
                      ref: "lex:app.bsky.feed.describeFeedGenerator#links"
                    }
                  }
                }
              }
            },
            feed: {
              type: "object",
              required: ["uri"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                }
              }
            },
            links: {
              type: "object",
              properties: {
                privacyPolicy: {
                  type: "string"
                },
                termsOfService: {
                  type: "string"
                }
              }
            }
          }
        },
        AppBskyFeedGenerator: {
          lexicon: 1,
          id: "app.bsky.feed.generator",
          defs: {
            main: {
              type: "record",
              description: "Record declaring of the existence of a feed generator, and containing metadata about it. The record can exist in any repository.",
              key: "any",
              record: {
                type: "object",
                required: ["did", "displayName", "createdAt"],
                properties: {
                  did: {
                    type: "string",
                    format: "did"
                  },
                  displayName: {
                    type: "string",
                    maxGraphemes: 24,
                    maxLength: 240
                  },
                  description: {
                    type: "string",
                    maxGraphemes: 300,
                    maxLength: 3e3
                  },
                  descriptionFacets: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.richtext.facet"
                    }
                  },
                  avatar: {
                    type: "blob",
                    accept: ["image/png", "image/jpeg"],
                    maxSize: 1e6
                  },
                  acceptsInteractions: {
                    type: "boolean",
                    description: "Declaration that a feed accepts feedback interactions from a client through app.bsky.feed.sendInteractions"
                  },
                  labels: {
                    type: "union",
                    description: "Self-label values",
                    refs: ["lex:com.atproto.label.defs#selfLabels"]
                  },
                  contentMode: {
                    type: "string",
                    knownValues: [
                      "app.bsky.feed.defs#contentModeUnspecified",
                      "app.bsky.feed.defs#contentModeVideo"
                    ]
                  },
                  createdAt: {
                    type: "string",
                    format: "datetime"
                  }
                }
              }
            }
          }
        },
        AppBskyFeedGetActorFeeds: {
          lexicon: 1,
          id: "app.bsky.feed.getActorFeeds",
          defs: {
            main: {
              type: "query",
              description: "Get a list of feeds (feed generator records) created by the actor (in the actor's repo).",
              parameters: {
                type: "params",
                required: ["actor"],
                properties: {
                  actor: {
                    type: "string",
                    format: "at-identifier"
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["feeds"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    feeds: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.feed.defs#generatorView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyFeedGetActorLikes: {
          lexicon: 1,
          id: "app.bsky.feed.getActorLikes",
          defs: {
            main: {
              type: "query",
              description: "Get a list of posts liked by an actor. Requires auth, actor must be the requesting account.",
              parameters: {
                type: "params",
                required: ["actor"],
                properties: {
                  actor: {
                    type: "string",
                    format: "at-identifier"
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["feed"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    feed: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.feed.defs#feedViewPost"
                      }
                    }
                  }
                }
              },
              errors: [
                {
                  name: "BlockedActor"
                },
                {
                  name: "BlockedByActor"
                }
              ]
            }
          }
        },
        AppBskyFeedGetAuthorFeed: {
          lexicon: 1,
          id: "app.bsky.feed.getAuthorFeed",
          defs: {
            main: {
              type: "query",
              description: "Get a view of an actor's 'author feed' (post and reposts by the author). Does not require auth.",
              parameters: {
                type: "params",
                required: ["actor"],
                properties: {
                  actor: {
                    type: "string",
                    format: "at-identifier"
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  },
                  filter: {
                    type: "string",
                    description: "Combinations of post/repost types to include in response.",
                    knownValues: [
                      "posts_with_replies",
                      "posts_no_replies",
                      "posts_with_media",
                      "posts_and_author_threads",
                      "posts_with_video"
                    ],
                    default: "posts_with_replies"
                  },
                  includePins: {
                    type: "boolean",
                    default: false
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["feed"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    feed: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.feed.defs#feedViewPost"
                      }
                    }
                  }
                }
              },
              errors: [
                {
                  name: "BlockedActor"
                },
                {
                  name: "BlockedByActor"
                }
              ]
            }
          }
        },
        AppBskyFeedGetFeed: {
          lexicon: 1,
          id: "app.bsky.feed.getFeed",
          defs: {
            main: {
              type: "query",
              description: "Get a hydrated feed from an actor's selected feed generator. Implemented by App View.",
              parameters: {
                type: "params",
                required: ["feed"],
                properties: {
                  feed: {
                    type: "string",
                    format: "at-uri"
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["feed"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    feed: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.feed.defs#feedViewPost"
                      }
                    }
                  }
                }
              },
              errors: [
                {
                  name: "UnknownFeed"
                }
              ]
            }
          }
        },
        AppBskyFeedGetFeedGenerator: {
          lexicon: 1,
          id: "app.bsky.feed.getFeedGenerator",
          defs: {
            main: {
              type: "query",
              description: "Get information about a feed generator. Implemented by AppView.",
              parameters: {
                type: "params",
                required: ["feed"],
                properties: {
                  feed: {
                    type: "string",
                    format: "at-uri",
                    description: "AT-URI of the feed generator record."
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["view", "isOnline", "isValid"],
                  properties: {
                    view: {
                      type: "ref",
                      ref: "lex:app.bsky.feed.defs#generatorView"
                    },
                    isOnline: {
                      type: "boolean",
                      description: "Indicates whether the feed generator service has been online recently, or else seems to be inactive."
                    },
                    isValid: {
                      type: "boolean",
                      description: "Indicates whether the feed generator service is compatible with the record declaration."
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyFeedGetFeedGenerators: {
          lexicon: 1,
          id: "app.bsky.feed.getFeedGenerators",
          defs: {
            main: {
              type: "query",
              description: "Get information about a list of feed generators.",
              parameters: {
                type: "params",
                required: ["feeds"],
                properties: {
                  feeds: {
                    type: "array",
                    items: {
                      type: "string",
                      format: "at-uri"
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["feeds"],
                  properties: {
                    feeds: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.feed.defs#generatorView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyFeedGetFeedSkeleton: {
          lexicon: 1,
          id: "app.bsky.feed.getFeedSkeleton",
          defs: {
            main: {
              type: "query",
              description: "Get a skeleton of a feed provided by a feed generator. Auth is optional, depending on provider requirements, and provides the DID of the requester. Implemented by Feed Generator Service.",
              parameters: {
                type: "params",
                required: ["feed"],
                properties: {
                  feed: {
                    type: "string",
                    format: "at-uri",
                    description: "Reference to feed generator record describing the specific feed being requested."
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["feed"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    feed: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.feed.defs#skeletonFeedPost"
                      }
                    }
                  }
                }
              },
              errors: [
                {
                  name: "UnknownFeed"
                }
              ]
            }
          }
        },
        AppBskyFeedGetLikes: {
          lexicon: 1,
          id: "app.bsky.feed.getLikes",
          defs: {
            main: {
              type: "query",
              description: "Get like records which reference a subject (by AT-URI and CID).",
              parameters: {
                type: "params",
                required: ["uri"],
                properties: {
                  uri: {
                    type: "string",
                    format: "at-uri",
                    description: "AT-URI of the subject (eg, a post record)."
                  },
                  cid: {
                    type: "string",
                    format: "cid",
                    description: "CID of the subject record (aka, specific version of record), to filter likes."
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["uri", "likes"],
                  properties: {
                    uri: {
                      type: "string",
                      format: "at-uri"
                    },
                    cid: {
                      type: "string",
                      format: "cid"
                    },
                    cursor: {
                      type: "string"
                    },
                    likes: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.feed.getLikes#like"
                      }
                    }
                  }
                }
              }
            },
            like: {
              type: "object",
              required: ["indexedAt", "createdAt", "actor"],
              properties: {
                indexedAt: {
                  type: "string",
                  format: "datetime"
                },
                createdAt: {
                  type: "string",
                  format: "datetime"
                },
                actor: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#profileView"
                }
              }
            }
          }
        },
        AppBskyFeedGetListFeed: {
          lexicon: 1,
          id: "app.bsky.feed.getListFeed",
          defs: {
            main: {
              type: "query",
              description: "Get a feed of recent posts from a list (posts and reposts from any actors on the list). Does not require auth.",
              parameters: {
                type: "params",
                required: ["list"],
                properties: {
                  list: {
                    type: "string",
                    format: "at-uri",
                    description: "Reference (AT-URI) to the list record."
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["feed"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    feed: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.feed.defs#feedViewPost"
                      }
                    }
                  }
                }
              },
              errors: [
                {
                  name: "UnknownList"
                }
              ]
            }
          }
        },
        AppBskyFeedGetPostThread: {
          lexicon: 1,
          id: "app.bsky.feed.getPostThread",
          defs: {
            main: {
              type: "query",
              description: "Get posts in a thread. Does not require auth, but additional metadata and filtering will be applied for authed requests.",
              parameters: {
                type: "params",
                required: ["uri"],
                properties: {
                  uri: {
                    type: "string",
                    format: "at-uri",
                    description: "Reference (AT-URI) to post record."
                  },
                  depth: {
                    type: "integer",
                    description: "How many levels of reply depth should be included in response.",
                    default: 6,
                    minimum: 0,
                    maximum: 1e3
                  },
                  parentHeight: {
                    type: "integer",
                    description: "How many levels of parent (and grandparent, etc) post to include.",
                    default: 80,
                    minimum: 0,
                    maximum: 1e3
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["thread"],
                  properties: {
                    thread: {
                      type: "union",
                      refs: [
                        "lex:app.bsky.feed.defs#threadViewPost",
                        "lex:app.bsky.feed.defs#notFoundPost",
                        "lex:app.bsky.feed.defs#blockedPost"
                      ]
                    },
                    threadgate: {
                      type: "ref",
                      ref: "lex:app.bsky.feed.defs#threadgateView"
                    }
                  }
                }
              },
              errors: [
                {
                  name: "NotFound"
                }
              ]
            }
          }
        },
        AppBskyFeedGetPosts: {
          lexicon: 1,
          id: "app.bsky.feed.getPosts",
          defs: {
            main: {
              type: "query",
              description: "Gets post views for a specified list of posts (by AT-URI). This is sometimes referred to as 'hydrating' a 'feed skeleton'.",
              parameters: {
                type: "params",
                required: ["uris"],
                properties: {
                  uris: {
                    type: "array",
                    description: "List of post AT-URIs to return hydrated views for.",
                    items: {
                      type: "string",
                      format: "at-uri"
                    },
                    maxLength: 25
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["posts"],
                  properties: {
                    posts: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.feed.defs#postView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyFeedGetQuotes: {
          lexicon: 1,
          id: "app.bsky.feed.getQuotes",
          defs: {
            main: {
              type: "query",
              description: "Get a list of quotes for a given post.",
              parameters: {
                type: "params",
                required: ["uri"],
                properties: {
                  uri: {
                    type: "string",
                    format: "at-uri",
                    description: "Reference (AT-URI) of post record"
                  },
                  cid: {
                    type: "string",
                    format: "cid",
                    description: "If supplied, filters to quotes of specific version (by CID) of the post record."
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["uri", "posts"],
                  properties: {
                    uri: {
                      type: "string",
                      format: "at-uri"
                    },
                    cid: {
                      type: "string",
                      format: "cid"
                    },
                    cursor: {
                      type: "string"
                    },
                    posts: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.feed.defs#postView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyFeedGetRepostedBy: {
          lexicon: 1,
          id: "app.bsky.feed.getRepostedBy",
          defs: {
            main: {
              type: "query",
              description: "Get a list of reposts for a given post.",
              parameters: {
                type: "params",
                required: ["uri"],
                properties: {
                  uri: {
                    type: "string",
                    format: "at-uri",
                    description: "Reference (AT-URI) of post record"
                  },
                  cid: {
                    type: "string",
                    format: "cid",
                    description: "If supplied, filters to reposts of specific version (by CID) of the post record."
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["uri", "repostedBy"],
                  properties: {
                    uri: {
                      type: "string",
                      format: "at-uri"
                    },
                    cid: {
                      type: "string",
                      format: "cid"
                    },
                    cursor: {
                      type: "string"
                    },
                    repostedBy: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.actor.defs#profileView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyFeedGetSuggestedFeeds: {
          lexicon: 1,
          id: "app.bsky.feed.getSuggestedFeeds",
          defs: {
            main: {
              type: "query",
              description: "Get a list of suggested feeds (feed generators) for the requesting account.",
              parameters: {
                type: "params",
                properties: {
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["feeds"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    feeds: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.feed.defs#generatorView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyFeedGetTimeline: {
          lexicon: 1,
          id: "app.bsky.feed.getTimeline",
          defs: {
            main: {
              type: "query",
              description: "Get a view of the requesting account's home timeline. This is expected to be some form of reverse-chronological feed.",
              parameters: {
                type: "params",
                properties: {
                  algorithm: {
                    type: "string",
                    description: "Variant 'algorithm' for timeline. Implementation-specific. NOTE: most feed flexibility has been moved to feed generator mechanism."
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["feed"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    feed: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.feed.defs#feedViewPost"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyFeedLike: {
          lexicon: 1,
          id: "app.bsky.feed.like",
          defs: {
            main: {
              type: "record",
              description: "Record declaring a 'like' of a piece of subject content.",
              key: "tid",
              record: {
                type: "object",
                required: ["subject", "createdAt"],
                properties: {
                  subject: {
                    type: "ref",
                    ref: "lex:com.atproto.repo.strongRef"
                  },
                  createdAt: {
                    type: "string",
                    format: "datetime"
                  }
                }
              }
            }
          }
        },
        AppBskyFeedPost: {
          lexicon: 1,
          id: "app.bsky.feed.post",
          defs: {
            main: {
              type: "record",
              description: "Record containing a Bluesky post.",
              key: "tid",
              record: {
                type: "object",
                required: ["text", "createdAt"],
                properties: {
                  text: {
                    type: "string",
                    maxLength: 3e3,
                    maxGraphemes: 300,
                    description: "The primary post content. May be an empty string, if there are embeds."
                  },
                  entities: {
                    type: "array",
                    description: "DEPRECATED: replaced by app.bsky.richtext.facet.",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.feed.post#entity"
                    }
                  },
                  facets: {
                    type: "array",
                    description: "Annotations of text (mentions, URLs, hashtags, etc)",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.richtext.facet"
                    }
                  },
                  reply: {
                    type: "ref",
                    ref: "lex:app.bsky.feed.post#replyRef"
                  },
                  embed: {
                    type: "union",
                    refs: [
                      "lex:app.bsky.embed.images",
                      "lex:app.bsky.embed.video",
                      "lex:app.bsky.embed.external",
                      "lex:app.bsky.embed.record",
                      "lex:app.bsky.embed.recordWithMedia"
                    ]
                  },
                  langs: {
                    type: "array",
                    description: "Indicates human language of post primary text content.",
                    maxLength: 3,
                    items: {
                      type: "string",
                      format: "language"
                    }
                  },
                  labels: {
                    type: "union",
                    description: "Self-label values for this post. Effectively content warnings.",
                    refs: ["lex:com.atproto.label.defs#selfLabels"]
                  },
                  tags: {
                    type: "array",
                    description: "Additional hashtags, in addition to any included in post text and facets.",
                    maxLength: 8,
                    items: {
                      type: "string",
                      maxLength: 640,
                      maxGraphemes: 64
                    }
                  },
                  createdAt: {
                    type: "string",
                    format: "datetime",
                    description: "Client-declared timestamp when this post was originally created."
                  }
                }
              }
            },
            replyRef: {
              type: "object",
              required: ["root", "parent"],
              properties: {
                root: {
                  type: "ref",
                  ref: "lex:com.atproto.repo.strongRef"
                },
                parent: {
                  type: "ref",
                  ref: "lex:com.atproto.repo.strongRef"
                }
              }
            },
            entity: {
              type: "object",
              description: "Deprecated: use facets instead.",
              required: ["index", "type", "value"],
              properties: {
                index: {
                  type: "ref",
                  ref: "lex:app.bsky.feed.post#textSlice"
                },
                type: {
                  type: "string",
                  description: "Expected values are 'mention' and 'link'."
                },
                value: {
                  type: "string"
                }
              }
            },
            textSlice: {
              type: "object",
              description: "Deprecated. Use app.bsky.richtext instead -- A text segment. Start is inclusive, end is exclusive. Indices are for utf16-encoded strings.",
              required: ["start", "end"],
              properties: {
                start: {
                  type: "integer",
                  minimum: 0
                },
                end: {
                  type: "integer",
                  minimum: 0
                }
              }
            }
          }
        },
        AppBskyFeedPostgate: {
          lexicon: 1,
          id: "app.bsky.feed.postgate",
          defs: {
            main: {
              type: "record",
              key: "tid",
              description: "Record defining interaction rules for a post. The record key (rkey) of the postgate record must match the record key of the post, and that record must be in the same repository.",
              record: {
                type: "object",
                required: ["post", "createdAt"],
                properties: {
                  createdAt: {
                    type: "string",
                    format: "datetime"
                  },
                  post: {
                    type: "string",
                    format: "at-uri",
                    description: "Reference (AT-URI) to the post record."
                  },
                  detachedEmbeddingUris: {
                    type: "array",
                    maxLength: 50,
                    items: {
                      type: "string",
                      format: "at-uri"
                    },
                    description: "List of AT-URIs embedding this post that the author has detached from."
                  },
                  embeddingRules: {
                    description: "List of rules defining who can embed this post. If value is an empty array or is undefined, no particular rules apply and anyone can embed.",
                    type: "array",
                    maxLength: 5,
                    items: {
                      type: "union",
                      refs: ["lex:app.bsky.feed.postgate#disableRule"]
                    }
                  }
                }
              }
            },
            disableRule: {
              type: "object",
              description: "Disables embedding of this post.",
              properties: {}
            }
          }
        },
        AppBskyFeedRepost: {
          lexicon: 1,
          id: "app.bsky.feed.repost",
          defs: {
            main: {
              description: "Record representing a 'repost' of an existing Bluesky post.",
              type: "record",
              key: "tid",
              record: {
                type: "object",
                required: ["subject", "createdAt"],
                properties: {
                  subject: {
                    type: "ref",
                    ref: "lex:com.atproto.repo.strongRef"
                  },
                  createdAt: {
                    type: "string",
                    format: "datetime"
                  }
                }
              }
            }
          }
        },
        AppBskyFeedSearchPosts: {
          lexicon: 1,
          id: "app.bsky.feed.searchPosts",
          defs: {
            main: {
              type: "query",
              description: "Find posts matching search criteria, returning views of those posts.",
              parameters: {
                type: "params",
                required: ["q"],
                properties: {
                  q: {
                    type: "string",
                    description: "Search query string; syntax, phrase, boolean, and faceting is unspecified, but Lucene query syntax is recommended."
                  },
                  sort: {
                    type: "string",
                    knownValues: ["top", "latest"],
                    default: "latest",
                    description: "Specifies the ranking order of results."
                  },
                  since: {
                    type: "string",
                    description: "Filter results for posts after the indicated datetime (inclusive). Expected to use 'sortAt' timestamp, which may not match 'createdAt'. Can be a datetime, or just an ISO date (YYYY-MM-DD)."
                  },
                  until: {
                    type: "string",
                    description: "Filter results for posts before the indicated datetime (not inclusive). Expected to use 'sortAt' timestamp, which may not match 'createdAt'. Can be a datetime, or just an ISO date (YYY-MM-DD)."
                  },
                  mentions: {
                    type: "string",
                    format: "at-identifier",
                    description: "Filter to posts which mention the given account. Handles are resolved to DID before query-time. Only matches rich-text facet mentions."
                  },
                  author: {
                    type: "string",
                    format: "at-identifier",
                    description: "Filter to posts by the given account. Handles are resolved to DID before query-time."
                  },
                  lang: {
                    type: "string",
                    format: "language",
                    description: "Filter to posts in the given language. Expected to be based on post language field, though server may override language detection."
                  },
                  domain: {
                    type: "string",
                    description: "Filter to posts with URLs (facet links or embeds) linking to the given domain (hostname). Server may apply hostname normalization."
                  },
                  url: {
                    type: "string",
                    format: "uri",
                    description: "Filter to posts with links (facet links or embeds) pointing to this URL. Server may apply URL normalization or fuzzy matching."
                  },
                  tag: {
                    type: "array",
                    items: {
                      type: "string",
                      maxLength: 640,
                      maxGraphemes: 64
                    },
                    description: "Filter to posts with the given tag (hashtag), based on rich-text facet or tag field. Do not include the hash (#) prefix. Multiple tags can be specified, with 'AND' matching."
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 25
                  },
                  cursor: {
                    type: "string",
                    description: "Optional pagination mechanism; may not necessarily allow scrolling through entire result set."
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["posts"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    hitsTotal: {
                      type: "integer",
                      description: "Count of search hits. Optional, may be rounded/truncated, and may not be possible to paginate through all hits."
                    },
                    posts: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.feed.defs#postView"
                      }
                    }
                  }
                }
              },
              errors: [
                {
                  name: "BadQueryString"
                }
              ]
            }
          }
        },
        AppBskyFeedSendInteractions: {
          lexicon: 1,
          id: "app.bsky.feed.sendInteractions",
          defs: {
            main: {
              type: "procedure",
              description: "Send information about interactions with feed items back to the feed generator that served them.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["interactions"],
                  properties: {
                    interactions: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.feed.defs#interaction"
                      }
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  properties: {}
                }
              }
            }
          }
        },
        AppBskyFeedThreadgate: {
          lexicon: 1,
          id: "app.bsky.feed.threadgate",
          defs: {
            main: {
              type: "record",
              key: "tid",
              description: "Record defining interaction gating rules for a thread (aka, reply controls). The record key (rkey) of the threadgate record must match the record key of the thread's root post, and that record must be in the same repository.",
              record: {
                type: "object",
                required: ["post", "createdAt"],
                properties: {
                  post: {
                    type: "string",
                    format: "at-uri",
                    description: "Reference (AT-URI) to the post record."
                  },
                  allow: {
                    description: "List of rules defining who can reply to this post. If value is an empty array, no one can reply. If value is undefined, anyone can reply.",
                    type: "array",
                    maxLength: 5,
                    items: {
                      type: "union",
                      refs: [
                        "lex:app.bsky.feed.threadgate#mentionRule",
                        "lex:app.bsky.feed.threadgate#followerRule",
                        "lex:app.bsky.feed.threadgate#followingRule",
                        "lex:app.bsky.feed.threadgate#listRule"
                      ]
                    }
                  },
                  createdAt: {
                    type: "string",
                    format: "datetime"
                  },
                  hiddenReplies: {
                    type: "array",
                    maxLength: 50,
                    items: {
                      type: "string",
                      format: "at-uri"
                    },
                    description: "List of hidden reply URIs."
                  }
                }
              }
            },
            mentionRule: {
              type: "object",
              description: "Allow replies from actors mentioned in your post.",
              properties: {}
            },
            followerRule: {
              type: "object",
              description: "Allow replies from actors who follow you.",
              properties: {}
            },
            followingRule: {
              type: "object",
              description: "Allow replies from actors you follow.",
              properties: {}
            },
            listRule: {
              type: "object",
              description: "Allow replies from actors on a list.",
              required: ["list"],
              properties: {
                list: {
                  type: "string",
                  format: "at-uri"
                }
              }
            }
          }
        },
        AppBskyGraphBlock: {
          lexicon: 1,
          id: "app.bsky.graph.block",
          defs: {
            main: {
              type: "record",
              description: "Record declaring a 'block' relationship against another account. NOTE: blocks are public in Bluesky; see blog posts for details.",
              key: "tid",
              record: {
                type: "object",
                required: ["subject", "createdAt"],
                properties: {
                  subject: {
                    type: "string",
                    format: "did",
                    description: "DID of the account to be blocked."
                  },
                  createdAt: {
                    type: "string",
                    format: "datetime"
                  }
                }
              }
            }
          }
        },
        AppBskyGraphDefs: {
          lexicon: 1,
          id: "app.bsky.graph.defs",
          defs: {
            listViewBasic: {
              type: "object",
              required: ["uri", "cid", "name", "purpose"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                cid: {
                  type: "string",
                  format: "cid"
                },
                name: {
                  type: "string",
                  maxLength: 64,
                  minLength: 1
                },
                purpose: {
                  type: "ref",
                  ref: "lex:app.bsky.graph.defs#listPurpose"
                },
                avatar: {
                  type: "string",
                  format: "uri"
                },
                listItemCount: {
                  type: "integer",
                  minimum: 0
                },
                labels: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.label.defs#label"
                  }
                },
                viewer: {
                  type: "ref",
                  ref: "lex:app.bsky.graph.defs#listViewerState"
                },
                indexedAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            },
            listView: {
              type: "object",
              required: ["uri", "cid", "creator", "name", "purpose", "indexedAt"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                cid: {
                  type: "string",
                  format: "cid"
                },
                creator: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#profileView"
                },
                name: {
                  type: "string",
                  maxLength: 64,
                  minLength: 1
                },
                purpose: {
                  type: "ref",
                  ref: "lex:app.bsky.graph.defs#listPurpose"
                },
                description: {
                  type: "string",
                  maxGraphemes: 300,
                  maxLength: 3e3
                },
                descriptionFacets: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.richtext.facet"
                  }
                },
                avatar: {
                  type: "string",
                  format: "uri"
                },
                listItemCount: {
                  type: "integer",
                  minimum: 0
                },
                labels: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.label.defs#label"
                  }
                },
                viewer: {
                  type: "ref",
                  ref: "lex:app.bsky.graph.defs#listViewerState"
                },
                indexedAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            },
            listItemView: {
              type: "object",
              required: ["uri", "subject"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                subject: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#profileView"
                }
              }
            },
            starterPackView: {
              type: "object",
              required: ["uri", "cid", "record", "creator", "indexedAt"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                cid: {
                  type: "string",
                  format: "cid"
                },
                record: {
                  type: "unknown"
                },
                creator: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#profileViewBasic"
                },
                list: {
                  type: "ref",
                  ref: "lex:app.bsky.graph.defs#listViewBasic"
                },
                listItemsSample: {
                  type: "array",
                  maxLength: 12,
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.graph.defs#listItemView"
                  }
                },
                feeds: {
                  type: "array",
                  maxLength: 3,
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.feed.defs#generatorView"
                  }
                },
                joinedWeekCount: {
                  type: "integer",
                  minimum: 0
                },
                joinedAllTimeCount: {
                  type: "integer",
                  minimum: 0
                },
                labels: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.label.defs#label"
                  }
                },
                indexedAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            },
            starterPackViewBasic: {
              type: "object",
              required: ["uri", "cid", "record", "creator", "indexedAt"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                cid: {
                  type: "string",
                  format: "cid"
                },
                record: {
                  type: "unknown"
                },
                creator: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#profileViewBasic"
                },
                listItemCount: {
                  type: "integer",
                  minimum: 0
                },
                joinedWeekCount: {
                  type: "integer",
                  minimum: 0
                },
                joinedAllTimeCount: {
                  type: "integer",
                  minimum: 0
                },
                labels: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.label.defs#label"
                  }
                },
                indexedAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            },
            listPurpose: {
              type: "string",
              knownValues: [
                "app.bsky.graph.defs#modlist",
                "app.bsky.graph.defs#curatelist",
                "app.bsky.graph.defs#referencelist"
              ]
            },
            modlist: {
              type: "token",
              description: "A list of actors to apply an aggregate moderation action (mute/block) on."
            },
            curatelist: {
              type: "token",
              description: "A list of actors used for curation purposes such as list feeds or interaction gating."
            },
            referencelist: {
              type: "token",
              description: "A list of actors used for only for reference purposes such as within a starter pack."
            },
            listViewerState: {
              type: "object",
              properties: {
                muted: {
                  type: "boolean"
                },
                blocked: {
                  type: "string",
                  format: "at-uri"
                }
              }
            },
            notFoundActor: {
              type: "object",
              description: "indicates that a handle or DID could not be resolved",
              required: ["actor", "notFound"],
              properties: {
                actor: {
                  type: "string",
                  format: "at-identifier"
                },
                notFound: {
                  type: "boolean",
                  const: true
                }
              }
            },
            relationship: {
              type: "object",
              description: "lists the bi-directional graph relationships between one actor (not indicated in the object), and the target actors (the DID included in the object)",
              required: ["did"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                },
                following: {
                  type: "string",
                  format: "at-uri",
                  description: "if the actor follows this DID, this is the AT-URI of the follow record"
                },
                followedBy: {
                  type: "string",
                  format: "at-uri",
                  description: "if the actor is followed by this DID, contains the AT-URI of the follow record"
                }
              }
            }
          }
        },
        AppBskyGraphFollow: {
          lexicon: 1,
          id: "app.bsky.graph.follow",
          defs: {
            main: {
              type: "record",
              description: "Record declaring a social 'follow' relationship of another account. Duplicate follows will be ignored by the AppView.",
              key: "tid",
              record: {
                type: "object",
                required: ["subject", "createdAt"],
                properties: {
                  subject: {
                    type: "string",
                    format: "did"
                  },
                  createdAt: {
                    type: "string",
                    format: "datetime"
                  }
                }
              }
            }
          }
        },
        AppBskyGraphGetActorStarterPacks: {
          lexicon: 1,
          id: "app.bsky.graph.getActorStarterPacks",
          defs: {
            main: {
              type: "query",
              description: "Get a list of starter packs created by the actor.",
              parameters: {
                type: "params",
                required: ["actor"],
                properties: {
                  actor: {
                    type: "string",
                    format: "at-identifier"
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["starterPacks"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    starterPacks: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.graph.defs#starterPackViewBasic"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyGraphGetBlocks: {
          lexicon: 1,
          id: "app.bsky.graph.getBlocks",
          defs: {
            main: {
              type: "query",
              description: "Enumerates which accounts the requesting account is currently blocking. Requires auth.",
              parameters: {
                type: "params",
                properties: {
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["blocks"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    blocks: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.actor.defs#profileView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyGraphGetFollowers: {
          lexicon: 1,
          id: "app.bsky.graph.getFollowers",
          defs: {
            main: {
              type: "query",
              description: "Enumerates accounts which follow a specified account (actor).",
              parameters: {
                type: "params",
                required: ["actor"],
                properties: {
                  actor: {
                    type: "string",
                    format: "at-identifier"
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["subject", "followers"],
                  properties: {
                    subject: {
                      type: "ref",
                      ref: "lex:app.bsky.actor.defs#profileView"
                    },
                    cursor: {
                      type: "string"
                    },
                    followers: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.actor.defs#profileView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyGraphGetFollows: {
          lexicon: 1,
          id: "app.bsky.graph.getFollows",
          defs: {
            main: {
              type: "query",
              description: "Enumerates accounts which a specified account (actor) follows.",
              parameters: {
                type: "params",
                required: ["actor"],
                properties: {
                  actor: {
                    type: "string",
                    format: "at-identifier"
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["subject", "follows"],
                  properties: {
                    subject: {
                      type: "ref",
                      ref: "lex:app.bsky.actor.defs#profileView"
                    },
                    cursor: {
                      type: "string"
                    },
                    follows: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.actor.defs#profileView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyGraphGetKnownFollowers: {
          lexicon: 1,
          id: "app.bsky.graph.getKnownFollowers",
          defs: {
            main: {
              type: "query",
              description: "Enumerates accounts which follow a specified account (actor) and are followed by the viewer.",
              parameters: {
                type: "params",
                required: ["actor"],
                properties: {
                  actor: {
                    type: "string",
                    format: "at-identifier"
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["subject", "followers"],
                  properties: {
                    subject: {
                      type: "ref",
                      ref: "lex:app.bsky.actor.defs#profileView"
                    },
                    cursor: {
                      type: "string"
                    },
                    followers: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.actor.defs#profileView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyGraphGetList: {
          lexicon: 1,
          id: "app.bsky.graph.getList",
          defs: {
            main: {
              type: "query",
              description: "Gets a 'view' (with additional context) of a specified list.",
              parameters: {
                type: "params",
                required: ["list"],
                properties: {
                  list: {
                    type: "string",
                    format: "at-uri",
                    description: "Reference (AT-URI) of the list record to hydrate."
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["list", "items"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    list: {
                      type: "ref",
                      ref: "lex:app.bsky.graph.defs#listView"
                    },
                    items: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.graph.defs#listItemView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyGraphGetListBlocks: {
          lexicon: 1,
          id: "app.bsky.graph.getListBlocks",
          defs: {
            main: {
              type: "query",
              description: "Get mod lists that the requesting account (actor) is blocking. Requires auth.",
              parameters: {
                type: "params",
                properties: {
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["lists"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    lists: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.graph.defs#listView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyGraphGetListMutes: {
          lexicon: 1,
          id: "app.bsky.graph.getListMutes",
          defs: {
            main: {
              type: "query",
              description: "Enumerates mod lists that the requesting account (actor) currently has muted. Requires auth.",
              parameters: {
                type: "params",
                properties: {
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["lists"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    lists: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.graph.defs#listView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyGraphGetLists: {
          lexicon: 1,
          id: "app.bsky.graph.getLists",
          defs: {
            main: {
              type: "query",
              description: "Enumerates the lists created by a specified account (actor).",
              parameters: {
                type: "params",
                required: ["actor"],
                properties: {
                  actor: {
                    type: "string",
                    format: "at-identifier",
                    description: "The account (actor) to enumerate lists from."
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["lists"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    lists: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.graph.defs#listView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyGraphGetMutes: {
          lexicon: 1,
          id: "app.bsky.graph.getMutes",
          defs: {
            main: {
              type: "query",
              description: "Enumerates accounts that the requesting account (actor) currently has muted. Requires auth.",
              parameters: {
                type: "params",
                properties: {
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["mutes"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    mutes: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.actor.defs#profileView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyGraphGetRelationships: {
          lexicon: 1,
          id: "app.bsky.graph.getRelationships",
          defs: {
            main: {
              type: "query",
              description: "Enumerates public relationships between one account, and a list of other accounts. Does not require auth.",
              parameters: {
                type: "params",
                required: ["actor"],
                properties: {
                  actor: {
                    type: "string",
                    format: "at-identifier",
                    description: "Primary account requesting relationships for."
                  },
                  others: {
                    type: "array",
                    description: "List of 'other' accounts to be related back to the primary.",
                    maxLength: 30,
                    items: {
                      type: "string",
                      format: "at-identifier"
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["relationships"],
                  properties: {
                    actor: {
                      type: "string",
                      format: "did"
                    },
                    relationships: {
                      type: "array",
                      items: {
                        type: "union",
                        refs: [
                          "lex:app.bsky.graph.defs#relationship",
                          "lex:app.bsky.graph.defs#notFoundActor"
                        ]
                      }
                    }
                  }
                }
              },
              errors: [
                {
                  name: "ActorNotFound",
                  description: "the primary actor at-identifier could not be resolved"
                }
              ]
            }
          }
        },
        AppBskyGraphGetStarterPack: {
          lexicon: 1,
          id: "app.bsky.graph.getStarterPack",
          defs: {
            main: {
              type: "query",
              description: "Gets a view of a starter pack.",
              parameters: {
                type: "params",
                required: ["starterPack"],
                properties: {
                  starterPack: {
                    type: "string",
                    format: "at-uri",
                    description: "Reference (AT-URI) of the starter pack record."
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["starterPack"],
                  properties: {
                    starterPack: {
                      type: "ref",
                      ref: "lex:app.bsky.graph.defs#starterPackView"
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyGraphGetStarterPacks: {
          lexicon: 1,
          id: "app.bsky.graph.getStarterPacks",
          defs: {
            main: {
              type: "query",
              description: "Get views for a list of starter packs.",
              parameters: {
                type: "params",
                required: ["uris"],
                properties: {
                  uris: {
                    type: "array",
                    items: {
                      type: "string",
                      format: "at-uri"
                    },
                    maxLength: 25
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["starterPacks"],
                  properties: {
                    starterPacks: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.graph.defs#starterPackViewBasic"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyGraphGetSuggestedFollowsByActor: {
          lexicon: 1,
          id: "app.bsky.graph.getSuggestedFollowsByActor",
          defs: {
            main: {
              type: "query",
              description: "Enumerates follows similar to a given account (actor). Expected use is to recommend additional accounts immediately after following one account.",
              parameters: {
                type: "params",
                required: ["actor"],
                properties: {
                  actor: {
                    type: "string",
                    format: "at-identifier"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["suggestions"],
                  properties: {
                    suggestions: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.actor.defs#profileView"
                      }
                    },
                    isFallback: {
                      type: "boolean",
                      description: "If true, response has fallen-back to generic results, and is not scoped using relativeToDid",
                      default: false
                    },
                    recId: {
                      type: "integer",
                      description: "Snowflake for this recommendation, use when submitting recommendation events."
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyGraphList: {
          lexicon: 1,
          id: "app.bsky.graph.list",
          defs: {
            main: {
              type: "record",
              description: "Record representing a list of accounts (actors). Scope includes both moderation-oriented lists and curration-oriented lists.",
              key: "tid",
              record: {
                type: "object",
                required: ["name", "purpose", "createdAt"],
                properties: {
                  purpose: {
                    type: "ref",
                    description: "Defines the purpose of the list (aka, moderation-oriented or curration-oriented)",
                    ref: "lex:app.bsky.graph.defs#listPurpose"
                  },
                  name: {
                    type: "string",
                    maxLength: 64,
                    minLength: 1,
                    description: "Display name for list; can not be empty."
                  },
                  description: {
                    type: "string",
                    maxGraphemes: 300,
                    maxLength: 3e3
                  },
                  descriptionFacets: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.richtext.facet"
                    }
                  },
                  avatar: {
                    type: "blob",
                    accept: ["image/png", "image/jpeg"],
                    maxSize: 1e6
                  },
                  labels: {
                    type: "union",
                    refs: ["lex:com.atproto.label.defs#selfLabels"]
                  },
                  createdAt: {
                    type: "string",
                    format: "datetime"
                  }
                }
              }
            }
          }
        },
        AppBskyGraphListblock: {
          lexicon: 1,
          id: "app.bsky.graph.listblock",
          defs: {
            main: {
              type: "record",
              description: "Record representing a block relationship against an entire an entire list of accounts (actors).",
              key: "tid",
              record: {
                type: "object",
                required: ["subject", "createdAt"],
                properties: {
                  subject: {
                    type: "string",
                    format: "at-uri",
                    description: "Reference (AT-URI) to the mod list record."
                  },
                  createdAt: {
                    type: "string",
                    format: "datetime"
                  }
                }
              }
            }
          }
        },
        AppBskyGraphListitem: {
          lexicon: 1,
          id: "app.bsky.graph.listitem",
          defs: {
            main: {
              type: "record",
              description: "Record representing an account's inclusion on a specific list. The AppView will ignore duplicate listitem records.",
              key: "tid",
              record: {
                type: "object",
                required: ["subject", "list", "createdAt"],
                properties: {
                  subject: {
                    type: "string",
                    format: "did",
                    description: "The account which is included on the list."
                  },
                  list: {
                    type: "string",
                    format: "at-uri",
                    description: "Reference (AT-URI) to the list record (app.bsky.graph.list)."
                  },
                  createdAt: {
                    type: "string",
                    format: "datetime"
                  }
                }
              }
            }
          }
        },
        AppBskyGraphMuteActor: {
          lexicon: 1,
          id: "app.bsky.graph.muteActor",
          defs: {
            main: {
              type: "procedure",
              description: "Creates a mute relationship for the specified account. Mutes are private in Bluesky. Requires auth.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["actor"],
                  properties: {
                    actor: {
                      type: "string",
                      format: "at-identifier"
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyGraphMuteActorList: {
          lexicon: 1,
          id: "app.bsky.graph.muteActorList",
          defs: {
            main: {
              type: "procedure",
              description: "Creates a mute relationship for the specified list of accounts. Mutes are private in Bluesky. Requires auth.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["list"],
                  properties: {
                    list: {
                      type: "string",
                      format: "at-uri"
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyGraphMuteThread: {
          lexicon: 1,
          id: "app.bsky.graph.muteThread",
          defs: {
            main: {
              type: "procedure",
              description: "Mutes a thread preventing notifications from the thread and any of its children. Mutes are private in Bluesky. Requires auth.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["root"],
                  properties: {
                    root: {
                      type: "string",
                      format: "at-uri"
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyGraphSearchStarterPacks: {
          lexicon: 1,
          id: "app.bsky.graph.searchStarterPacks",
          defs: {
            main: {
              type: "query",
              description: "Find starter packs matching search criteria. Does not require auth.",
              parameters: {
                type: "params",
                required: ["q"],
                properties: {
                  q: {
                    type: "string",
                    description: "Search query string. Syntax, phrase, boolean, and faceting is unspecified, but Lucene query syntax is recommended."
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 25
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["starterPacks"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    starterPacks: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.graph.defs#starterPackViewBasic"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyGraphStarterpack: {
          lexicon: 1,
          id: "app.bsky.graph.starterpack",
          defs: {
            main: {
              type: "record",
              description: "Record defining a starter pack of actors and feeds for new users.",
              key: "tid",
              record: {
                type: "object",
                required: ["name", "list", "createdAt"],
                properties: {
                  name: {
                    type: "string",
                    maxGraphemes: 50,
                    maxLength: 500,
                    minLength: 1,
                    description: "Display name for starter pack; can not be empty."
                  },
                  description: {
                    type: "string",
                    maxGraphemes: 300,
                    maxLength: 3e3
                  },
                  descriptionFacets: {
                    type: "array",
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.richtext.facet"
                    }
                  },
                  list: {
                    type: "string",
                    format: "at-uri",
                    description: "Reference (AT-URI) to the list record."
                  },
                  feeds: {
                    type: "array",
                    maxLength: 3,
                    items: {
                      type: "ref",
                      ref: "lex:app.bsky.graph.starterpack#feedItem"
                    }
                  },
                  createdAt: {
                    type: "string",
                    format: "datetime"
                  }
                }
              }
            },
            feedItem: {
              type: "object",
              required: ["uri"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                }
              }
            }
          }
        },
        AppBskyGraphUnmuteActor: {
          lexicon: 1,
          id: "app.bsky.graph.unmuteActor",
          defs: {
            main: {
              type: "procedure",
              description: "Unmutes the specified account. Requires auth.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["actor"],
                  properties: {
                    actor: {
                      type: "string",
                      format: "at-identifier"
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyGraphUnmuteActorList: {
          lexicon: 1,
          id: "app.bsky.graph.unmuteActorList",
          defs: {
            main: {
              type: "procedure",
              description: "Unmutes the specified list of accounts. Requires auth.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["list"],
                  properties: {
                    list: {
                      type: "string",
                      format: "at-uri"
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyGraphUnmuteThread: {
          lexicon: 1,
          id: "app.bsky.graph.unmuteThread",
          defs: {
            main: {
              type: "procedure",
              description: "Unmutes the specified thread. Requires auth.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["root"],
                  properties: {
                    root: {
                      type: "string",
                      format: "at-uri"
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyLabelerDefs: {
          lexicon: 1,
          id: "app.bsky.labeler.defs",
          defs: {
            labelerView: {
              type: "object",
              required: ["uri", "cid", "creator", "indexedAt"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                cid: {
                  type: "string",
                  format: "cid"
                },
                creator: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#profileView"
                },
                likeCount: {
                  type: "integer",
                  minimum: 0
                },
                viewer: {
                  type: "ref",
                  ref: "lex:app.bsky.labeler.defs#labelerViewerState"
                },
                indexedAt: {
                  type: "string",
                  format: "datetime"
                },
                labels: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.label.defs#label"
                  }
                }
              }
            },
            labelerViewDetailed: {
              type: "object",
              required: ["uri", "cid", "creator", "policies", "indexedAt"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                cid: {
                  type: "string",
                  format: "cid"
                },
                creator: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#profileView"
                },
                policies: {
                  type: "ref",
                  ref: "lex:app.bsky.labeler.defs#labelerPolicies"
                },
                likeCount: {
                  type: "integer",
                  minimum: 0
                },
                viewer: {
                  type: "ref",
                  ref: "lex:app.bsky.labeler.defs#labelerViewerState"
                },
                indexedAt: {
                  type: "string",
                  format: "datetime"
                },
                labels: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.label.defs#label"
                  }
                }
              }
            },
            labelerViewerState: {
              type: "object",
              properties: {
                like: {
                  type: "string",
                  format: "at-uri"
                }
              }
            },
            labelerPolicies: {
              type: "object",
              required: ["labelValues"],
              properties: {
                labelValues: {
                  type: "array",
                  description: "The label values which this labeler publishes. May include global or custom labels.",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.label.defs#labelValue"
                  }
                },
                labelValueDefinitions: {
                  type: "array",
                  description: "Label values created by this labeler and scoped exclusively to it. Labels defined here will override global label definitions for this labeler.",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.label.defs#labelValueDefinition"
                  }
                }
              }
            }
          }
        },
        AppBskyLabelerGetServices: {
          lexicon: 1,
          id: "app.bsky.labeler.getServices",
          defs: {
            main: {
              type: "query",
              description: "Get information about a list of labeler services.",
              parameters: {
                type: "params",
                required: ["dids"],
                properties: {
                  dids: {
                    type: "array",
                    items: {
                      type: "string",
                      format: "did"
                    }
                  },
                  detailed: {
                    type: "boolean",
                    default: false
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["views"],
                  properties: {
                    views: {
                      type: "array",
                      items: {
                        type: "union",
                        refs: [
                          "lex:app.bsky.labeler.defs#labelerView",
                          "lex:app.bsky.labeler.defs#labelerViewDetailed"
                        ]
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyLabelerService: {
          lexicon: 1,
          id: "app.bsky.labeler.service",
          defs: {
            main: {
              type: "record",
              description: "A declaration of the existence of labeler service.",
              key: "literal:self",
              record: {
                type: "object",
                required: ["policies", "createdAt"],
                properties: {
                  policies: {
                    type: "ref",
                    ref: "lex:app.bsky.labeler.defs#labelerPolicies"
                  },
                  labels: {
                    type: "union",
                    refs: ["lex:com.atproto.label.defs#selfLabels"]
                  },
                  createdAt: {
                    type: "string",
                    format: "datetime"
                  }
                }
              }
            }
          }
        },
        AppBskyNotificationGetUnreadCount: {
          lexicon: 1,
          id: "app.bsky.notification.getUnreadCount",
          defs: {
            main: {
              type: "query",
              description: "Count the number of unread notifications for the requesting account. Requires auth.",
              parameters: {
                type: "params",
                properties: {
                  priority: {
                    type: "boolean"
                  },
                  seenAt: {
                    type: "string",
                    format: "datetime"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["count"],
                  properties: {
                    count: {
                      type: "integer"
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyNotificationListNotifications: {
          lexicon: 1,
          id: "app.bsky.notification.listNotifications",
          defs: {
            main: {
              type: "query",
              description: "Enumerate notifications for the requesting account. Requires auth.",
              parameters: {
                type: "params",
                properties: {
                  reasons: {
                    description: "Notification reasons to include in response.",
                    type: "array",
                    items: {
                      type: "string",
                      description: "A reason that matches the reason property of #notification."
                    }
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  priority: {
                    type: "boolean"
                  },
                  cursor: {
                    type: "string"
                  },
                  seenAt: {
                    type: "string",
                    format: "datetime"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["notifications"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    notifications: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.notification.listNotifications#notification"
                      }
                    },
                    priority: {
                      type: "boolean"
                    },
                    seenAt: {
                      type: "string",
                      format: "datetime"
                    }
                  }
                }
              }
            },
            notification: {
              type: "object",
              required: [
                "uri",
                "cid",
                "author",
                "reason",
                "record",
                "isRead",
                "indexedAt"
              ],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                cid: {
                  type: "string",
                  format: "cid"
                },
                author: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#profileView"
                },
                reason: {
                  type: "string",
                  description: "Expected values are 'like', 'repost', 'follow', 'mention', 'reply', 'quote', and 'starterpack-joined'.",
                  knownValues: [
                    "like",
                    "repost",
                    "follow",
                    "mention",
                    "reply",
                    "quote",
                    "starterpack-joined"
                  ]
                },
                reasonSubject: {
                  type: "string",
                  format: "at-uri"
                },
                record: {
                  type: "unknown"
                },
                isRead: {
                  type: "boolean"
                },
                indexedAt: {
                  type: "string",
                  format: "datetime"
                },
                labels: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.label.defs#label"
                  }
                }
              }
            }
          }
        },
        AppBskyNotificationPutPreferences: {
          lexicon: 1,
          id: "app.bsky.notification.putPreferences",
          defs: {
            main: {
              type: "procedure",
              description: "Set notification-related preferences for an account. Requires auth.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["priority"],
                  properties: {
                    priority: {
                      type: "boolean"
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyNotificationRegisterPush: {
          lexicon: 1,
          id: "app.bsky.notification.registerPush",
          defs: {
            main: {
              type: "procedure",
              description: "Register to receive push notifications, via a specified service, for the requesting account. Requires auth.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["serviceDid", "token", "platform", "appId"],
                  properties: {
                    serviceDid: {
                      type: "string",
                      format: "did"
                    },
                    token: {
                      type: "string"
                    },
                    platform: {
                      type: "string",
                      knownValues: ["ios", "android", "web"]
                    },
                    appId: {
                      type: "string"
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyNotificationUpdateSeen: {
          lexicon: 1,
          id: "app.bsky.notification.updateSeen",
          defs: {
            main: {
              type: "procedure",
              description: "Notify server that the requesting account has seen notifications. Requires auth.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["seenAt"],
                  properties: {
                    seenAt: {
                      type: "string",
                      format: "datetime"
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyRichtextFacet: {
          lexicon: 1,
          id: "app.bsky.richtext.facet",
          defs: {
            main: {
              type: "object",
              description: "Annotation of a sub-string within rich text.",
              required: ["index", "features"],
              properties: {
                index: {
                  type: "ref",
                  ref: "lex:app.bsky.richtext.facet#byteSlice"
                },
                features: {
                  type: "array",
                  items: {
                    type: "union",
                    refs: [
                      "lex:app.bsky.richtext.facet#mention",
                      "lex:app.bsky.richtext.facet#link",
                      "lex:app.bsky.richtext.facet#tag"
                    ]
                  }
                }
              }
            },
            mention: {
              type: "object",
              description: "Facet feature for mention of another account. The text is usually a handle, including a '@' prefix, but the facet reference is a DID.",
              required: ["did"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                }
              }
            },
            link: {
              type: "object",
              description: "Facet feature for a URL. The text URL may have been simplified or truncated, but the facet reference should be a complete URL.",
              required: ["uri"],
              properties: {
                uri: {
                  type: "string",
                  format: "uri"
                }
              }
            },
            tag: {
              type: "object",
              description: "Facet feature for a hashtag. The text usually includes a '#' prefix, but the facet reference should not (except in the case of 'double hash tags').",
              required: ["tag"],
              properties: {
                tag: {
                  type: "string",
                  maxLength: 640,
                  maxGraphemes: 64
                }
              }
            },
            byteSlice: {
              type: "object",
              description: "Specifies the sub-string range a facet feature applies to. Start index is inclusive, end index is exclusive. Indices are zero-indexed, counting bytes of the UTF-8 encoded text. NOTE: some languages, like Javascript, use UTF-16 or Unicode codepoints for string slice indexing; in these languages, convert to byte arrays before working with facets.",
              required: ["byteStart", "byteEnd"],
              properties: {
                byteStart: {
                  type: "integer",
                  minimum: 0
                },
                byteEnd: {
                  type: "integer",
                  minimum: 0
                }
              }
            }
          }
        },
        AppBskyUnspeccedDefs: {
          lexicon: 1,
          id: "app.bsky.unspecced.defs",
          defs: {
            skeletonSearchPost: {
              type: "object",
              required: ["uri"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                }
              }
            },
            skeletonSearchActor: {
              type: "object",
              required: ["did"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                }
              }
            },
            skeletonSearchStarterPack: {
              type: "object",
              required: ["uri"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                }
              }
            },
            trendingTopic: {
              type: "object",
              required: ["topic", "link"],
              properties: {
                topic: {
                  type: "string"
                },
                displayName: {
                  type: "string"
                },
                description: {
                  type: "string"
                },
                link: {
                  type: "string"
                }
              }
            }
          }
        },
        AppBskyUnspeccedGetConfig: {
          lexicon: 1,
          id: "app.bsky.unspecced.getConfig",
          defs: {
            main: {
              type: "query",
              description: "Get miscellaneous runtime configuration.",
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: [],
                  properties: {
                    checkEmailConfirmed: {
                      type: "boolean"
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyUnspeccedGetPopularFeedGenerators: {
          lexicon: 1,
          id: "app.bsky.unspecced.getPopularFeedGenerators",
          defs: {
            main: {
              type: "query",
              description: "An unspecced view of globally popular feed generators.",
              parameters: {
                type: "params",
                properties: {
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  },
                  query: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["feeds"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    feeds: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.feed.defs#generatorView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyUnspeccedGetSuggestionsSkeleton: {
          lexicon: 1,
          id: "app.bsky.unspecced.getSuggestionsSkeleton",
          defs: {
            main: {
              type: "query",
              description: "Get a skeleton of suggested actors. Intended to be called and then hydrated through app.bsky.actor.getSuggestions",
              parameters: {
                type: "params",
                properties: {
                  viewer: {
                    type: "string",
                    format: "did",
                    description: "DID of the account making the request (not included for public/unauthenticated queries). Used to boost followed accounts in ranking."
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  },
                  relativeToDid: {
                    type: "string",
                    format: "did",
                    description: "DID of the account to get suggestions relative to. If not provided, suggestions will be based on the viewer."
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["actors"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    actors: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.unspecced.defs#skeletonSearchActor"
                      }
                    },
                    relativeToDid: {
                      type: "string",
                      format: "did",
                      description: "DID of the account these suggestions are relative to. If this is returned undefined, suggestions are based on the viewer."
                    },
                    recId: {
                      type: "integer",
                      description: "Snowflake for this recommendation, use when submitting recommendation events."
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyUnspeccedGetTaggedSuggestions: {
          lexicon: 1,
          id: "app.bsky.unspecced.getTaggedSuggestions",
          defs: {
            main: {
              type: "query",
              description: "Get a list of suggestions (feeds and users) tagged with categories",
              parameters: {
                type: "params",
                properties: {}
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["suggestions"],
                  properties: {
                    suggestions: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.unspecced.getTaggedSuggestions#suggestion"
                      }
                    }
                  }
                }
              }
            },
            suggestion: {
              type: "object",
              required: ["tag", "subjectType", "subject"],
              properties: {
                tag: {
                  type: "string"
                },
                subjectType: {
                  type: "string",
                  knownValues: ["actor", "feed"]
                },
                subject: {
                  type: "string",
                  format: "uri"
                }
              }
            }
          }
        },
        AppBskyUnspeccedGetTrendingTopics: {
          lexicon: 1,
          id: "app.bsky.unspecced.getTrendingTopics",
          defs: {
            main: {
              type: "query",
              description: "Get a list of trending topics",
              parameters: {
                type: "params",
                properties: {
                  viewer: {
                    type: "string",
                    format: "did",
                    description: "DID of the account making the request (not included for public/unauthenticated queries). Used to boost followed accounts in ranking."
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 25,
                    default: 10
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["topics", "suggested"],
                  properties: {
                    topics: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.unspecced.defs#trendingTopic"
                      }
                    },
                    suggested: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.unspecced.defs#trendingTopic"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyUnspeccedSearchActorsSkeleton: {
          lexicon: 1,
          id: "app.bsky.unspecced.searchActorsSkeleton",
          defs: {
            main: {
              type: "query",
              description: "Backend Actors (profile) search, returns only skeleton.",
              parameters: {
                type: "params",
                required: ["q"],
                properties: {
                  q: {
                    type: "string",
                    description: "Search query string; syntax, phrase, boolean, and faceting is unspecified, but Lucene query syntax is recommended. For typeahead search, only simple term match is supported, not full syntax."
                  },
                  viewer: {
                    type: "string",
                    format: "did",
                    description: "DID of the account making the request (not included for public/unauthenticated queries). Used to boost followed accounts in ranking."
                  },
                  typeahead: {
                    type: "boolean",
                    description: "If true, acts as fast/simple 'typeahead' query."
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 25
                  },
                  cursor: {
                    type: "string",
                    description: "Optional pagination mechanism; may not necessarily allow scrolling through entire result set."
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["actors"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    hitsTotal: {
                      type: "integer",
                      description: "Count of search hits. Optional, may be rounded/truncated, and may not be possible to paginate through all hits."
                    },
                    actors: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.unspecced.defs#skeletonSearchActor"
                      }
                    }
                  }
                }
              },
              errors: [
                {
                  name: "BadQueryString"
                }
              ]
            }
          }
        },
        AppBskyUnspeccedSearchPostsSkeleton: {
          lexicon: 1,
          id: "app.bsky.unspecced.searchPostsSkeleton",
          defs: {
            main: {
              type: "query",
              description: "Backend Posts search, returns only skeleton",
              parameters: {
                type: "params",
                required: ["q"],
                properties: {
                  q: {
                    type: "string",
                    description: "Search query string; syntax, phrase, boolean, and faceting is unspecified, but Lucene query syntax is recommended."
                  },
                  sort: {
                    type: "string",
                    knownValues: ["top", "latest"],
                    default: "latest",
                    description: "Specifies the ranking order of results."
                  },
                  since: {
                    type: "string",
                    description: "Filter results for posts after the indicated datetime (inclusive). Expected to use 'sortAt' timestamp, which may not match 'createdAt'. Can be a datetime, or just an ISO date (YYYY-MM-DD)."
                  },
                  until: {
                    type: "string",
                    description: "Filter results for posts before the indicated datetime (not inclusive). Expected to use 'sortAt' timestamp, which may not match 'createdAt'. Can be a datetime, or just an ISO date (YYY-MM-DD)."
                  },
                  mentions: {
                    type: "string",
                    format: "at-identifier",
                    description: "Filter to posts which mention the given account. Handles are resolved to DID before query-time. Only matches rich-text facet mentions."
                  },
                  author: {
                    type: "string",
                    format: "at-identifier",
                    description: "Filter to posts by the given account. Handles are resolved to DID before query-time."
                  },
                  lang: {
                    type: "string",
                    format: "language",
                    description: "Filter to posts in the given language. Expected to be based on post language field, though server may override language detection."
                  },
                  domain: {
                    type: "string",
                    description: "Filter to posts with URLs (facet links or embeds) linking to the given domain (hostname). Server may apply hostname normalization."
                  },
                  url: {
                    type: "string",
                    format: "uri",
                    description: "Filter to posts with links (facet links or embeds) pointing to this URL. Server may apply URL normalization or fuzzy matching."
                  },
                  tag: {
                    type: "array",
                    items: {
                      type: "string",
                      maxLength: 640,
                      maxGraphemes: 64
                    },
                    description: "Filter to posts with the given tag (hashtag), based on rich-text facet or tag field. Do not include the hash (#) prefix. Multiple tags can be specified, with 'AND' matching."
                  },
                  viewer: {
                    type: "string",
                    format: "did",
                    description: "DID of the account making the request (not included for public/unauthenticated queries). Used for 'from:me' queries."
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 25
                  },
                  cursor: {
                    type: "string",
                    description: "Optional pagination mechanism; may not necessarily allow scrolling through entire result set."
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["posts"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    hitsTotal: {
                      type: "integer",
                      description: "Count of search hits. Optional, may be rounded/truncated, and may not be possible to paginate through all hits."
                    },
                    posts: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.unspecced.defs#skeletonSearchPost"
                      }
                    }
                  }
                }
              },
              errors: [
                {
                  name: "BadQueryString"
                }
              ]
            }
          }
        },
        AppBskyUnspeccedSearchStarterPacksSkeleton: {
          lexicon: 1,
          id: "app.bsky.unspecced.searchStarterPacksSkeleton",
          defs: {
            main: {
              type: "query",
              description: "Backend Starter Pack search, returns only skeleton.",
              parameters: {
                type: "params",
                required: ["q"],
                properties: {
                  q: {
                    type: "string",
                    description: "Search query string; syntax, phrase, boolean, and faceting is unspecified, but Lucene query syntax is recommended."
                  },
                  viewer: {
                    type: "string",
                    format: "did",
                    description: "DID of the account making the request (not included for public/unauthenticated queries)."
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 25
                  },
                  cursor: {
                    type: "string",
                    description: "Optional pagination mechanism; may not necessarily allow scrolling through entire result set."
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["starterPacks"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    hitsTotal: {
                      type: "integer",
                      description: "Count of search hits. Optional, may be rounded/truncated, and may not be possible to paginate through all hits."
                    },
                    starterPacks: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:app.bsky.unspecced.defs#skeletonSearchStarterPack"
                      }
                    }
                  }
                }
              },
              errors: [
                {
                  name: "BadQueryString"
                }
              ]
            }
          }
        },
        AppBskyVideoDefs: {
          lexicon: 1,
          id: "app.bsky.video.defs",
          defs: {
            jobStatus: {
              type: "object",
              required: ["jobId", "did", "state"],
              properties: {
                jobId: {
                  type: "string"
                },
                did: {
                  type: "string",
                  format: "did"
                },
                state: {
                  type: "string",
                  description: "The state of the video processing job. All values not listed as a known value indicate that the job is in process.",
                  knownValues: ["JOB_STATE_COMPLETED", "JOB_STATE_FAILED"]
                },
                progress: {
                  type: "integer",
                  minimum: 0,
                  maximum: 100,
                  description: "Progress within the current processing state."
                },
                blob: {
                  type: "blob"
                },
                error: {
                  type: "string"
                },
                message: {
                  type: "string"
                }
              }
            }
          }
        },
        AppBskyVideoGetJobStatus: {
          lexicon: 1,
          id: "app.bsky.video.getJobStatus",
          defs: {
            main: {
              type: "query",
              description: "Get status details for a video processing job.",
              parameters: {
                type: "params",
                required: ["jobId"],
                properties: {
                  jobId: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["jobStatus"],
                  properties: {
                    jobStatus: {
                      type: "ref",
                      ref: "lex:app.bsky.video.defs#jobStatus"
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyVideoGetUploadLimits: {
          lexicon: 1,
          id: "app.bsky.video.getUploadLimits",
          defs: {
            main: {
              type: "query",
              description: "Get video upload limits for the authenticated user.",
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["canUpload"],
                  properties: {
                    canUpload: {
                      type: "boolean"
                    },
                    remainingDailyVideos: {
                      type: "integer"
                    },
                    remainingDailyBytes: {
                      type: "integer"
                    },
                    message: {
                      type: "string"
                    },
                    error: {
                      type: "string"
                    }
                  }
                }
              }
            }
          }
        },
        AppBskyVideoUploadVideo: {
          lexicon: 1,
          id: "app.bsky.video.uploadVideo",
          defs: {
            main: {
              type: "procedure",
              description: "Upload a video to be processed then stored on the PDS.",
              input: {
                encoding: "video/mp4"
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["jobStatus"],
                  properties: {
                    jobStatus: {
                      type: "ref",
                      ref: "lex:app.bsky.video.defs#jobStatus"
                    }
                  }
                }
              }
            }
          }
        },
        ChatBskyActorDeclaration: {
          lexicon: 1,
          id: "chat.bsky.actor.declaration",
          defs: {
            main: {
              type: "record",
              description: "A declaration of a Bluesky chat account.",
              key: "literal:self",
              record: {
                type: "object",
                required: ["allowIncoming"],
                properties: {
                  allowIncoming: {
                    type: "string",
                    knownValues: ["all", "none", "following"]
                  }
                }
              }
            }
          }
        },
        ChatBskyActorDefs: {
          lexicon: 1,
          id: "chat.bsky.actor.defs",
          defs: {
            profileViewBasic: {
              type: "object",
              required: ["did", "handle"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                },
                handle: {
                  type: "string",
                  format: "handle"
                },
                displayName: {
                  type: "string",
                  maxGraphemes: 64,
                  maxLength: 640
                },
                avatar: {
                  type: "string",
                  format: "uri"
                },
                associated: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#profileAssociated"
                },
                viewer: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#viewerState"
                },
                labels: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.label.defs#label"
                  }
                },
                chatDisabled: {
                  type: "boolean",
                  description: "Set to true when the actor cannot actively participate in converations"
                }
              }
            }
          }
        },
        ChatBskyActorDeleteAccount: {
          lexicon: 1,
          id: "chat.bsky.actor.deleteAccount",
          defs: {
            main: {
              type: "procedure",
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  properties: {}
                }
              }
            }
          }
        },
        ChatBskyActorExportAccountData: {
          lexicon: 1,
          id: "chat.bsky.actor.exportAccountData",
          defs: {
            main: {
              type: "query",
              output: {
                encoding: "application/jsonl"
              }
            }
          }
        },
        ChatBskyConvoDefs: {
          lexicon: 1,
          id: "chat.bsky.convo.defs",
          defs: {
            messageRef: {
              type: "object",
              required: ["did", "messageId", "convoId"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                },
                convoId: {
                  type: "string"
                },
                messageId: {
                  type: "string"
                }
              }
            },
            messageInput: {
              type: "object",
              required: ["text"],
              properties: {
                text: {
                  type: "string",
                  maxLength: 1e4,
                  maxGraphemes: 1e3
                },
                facets: {
                  type: "array",
                  description: "Annotations of text (mentions, URLs, hashtags, etc)",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.richtext.facet"
                  }
                },
                embed: {
                  type: "union",
                  refs: ["lex:app.bsky.embed.record"]
                }
              }
            },
            messageView: {
              type: "object",
              required: ["id", "rev", "text", "sender", "sentAt"],
              properties: {
                id: {
                  type: "string"
                },
                rev: {
                  type: "string"
                },
                text: {
                  type: "string",
                  maxLength: 1e4,
                  maxGraphemes: 1e3
                },
                facets: {
                  type: "array",
                  description: "Annotations of text (mentions, URLs, hashtags, etc)",
                  items: {
                    type: "ref",
                    ref: "lex:app.bsky.richtext.facet"
                  }
                },
                embed: {
                  type: "union",
                  refs: ["lex:app.bsky.embed.record#view"]
                },
                sender: {
                  type: "ref",
                  ref: "lex:chat.bsky.convo.defs#messageViewSender"
                },
                sentAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            },
            deletedMessageView: {
              type: "object",
              required: ["id", "rev", "sender", "sentAt"],
              properties: {
                id: {
                  type: "string"
                },
                rev: {
                  type: "string"
                },
                sender: {
                  type: "ref",
                  ref: "lex:chat.bsky.convo.defs#messageViewSender"
                },
                sentAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            },
            messageViewSender: {
              type: "object",
              required: ["did"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                }
              }
            },
            convoView: {
              type: "object",
              required: ["id", "rev", "members", "muted", "unreadCount"],
              properties: {
                id: {
                  type: "string"
                },
                rev: {
                  type: "string"
                },
                members: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:chat.bsky.actor.defs#profileViewBasic"
                  }
                },
                lastMessage: {
                  type: "union",
                  refs: [
                    "lex:chat.bsky.convo.defs#messageView",
                    "lex:chat.bsky.convo.defs#deletedMessageView"
                  ]
                },
                muted: {
                  type: "boolean"
                },
                opened: {
                  type: "boolean"
                },
                unreadCount: {
                  type: "integer"
                }
              }
            },
            logBeginConvo: {
              type: "object",
              required: ["rev", "convoId"],
              properties: {
                rev: {
                  type: "string"
                },
                convoId: {
                  type: "string"
                }
              }
            },
            logLeaveConvo: {
              type: "object",
              required: ["rev", "convoId"],
              properties: {
                rev: {
                  type: "string"
                },
                convoId: {
                  type: "string"
                }
              }
            },
            logCreateMessage: {
              type: "object",
              required: ["rev", "convoId", "message"],
              properties: {
                rev: {
                  type: "string"
                },
                convoId: {
                  type: "string"
                },
                message: {
                  type: "union",
                  refs: [
                    "lex:chat.bsky.convo.defs#messageView",
                    "lex:chat.bsky.convo.defs#deletedMessageView"
                  ]
                }
              }
            },
            logDeleteMessage: {
              type: "object",
              required: ["rev", "convoId", "message"],
              properties: {
                rev: {
                  type: "string"
                },
                convoId: {
                  type: "string"
                },
                message: {
                  type: "union",
                  refs: [
                    "lex:chat.bsky.convo.defs#messageView",
                    "lex:chat.bsky.convo.defs#deletedMessageView"
                  ]
                }
              }
            }
          }
        },
        ChatBskyConvoDeleteMessageForSelf: {
          lexicon: 1,
          id: "chat.bsky.convo.deleteMessageForSelf",
          defs: {
            main: {
              type: "procedure",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["convoId", "messageId"],
                  properties: {
                    convoId: {
                      type: "string"
                    },
                    messageId: {
                      type: "string"
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "ref",
                  ref: "lex:chat.bsky.convo.defs#deletedMessageView"
                }
              }
            }
          }
        },
        ChatBskyConvoGetConvo: {
          lexicon: 1,
          id: "chat.bsky.convo.getConvo",
          defs: {
            main: {
              type: "query",
              parameters: {
                type: "params",
                required: ["convoId"],
                properties: {
                  convoId: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["convo"],
                  properties: {
                    convo: {
                      type: "ref",
                      ref: "lex:chat.bsky.convo.defs#convoView"
                    }
                  }
                }
              }
            }
          }
        },
        ChatBskyConvoGetConvoForMembers: {
          lexicon: 1,
          id: "chat.bsky.convo.getConvoForMembers",
          defs: {
            main: {
              type: "query",
              parameters: {
                type: "params",
                required: ["members"],
                properties: {
                  members: {
                    type: "array",
                    minLength: 1,
                    maxLength: 10,
                    items: {
                      type: "string",
                      format: "did"
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["convo"],
                  properties: {
                    convo: {
                      type: "ref",
                      ref: "lex:chat.bsky.convo.defs#convoView"
                    }
                  }
                }
              }
            }
          }
        },
        ChatBskyConvoGetLog: {
          lexicon: 1,
          id: "chat.bsky.convo.getLog",
          defs: {
            main: {
              type: "query",
              parameters: {
                type: "params",
                required: [],
                properties: {
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["logs"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    logs: {
                      type: "array",
                      items: {
                        type: "union",
                        refs: [
                          "lex:chat.bsky.convo.defs#logBeginConvo",
                          "lex:chat.bsky.convo.defs#logLeaveConvo",
                          "lex:chat.bsky.convo.defs#logCreateMessage",
                          "lex:chat.bsky.convo.defs#logDeleteMessage"
                        ]
                      }
                    }
                  }
                }
              }
            }
          }
        },
        ChatBskyConvoGetMessages: {
          lexicon: 1,
          id: "chat.bsky.convo.getMessages",
          defs: {
            main: {
              type: "query",
              parameters: {
                type: "params",
                required: ["convoId"],
                properties: {
                  convoId: {
                    type: "string"
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["messages"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    messages: {
                      type: "array",
                      items: {
                        type: "union",
                        refs: [
                          "lex:chat.bsky.convo.defs#messageView",
                          "lex:chat.bsky.convo.defs#deletedMessageView"
                        ]
                      }
                    }
                  }
                }
              }
            }
          }
        },
        ChatBskyConvoLeaveConvo: {
          lexicon: 1,
          id: "chat.bsky.convo.leaveConvo",
          defs: {
            main: {
              type: "procedure",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["convoId"],
                  properties: {
                    convoId: {
                      type: "string"
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["convoId", "rev"],
                  properties: {
                    convoId: {
                      type: "string"
                    },
                    rev: {
                      type: "string"
                    }
                  }
                }
              }
            }
          }
        },
        ChatBskyConvoListConvos: {
          lexicon: 1,
          id: "chat.bsky.convo.listConvos",
          defs: {
            main: {
              type: "query",
              parameters: {
                type: "params",
                properties: {
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["convos"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    convos: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:chat.bsky.convo.defs#convoView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        ChatBskyConvoMuteConvo: {
          lexicon: 1,
          id: "chat.bsky.convo.muteConvo",
          defs: {
            main: {
              type: "procedure",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["convoId"],
                  properties: {
                    convoId: {
                      type: "string"
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["convo"],
                  properties: {
                    convo: {
                      type: "ref",
                      ref: "lex:chat.bsky.convo.defs#convoView"
                    }
                  }
                }
              }
            }
          }
        },
        ChatBskyConvoSendMessage: {
          lexicon: 1,
          id: "chat.bsky.convo.sendMessage",
          defs: {
            main: {
              type: "procedure",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["convoId", "message"],
                  properties: {
                    convoId: {
                      type: "string"
                    },
                    message: {
                      type: "ref",
                      ref: "lex:chat.bsky.convo.defs#messageInput"
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "ref",
                  ref: "lex:chat.bsky.convo.defs#messageView"
                }
              }
            }
          }
        },
        ChatBskyConvoSendMessageBatch: {
          lexicon: 1,
          id: "chat.bsky.convo.sendMessageBatch",
          defs: {
            main: {
              type: "procedure",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["items"],
                  properties: {
                    items: {
                      type: "array",
                      maxLength: 100,
                      items: {
                        type: "ref",
                        ref: "lex:chat.bsky.convo.sendMessageBatch#batchItem"
                      }
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["items"],
                  properties: {
                    items: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:chat.bsky.convo.defs#messageView"
                      }
                    }
                  }
                }
              }
            },
            batchItem: {
              type: "object",
              required: ["convoId", "message"],
              properties: {
                convoId: {
                  type: "string"
                },
                message: {
                  type: "ref",
                  ref: "lex:chat.bsky.convo.defs#messageInput"
                }
              }
            }
          }
        },
        ChatBskyConvoUnmuteConvo: {
          lexicon: 1,
          id: "chat.bsky.convo.unmuteConvo",
          defs: {
            main: {
              type: "procedure",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["convoId"],
                  properties: {
                    convoId: {
                      type: "string"
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["convo"],
                  properties: {
                    convo: {
                      type: "ref",
                      ref: "lex:chat.bsky.convo.defs#convoView"
                    }
                  }
                }
              }
            }
          }
        },
        ChatBskyConvoUpdateRead: {
          lexicon: 1,
          id: "chat.bsky.convo.updateRead",
          defs: {
            main: {
              type: "procedure",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["convoId"],
                  properties: {
                    convoId: {
                      type: "string"
                    },
                    messageId: {
                      type: "string"
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["convo"],
                  properties: {
                    convo: {
                      type: "ref",
                      ref: "lex:chat.bsky.convo.defs#convoView"
                    }
                  }
                }
              }
            }
          }
        },
        ChatBskyModerationGetActorMetadata: {
          lexicon: 1,
          id: "chat.bsky.moderation.getActorMetadata",
          defs: {
            main: {
              type: "query",
              parameters: {
                type: "params",
                required: ["actor"],
                properties: {
                  actor: {
                    type: "string",
                    format: "did"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["day", "month", "all"],
                  properties: {
                    day: {
                      type: "ref",
                      ref: "lex:chat.bsky.moderation.getActorMetadata#metadata"
                    },
                    month: {
                      type: "ref",
                      ref: "lex:chat.bsky.moderation.getActorMetadata#metadata"
                    },
                    all: {
                      type: "ref",
                      ref: "lex:chat.bsky.moderation.getActorMetadata#metadata"
                    }
                  }
                }
              }
            },
            metadata: {
              type: "object",
              required: [
                "messagesSent",
                "messagesReceived",
                "convos",
                "convosStarted"
              ],
              properties: {
                messagesSent: {
                  type: "integer"
                },
                messagesReceived: {
                  type: "integer"
                },
                convos: {
                  type: "integer"
                },
                convosStarted: {
                  type: "integer"
                }
              }
            }
          }
        },
        ChatBskyModerationGetMessageContext: {
          lexicon: 1,
          id: "chat.bsky.moderation.getMessageContext",
          defs: {
            main: {
              type: "query",
              parameters: {
                type: "params",
                required: ["messageId"],
                properties: {
                  convoId: {
                    type: "string",
                    description: "Conversation that the message is from. NOTE: this field will eventually be required."
                  },
                  messageId: {
                    type: "string"
                  },
                  before: {
                    type: "integer",
                    default: 5
                  },
                  after: {
                    type: "integer",
                    default: 5
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["messages"],
                  properties: {
                    messages: {
                      type: "array",
                      items: {
                        type: "union",
                        refs: [
                          "lex:chat.bsky.convo.defs#messageView",
                          "lex:chat.bsky.convo.defs#deletedMessageView"
                        ]
                      }
                    }
                  }
                }
              }
            }
          }
        },
        ChatBskyModerationUpdateActorAccess: {
          lexicon: 1,
          id: "chat.bsky.moderation.updateActorAccess",
          defs: {
            main: {
              type: "procedure",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["actor", "allowAccess"],
                  properties: {
                    actor: {
                      type: "string",
                      format: "did"
                    },
                    allowAccess: {
                      type: "boolean"
                    },
                    ref: {
                      type: "string"
                    }
                  }
                }
              }
            }
          }
        },
        ToolsOzoneCommunicationCreateTemplate: {
          lexicon: 1,
          id: "tools.ozone.communication.createTemplate",
          defs: {
            main: {
              type: "procedure",
              description: "Administrative action to create a new, re-usable communication (email for now) template.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["subject", "contentMarkdown", "name"],
                  properties: {
                    name: {
                      type: "string",
                      description: "Name of the template."
                    },
                    contentMarkdown: {
                      type: "string",
                      description: "Content of the template, markdown supported, can contain variable placeholders."
                    },
                    subject: {
                      type: "string",
                      description: "Subject of the message, used in emails."
                    },
                    lang: {
                      type: "string",
                      format: "language",
                      description: "Message language."
                    },
                    createdBy: {
                      type: "string",
                      format: "did",
                      description: "DID of the user who is creating the template."
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "ref",
                  ref: "lex:tools.ozone.communication.defs#templateView"
                }
              },
              errors: [
                {
                  name: "DuplicateTemplateName"
                }
              ]
            }
          }
        },
        ToolsOzoneCommunicationDefs: {
          lexicon: 1,
          id: "tools.ozone.communication.defs",
          defs: {
            templateView: {
              type: "object",
              required: [
                "id",
                "name",
                "contentMarkdown",
                "disabled",
                "lastUpdatedBy",
                "createdAt",
                "updatedAt"
              ],
              properties: {
                id: {
                  type: "string"
                },
                name: {
                  type: "string",
                  description: "Name of the template."
                },
                subject: {
                  type: "string",
                  description: "Content of the template, can contain markdown and variable placeholders."
                },
                contentMarkdown: {
                  type: "string",
                  description: "Subject of the message, used in emails."
                },
                disabled: {
                  type: "boolean"
                },
                lang: {
                  type: "string",
                  format: "language",
                  description: "Message language."
                },
                lastUpdatedBy: {
                  type: "string",
                  format: "did",
                  description: "DID of the user who last updated the template."
                },
                createdAt: {
                  type: "string",
                  format: "datetime"
                },
                updatedAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            }
          }
        },
        ToolsOzoneCommunicationDeleteTemplate: {
          lexicon: 1,
          id: "tools.ozone.communication.deleteTemplate",
          defs: {
            main: {
              type: "procedure",
              description: "Delete a communication template.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["id"],
                  properties: {
                    id: {
                      type: "string"
                    }
                  }
                }
              }
            }
          }
        },
        ToolsOzoneCommunicationListTemplates: {
          lexicon: 1,
          id: "tools.ozone.communication.listTemplates",
          defs: {
            main: {
              type: "query",
              description: "Get list of all communication templates.",
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["communicationTemplates"],
                  properties: {
                    communicationTemplates: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:tools.ozone.communication.defs#templateView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        ToolsOzoneCommunicationUpdateTemplate: {
          lexicon: 1,
          id: "tools.ozone.communication.updateTemplate",
          defs: {
            main: {
              type: "procedure",
              description: "Administrative action to update an existing communication template. Allows passing partial fields to patch specific fields only.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["id"],
                  properties: {
                    id: {
                      type: "string",
                      description: "ID of the template to be updated."
                    },
                    name: {
                      type: "string",
                      description: "Name of the template."
                    },
                    lang: {
                      type: "string",
                      format: "language",
                      description: "Message language."
                    },
                    contentMarkdown: {
                      type: "string",
                      description: "Content of the template, markdown supported, can contain variable placeholders."
                    },
                    subject: {
                      type: "string",
                      description: "Subject of the message, used in emails."
                    },
                    updatedBy: {
                      type: "string",
                      format: "did",
                      description: "DID of the user who is updating the template."
                    },
                    disabled: {
                      type: "boolean"
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "ref",
                  ref: "lex:tools.ozone.communication.defs#templateView"
                }
              },
              errors: [
                {
                  name: "DuplicateTemplateName"
                }
              ]
            }
          }
        },
        ToolsOzoneModerationDefs: {
          lexicon: 1,
          id: "tools.ozone.moderation.defs",
          defs: {
            modEventView: {
              type: "object",
              required: [
                "id",
                "event",
                "subject",
                "subjectBlobCids",
                "createdBy",
                "createdAt"
              ],
              properties: {
                id: {
                  type: "integer"
                },
                event: {
                  type: "union",
                  refs: [
                    "lex:tools.ozone.moderation.defs#modEventTakedown",
                    "lex:tools.ozone.moderation.defs#modEventReverseTakedown",
                    "lex:tools.ozone.moderation.defs#modEventComment",
                    "lex:tools.ozone.moderation.defs#modEventReport",
                    "lex:tools.ozone.moderation.defs#modEventLabel",
                    "lex:tools.ozone.moderation.defs#modEventAcknowledge",
                    "lex:tools.ozone.moderation.defs#modEventEscalate",
                    "lex:tools.ozone.moderation.defs#modEventMute",
                    "lex:tools.ozone.moderation.defs#modEventUnmute",
                    "lex:tools.ozone.moderation.defs#modEventMuteReporter",
                    "lex:tools.ozone.moderation.defs#modEventUnmuteReporter",
                    "lex:tools.ozone.moderation.defs#modEventEmail",
                    "lex:tools.ozone.moderation.defs#modEventResolveAppeal",
                    "lex:tools.ozone.moderation.defs#modEventDivert",
                    "lex:tools.ozone.moderation.defs#modEventTag",
                    "lex:tools.ozone.moderation.defs#accountEvent",
                    "lex:tools.ozone.moderation.defs#identityEvent",
                    "lex:tools.ozone.moderation.defs#recordEvent",
                    "lex:tools.ozone.moderation.defs#modEventPriorityScore"
                  ]
                },
                subject: {
                  type: "union",
                  refs: [
                    "lex:com.atproto.admin.defs#repoRef",
                    "lex:com.atproto.repo.strongRef",
                    "lex:chat.bsky.convo.defs#messageRef"
                  ]
                },
                subjectBlobCids: {
                  type: "array",
                  items: {
                    type: "string"
                  }
                },
                createdBy: {
                  type: "string",
                  format: "did"
                },
                createdAt: {
                  type: "string",
                  format: "datetime"
                },
                creatorHandle: {
                  type: "string"
                },
                subjectHandle: {
                  type: "string"
                }
              }
            },
            modEventViewDetail: {
              type: "object",
              required: [
                "id",
                "event",
                "subject",
                "subjectBlobs",
                "createdBy",
                "createdAt"
              ],
              properties: {
                id: {
                  type: "integer"
                },
                event: {
                  type: "union",
                  refs: [
                    "lex:tools.ozone.moderation.defs#modEventTakedown",
                    "lex:tools.ozone.moderation.defs#modEventReverseTakedown",
                    "lex:tools.ozone.moderation.defs#modEventComment",
                    "lex:tools.ozone.moderation.defs#modEventReport",
                    "lex:tools.ozone.moderation.defs#modEventLabel",
                    "lex:tools.ozone.moderation.defs#modEventAcknowledge",
                    "lex:tools.ozone.moderation.defs#modEventEscalate",
                    "lex:tools.ozone.moderation.defs#modEventMute",
                    "lex:tools.ozone.moderation.defs#modEventUnmute",
                    "lex:tools.ozone.moderation.defs#modEventMuteReporter",
                    "lex:tools.ozone.moderation.defs#modEventUnmuteReporter",
                    "lex:tools.ozone.moderation.defs#modEventEmail",
                    "lex:tools.ozone.moderation.defs#modEventResolveAppeal",
                    "lex:tools.ozone.moderation.defs#modEventDivert",
                    "lex:tools.ozone.moderation.defs#modEventTag",
                    "lex:tools.ozone.moderation.defs#accountEvent",
                    "lex:tools.ozone.moderation.defs#identityEvent",
                    "lex:tools.ozone.moderation.defs#recordEvent",
                    "lex:tools.ozone.moderation.defs#modEventPriorityScore"
                  ]
                },
                subject: {
                  type: "union",
                  refs: [
                    "lex:tools.ozone.moderation.defs#repoView",
                    "lex:tools.ozone.moderation.defs#repoViewNotFound",
                    "lex:tools.ozone.moderation.defs#recordView",
                    "lex:tools.ozone.moderation.defs#recordViewNotFound"
                  ]
                },
                subjectBlobs: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:tools.ozone.moderation.defs#blobView"
                  }
                },
                createdBy: {
                  type: "string",
                  format: "did"
                },
                createdAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            },
            subjectStatusView: {
              type: "object",
              required: ["id", "subject", "createdAt", "updatedAt", "reviewState"],
              properties: {
                id: {
                  type: "integer"
                },
                subject: {
                  type: "union",
                  refs: [
                    "lex:com.atproto.admin.defs#repoRef",
                    "lex:com.atproto.repo.strongRef"
                  ]
                },
                hosting: {
                  type: "union",
                  refs: [
                    "lex:tools.ozone.moderation.defs#accountHosting",
                    "lex:tools.ozone.moderation.defs#recordHosting"
                  ]
                },
                subjectBlobCids: {
                  type: "array",
                  items: {
                    type: "string",
                    format: "cid"
                  }
                },
                subjectRepoHandle: {
                  type: "string"
                },
                updatedAt: {
                  type: "string",
                  format: "datetime",
                  description: "Timestamp referencing when the last update was made to the moderation status of the subject"
                },
                createdAt: {
                  type: "string",
                  format: "datetime",
                  description: "Timestamp referencing the first moderation status impacting event was emitted on the subject"
                },
                reviewState: {
                  type: "ref",
                  ref: "lex:tools.ozone.moderation.defs#subjectReviewState"
                },
                comment: {
                  type: "string",
                  description: "Sticky comment on the subject."
                },
                priorityScore: {
                  type: "integer",
                  description: "Numeric value representing the level of priority. Higher score means higher priority.",
                  minimum: 0,
                  maximum: 100
                },
                muteUntil: {
                  type: "string",
                  format: "datetime"
                },
                muteReportingUntil: {
                  type: "string",
                  format: "datetime"
                },
                lastReviewedBy: {
                  type: "string",
                  format: "did"
                },
                lastReviewedAt: {
                  type: "string",
                  format: "datetime"
                },
                lastReportedAt: {
                  type: "string",
                  format: "datetime"
                },
                lastAppealedAt: {
                  type: "string",
                  format: "datetime",
                  description: "Timestamp referencing when the author of the subject appealed a moderation action"
                },
                takendown: {
                  type: "boolean"
                },
                appealed: {
                  type: "boolean",
                  description: "True indicates that the a previously taken moderator action was appealed against, by the author of the content. False indicates last appeal was resolved by moderators."
                },
                suspendUntil: {
                  type: "string",
                  format: "datetime"
                },
                tags: {
                  type: "array",
                  items: {
                    type: "string"
                  }
                },
                accountStats: {
                  description: "Statistics related to the account subject",
                  type: "ref",
                  ref: "lex:tools.ozone.moderation.defs#accountStats"
                },
                recordsStats: {
                  description: "Statistics related to the record subjects authored by the subject's account",
                  type: "ref",
                  ref: "lex:tools.ozone.moderation.defs#recordsStats"
                }
              }
            },
            accountStats: {
              description: "Statistics about a particular account subject",
              type: "object",
              properties: {
                reportCount: {
                  description: "Total number of reports on the account",
                  type: "integer"
                },
                appealCount: {
                  description: "Total number of appeals against a moderation action on the account",
                  type: "integer"
                },
                suspendCount: {
                  description: "Number of times the account was suspended",
                  type: "integer"
                },
                escalateCount: {
                  description: "Number of times the account was escalated",
                  type: "integer"
                },
                takedownCount: {
                  description: "Number of times the account was taken down",
                  type: "integer"
                }
              }
            },
            recordsStats: {
              description: "Statistics about a set of record subject items",
              type: "object",
              properties: {
                totalReports: {
                  description: "Cumulative sum of the number of reports on the items in the set",
                  type: "integer"
                },
                reportedCount: {
                  description: "Number of items that were reported at least once",
                  type: "integer"
                },
                escalatedCount: {
                  description: "Number of items that were escalated at least once",
                  type: "integer"
                },
                appealedCount: {
                  description: "Number of items that were appealed at least once",
                  type: "integer"
                },
                subjectCount: {
                  description: "Total number of item in the set",
                  type: "integer"
                },
                pendingCount: {
                  description: 'Number of item currently in "reviewOpen" or "reviewEscalated" state',
                  type: "integer"
                },
                processedCount: {
                  description: 'Number of item currently in "reviewNone" or "reviewClosed" state',
                  type: "integer"
                },
                takendownCount: {
                  description: "Number of item currently taken down",
                  type: "integer"
                }
              }
            },
            subjectReviewState: {
              type: "string",
              knownValues: [
                "lex:tools.ozone.moderation.defs#reviewOpen",
                "lex:tools.ozone.moderation.defs#reviewEscalated",
                "lex:tools.ozone.moderation.defs#reviewClosed",
                "lex:tools.ozone.moderation.defs#reviewNone"
              ]
            },
            reviewOpen: {
              type: "token",
              description: "Moderator review status of a subject: Open. Indicates that the subject needs to be reviewed by a moderator"
            },
            reviewEscalated: {
              type: "token",
              description: "Moderator review status of a subject: Escalated. Indicates that the subject was escalated for review by a moderator"
            },
            reviewClosed: {
              type: "token",
              description: "Moderator review status of a subject: Closed. Indicates that the subject was already reviewed and resolved by a moderator"
            },
            reviewNone: {
              type: "token",
              description: "Moderator review status of a subject: Unnecessary. Indicates that the subject does not need a review at the moment but there is probably some moderation related metadata available for it"
            },
            modEventTakedown: {
              type: "object",
              description: "Take down a subject permanently or temporarily",
              properties: {
                comment: {
                  type: "string"
                },
                durationInHours: {
                  type: "integer",
                  description: "Indicates how long the takedown should be in effect before automatically expiring."
                },
                acknowledgeAccountSubjects: {
                  type: "boolean",
                  description: "If true, all other reports on content authored by this account will be resolved (acknowledged)."
                },
                policies: {
                  type: "array",
                  maxLength: 5,
                  items: {
                    type: "string"
                  },
                  description: "Names/Keywords of the policies that drove the decision."
                }
              }
            },
            modEventReverseTakedown: {
              type: "object",
              description: "Revert take down action on a subject",
              properties: {
                comment: {
                  type: "string",
                  description: "Describe reasoning behind the reversal."
                }
              }
            },
            modEventResolveAppeal: {
              type: "object",
              description: "Resolve appeal on a subject",
              properties: {
                comment: {
                  type: "string",
                  description: "Describe resolution."
                }
              }
            },
            modEventComment: {
              type: "object",
              description: "Add a comment to a subject",
              required: ["comment"],
              properties: {
                comment: {
                  type: "string"
                },
                sticky: {
                  type: "boolean",
                  description: "Make the comment persistent on the subject"
                }
              }
            },
            modEventReport: {
              type: "object",
              description: "Report a subject",
              required: ["reportType"],
              properties: {
                comment: {
                  type: "string"
                },
                isReporterMuted: {
                  type: "boolean",
                  description: "Set to true if the reporter was muted from reporting at the time of the event. These reports won't impact the reviewState of the subject."
                },
                reportType: {
                  type: "ref",
                  ref: "lex:com.atproto.moderation.defs#reasonType"
                }
              }
            },
            modEventLabel: {
              type: "object",
              description: "Apply/Negate labels on a subject",
              required: ["createLabelVals", "negateLabelVals"],
              properties: {
                comment: {
                  type: "string"
                },
                createLabelVals: {
                  type: "array",
                  items: {
                    type: "string"
                  }
                },
                negateLabelVals: {
                  type: "array",
                  items: {
                    type: "string"
                  }
                },
                durationInHours: {
                  type: "integer",
                  description: "Indicates how long the label will remain on the subject. Only applies on labels that are being added."
                }
              }
            },
            modEventPriorityScore: {
              type: "object",
              description: "Set priority score of the subject. Higher score means higher priority.",
              required: ["score"],
              properties: {
                comment: {
                  type: "string"
                },
                score: {
                  type: "integer",
                  minimum: 0,
                  maximum: 100
                }
              }
            },
            modEventAcknowledge: {
              type: "object",
              properties: {
                comment: {
                  type: "string"
                },
                acknowledgeAccountSubjects: {
                  type: "boolean",
                  description: "If true, all other reports on content authored by this account will be resolved (acknowledged)."
                }
              }
            },
            modEventEscalate: {
              type: "object",
              properties: {
                comment: {
                  type: "string"
                }
              }
            },
            modEventMute: {
              type: "object",
              description: "Mute incoming reports on a subject",
              required: ["durationInHours"],
              properties: {
                comment: {
                  type: "string"
                },
                durationInHours: {
                  type: "integer",
                  description: "Indicates how long the subject should remain muted."
                }
              }
            },
            modEventUnmute: {
              type: "object",
              description: "Unmute action on a subject",
              properties: {
                comment: {
                  type: "string",
                  description: "Describe reasoning behind the reversal."
                }
              }
            },
            modEventMuteReporter: {
              type: "object",
              description: "Mute incoming reports from an account",
              properties: {
                comment: {
                  type: "string"
                },
                durationInHours: {
                  type: "integer",
                  description: "Indicates how long the account should remain muted. Falsy value here means a permanent mute."
                }
              }
            },
            modEventUnmuteReporter: {
              type: "object",
              description: "Unmute incoming reports from an account",
              properties: {
                comment: {
                  type: "string",
                  description: "Describe reasoning behind the reversal."
                }
              }
            },
            modEventEmail: {
              type: "object",
              description: "Keep a log of outgoing email to a user",
              required: ["subjectLine"],
              properties: {
                subjectLine: {
                  type: "string",
                  description: "The subject line of the email sent to the user."
                },
                content: {
                  type: "string",
                  description: "The content of the email sent to the user."
                },
                comment: {
                  type: "string",
                  description: "Additional comment about the outgoing comm."
                }
              }
            },
            modEventDivert: {
              type: "object",
              description: "Divert a record's blobs to a 3rd party service for further scanning/tagging",
              properties: {
                comment: {
                  type: "string"
                }
              }
            },
            modEventTag: {
              type: "object",
              description: "Add/Remove a tag on a subject",
              required: ["add", "remove"],
              properties: {
                add: {
                  type: "array",
                  items: {
                    type: "string"
                  },
                  description: "Tags to be added to the subject. If already exists, won't be duplicated."
                },
                remove: {
                  type: "array",
                  items: {
                    type: "string"
                  },
                  description: "Tags to be removed to the subject. Ignores a tag If it doesn't exist, won't be duplicated."
                },
                comment: {
                  type: "string",
                  description: "Additional comment about added/removed tags."
                }
              }
            },
            accountEvent: {
              type: "object",
              description: "Logs account status related events on a repo subject. Normally captured by automod from the firehose and emitted to ozone for historical tracking.",
              required: ["timestamp", "active"],
              properties: {
                comment: {
                  type: "string"
                },
                active: {
                  type: "boolean",
                  description: "Indicates that the account has a repository which can be fetched from the host that emitted this event."
                },
                status: {
                  type: "string",
                  knownValues: [
                    "unknown",
                    "deactivated",
                    "deleted",
                    "takendown",
                    "suspended",
                    "tombstoned"
                  ]
                },
                timestamp: {
                  type: "string",
                  format: "datetime"
                }
              }
            },
            identityEvent: {
              type: "object",
              description: "Logs identity related events on a repo subject. Normally captured by automod from the firehose and emitted to ozone for historical tracking.",
              required: ["timestamp"],
              properties: {
                comment: {
                  type: "string"
                },
                handle: {
                  type: "string",
                  format: "handle"
                },
                pdsHost: {
                  type: "string",
                  format: "uri"
                },
                tombstone: {
                  type: "boolean"
                },
                timestamp: {
                  type: "string",
                  format: "datetime"
                }
              }
            },
            recordEvent: {
              type: "object",
              description: "Logs lifecycle event on a record subject. Normally captured by automod from the firehose and emitted to ozone for historical tracking.",
              required: ["timestamp", "op"],
              properties: {
                comment: {
                  type: "string"
                },
                op: {
                  type: "string",
                  knownValues: ["create", "update", "delete"]
                },
                cid: {
                  type: "string",
                  format: "cid"
                },
                timestamp: {
                  type: "string",
                  format: "datetime"
                }
              }
            },
            repoView: {
              type: "object",
              required: [
                "did",
                "handle",
                "relatedRecords",
                "indexedAt",
                "moderation"
              ],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                },
                handle: {
                  type: "string",
                  format: "handle"
                },
                email: {
                  type: "string"
                },
                relatedRecords: {
                  type: "array",
                  items: {
                    type: "unknown"
                  }
                },
                indexedAt: {
                  type: "string",
                  format: "datetime"
                },
                moderation: {
                  type: "ref",
                  ref: "lex:tools.ozone.moderation.defs#moderation"
                },
                invitedBy: {
                  type: "ref",
                  ref: "lex:com.atproto.server.defs#inviteCode"
                },
                invitesDisabled: {
                  type: "boolean"
                },
                inviteNote: {
                  type: "string"
                },
                deactivatedAt: {
                  type: "string",
                  format: "datetime"
                },
                threatSignatures: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.admin.defs#threatSignature"
                  }
                }
              }
            },
            repoViewDetail: {
              type: "object",
              required: [
                "did",
                "handle",
                "relatedRecords",
                "indexedAt",
                "moderation"
              ],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                },
                handle: {
                  type: "string",
                  format: "handle"
                },
                email: {
                  type: "string"
                },
                relatedRecords: {
                  type: "array",
                  items: {
                    type: "unknown"
                  }
                },
                indexedAt: {
                  type: "string",
                  format: "datetime"
                },
                moderation: {
                  type: "ref",
                  ref: "lex:tools.ozone.moderation.defs#moderationDetail"
                },
                labels: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.label.defs#label"
                  }
                },
                invitedBy: {
                  type: "ref",
                  ref: "lex:com.atproto.server.defs#inviteCode"
                },
                invites: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.server.defs#inviteCode"
                  }
                },
                invitesDisabled: {
                  type: "boolean"
                },
                inviteNote: {
                  type: "string"
                },
                emailConfirmedAt: {
                  type: "string",
                  format: "datetime"
                },
                deactivatedAt: {
                  type: "string",
                  format: "datetime"
                },
                threatSignatures: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.admin.defs#threatSignature"
                  }
                }
              }
            },
            repoViewNotFound: {
              type: "object",
              required: ["did"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                }
              }
            },
            recordView: {
              type: "object",
              required: [
                "uri",
                "cid",
                "value",
                "blobCids",
                "indexedAt",
                "moderation",
                "repo"
              ],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                cid: {
                  type: "string",
                  format: "cid"
                },
                value: {
                  type: "unknown"
                },
                blobCids: {
                  type: "array",
                  items: {
                    type: "string",
                    format: "cid"
                  }
                },
                indexedAt: {
                  type: "string",
                  format: "datetime"
                },
                moderation: {
                  type: "ref",
                  ref: "lex:tools.ozone.moderation.defs#moderation"
                },
                repo: {
                  type: "ref",
                  ref: "lex:tools.ozone.moderation.defs#repoView"
                }
              }
            },
            recordViewDetail: {
              type: "object",
              required: [
                "uri",
                "cid",
                "value",
                "blobs",
                "indexedAt",
                "moderation",
                "repo"
              ],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                },
                cid: {
                  type: "string",
                  format: "cid"
                },
                value: {
                  type: "unknown"
                },
                blobs: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:tools.ozone.moderation.defs#blobView"
                  }
                },
                labels: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:com.atproto.label.defs#label"
                  }
                },
                indexedAt: {
                  type: "string",
                  format: "datetime"
                },
                moderation: {
                  type: "ref",
                  ref: "lex:tools.ozone.moderation.defs#moderationDetail"
                },
                repo: {
                  type: "ref",
                  ref: "lex:tools.ozone.moderation.defs#repoView"
                }
              }
            },
            recordViewNotFound: {
              type: "object",
              required: ["uri"],
              properties: {
                uri: {
                  type: "string",
                  format: "at-uri"
                }
              }
            },
            moderation: {
              type: "object",
              properties: {
                subjectStatus: {
                  type: "ref",
                  ref: "lex:tools.ozone.moderation.defs#subjectStatusView"
                }
              }
            },
            moderationDetail: {
              type: "object",
              properties: {
                subjectStatus: {
                  type: "ref",
                  ref: "lex:tools.ozone.moderation.defs#subjectStatusView"
                }
              }
            },
            blobView: {
              type: "object",
              required: ["cid", "mimeType", "size", "createdAt"],
              properties: {
                cid: {
                  type: "string",
                  format: "cid"
                },
                mimeType: {
                  type: "string"
                },
                size: {
                  type: "integer"
                },
                createdAt: {
                  type: "string",
                  format: "datetime"
                },
                details: {
                  type: "union",
                  refs: [
                    "lex:tools.ozone.moderation.defs#imageDetails",
                    "lex:tools.ozone.moderation.defs#videoDetails"
                  ]
                },
                moderation: {
                  type: "ref",
                  ref: "lex:tools.ozone.moderation.defs#moderation"
                }
              }
            },
            imageDetails: {
              type: "object",
              required: ["width", "height"],
              properties: {
                width: {
                  type: "integer"
                },
                height: {
                  type: "integer"
                }
              }
            },
            videoDetails: {
              type: "object",
              required: ["width", "height", "length"],
              properties: {
                width: {
                  type: "integer"
                },
                height: {
                  type: "integer"
                },
                length: {
                  type: "integer"
                }
              }
            },
            accountHosting: {
              type: "object",
              required: ["status"],
              properties: {
                status: {
                  type: "string",
                  knownValues: [
                    "takendown",
                    "suspended",
                    "deleted",
                    "deactivated",
                    "unknown"
                  ]
                },
                updatedAt: {
                  type: "string",
                  format: "datetime"
                },
                createdAt: {
                  type: "string",
                  format: "datetime"
                },
                deletedAt: {
                  type: "string",
                  format: "datetime"
                },
                deactivatedAt: {
                  type: "string",
                  format: "datetime"
                },
                reactivatedAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            },
            recordHosting: {
              type: "object",
              required: ["status"],
              properties: {
                status: {
                  type: "string",
                  knownValues: ["deleted", "unknown"]
                },
                updatedAt: {
                  type: "string",
                  format: "datetime"
                },
                createdAt: {
                  type: "string",
                  format: "datetime"
                },
                deletedAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            }
          }
        },
        ToolsOzoneModerationEmitEvent: {
          lexicon: 1,
          id: "tools.ozone.moderation.emitEvent",
          defs: {
            main: {
              type: "procedure",
              description: "Take a moderation action on an actor.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["event", "subject", "createdBy"],
                  properties: {
                    event: {
                      type: "union",
                      refs: [
                        "lex:tools.ozone.moderation.defs#modEventTakedown",
                        "lex:tools.ozone.moderation.defs#modEventAcknowledge",
                        "lex:tools.ozone.moderation.defs#modEventEscalate",
                        "lex:tools.ozone.moderation.defs#modEventComment",
                        "lex:tools.ozone.moderation.defs#modEventLabel",
                        "lex:tools.ozone.moderation.defs#modEventReport",
                        "lex:tools.ozone.moderation.defs#modEventMute",
                        "lex:tools.ozone.moderation.defs#modEventUnmute",
                        "lex:tools.ozone.moderation.defs#modEventMuteReporter",
                        "lex:tools.ozone.moderation.defs#modEventUnmuteReporter",
                        "lex:tools.ozone.moderation.defs#modEventReverseTakedown",
                        "lex:tools.ozone.moderation.defs#modEventResolveAppeal",
                        "lex:tools.ozone.moderation.defs#modEventEmail",
                        "lex:tools.ozone.moderation.defs#modEventTag",
                        "lex:tools.ozone.moderation.defs#accountEvent",
                        "lex:tools.ozone.moderation.defs#identityEvent",
                        "lex:tools.ozone.moderation.defs#recordEvent",
                        "lex:tools.ozone.moderation.defs#modEventPriorityScore"
                      ]
                    },
                    subject: {
                      type: "union",
                      refs: [
                        "lex:com.atproto.admin.defs#repoRef",
                        "lex:com.atproto.repo.strongRef"
                      ]
                    },
                    subjectBlobCids: {
                      type: "array",
                      items: {
                        type: "string",
                        format: "cid"
                      }
                    },
                    createdBy: {
                      type: "string",
                      format: "did"
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "ref",
                  ref: "lex:tools.ozone.moderation.defs#modEventView"
                }
              },
              errors: [
                {
                  name: "SubjectHasAction"
                }
              ]
            }
          }
        },
        ToolsOzoneModerationGetEvent: {
          lexicon: 1,
          id: "tools.ozone.moderation.getEvent",
          defs: {
            main: {
              type: "query",
              description: "Get details about a moderation event.",
              parameters: {
                type: "params",
                required: ["id"],
                properties: {
                  id: {
                    type: "integer"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "ref",
                  ref: "lex:tools.ozone.moderation.defs#modEventViewDetail"
                }
              }
            }
          }
        },
        ToolsOzoneModerationGetRecord: {
          lexicon: 1,
          id: "tools.ozone.moderation.getRecord",
          defs: {
            main: {
              type: "query",
              description: "Get details about a record.",
              parameters: {
                type: "params",
                required: ["uri"],
                properties: {
                  uri: {
                    type: "string",
                    format: "at-uri"
                  },
                  cid: {
                    type: "string",
                    format: "cid"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "ref",
                  ref: "lex:tools.ozone.moderation.defs#recordViewDetail"
                }
              },
              errors: [
                {
                  name: "RecordNotFound"
                }
              ]
            }
          }
        },
        ToolsOzoneModerationGetRecords: {
          lexicon: 1,
          id: "tools.ozone.moderation.getRecords",
          defs: {
            main: {
              type: "query",
              description: "Get details about some records.",
              parameters: {
                type: "params",
                required: ["uris"],
                properties: {
                  uris: {
                    type: "array",
                    maxLength: 100,
                    items: {
                      type: "string",
                      format: "at-uri"
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["records"],
                  properties: {
                    records: {
                      type: "array",
                      items: {
                        type: "union",
                        refs: [
                          "lex:tools.ozone.moderation.defs#recordViewDetail",
                          "lex:tools.ozone.moderation.defs#recordViewNotFound"
                        ]
                      }
                    }
                  }
                }
              }
            }
          }
        },
        ToolsOzoneModerationGetRepo: {
          lexicon: 1,
          id: "tools.ozone.moderation.getRepo",
          defs: {
            main: {
              type: "query",
              description: "Get details about a repository.",
              parameters: {
                type: "params",
                required: ["did"],
                properties: {
                  did: {
                    type: "string",
                    format: "did"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "ref",
                  ref: "lex:tools.ozone.moderation.defs#repoViewDetail"
                }
              },
              errors: [
                {
                  name: "RepoNotFound"
                }
              ]
            }
          }
        },
        ToolsOzoneModerationGetRepos: {
          lexicon: 1,
          id: "tools.ozone.moderation.getRepos",
          defs: {
            main: {
              type: "query",
              description: "Get details about some repositories.",
              parameters: {
                type: "params",
                required: ["dids"],
                properties: {
                  dids: {
                    type: "array",
                    maxLength: 100,
                    items: {
                      type: "string",
                      format: "did"
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["repos"],
                  properties: {
                    repos: {
                      type: "array",
                      items: {
                        type: "union",
                        refs: [
                          "lex:tools.ozone.moderation.defs#repoViewDetail",
                          "lex:tools.ozone.moderation.defs#repoViewNotFound"
                        ]
                      }
                    }
                  }
                }
              }
            }
          }
        },
        ToolsOzoneModerationQueryEvents: {
          lexicon: 1,
          id: "tools.ozone.moderation.queryEvents",
          defs: {
            main: {
              type: "query",
              description: "List moderation events related to a subject.",
              parameters: {
                type: "params",
                properties: {
                  types: {
                    type: "array",
                    items: {
                      type: "string"
                    },
                    description: "The types of events (fully qualified string in the format of tools.ozone.moderation.defs#modEvent<name>) to filter by. If not specified, all events are returned."
                  },
                  createdBy: {
                    type: "string",
                    format: "did"
                  },
                  sortDirection: {
                    type: "string",
                    default: "desc",
                    enum: ["asc", "desc"],
                    description: "Sort direction for the events. Defaults to descending order of created at timestamp."
                  },
                  createdAfter: {
                    type: "string",
                    format: "datetime",
                    description: "Retrieve events created after a given timestamp"
                  },
                  createdBefore: {
                    type: "string",
                    format: "datetime",
                    description: "Retrieve events created before a given timestamp"
                  },
                  subject: {
                    type: "string",
                    format: "uri"
                  },
                  collections: {
                    type: "array",
                    maxLength: 20,
                    description: "If specified, only events where the subject belongs to the given collections will be returned. When subjectType is set to 'account', this will be ignored.",
                    items: {
                      type: "string",
                      format: "nsid"
                    }
                  },
                  subjectType: {
                    type: "string",
                    description: "If specified, only events where the subject is of the given type (account or record) will be returned. When this is set to 'account' the 'collections' parameter will be ignored. When includeAllUserRecords or subject is set, this will be ignored.",
                    knownValues: ["account", "record"]
                  },
                  includeAllUserRecords: {
                    type: "boolean",
                    default: false,
                    description: "If true, events on all record types (posts, lists, profile etc.) or records from given 'collections' param, owned by the did are returned."
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  hasComment: {
                    type: "boolean",
                    description: "If true, only events with comments are returned"
                  },
                  comment: {
                    type: "string",
                    description: "If specified, only events with comments containing the keyword are returned. Apply || separator to use multiple keywords and match using OR condition."
                  },
                  addedLabels: {
                    type: "array",
                    items: {
                      type: "string"
                    },
                    description: "If specified, only events where all of these labels were added are returned"
                  },
                  removedLabels: {
                    type: "array",
                    items: {
                      type: "string"
                    },
                    description: "If specified, only events where all of these labels were removed are returned"
                  },
                  addedTags: {
                    type: "array",
                    items: {
                      type: "string"
                    },
                    description: "If specified, only events where all of these tags were added are returned"
                  },
                  removedTags: {
                    type: "array",
                    items: {
                      type: "string"
                    },
                    description: "If specified, only events where all of these tags were removed are returned"
                  },
                  reportTypes: {
                    type: "array",
                    items: {
                      type: "string"
                    }
                  },
                  policies: {
                    type: "array",
                    items: {
                      type: "string",
                      description: "If specified, only events where the action policies match any of the given policies are returned"
                    }
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["events"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    events: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:tools.ozone.moderation.defs#modEventView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        ToolsOzoneModerationQueryStatuses: {
          lexicon: 1,
          id: "tools.ozone.moderation.queryStatuses",
          defs: {
            main: {
              type: "query",
              description: "View moderation statuses of subjects (record or repo).",
              parameters: {
                type: "params",
                properties: {
                  queueCount: {
                    type: "integer",
                    description: "Number of queues being used by moderators. Subjects will be split among all queues."
                  },
                  queueIndex: {
                    type: "integer",
                    description: "Index of the queue to fetch subjects from. Works only when queueCount value is specified."
                  },
                  queueSeed: {
                    type: "string",
                    description: "A seeder to shuffle/balance the queue items."
                  },
                  includeAllUserRecords: {
                    type: "boolean",
                    description: "All subjects, or subjects from given 'collections' param, belonging to the account specified in the 'subject' param will be returned."
                  },
                  subject: {
                    type: "string",
                    format: "uri",
                    description: "The subject to get the status for."
                  },
                  comment: {
                    type: "string",
                    description: "Search subjects by keyword from comments"
                  },
                  reportedAfter: {
                    type: "string",
                    format: "datetime",
                    description: "Search subjects reported after a given timestamp"
                  },
                  reportedBefore: {
                    type: "string",
                    format: "datetime",
                    description: "Search subjects reported before a given timestamp"
                  },
                  reviewedAfter: {
                    type: "string",
                    format: "datetime",
                    description: "Search subjects reviewed after a given timestamp"
                  },
                  hostingDeletedAfter: {
                    type: "string",
                    format: "datetime",
                    description: "Search subjects where the associated record/account was deleted after a given timestamp"
                  },
                  hostingDeletedBefore: {
                    type: "string",
                    format: "datetime",
                    description: "Search subjects where the associated record/account was deleted before a given timestamp"
                  },
                  hostingUpdatedAfter: {
                    type: "string",
                    format: "datetime",
                    description: "Search subjects where the associated record/account was updated after a given timestamp"
                  },
                  hostingUpdatedBefore: {
                    type: "string",
                    format: "datetime",
                    description: "Search subjects where the associated record/account was updated before a given timestamp"
                  },
                  hostingStatuses: {
                    type: "array",
                    items: {
                      type: "string"
                    },
                    description: "Search subjects by the status of the associated record/account"
                  },
                  reviewedBefore: {
                    type: "string",
                    format: "datetime",
                    description: "Search subjects reviewed before a given timestamp"
                  },
                  includeMuted: {
                    type: "boolean",
                    description: "By default, we don't include muted subjects in the results. Set this to true to include them."
                  },
                  onlyMuted: {
                    type: "boolean",
                    description: "When set to true, only muted subjects and reporters will be returned."
                  },
                  reviewState: {
                    type: "string",
                    description: "Specify when fetching subjects in a certain state"
                  },
                  ignoreSubjects: {
                    type: "array",
                    items: {
                      type: "string",
                      format: "uri"
                    }
                  },
                  lastReviewedBy: {
                    type: "string",
                    format: "did",
                    description: "Get all subject statuses that were reviewed by a specific moderator"
                  },
                  sortField: {
                    type: "string",
                    default: "lastReportedAt",
                    enum: [
                      "lastReviewedAt",
                      "lastReportedAt",
                      "reportedRecordsCount",
                      "takendownRecordsCount",
                      "priorityScore"
                    ]
                  },
                  sortDirection: {
                    type: "string",
                    default: "desc",
                    enum: ["asc", "desc"]
                  },
                  takendown: {
                    type: "boolean",
                    description: "Get subjects that were taken down"
                  },
                  appealed: {
                    type: "boolean",
                    description: "Get subjects in unresolved appealed status"
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  tags: {
                    type: "array",
                    maxLength: 25,
                    items: {
                      type: "string",
                      description: "Items in this array are applied with OR filters. To apply AND filter, put all tags in the same string and separate using && characters"
                    }
                  },
                  excludeTags: {
                    type: "array",
                    items: {
                      type: "string"
                    }
                  },
                  cursor: {
                    type: "string"
                  },
                  collections: {
                    type: "array",
                    maxLength: 20,
                    description: "If specified, subjects belonging to the given collections will be returned. When subjectType is set to 'account', this will be ignored.",
                    items: {
                      type: "string",
                      format: "nsid"
                    }
                  },
                  subjectType: {
                    type: "string",
                    description: "If specified, subjects of the given type (account or record) will be returned. When this is set to 'account' the 'collections' parameter will be ignored. When includeAllUserRecords or subject is set, this will be ignored.",
                    knownValues: ["account", "record"]
                  },
                  minAccountSuspendCount: {
                    type: "integer",
                    description: "If specified, only subjects that belong to an account that has at least this many suspensions will be returned."
                  },
                  minReportedRecordsCount: {
                    type: "integer",
                    description: "If specified, only subjects that belong to an account that has at least this many reported records will be returned."
                  },
                  minTakendownRecordsCount: {
                    type: "integer",
                    description: "If specified, only subjects that belong to an account that has at least this many taken down records will be returned."
                  },
                  minPriorityScore: {
                    minimum: 0,
                    maximum: 100,
                    type: "integer",
                    description: "If specified, only subjects that have priority score value above the given value will be returned."
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["subjectStatuses"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    subjectStatuses: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:tools.ozone.moderation.defs#subjectStatusView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        ToolsOzoneModerationSearchRepos: {
          lexicon: 1,
          id: "tools.ozone.moderation.searchRepos",
          defs: {
            main: {
              type: "query",
              description: "Find repositories based on a search term.",
              parameters: {
                type: "params",
                properties: {
                  term: {
                    type: "string",
                    description: "DEPRECATED: use 'q' instead"
                  },
                  q: {
                    type: "string"
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["repos"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    repos: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:tools.ozone.moderation.defs#repoView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        ToolsOzoneServerGetConfig: {
          lexicon: 1,
          id: "tools.ozone.server.getConfig",
          defs: {
            main: {
              type: "query",
              description: "Get details about ozone's server configuration.",
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  properties: {
                    appview: {
                      type: "ref",
                      ref: "lex:tools.ozone.server.getConfig#serviceConfig"
                    },
                    pds: {
                      type: "ref",
                      ref: "lex:tools.ozone.server.getConfig#serviceConfig"
                    },
                    blobDivert: {
                      type: "ref",
                      ref: "lex:tools.ozone.server.getConfig#serviceConfig"
                    },
                    chat: {
                      type: "ref",
                      ref: "lex:tools.ozone.server.getConfig#serviceConfig"
                    },
                    viewer: {
                      type: "ref",
                      ref: "lex:tools.ozone.server.getConfig#viewerConfig"
                    }
                  }
                }
              }
            },
            serviceConfig: {
              type: "object",
              properties: {
                url: {
                  type: "string",
                  format: "uri"
                }
              }
            },
            viewerConfig: {
              type: "object",
              properties: {
                role: {
                  type: "string",
                  knownValues: [
                    "tools.ozone.team.defs#roleAdmin",
                    "tools.ozone.team.defs#roleModerator",
                    "tools.ozone.team.defs#roleTriage"
                  ]
                }
              }
            }
          }
        },
        ToolsOzoneSetAddValues: {
          lexicon: 1,
          id: "tools.ozone.set.addValues",
          defs: {
            main: {
              type: "procedure",
              description: "Add values to a specific set. Attempting to add values to a set that does not exist will result in an error.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["name", "values"],
                  properties: {
                    name: {
                      type: "string",
                      description: "Name of the set to add values to"
                    },
                    values: {
                      type: "array",
                      minLength: 1,
                      maxLength: 1e3,
                      items: {
                        type: "string"
                      },
                      description: "Array of string values to add to the set"
                    }
                  }
                }
              }
            }
          }
        },
        ToolsOzoneSetDefs: {
          lexicon: 1,
          id: "tools.ozone.set.defs",
          defs: {
            set: {
              type: "object",
              required: ["name"],
              properties: {
                name: {
                  type: "string",
                  minLength: 3,
                  maxLength: 128
                },
                description: {
                  type: "string",
                  maxGraphemes: 1024,
                  maxLength: 10240
                }
              }
            },
            setView: {
              type: "object",
              required: ["name", "setSize", "createdAt", "updatedAt"],
              properties: {
                name: {
                  type: "string",
                  minLength: 3,
                  maxLength: 128
                },
                description: {
                  type: "string",
                  maxGraphemes: 1024,
                  maxLength: 10240
                },
                setSize: {
                  type: "integer"
                },
                createdAt: {
                  type: "string",
                  format: "datetime"
                },
                updatedAt: {
                  type: "string",
                  format: "datetime"
                }
              }
            }
          }
        },
        ToolsOzoneSetDeleteSet: {
          lexicon: 1,
          id: "tools.ozone.set.deleteSet",
          defs: {
            main: {
              type: "procedure",
              description: "Delete an entire set. Attempting to delete a set that does not exist will result in an error.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["name"],
                  properties: {
                    name: {
                      type: "string",
                      description: "Name of the set to delete"
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  properties: {}
                }
              },
              errors: [
                {
                  name: "SetNotFound",
                  description: "set with the given name does not exist"
                }
              ]
            }
          }
        },
        ToolsOzoneSetDeleteValues: {
          lexicon: 1,
          id: "tools.ozone.set.deleteValues",
          defs: {
            main: {
              type: "procedure",
              description: "Delete values from a specific set. Attempting to delete values that are not in the set will not result in an error",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["name", "values"],
                  properties: {
                    name: {
                      type: "string",
                      description: "Name of the set to delete values from"
                    },
                    values: {
                      type: "array",
                      minLength: 1,
                      items: {
                        type: "string"
                      },
                      description: "Array of string values to delete from the set"
                    }
                  }
                }
              },
              errors: [
                {
                  name: "SetNotFound",
                  description: "set with the given name does not exist"
                }
              ]
            }
          }
        },
        ToolsOzoneSetGetValues: {
          lexicon: 1,
          id: "tools.ozone.set.getValues",
          defs: {
            main: {
              type: "query",
              description: "Get a specific set and its values",
              parameters: {
                type: "params",
                required: ["name"],
                properties: {
                  name: {
                    type: "string"
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 1e3,
                    default: 100
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["set", "values"],
                  properties: {
                    set: {
                      type: "ref",
                      ref: "lex:tools.ozone.set.defs#setView"
                    },
                    values: {
                      type: "array",
                      items: {
                        type: "string"
                      }
                    },
                    cursor: {
                      type: "string"
                    }
                  }
                }
              },
              errors: [
                {
                  name: "SetNotFound",
                  description: "set with the given name does not exist"
                }
              ]
            }
          }
        },
        ToolsOzoneSetQuerySets: {
          lexicon: 1,
          id: "tools.ozone.set.querySets",
          defs: {
            main: {
              type: "query",
              description: "Query available sets",
              parameters: {
                type: "params",
                properties: {
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  },
                  namePrefix: {
                    type: "string"
                  },
                  sortBy: {
                    type: "string",
                    enum: ["name", "createdAt", "updatedAt"],
                    default: "name"
                  },
                  sortDirection: {
                    type: "string",
                    default: "asc",
                    enum: ["asc", "desc"],
                    description: "Defaults to ascending order of name field."
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["sets"],
                  properties: {
                    sets: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:tools.ozone.set.defs#setView"
                      }
                    },
                    cursor: {
                      type: "string"
                    }
                  }
                }
              }
            }
          }
        },
        ToolsOzoneSetUpsertSet: {
          lexicon: 1,
          id: "tools.ozone.set.upsertSet",
          defs: {
            main: {
              type: "procedure",
              description: "Create or update set metadata",
              input: {
                encoding: "application/json",
                schema: {
                  type: "ref",
                  ref: "lex:tools.ozone.set.defs#set"
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "ref",
                  ref: "lex:tools.ozone.set.defs#setView"
                }
              }
            }
          }
        },
        ToolsOzoneSettingDefs: {
          lexicon: 1,
          id: "tools.ozone.setting.defs",
          defs: {
            option: {
              type: "object",
              required: [
                "key",
                "value",
                "did",
                "scope",
                "createdBy",
                "lastUpdatedBy"
              ],
              properties: {
                key: {
                  type: "string",
                  format: "nsid"
                },
                did: {
                  type: "string",
                  format: "did"
                },
                value: {
                  type: "unknown"
                },
                description: {
                  type: "string",
                  maxGraphemes: 1024,
                  maxLength: 10240
                },
                createdAt: {
                  type: "string",
                  format: "datetime"
                },
                updatedAt: {
                  type: "string",
                  format: "datetime"
                },
                managerRole: {
                  type: "string",
                  knownValues: [
                    "tools.ozone.team.defs#roleModerator",
                    "tools.ozone.team.defs#roleTriage",
                    "tools.ozone.team.defs#roleAdmin"
                  ]
                },
                scope: {
                  type: "string",
                  knownValues: ["instance", "personal"]
                },
                createdBy: {
                  type: "string",
                  format: "did"
                },
                lastUpdatedBy: {
                  type: "string",
                  format: "did"
                }
              }
            }
          }
        },
        ToolsOzoneSettingListOptions: {
          lexicon: 1,
          id: "tools.ozone.setting.listOptions",
          defs: {
            main: {
              type: "query",
              description: "List settings with optional filtering",
              parameters: {
                type: "params",
                properties: {
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  },
                  scope: {
                    type: "string",
                    knownValues: ["instance", "personal"],
                    default: "instance"
                  },
                  prefix: {
                    type: "string",
                    description: "Filter keys by prefix"
                  },
                  keys: {
                    type: "array",
                    maxLength: 100,
                    items: {
                      type: "string",
                      format: "nsid"
                    },
                    description: "Filter for only the specified keys. Ignored if prefix is provided"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["options"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    options: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:tools.ozone.setting.defs#option"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        ToolsOzoneSettingRemoveOptions: {
          lexicon: 1,
          id: "tools.ozone.setting.removeOptions",
          defs: {
            main: {
              type: "procedure",
              description: "Delete settings by key",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["keys", "scope"],
                  properties: {
                    keys: {
                      type: "array",
                      minLength: 1,
                      maxLength: 200,
                      items: {
                        type: "string",
                        format: "nsid"
                      }
                    },
                    scope: {
                      type: "string",
                      knownValues: ["instance", "personal"]
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  properties: {}
                }
              }
            }
          }
        },
        ToolsOzoneSettingUpsertOption: {
          lexicon: 1,
          id: "tools.ozone.setting.upsertOption",
          defs: {
            main: {
              type: "procedure",
              description: "Create or update setting option",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["key", "scope", "value"],
                  properties: {
                    key: {
                      type: "string",
                      format: "nsid"
                    },
                    scope: {
                      type: "string",
                      knownValues: ["instance", "personal"]
                    },
                    value: {
                      type: "unknown"
                    },
                    description: {
                      type: "string",
                      maxLength: 2e3
                    },
                    managerRole: {
                      type: "string",
                      knownValues: [
                        "tools.ozone.team.defs#roleModerator",
                        "tools.ozone.team.defs#roleTriage",
                        "tools.ozone.team.defs#roleAdmin"
                      ]
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["option"],
                  properties: {
                    option: {
                      type: "ref",
                      ref: "lex:tools.ozone.setting.defs#option"
                    }
                  }
                }
              }
            }
          }
        },
        ToolsOzoneSignatureDefs: {
          lexicon: 1,
          id: "tools.ozone.signature.defs",
          defs: {
            sigDetail: {
              type: "object",
              required: ["property", "value"],
              properties: {
                property: {
                  type: "string"
                },
                value: {
                  type: "string"
                }
              }
            }
          }
        },
        ToolsOzoneSignatureFindCorrelation: {
          lexicon: 1,
          id: "tools.ozone.signature.findCorrelation",
          defs: {
            main: {
              type: "query",
              description: "Find all correlated threat signatures between 2 or more accounts.",
              parameters: {
                type: "params",
                required: ["dids"],
                properties: {
                  dids: {
                    type: "array",
                    items: {
                      type: "string",
                      format: "did"
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["details"],
                  properties: {
                    details: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:tools.ozone.signature.defs#sigDetail"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        ToolsOzoneSignatureFindRelatedAccounts: {
          lexicon: 1,
          id: "tools.ozone.signature.findRelatedAccounts",
          defs: {
            main: {
              type: "query",
              description: "Get accounts that share some matching threat signatures with the root account.",
              parameters: {
                type: "params",
                required: ["did"],
                properties: {
                  did: {
                    type: "string",
                    format: "did"
                  },
                  cursor: {
                    type: "string"
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["accounts"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    accounts: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:tools.ozone.signature.findRelatedAccounts#relatedAccount"
                      }
                    }
                  }
                }
              }
            },
            relatedAccount: {
              type: "object",
              required: ["account"],
              properties: {
                account: {
                  type: "ref",
                  ref: "lex:com.atproto.admin.defs#accountView"
                },
                similarities: {
                  type: "array",
                  items: {
                    type: "ref",
                    ref: "lex:tools.ozone.signature.defs#sigDetail"
                  }
                }
              }
            }
          }
        },
        ToolsOzoneSignatureSearchAccounts: {
          lexicon: 1,
          id: "tools.ozone.signature.searchAccounts",
          defs: {
            main: {
              type: "query",
              description: "Search for accounts that match one or more threat signature values.",
              parameters: {
                type: "params",
                required: ["values"],
                properties: {
                  values: {
                    type: "array",
                    items: {
                      type: "string"
                    }
                  },
                  cursor: {
                    type: "string"
                  },
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["accounts"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    accounts: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:com.atproto.admin.defs#accountView"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        ToolsOzoneTeamAddMember: {
          lexicon: 1,
          id: "tools.ozone.team.addMember",
          defs: {
            main: {
              type: "procedure",
              description: "Add a member to the ozone team. Requires admin role.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["did", "role"],
                  properties: {
                    did: {
                      type: "string",
                      format: "did"
                    },
                    role: {
                      type: "string",
                      knownValues: [
                        "tools.ozone.team.defs#roleAdmin",
                        "tools.ozone.team.defs#roleModerator",
                        "tools.ozone.team.defs#roleTriage"
                      ]
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "ref",
                  ref: "lex:tools.ozone.team.defs#member"
                }
              },
              errors: [
                {
                  name: "MemberAlreadyExists",
                  description: "Member already exists in the team."
                }
              ]
            }
          }
        },
        ToolsOzoneTeamDefs: {
          lexicon: 1,
          id: "tools.ozone.team.defs",
          defs: {
            member: {
              type: "object",
              required: ["did", "role"],
              properties: {
                did: {
                  type: "string",
                  format: "did"
                },
                disabled: {
                  type: "boolean"
                },
                profile: {
                  type: "ref",
                  ref: "lex:app.bsky.actor.defs#profileViewDetailed"
                },
                createdAt: {
                  type: "string",
                  format: "datetime"
                },
                updatedAt: {
                  type: "string",
                  format: "datetime"
                },
                lastUpdatedBy: {
                  type: "string"
                },
                role: {
                  type: "string",
                  knownValues: [
                    "lex:tools.ozone.team.defs#roleAdmin",
                    "lex:tools.ozone.team.defs#roleModerator",
                    "lex:tools.ozone.team.defs#roleTriage"
                  ]
                }
              }
            },
            roleAdmin: {
              type: "token",
              description: "Admin role. Highest level of access, can perform all actions."
            },
            roleModerator: {
              type: "token",
              description: "Moderator role. Can perform most actions."
            },
            roleTriage: {
              type: "token",
              description: "Triage role. Mostly intended for monitoring and escalating issues."
            }
          }
        },
        ToolsOzoneTeamDeleteMember: {
          lexicon: 1,
          id: "tools.ozone.team.deleteMember",
          defs: {
            main: {
              type: "procedure",
              description: "Delete a member from ozone team. Requires admin role.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["did"],
                  properties: {
                    did: {
                      type: "string",
                      format: "did"
                    }
                  }
                }
              },
              errors: [
                {
                  name: "MemberNotFound",
                  description: "The member being deleted does not exist"
                },
                {
                  name: "CannotDeleteSelf",
                  description: "You can not delete yourself from the team"
                }
              ]
            }
          }
        },
        ToolsOzoneTeamListMembers: {
          lexicon: 1,
          id: "tools.ozone.team.listMembers",
          defs: {
            main: {
              type: "query",
              description: "List all members with access to the ozone service.",
              parameters: {
                type: "params",
                properties: {
                  limit: {
                    type: "integer",
                    minimum: 1,
                    maximum: 100,
                    default: 50
                  },
                  cursor: {
                    type: "string"
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["members"],
                  properties: {
                    cursor: {
                      type: "string"
                    },
                    members: {
                      type: "array",
                      items: {
                        type: "ref",
                        ref: "lex:tools.ozone.team.defs#member"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        ToolsOzoneTeamUpdateMember: {
          lexicon: 1,
          id: "tools.ozone.team.updateMember",
          defs: {
            main: {
              type: "procedure",
              description: "Update a member in the ozone service. Requires admin role.",
              input: {
                encoding: "application/json",
                schema: {
                  type: "object",
                  required: ["did"],
                  properties: {
                    did: {
                      type: "string",
                      format: "did"
                    },
                    disabled: {
                      type: "boolean"
                    },
                    role: {
                      type: "string",
                      knownValues: [
                        "tools.ozone.team.defs#roleAdmin",
                        "tools.ozone.team.defs#roleModerator",
                        "tools.ozone.team.defs#roleTriage"
                      ]
                    }
                  }
                }
              },
              output: {
                encoding: "application/json",
                schema: {
                  type: "ref",
                  ref: "lex:tools.ozone.team.defs#member"
                }
              },
              errors: [
                {
                  name: "MemberNotFound",
                  description: "The member being updated does not exist in the team"
                }
              ]
            }
          }
        }
      };
      exports$1.schemas = Object.values(exports$1.schemaDict);
      exports$1.lexicons = new lexicon_1.Lexicons(exports$1.schemas);
      function validate(v, id, hash, requiredType) {
        return (requiredType ? util_js_1.is$typed : util_js_1.maybe$typed)(v, id, hash) ? exports$1.lexicons.validate(`${id}#${hash}`, v) : {
          success: false,
          error: new lexicon_1.ValidationError(`Must be an object with "${hash === "main" ? id : `${id}#${hash}`}" $type property`)
        };
      }
      exports$1.ids = {
        ComAtprotoAdminDefs: "com.atproto.admin.defs",
        ComAtprotoAdminDeleteAccount: "com.atproto.admin.deleteAccount",
        ComAtprotoAdminDisableAccountInvites: "com.atproto.admin.disableAccountInvites",
        ComAtprotoAdminDisableInviteCodes: "com.atproto.admin.disableInviteCodes",
        ComAtprotoAdminEnableAccountInvites: "com.atproto.admin.enableAccountInvites",
        ComAtprotoAdminGetAccountInfo: "com.atproto.admin.getAccountInfo",
        ComAtprotoAdminGetAccountInfos: "com.atproto.admin.getAccountInfos",
        ComAtprotoAdminGetInviteCodes: "com.atproto.admin.getInviteCodes",
        ComAtprotoAdminGetSubjectStatus: "com.atproto.admin.getSubjectStatus",
        ComAtprotoAdminSearchAccounts: "com.atproto.admin.searchAccounts",
        ComAtprotoAdminSendEmail: "com.atproto.admin.sendEmail",
        ComAtprotoAdminUpdateAccountEmail: "com.atproto.admin.updateAccountEmail",
        ComAtprotoAdminUpdateAccountHandle: "com.atproto.admin.updateAccountHandle",
        ComAtprotoAdminUpdateAccountPassword: "com.atproto.admin.updateAccountPassword",
        ComAtprotoAdminUpdateSubjectStatus: "com.atproto.admin.updateSubjectStatus",
        ComAtprotoIdentityGetRecommendedDidCredentials: "com.atproto.identity.getRecommendedDidCredentials",
        ComAtprotoIdentityRequestPlcOperationSignature: "com.atproto.identity.requestPlcOperationSignature",
        ComAtprotoIdentityResolveHandle: "com.atproto.identity.resolveHandle",
        ComAtprotoIdentitySignPlcOperation: "com.atproto.identity.signPlcOperation",
        ComAtprotoIdentitySubmitPlcOperation: "com.atproto.identity.submitPlcOperation",
        ComAtprotoIdentityUpdateHandle: "com.atproto.identity.updateHandle",
        ComAtprotoLabelDefs: "com.atproto.label.defs",
        ComAtprotoLabelQueryLabels: "com.atproto.label.queryLabels",
        ComAtprotoLabelSubscribeLabels: "com.atproto.label.subscribeLabels",
        ComAtprotoLexiconSchema: "com.atproto.lexicon.schema",
        ComAtprotoModerationCreateReport: "com.atproto.moderation.createReport",
        ComAtprotoModerationDefs: "com.atproto.moderation.defs",
        ComAtprotoRepoApplyWrites: "com.atproto.repo.applyWrites",
        ComAtprotoRepoCreateRecord: "com.atproto.repo.createRecord",
        ComAtprotoRepoDefs: "com.atproto.repo.defs",
        ComAtprotoRepoDeleteRecord: "com.atproto.repo.deleteRecord",
        ComAtprotoRepoDescribeRepo: "com.atproto.repo.describeRepo",
        ComAtprotoRepoGetRecord: "com.atproto.repo.getRecord",
        ComAtprotoRepoImportRepo: "com.atproto.repo.importRepo",
        ComAtprotoRepoListMissingBlobs: "com.atproto.repo.listMissingBlobs",
        ComAtprotoRepoListRecords: "com.atproto.repo.listRecords",
        ComAtprotoRepoPutRecord: "com.atproto.repo.putRecord",
        ComAtprotoRepoStrongRef: "com.atproto.repo.strongRef",
        ComAtprotoRepoUploadBlob: "com.atproto.repo.uploadBlob",
        ComAtprotoServerActivateAccount: "com.atproto.server.activateAccount",
        ComAtprotoServerCheckAccountStatus: "com.atproto.server.checkAccountStatus",
        ComAtprotoServerConfirmEmail: "com.atproto.server.confirmEmail",
        ComAtprotoServerCreateAccount: "com.atproto.server.createAccount",
        ComAtprotoServerCreateAppPassword: "com.atproto.server.createAppPassword",
        ComAtprotoServerCreateInviteCode: "com.atproto.server.createInviteCode",
        ComAtprotoServerCreateInviteCodes: "com.atproto.server.createInviteCodes",
        ComAtprotoServerCreateSession: "com.atproto.server.createSession",
        ComAtprotoServerDeactivateAccount: "com.atproto.server.deactivateAccount",
        ComAtprotoServerDefs: "com.atproto.server.defs",
        ComAtprotoServerDeleteAccount: "com.atproto.server.deleteAccount",
        ComAtprotoServerDeleteSession: "com.atproto.server.deleteSession",
        ComAtprotoServerDescribeServer: "com.atproto.server.describeServer",
        ComAtprotoServerGetAccountInviteCodes: "com.atproto.server.getAccountInviteCodes",
        ComAtprotoServerGetServiceAuth: "com.atproto.server.getServiceAuth",
        ComAtprotoServerGetSession: "com.atproto.server.getSession",
        ComAtprotoServerListAppPasswords: "com.atproto.server.listAppPasswords",
        ComAtprotoServerRefreshSession: "com.atproto.server.refreshSession",
        ComAtprotoServerRequestAccountDelete: "com.atproto.server.requestAccountDelete",
        ComAtprotoServerRequestEmailConfirmation: "com.atproto.server.requestEmailConfirmation",
        ComAtprotoServerRequestEmailUpdate: "com.atproto.server.requestEmailUpdate",
        ComAtprotoServerRequestPasswordReset: "com.atproto.server.requestPasswordReset",
        ComAtprotoServerReserveSigningKey: "com.atproto.server.reserveSigningKey",
        ComAtprotoServerResetPassword: "com.atproto.server.resetPassword",
        ComAtprotoServerRevokeAppPassword: "com.atproto.server.revokeAppPassword",
        ComAtprotoServerUpdateEmail: "com.atproto.server.updateEmail",
        ComAtprotoSyncGetBlob: "com.atproto.sync.getBlob",
        ComAtprotoSyncGetBlocks: "com.atproto.sync.getBlocks",
        ComAtprotoSyncGetCheckout: "com.atproto.sync.getCheckout",
        ComAtprotoSyncGetHead: "com.atproto.sync.getHead",
        ComAtprotoSyncGetLatestCommit: "com.atproto.sync.getLatestCommit",
        ComAtprotoSyncGetRecord: "com.atproto.sync.getRecord",
        ComAtprotoSyncGetRepo: "com.atproto.sync.getRepo",
        ComAtprotoSyncGetRepoStatus: "com.atproto.sync.getRepoStatus",
        ComAtprotoSyncListBlobs: "com.atproto.sync.listBlobs",
        ComAtprotoSyncListRepos: "com.atproto.sync.listRepos",
        ComAtprotoSyncNotifyOfUpdate: "com.atproto.sync.notifyOfUpdate",
        ComAtprotoSyncRequestCrawl: "com.atproto.sync.requestCrawl",
        ComAtprotoSyncSubscribeRepos: "com.atproto.sync.subscribeRepos",
        ComAtprotoTempAddReservedHandle: "com.atproto.temp.addReservedHandle",
        ComAtprotoTempCheckSignupQueue: "com.atproto.temp.checkSignupQueue",
        ComAtprotoTempFetchLabels: "com.atproto.temp.fetchLabels",
        ComAtprotoTempRequestPhoneVerification: "com.atproto.temp.requestPhoneVerification",
        AppBskyActorDefs: "app.bsky.actor.defs",
        AppBskyActorGetPreferences: "app.bsky.actor.getPreferences",
        AppBskyActorGetProfile: "app.bsky.actor.getProfile",
        AppBskyActorGetProfiles: "app.bsky.actor.getProfiles",
        AppBskyActorGetSuggestions: "app.bsky.actor.getSuggestions",
        AppBskyActorProfile: "app.bsky.actor.profile",
        AppBskyActorPutPreferences: "app.bsky.actor.putPreferences",
        AppBskyActorSearchActors: "app.bsky.actor.searchActors",
        AppBskyActorSearchActorsTypeahead: "app.bsky.actor.searchActorsTypeahead",
        AppBskyEmbedDefs: "app.bsky.embed.defs",
        AppBskyEmbedExternal: "app.bsky.embed.external",
        AppBskyEmbedImages: "app.bsky.embed.images",
        AppBskyEmbedRecord: "app.bsky.embed.record",
        AppBskyEmbedRecordWithMedia: "app.bsky.embed.recordWithMedia",
        AppBskyEmbedVideo: "app.bsky.embed.video",
        AppBskyFeedDefs: "app.bsky.feed.defs",
        AppBskyFeedDescribeFeedGenerator: "app.bsky.feed.describeFeedGenerator",
        AppBskyFeedGenerator: "app.bsky.feed.generator",
        AppBskyFeedGetActorFeeds: "app.bsky.feed.getActorFeeds",
        AppBskyFeedGetActorLikes: "app.bsky.feed.getActorLikes",
        AppBskyFeedGetAuthorFeed: "app.bsky.feed.getAuthorFeed",
        AppBskyFeedGetFeed: "app.bsky.feed.getFeed",
        AppBskyFeedGetFeedGenerator: "app.bsky.feed.getFeedGenerator",
        AppBskyFeedGetFeedGenerators: "app.bsky.feed.getFeedGenerators",
        AppBskyFeedGetFeedSkeleton: "app.bsky.feed.getFeedSkeleton",
        AppBskyFeedGetLikes: "app.bsky.feed.getLikes",
        AppBskyFeedGetListFeed: "app.bsky.feed.getListFeed",
        AppBskyFeedGetPostThread: "app.bsky.feed.getPostThread",
        AppBskyFeedGetPosts: "app.bsky.feed.getPosts",
        AppBskyFeedGetQuotes: "app.bsky.feed.getQuotes",
        AppBskyFeedGetRepostedBy: "app.bsky.feed.getRepostedBy",
        AppBskyFeedGetSuggestedFeeds: "app.bsky.feed.getSuggestedFeeds",
        AppBskyFeedGetTimeline: "app.bsky.feed.getTimeline",
        AppBskyFeedLike: "app.bsky.feed.like",
        AppBskyFeedPost: "app.bsky.feed.post",
        AppBskyFeedPostgate: "app.bsky.feed.postgate",
        AppBskyFeedRepost: "app.bsky.feed.repost",
        AppBskyFeedSearchPosts: "app.bsky.feed.searchPosts",
        AppBskyFeedSendInteractions: "app.bsky.feed.sendInteractions",
        AppBskyFeedThreadgate: "app.bsky.feed.threadgate",
        AppBskyGraphBlock: "app.bsky.graph.block",
        AppBskyGraphDefs: "app.bsky.graph.defs",
        AppBskyGraphFollow: "app.bsky.graph.follow",
        AppBskyGraphGetActorStarterPacks: "app.bsky.graph.getActorStarterPacks",
        AppBskyGraphGetBlocks: "app.bsky.graph.getBlocks",
        AppBskyGraphGetFollowers: "app.bsky.graph.getFollowers",
        AppBskyGraphGetFollows: "app.bsky.graph.getFollows",
        AppBskyGraphGetKnownFollowers: "app.bsky.graph.getKnownFollowers",
        AppBskyGraphGetList: "app.bsky.graph.getList",
        AppBskyGraphGetListBlocks: "app.bsky.graph.getListBlocks",
        AppBskyGraphGetListMutes: "app.bsky.graph.getListMutes",
        AppBskyGraphGetLists: "app.bsky.graph.getLists",
        AppBskyGraphGetMutes: "app.bsky.graph.getMutes",
        AppBskyGraphGetRelationships: "app.bsky.graph.getRelationships",
        AppBskyGraphGetStarterPack: "app.bsky.graph.getStarterPack",
        AppBskyGraphGetStarterPacks: "app.bsky.graph.getStarterPacks",
        AppBskyGraphGetSuggestedFollowsByActor: "app.bsky.graph.getSuggestedFollowsByActor",
        AppBskyGraphList: "app.bsky.graph.list",
        AppBskyGraphListblock: "app.bsky.graph.listblock",
        AppBskyGraphListitem: "app.bsky.graph.listitem",
        AppBskyGraphMuteActor: "app.bsky.graph.muteActor",
        AppBskyGraphMuteActorList: "app.bsky.graph.muteActorList",
        AppBskyGraphMuteThread: "app.bsky.graph.muteThread",
        AppBskyGraphSearchStarterPacks: "app.bsky.graph.searchStarterPacks",
        AppBskyGraphStarterpack: "app.bsky.graph.starterpack",
        AppBskyGraphUnmuteActor: "app.bsky.graph.unmuteActor",
        AppBskyGraphUnmuteActorList: "app.bsky.graph.unmuteActorList",
        AppBskyGraphUnmuteThread: "app.bsky.graph.unmuteThread",
        AppBskyLabelerDefs: "app.bsky.labeler.defs",
        AppBskyLabelerGetServices: "app.bsky.labeler.getServices",
        AppBskyLabelerService: "app.bsky.labeler.service",
        AppBskyNotificationGetUnreadCount: "app.bsky.notification.getUnreadCount",
        AppBskyNotificationListNotifications: "app.bsky.notification.listNotifications",
        AppBskyNotificationPutPreferences: "app.bsky.notification.putPreferences",
        AppBskyNotificationRegisterPush: "app.bsky.notification.registerPush",
        AppBskyNotificationUpdateSeen: "app.bsky.notification.updateSeen",
        AppBskyRichtextFacet: "app.bsky.richtext.facet",
        AppBskyUnspeccedDefs: "app.bsky.unspecced.defs",
        AppBskyUnspeccedGetConfig: "app.bsky.unspecced.getConfig",
        AppBskyUnspeccedGetPopularFeedGenerators: "app.bsky.unspecced.getPopularFeedGenerators",
        AppBskyUnspeccedGetSuggestionsSkeleton: "app.bsky.unspecced.getSuggestionsSkeleton",
        AppBskyUnspeccedGetTaggedSuggestions: "app.bsky.unspecced.getTaggedSuggestions",
        AppBskyUnspeccedGetTrendingTopics: "app.bsky.unspecced.getTrendingTopics",
        AppBskyUnspeccedSearchActorsSkeleton: "app.bsky.unspecced.searchActorsSkeleton",
        AppBskyUnspeccedSearchPostsSkeleton: "app.bsky.unspecced.searchPostsSkeleton",
        AppBskyUnspeccedSearchStarterPacksSkeleton: "app.bsky.unspecced.searchStarterPacksSkeleton",
        AppBskyVideoDefs: "app.bsky.video.defs",
        AppBskyVideoGetJobStatus: "app.bsky.video.getJobStatus",
        AppBskyVideoGetUploadLimits: "app.bsky.video.getUploadLimits",
        AppBskyVideoUploadVideo: "app.bsky.video.uploadVideo",
        ChatBskyActorDeclaration: "chat.bsky.actor.declaration",
        ChatBskyActorDefs: "chat.bsky.actor.defs",
        ChatBskyActorDeleteAccount: "chat.bsky.actor.deleteAccount",
        ChatBskyActorExportAccountData: "chat.bsky.actor.exportAccountData",
        ChatBskyConvoDefs: "chat.bsky.convo.defs",
        ChatBskyConvoDeleteMessageForSelf: "chat.bsky.convo.deleteMessageForSelf",
        ChatBskyConvoGetConvo: "chat.bsky.convo.getConvo",
        ChatBskyConvoGetConvoForMembers: "chat.bsky.convo.getConvoForMembers",
        ChatBskyConvoGetLog: "chat.bsky.convo.getLog",
        ChatBskyConvoGetMessages: "chat.bsky.convo.getMessages",
        ChatBskyConvoLeaveConvo: "chat.bsky.convo.leaveConvo",
        ChatBskyConvoListConvos: "chat.bsky.convo.listConvos",
        ChatBskyConvoMuteConvo: "chat.bsky.convo.muteConvo",
        ChatBskyConvoSendMessage: "chat.bsky.convo.sendMessage",
        ChatBskyConvoSendMessageBatch: "chat.bsky.convo.sendMessageBatch",
        ChatBskyConvoUnmuteConvo: "chat.bsky.convo.unmuteConvo",
        ChatBskyConvoUpdateRead: "chat.bsky.convo.updateRead",
        ChatBskyModerationGetActorMetadata: "chat.bsky.moderation.getActorMetadata",
        ChatBskyModerationGetMessageContext: "chat.bsky.moderation.getMessageContext",
        ChatBskyModerationUpdateActorAccess: "chat.bsky.moderation.updateActorAccess",
        ToolsOzoneCommunicationCreateTemplate: "tools.ozone.communication.createTemplate",
        ToolsOzoneCommunicationDefs: "tools.ozone.communication.defs",
        ToolsOzoneCommunicationDeleteTemplate: "tools.ozone.communication.deleteTemplate",
        ToolsOzoneCommunicationListTemplates: "tools.ozone.communication.listTemplates",
        ToolsOzoneCommunicationUpdateTemplate: "tools.ozone.communication.updateTemplate",
        ToolsOzoneModerationDefs: "tools.ozone.moderation.defs",
        ToolsOzoneModerationEmitEvent: "tools.ozone.moderation.emitEvent",
        ToolsOzoneModerationGetEvent: "tools.ozone.moderation.getEvent",
        ToolsOzoneModerationGetRecord: "tools.ozone.moderation.getRecord",
        ToolsOzoneModerationGetRecords: "tools.ozone.moderation.getRecords",
        ToolsOzoneModerationGetRepo: "tools.ozone.moderation.getRepo",
        ToolsOzoneModerationGetRepos: "tools.ozone.moderation.getRepos",
        ToolsOzoneModerationQueryEvents: "tools.ozone.moderation.queryEvents",
        ToolsOzoneModerationQueryStatuses: "tools.ozone.moderation.queryStatuses",
        ToolsOzoneModerationSearchRepos: "tools.ozone.moderation.searchRepos",
        ToolsOzoneServerGetConfig: "tools.ozone.server.getConfig",
        ToolsOzoneSetAddValues: "tools.ozone.set.addValues",
        ToolsOzoneSetDefs: "tools.ozone.set.defs",
        ToolsOzoneSetDeleteSet: "tools.ozone.set.deleteSet",
        ToolsOzoneSetDeleteValues: "tools.ozone.set.deleteValues",
        ToolsOzoneSetGetValues: "tools.ozone.set.getValues",
        ToolsOzoneSetQuerySets: "tools.ozone.set.querySets",
        ToolsOzoneSetUpsertSet: "tools.ozone.set.upsertSet",
        ToolsOzoneSettingDefs: "tools.ozone.setting.defs",
        ToolsOzoneSettingListOptions: "tools.ozone.setting.listOptions",
        ToolsOzoneSettingRemoveOptions: "tools.ozone.setting.removeOptions",
        ToolsOzoneSettingUpsertOption: "tools.ozone.setting.upsertOption",
        ToolsOzoneSignatureDefs: "tools.ozone.signature.defs",
        ToolsOzoneSignatureFindCorrelation: "tools.ozone.signature.findCorrelation",
        ToolsOzoneSignatureFindRelatedAccounts: "tools.ozone.signature.findRelatedAccounts",
        ToolsOzoneSignatureSearchAccounts: "tools.ozone.signature.searchAccounts",
        ToolsOzoneTeamAddMember: "tools.ozone.team.addMember",
        ToolsOzoneTeamDefs: "tools.ozone.team.defs",
        ToolsOzoneTeamDeleteMember: "tools.ozone.team.deleteMember",
        ToolsOzoneTeamListMembers: "tools.ozone.team.listMembers",
        ToolsOzoneTeamUpdateMember: "tools.ozone.team.updateMember"
      };
    })(lexicons);
    return lexicons;
  }
  var types$2 = {};
  var hasRequiredTypes$2;
  function requireTypes$2() {
    if (hasRequiredTypes$2) return types$2;
    hasRequiredTypes$2 = 1;
    Object.defineProperty(types$2, "__esModule", { value: true });
    return types$2;
  }
  var _const = {};
  var hasRequired_const;
  function require_const() {
    if (hasRequired_const) return _const;
    hasRequired_const = 1;
    Object.defineProperty(_const, "__esModule", { value: true });
    _const.BSKY_LABELER_DID = void 0;
    _const.BSKY_LABELER_DID = "did:plc:ar7c4by46qjdydhdevvrndac";
    return _const;
  }
  var util$4 = {};
  var hasRequiredUtil$4;
  function requireUtil$4() {
    if (hasRequiredUtil$4) return util$4;
    hasRequiredUtil$4 = 1;
    (function(exports$1) {
      Object.defineProperty(exports$1, "__esModule", { value: true });
      exports$1.nuxSchema = exports$1.asDid = exports$1.isDid = void 0;
      exports$1.sanitizeMutedWordValue = sanitizeMutedWordValue;
      exports$1.savedFeedsToUriArrays = savedFeedsToUriArrays;
      exports$1.getSavedFeedType = getSavedFeedType;
      exports$1.validateSavedFeed = validateSavedFeed;
      exports$1.validateNux = validateNux;
      const zod_1 = /* @__PURE__ */ requireLib$1();
      const common_web_1 = requireDist$4();
      const syntax_1 = requireDist$5();
      function sanitizeMutedWordValue(value) {
        return value.trim().replace(/^#(?!\ufe0f)/, "").replace(/[\r\n\u00AD\u2060\u200D\u200C\u200B]+/, "");
      }
      function savedFeedsToUriArrays(savedFeeds) {
        const pinned = [];
        const saved = [];
        for (const feed of savedFeeds) {
          if (feed.pinned) {
            pinned.push(feed.value);
            saved.push(feed.value);
          } else {
            saved.push(feed.value);
          }
        }
        return {
          pinned,
          saved
        };
      }
      function getSavedFeedType(uri) {
        const urip = new syntax_1.AtUri(uri);
        switch (urip.collection) {
          case "app.bsky.feed.generator":
            return "feed";
          case "app.bsky.graph.list":
            return "list";
          default:
            return "unknown";
        }
      }
      function validateSavedFeed(savedFeed) {
        new common_web_1.TID(savedFeed.id);
        if (["feed", "list"].includes(savedFeed.type)) {
          const uri = new syntax_1.AtUri(savedFeed.value);
          const isFeed = uri.collection === "app.bsky.feed.generator";
          const isList = uri.collection === "app.bsky.graph.list";
          if (savedFeed.type === "feed" && !isFeed) {
            throw new Error(`Saved feed of type 'feed' must be a feed, got ${uri.collection}`);
          }
          if (savedFeed.type === "list" && !isList) {
            throw new Error(`Saved feed of type 'list' must be a list, got ${uri.collection}`);
          }
        }
      }
      const isDid = (str) => typeof str === "string" && str.startsWith("did:") && str.includes(":", 4) && str.length > 8 && str.length <= 2048;
      exports$1.isDid = isDid;
      const asDid = (value) => {
        if ((0, exports$1.isDid)(value))
          return value;
        throw new TypeError(`Invalid DID: ${value}`);
      };
      exports$1.asDid = asDid;
      exports$1.nuxSchema = zod_1.z.object({
        id: zod_1.z.string().max(64),
        completed: zod_1.z.boolean(),
        data: zod_1.z.string().max(300).optional(),
        expiresAt: zod_1.z.string().datetime().optional()
      }).strict();
      function validateNux(nux) {
        exports$1.nuxSchema.parse(nux);
      }
    })(util$4);
    return util$4;
  }
  var client$1 = {};
  var dist = {};
  var client = {};
  var util$3 = {};
  var types$1 = {};
  var hasRequiredTypes$1;
  function requireTypes$1() {
    if (hasRequiredTypes$1) return types$1;
    hasRequiredTypes$1 = 1;
    (function(exports$1) {
      Object.defineProperty(exports$1, "__esModule", { value: true });
      exports$1.XRPCInvalidResponseError = exports$1.XRPCError = exports$1.XRPCResponse = exports$1.ResponseTypeStrings = exports$1.ResponseTypeNames = exports$1.ResponseType = exports$1.errorResponseBody = void 0;
      exports$1.httpResponseCodeToEnum = httpResponseCodeToEnum;
      exports$1.httpResponseCodeToName = httpResponseCodeToName;
      exports$1.httpResponseCodeToString = httpResponseCodeToString;
      const zod_1 = /* @__PURE__ */ requireLib$1();
      exports$1.errorResponseBody = zod_1.z.object({
        error: zod_1.z.string().optional(),
        message: zod_1.z.string().optional()
      });
      var ResponseType;
      (function(ResponseType2) {
        ResponseType2[ResponseType2["Unknown"] = 1] = "Unknown";
        ResponseType2[ResponseType2["InvalidResponse"] = 2] = "InvalidResponse";
        ResponseType2[ResponseType2["Success"] = 200] = "Success";
        ResponseType2[ResponseType2["InvalidRequest"] = 400] = "InvalidRequest";
        ResponseType2[ResponseType2["AuthRequired"] = 401] = "AuthRequired";
        ResponseType2[ResponseType2["Forbidden"] = 403] = "Forbidden";
        ResponseType2[ResponseType2["XRPCNotSupported"] = 404] = "XRPCNotSupported";
        ResponseType2[ResponseType2["NotAcceptable"] = 406] = "NotAcceptable";
        ResponseType2[ResponseType2["PayloadTooLarge"] = 413] = "PayloadTooLarge";
        ResponseType2[ResponseType2["UnsupportedMediaType"] = 415] = "UnsupportedMediaType";
        ResponseType2[ResponseType2["RateLimitExceeded"] = 429] = "RateLimitExceeded";
        ResponseType2[ResponseType2["InternalServerError"] = 500] = "InternalServerError";
        ResponseType2[ResponseType2["MethodNotImplemented"] = 501] = "MethodNotImplemented";
        ResponseType2[ResponseType2["UpstreamFailure"] = 502] = "UpstreamFailure";
        ResponseType2[ResponseType2["NotEnoughResources"] = 503] = "NotEnoughResources";
        ResponseType2[ResponseType2["UpstreamTimeout"] = 504] = "UpstreamTimeout";
      })(ResponseType || (exports$1.ResponseType = ResponseType = {}));
      function httpResponseCodeToEnum(status) {
        if (status in ResponseType) {
          return status;
        } else if (status >= 100 && status < 200) {
          return ResponseType.XRPCNotSupported;
        } else if (status >= 200 && status < 300) {
          return ResponseType.Success;
        } else if (status >= 300 && status < 400) {
          return ResponseType.XRPCNotSupported;
        } else if (status >= 400 && status < 500) {
          return ResponseType.InvalidRequest;
        } else {
          return ResponseType.InternalServerError;
        }
      }
      exports$1.ResponseTypeNames = {
        [ResponseType.Unknown]: "Unknown",
        [ResponseType.InvalidResponse]: "InvalidResponse",
        [ResponseType.Success]: "Success",
        [ResponseType.InvalidRequest]: "InvalidRequest",
        [ResponseType.AuthRequired]: "AuthenticationRequired",
        [ResponseType.Forbidden]: "Forbidden",
        [ResponseType.XRPCNotSupported]: "XRPCNotSupported",
        [ResponseType.PayloadTooLarge]: "PayloadTooLarge",
        [ResponseType.UnsupportedMediaType]: "UnsupportedMediaType",
        [ResponseType.RateLimitExceeded]: "RateLimitExceeded",
        [ResponseType.InternalServerError]: "InternalServerError",
        [ResponseType.MethodNotImplemented]: "MethodNotImplemented",
        [ResponseType.UpstreamFailure]: "UpstreamFailure",
        [ResponseType.NotEnoughResources]: "NotEnoughResources",
        [ResponseType.UpstreamTimeout]: "UpstreamTimeout"
      };
      function httpResponseCodeToName(status) {
        return exports$1.ResponseTypeNames[httpResponseCodeToEnum(status)];
      }
      exports$1.ResponseTypeStrings = {
        [ResponseType.Unknown]: "Unknown",
        [ResponseType.InvalidResponse]: "Invalid Response",
        [ResponseType.Success]: "Success",
        [ResponseType.InvalidRequest]: "Invalid Request",
        [ResponseType.AuthRequired]: "Authentication Required",
        [ResponseType.Forbidden]: "Forbidden",
        [ResponseType.XRPCNotSupported]: "XRPC Not Supported",
        [ResponseType.PayloadTooLarge]: "Payload Too Large",
        [ResponseType.UnsupportedMediaType]: "Unsupported Media Type",
        [ResponseType.RateLimitExceeded]: "Rate Limit Exceeded",
        [ResponseType.InternalServerError]: "Internal Server Error",
        [ResponseType.MethodNotImplemented]: "Method Not Implemented",
        [ResponseType.UpstreamFailure]: "Upstream Failure",
        [ResponseType.NotEnoughResources]: "Not Enough Resources",
        [ResponseType.UpstreamTimeout]: "Upstream Timeout"
      };
      function httpResponseCodeToString(status) {
        return exports$1.ResponseTypeStrings[httpResponseCodeToEnum(status)];
      }
      class XRPCResponse {
        constructor(data, headers) {
          Object.defineProperty(this, "data", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: data
          });
          Object.defineProperty(this, "headers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: headers
          });
          Object.defineProperty(this, "success", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: true
          });
        }
      }
      exports$1.XRPCResponse = XRPCResponse;
      class XRPCError extends Error {
        constructor(statusCode, error = httpResponseCodeToName(statusCode), message2, headers, options) {
          super(message2 || error || httpResponseCodeToString(statusCode), options);
          Object.defineProperty(this, "error", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: error
          });
          Object.defineProperty(this, "headers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: headers
          });
          Object.defineProperty(this, "success", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
          });
          Object.defineProperty(this, "status", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          this.status = httpResponseCodeToEnum(statusCode);
          const cause = options?.cause;
          if (this.cause === void 0 && cause !== void 0) {
            this.cause = cause;
          }
        }
        static from(cause, fallbackStatus) {
          if (cause instanceof XRPCError) {
            return cause;
          }
          const causeErr = cause instanceof Error ? cause : void 0;
          const causeResponse = cause instanceof Response ? cause : cause?.["response"] instanceof Response ? cause["response"] : void 0;
          const statusCode = (
            // Extract status code from "http-errors" like errors
            causeErr?.["statusCode"] ?? causeErr?.["status"] ?? // Use the status code from the response object as fallback
            causeResponse?.status
          );
          const status = typeof statusCode === "number" ? httpResponseCodeToEnum(statusCode) : fallbackStatus ?? ResponseType.Unknown;
          const message2 = causeErr?.message ?? String(cause);
          const headers = causeResponse ? Object.fromEntries(causeResponse.headers.entries()) : void 0;
          return new XRPCError(status, void 0, message2, headers, { cause });
        }
      }
      exports$1.XRPCError = XRPCError;
      class XRPCInvalidResponseError extends XRPCError {
        constructor(lexiconNsid, validationError, responseBody) {
          super(ResponseType.InvalidResponse, exports$1.ResponseTypeStrings[ResponseType.InvalidResponse], `The server gave an invalid response and may be out of date.`, void 0, { cause: validationError });
          Object.defineProperty(this, "lexiconNsid", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: lexiconNsid
          });
          Object.defineProperty(this, "validationError", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: validationError
          });
          Object.defineProperty(this, "responseBody", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: responseBody
          });
        }
      }
      exports$1.XRPCInvalidResponseError = XRPCInvalidResponseError;
    })(types$1);
    return types$1;
  }
  var hasRequiredUtil$3;
  function requireUtil$3() {
    if (hasRequiredUtil$3) return util$3;
    hasRequiredUtil$3 = 1;
    Object.defineProperty(util$3, "__esModule", { value: true });
    util$3.isErrorResponseBody = isErrorResponseBody;
    util$3.getMethodSchemaHTTPMethod = getMethodSchemaHTTPMethod;
    util$3.constructMethodCallUri = constructMethodCallUri;
    util$3.constructMethodCallUrl = constructMethodCallUrl;
    util$3.encodeQueryParam = encodeQueryParam;
    util$3.constructMethodCallHeaders = constructMethodCallHeaders;
    util$3.combineHeaders = combineHeaders;
    util$3.isBodyInit = isBodyInit;
    util$3.isIterable = isIterable;
    util$3.encodeMethodCallBody = encodeMethodCallBody;
    util$3.httpResponseBodyParse = httpResponseBodyParse;
    const lexicon_1 = requireDist$2();
    const types_1 = requireTypes$1();
    const ReadableStream = globalThis.ReadableStream || class {
      constructor() {
        throw new Error("ReadableStream is not supported in this environment");
      }
    };
    function isErrorResponseBody(v) {
      return types_1.errorResponseBody.safeParse(v).success;
    }
    function getMethodSchemaHTTPMethod(schema2) {
      if (schema2.type === "procedure") {
        return "post";
      }
      return "get";
    }
    function constructMethodCallUri(nsid2, schema2, serviceUri, params) {
      const uri = new URL(constructMethodCallUrl(nsid2, schema2, params), serviceUri);
      return uri.toString();
    }
    function constructMethodCallUrl(nsid2, schema2, params) {
      const pathname = `/xrpc/${encodeURIComponent(nsid2)}`;
      if (!params)
        return pathname;
      const searchParams = [];
      for (const [key, value] of Object.entries(params)) {
        const paramSchema = schema2.parameters?.properties?.[key];
        if (!paramSchema) {
          throw new Error(`Invalid query parameter: ${key}`);
        }
        if (value !== void 0) {
          if (paramSchema.type === "array") {
            const values = Array.isArray(value) ? value : [value];
            for (const val of values) {
              searchParams.push([
                key,
                encodeQueryParam(paramSchema.items.type, val)
              ]);
            }
          } else {
            searchParams.push([key, encodeQueryParam(paramSchema.type, value)]);
          }
        }
      }
      if (!searchParams.length)
        return pathname;
      return `${pathname}?${new URLSearchParams(searchParams).toString()}`;
    }
    function encodeQueryParam(type, value) {
      if (type === "string" || type === "unknown") {
        return String(value);
      }
      if (type === "float") {
        return String(Number(value));
      } else if (type === "integer") {
        return String(Number(value) | 0);
      } else if (type === "boolean") {
        return value ? "true" : "false";
      } else if (type === "datetime") {
        if (value instanceof Date) {
          return value.toISOString();
        }
        return String(value);
      }
      throw new Error(`Unsupported query param type: ${type}`);
    }
    function constructMethodCallHeaders(schema2, data, opts) {
      const headers = new Headers();
      if (opts?.headers) {
        for (const name in opts.headers) {
          if (headers.has(name)) {
            throw new TypeError(`Duplicate header: ${name}`);
          }
          const value = opts.headers[name];
          if (value != null) {
            headers.set(name, value);
          }
        }
      }
      if (schema2.type === "procedure") {
        if (opts?.encoding) {
          headers.set("content-type", opts.encoding);
        } else if (!headers.has("content-type") && typeof data !== "undefined") {
          if (data instanceof ArrayBuffer || data instanceof ReadableStream || ArrayBuffer.isView(data)) {
            headers.set("content-type", "application/octet-stream");
          } else if (data instanceof FormData) {
            headers.set("content-type", "multipart/form-data");
          } else if (data instanceof URLSearchParams) {
            headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
          } else if (isBlobLike(data)) {
            headers.set("content-type", data.type || "application/octet-stream");
          } else if (typeof data === "string") {
            headers.set("content-type", "text/plain;charset=UTF-8");
          } else if (isIterable(data)) {
            headers.set("content-type", "application/octet-stream");
          } else if (typeof data === "boolean" || typeof data === "number" || typeof data === "string" || typeof data === "object") {
            headers.set("content-type", "application/json");
          } else {
            throw new types_1.XRPCError(types_1.ResponseType.InvalidRequest, `Unsupported data type: ${typeof data}`);
          }
        }
      }
      return headers;
    }
    function combineHeaders(headersInit, defaultHeaders) {
      if (!defaultHeaders)
        return headersInit;
      let headers = void 0;
      for (const [name, definition] of defaultHeaders) {
        if (definition === void 0)
          continue;
        headers ?? (headers = new Headers(headersInit));
        if (headers.has(name))
          continue;
        const value = typeof definition === "function" ? definition() : definition;
        if (typeof value === "string")
          headers.set(name, value);
        else if (value === null)
          headers.delete(name);
        else
          throw new TypeError(`Invalid "${name}" header value: ${typeof value}`);
      }
      return headers ?? headersInit;
    }
    function isBlobLike(value) {
      if (value == null)
        return false;
      if (typeof value !== "object")
        return false;
      if (typeof Blob === "function" && value instanceof Blob)
        return true;
      const tag = value[Symbol.toStringTag];
      if (tag === "Blob" || tag === "File") {
        return "stream" in value && typeof value.stream === "function";
      }
      return false;
    }
    function isBodyInit(value) {
      switch (typeof value) {
        case "string":
          return true;
        case "object":
          return value instanceof ArrayBuffer || value instanceof FormData || value instanceof URLSearchParams || value instanceof ReadableStream || ArrayBuffer.isView(value) || isBlobLike(value);
        default:
          return false;
      }
    }
    function isIterable(value) {
      return value != null && typeof value === "object" && (Symbol.iterator in value || Symbol.asyncIterator in value);
    }
    function encodeMethodCallBody(headers, data) {
      const contentType = headers.get("content-type");
      if (!contentType) {
        return void 0;
      }
      if (typeof data === "undefined") {
        throw new types_1.XRPCError(types_1.ResponseType.InvalidRequest, `A request body is expected but none was provided`);
      }
      if (isBodyInit(data)) {
        if (data instanceof FormData && contentType === "multipart/form-data") {
          headers.delete("content-type");
        }
        return data;
      }
      if (isIterable(data)) {
        return iterableToReadableStream(data);
      }
      if (contentType.startsWith("text/")) {
        return new TextEncoder().encode(String(data));
      }
      if (contentType.startsWith("application/json")) {
        const json = (0, lexicon_1.stringifyLex)(data);
        if (json === void 0) {
          throw new types_1.XRPCError(types_1.ResponseType.InvalidRequest, `Failed to encode request body as JSON`);
        }
        return new TextEncoder().encode(json);
      }
      const type = !data || typeof data !== "object" ? typeof data : data.constructor !== Object && typeof data.constructor === "function" && typeof data.constructor?.name === "string" ? data.constructor.name : "object";
      throw new types_1.XRPCError(types_1.ResponseType.InvalidRequest, `Unable to encode ${type} as ${contentType} data`);
    }
    function iterableToReadableStream(iterable) {
      if ("from" in ReadableStream && typeof ReadableStream.from === "function") {
        return ReadableStream.from(iterable);
      }
      throw new TypeError("ReadableStream.from() is not supported in this environment. It is required to support using iterables as the request body. Consider using a polyfill or re-write your code to use a different body type.");
    }
    function httpResponseBodyParse(mimeType, data) {
      try {
        if (mimeType) {
          if (mimeType.includes("application/json")) {
            const str = new TextDecoder().decode(data);
            return (0, lexicon_1.jsonStringToLex)(str);
          }
          if (mimeType.startsWith("text/")) {
            return new TextDecoder().decode(data);
          }
        }
        if (data instanceof ArrayBuffer) {
          return new Uint8Array(data);
        }
        return data;
      } catch (cause) {
        throw new types_1.XRPCError(types_1.ResponseType.InvalidResponse, void 0, `Failed to parse response body: ${String(cause)}`, void 0, { cause });
      }
    }
    return util$3;
  }
  var xrpcClient = {};
  var fetchHandler = {};
  var hasRequiredFetchHandler;
  function requireFetchHandler() {
    if (hasRequiredFetchHandler) return fetchHandler;
    hasRequiredFetchHandler = 1;
    Object.defineProperty(fetchHandler, "__esModule", { value: true });
    fetchHandler.buildFetchHandler = buildFetchHandler;
    const util_1 = requireUtil$3();
    function buildFetchHandler(options) {
      if (typeof options === "function")
        return options;
      if (typeof options === "object" && "fetchHandler" in options) {
        return options.fetchHandler.bind(options);
      }
      const { service: service2, headers: defaultHeaders = void 0, fetch: fetch2 = globalThis.fetch } = typeof options === "string" || options instanceof URL ? { service: options } : options;
      if (typeof fetch2 !== "function") {
        throw new TypeError("XrpcDispatcher requires fetch() to be available in your environment.");
      }
      const defaultHeadersEntries = defaultHeaders != null ? Object.entries(defaultHeaders) : void 0;
      return async function(url, init) {
        const base3 = typeof service2 === "function" ? service2() : service2;
        const fullUrl = new URL(url, base3);
        const headers = (0, util_1.combineHeaders)(init.headers, defaultHeadersEntries);
        return fetch2(fullUrl, { ...init, headers });
      };
    }
    return fetchHandler;
  }
  var hasRequiredXrpcClient;
  function requireXrpcClient() {
    if (hasRequiredXrpcClient) return xrpcClient;
    hasRequiredXrpcClient = 1;
    Object.defineProperty(xrpcClient, "__esModule", { value: true });
    xrpcClient.XrpcClient = void 0;
    const lexicon_1 = requireDist$2();
    const fetch_handler_1 = requireFetchHandler();
    const types_1 = requireTypes$1();
    const util_1 = requireUtil$3();
    class XrpcClient {
      constructor(fetchHandlerOpts, lex) {
        Object.defineProperty(this, "fetchHandler", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "headers", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: /* @__PURE__ */ new Map()
        });
        Object.defineProperty(this, "lex", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.fetchHandler = (0, fetch_handler_1.buildFetchHandler)(fetchHandlerOpts);
        this.lex = lex instanceof lexicon_1.Lexicons ? lex : new lexicon_1.Lexicons(lex);
      }
      setHeader(key, value) {
        this.headers.set(key.toLowerCase(), value);
      }
      unsetHeader(key) {
        this.headers.delete(key.toLowerCase());
      }
      clearHeaders() {
        this.headers.clear();
      }
      async call(methodNsid, params, data, opts) {
        const def = this.lex.getDefOrThrow(methodNsid);
        if (!def || def.type !== "query" && def.type !== "procedure") {
          throw new TypeError(`Invalid lexicon: ${methodNsid}. Must be a query or procedure.`);
        }
        const reqUrl = (0, util_1.constructMethodCallUrl)(methodNsid, def, params);
        const reqMethod = (0, util_1.getMethodSchemaHTTPMethod)(def);
        const reqHeaders = (0, util_1.constructMethodCallHeaders)(def, data, opts);
        const reqBody = (0, util_1.encodeMethodCallBody)(reqHeaders, data);
        const init = {
          method: reqMethod,
          headers: (0, util_1.combineHeaders)(reqHeaders, this.headers),
          body: reqBody,
          duplex: "half",
          signal: opts?.signal
        };
        try {
          const response = await this.fetchHandler.call(void 0, reqUrl, init);
          const resStatus = response.status;
          const resHeaders = Object.fromEntries(response.headers.entries());
          const resBodyBytes = await response.arrayBuffer();
          const resBody = (0, util_1.httpResponseBodyParse)(response.headers.get("content-type"), resBodyBytes);
          const resCode = (0, types_1.httpResponseCodeToEnum)(resStatus);
          if (resCode !== types_1.ResponseType.Success) {
            const { error = void 0, message: message2 = void 0 } = resBody && (0, util_1.isErrorResponseBody)(resBody) ? resBody : {};
            throw new types_1.XRPCError(resCode, error, message2, resHeaders);
          }
          try {
            this.lex.assertValidXrpcOutput(methodNsid, resBody);
          } catch (e) {
            if (e instanceof lexicon_1.ValidationError) {
              throw new types_1.XRPCInvalidResponseError(methodNsid, e, resBody);
            }
            throw e;
          }
          return new types_1.XRPCResponse(resBody, resHeaders);
        } catch (err) {
          throw types_1.XRPCError.from(err);
        }
      }
    }
    xrpcClient.XrpcClient = XrpcClient;
    return xrpcClient;
  }
  var hasRequiredClient$1;
  function requireClient$1() {
    if (hasRequiredClient$1) return client;
    hasRequiredClient$1 = 1;
    Object.defineProperty(client, "__esModule", { value: true });
    client.ServiceClient = client.Client = void 0;
    const lexicon_1 = requireDist$2();
    const util_1 = requireUtil$3();
    const xrpc_client_1 = requireXrpcClient();
    class Client {
      constructor() {
        Object.defineProperty(this, "lex", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: new lexicon_1.Lexicons()
        });
      }
      /** @deprecated */
      get fetch() {
        throw new Error("Client.fetch is no longer supported. Use an XrpcClient instead.");
      }
      /** @deprecated */
      set fetch(_) {
        throw new Error("Client.fetch is no longer supported. Use an XrpcClient instead.");
      }
      // method calls
      //
      async call(serviceUri, methodNsid, params, data, opts) {
        return this.service(serviceUri).call(methodNsid, params, data, opts);
      }
      service(serviceUri) {
        return new ServiceClient(this, serviceUri);
      }
      // schemas
      // =
      addLexicon(doc) {
        this.lex.add(doc);
      }
      addLexicons(docs) {
        for (const doc of docs) {
          this.addLexicon(doc);
        }
      }
      removeLexicon(uri) {
        this.lex.remove(uri);
      }
    }
    client.Client = Client;
    class ServiceClient extends xrpc_client_1.XrpcClient {
      constructor(baseClient, serviceUri) {
        super(async (input, init) => {
          const headers = (0, util_1.combineHeaders)(init.headers, Object.entries(this.headers));
          return fetch(new URL(input, this.uri), { ...init, headers });
        }, baseClient.lex);
        Object.defineProperty(this, "baseClient", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: baseClient
        });
        Object.defineProperty(this, "uri", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.uri = typeof serviceUri === "string" ? new URL(serviceUri) : serviceUri;
      }
    }
    client.ServiceClient = ServiceClient;
    return client;
  }
  var hasRequiredDist$1;
  function requireDist$1() {
    if (hasRequiredDist$1) return dist;
    hasRequiredDist$1 = 1;
    (function(exports$1) {
      var __createBinding = dist && dist.__createBinding || (Object.create ? (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      }));
      var __exportStar = dist && dist.__exportStar || function(m, exports$12) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$12, p)) __createBinding(exports$12, m, p);
      };
      Object.defineProperty(exports$1, "__esModule", { value: true });
      __exportStar(requireClient$1(), exports$1);
      __exportStar(requireFetchHandler(), exports$1);
      __exportStar(requireTypes$1(), exports$1);
      __exportStar(requireUtil$3(), exports$1);
      __exportStar(requireXrpcClient(), exports$1);
      const client_1 = requireClient$1();
      const defaultInst = new client_1.Client();
      exports$1.default = defaultInst;
    })(dist);
    return dist;
  }
  var applyWrites = {};
  var hasRequiredApplyWrites;
  function requireApplyWrites() {
    if (hasRequiredApplyWrites) return applyWrites;
    hasRequiredApplyWrites = 1;
    Object.defineProperty(applyWrites, "__esModule", { value: true });
    applyWrites.InvalidSwapError = void 0;
    applyWrites.toKnownErr = toKnownErr;
    applyWrites.isCreate = isCreate;
    applyWrites.validateCreate = validateCreate;
    applyWrites.isUpdate = isUpdate;
    applyWrites.validateUpdate = validateUpdate;
    applyWrites.isDelete = isDelete;
    applyWrites.validateDelete = validateDelete;
    applyWrites.isCreateResult = isCreateResult;
    applyWrites.validateCreateResult = validateCreateResult;
    applyWrites.isUpdateResult = isUpdateResult;
    applyWrites.validateUpdateResult = validateUpdateResult;
    applyWrites.isDeleteResult = isDeleteResult;
    applyWrites.validateDeleteResult = validateDeleteResult;
    const xrpc_1 = requireDist$1();
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "com.atproto.repo.applyWrites";
    class InvalidSwapError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    applyWrites.InvalidSwapError = InvalidSwapError;
    function toKnownErr(e) {
      if (e instanceof xrpc_1.XRPCError) {
        if (e.error === "InvalidSwap")
          return new InvalidSwapError(e);
      }
      return e;
    }
    const hashCreate = "create";
    function isCreate(v) {
      return is$typed(v, id, hashCreate);
    }
    function validateCreate(v) {
      return validate(v, id, hashCreate);
    }
    const hashUpdate = "update";
    function isUpdate(v) {
      return is$typed(v, id, hashUpdate);
    }
    function validateUpdate(v) {
      return validate(v, id, hashUpdate);
    }
    const hashDelete = "delete";
    function isDelete(v) {
      return is$typed(v, id, hashDelete);
    }
    function validateDelete(v) {
      return validate(v, id, hashDelete);
    }
    const hashCreateResult = "createResult";
    function isCreateResult(v) {
      return is$typed(v, id, hashCreateResult);
    }
    function validateCreateResult(v) {
      return validate(v, id, hashCreateResult);
    }
    const hashUpdateResult = "updateResult";
    function isUpdateResult(v) {
      return is$typed(v, id, hashUpdateResult);
    }
    function validateUpdateResult(v) {
      return validate(v, id, hashUpdateResult);
    }
    const hashDeleteResult = "deleteResult";
    function isDeleteResult(v) {
      return is$typed(v, id, hashDeleteResult);
    }
    function validateDeleteResult(v) {
      return validate(v, id, hashDeleteResult);
    }
    return applyWrites;
  }
  var createRecord = {};
  var hasRequiredCreateRecord;
  function requireCreateRecord() {
    if (hasRequiredCreateRecord) return createRecord;
    hasRequiredCreateRecord = 1;
    Object.defineProperty(createRecord, "__esModule", { value: true });
    createRecord.InvalidSwapError = void 0;
    createRecord.toKnownErr = toKnownErr;
    const xrpc_1 = requireDist$1();
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    class InvalidSwapError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    createRecord.InvalidSwapError = InvalidSwapError;
    function toKnownErr(e) {
      if (e instanceof xrpc_1.XRPCError) {
        if (e.error === "InvalidSwap")
          return new InvalidSwapError(e);
      }
      return e;
    }
    return createRecord;
  }
  var deleteRecord = {};
  var hasRequiredDeleteRecord;
  function requireDeleteRecord() {
    if (hasRequiredDeleteRecord) return deleteRecord;
    hasRequiredDeleteRecord = 1;
    Object.defineProperty(deleteRecord, "__esModule", { value: true });
    deleteRecord.InvalidSwapError = void 0;
    deleteRecord.toKnownErr = toKnownErr;
    const xrpc_1 = requireDist$1();
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    class InvalidSwapError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    deleteRecord.InvalidSwapError = InvalidSwapError;
    function toKnownErr(e) {
      if (e instanceof xrpc_1.XRPCError) {
        if (e.error === "InvalidSwap")
          return new InvalidSwapError(e);
      }
      return e;
    }
    return deleteRecord;
  }
  var getRecord$2 = {};
  var hasRequiredGetRecord$2;
  function requireGetRecord$2() {
    if (hasRequiredGetRecord$2) return getRecord$2;
    hasRequiredGetRecord$2 = 1;
    Object.defineProperty(getRecord$2, "__esModule", { value: true });
    getRecord$2.RecordNotFoundError = void 0;
    getRecord$2.toKnownErr = toKnownErr;
    const xrpc_1 = requireDist$1();
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    class RecordNotFoundError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    getRecord$2.RecordNotFoundError = RecordNotFoundError;
    function toKnownErr(e) {
      if (e instanceof xrpc_1.XRPCError) {
        if (e.error === "RecordNotFound")
          return new RecordNotFoundError(e);
      }
      return e;
    }
    return getRecord$2;
  }
  var putRecord = {};
  var hasRequiredPutRecord;
  function requirePutRecord() {
    if (hasRequiredPutRecord) return putRecord;
    hasRequiredPutRecord = 1;
    Object.defineProperty(putRecord, "__esModule", { value: true });
    putRecord.InvalidSwapError = void 0;
    putRecord.toKnownErr = toKnownErr;
    const xrpc_1 = requireDist$1();
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    class InvalidSwapError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    putRecord.InvalidSwapError = InvalidSwapError;
    function toKnownErr(e) {
      if (e instanceof xrpc_1.XRPCError) {
        if (e.error === "InvalidSwap")
          return new InvalidSwapError(e);
      }
      return e;
    }
    return putRecord;
  }
  var confirmEmail = {};
  var hasRequiredConfirmEmail;
  function requireConfirmEmail() {
    if (hasRequiredConfirmEmail) return confirmEmail;
    hasRequiredConfirmEmail = 1;
    Object.defineProperty(confirmEmail, "__esModule", { value: true });
    confirmEmail.InvalidEmailError = confirmEmail.InvalidTokenError = confirmEmail.ExpiredTokenError = confirmEmail.AccountNotFoundError = void 0;
    confirmEmail.toKnownErr = toKnownErr;
    const xrpc_1 = requireDist$1();
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    class AccountNotFoundError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    confirmEmail.AccountNotFoundError = AccountNotFoundError;
    class ExpiredTokenError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    confirmEmail.ExpiredTokenError = ExpiredTokenError;
    class InvalidTokenError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    confirmEmail.InvalidTokenError = InvalidTokenError;
    class InvalidEmailError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    confirmEmail.InvalidEmailError = InvalidEmailError;
    function toKnownErr(e) {
      if (e instanceof xrpc_1.XRPCError) {
        if (e.error === "AccountNotFound")
          return new AccountNotFoundError(e);
        if (e.error === "ExpiredToken")
          return new ExpiredTokenError(e);
        if (e.error === "InvalidToken")
          return new InvalidTokenError(e);
        if (e.error === "InvalidEmail")
          return new InvalidEmailError(e);
      }
      return e;
    }
    return confirmEmail;
  }
  var createAccount = {};
  var hasRequiredCreateAccount;
  function requireCreateAccount() {
    if (hasRequiredCreateAccount) return createAccount;
    hasRequiredCreateAccount = 1;
    Object.defineProperty(createAccount, "__esModule", { value: true });
    createAccount.IncompatibleDidDocError = createAccount.UnresolvableDidError = createAccount.UnsupportedDomainError = createAccount.HandleNotAvailableError = createAccount.InvalidInviteCodeError = createAccount.InvalidPasswordError = createAccount.InvalidHandleError = void 0;
    createAccount.toKnownErr = toKnownErr;
    const xrpc_1 = requireDist$1();
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    class InvalidHandleError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    createAccount.InvalidHandleError = InvalidHandleError;
    class InvalidPasswordError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    createAccount.InvalidPasswordError = InvalidPasswordError;
    class InvalidInviteCodeError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    createAccount.InvalidInviteCodeError = InvalidInviteCodeError;
    class HandleNotAvailableError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    createAccount.HandleNotAvailableError = HandleNotAvailableError;
    class UnsupportedDomainError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    createAccount.UnsupportedDomainError = UnsupportedDomainError;
    class UnresolvableDidError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    createAccount.UnresolvableDidError = UnresolvableDidError;
    class IncompatibleDidDocError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    createAccount.IncompatibleDidDocError = IncompatibleDidDocError;
    function toKnownErr(e) {
      if (e instanceof xrpc_1.XRPCError) {
        if (e.error === "InvalidHandle")
          return new InvalidHandleError(e);
        if (e.error === "InvalidPassword")
          return new InvalidPasswordError(e);
        if (e.error === "InvalidInviteCode")
          return new InvalidInviteCodeError(e);
        if (e.error === "HandleNotAvailable")
          return new HandleNotAvailableError(e);
        if (e.error === "UnsupportedDomain")
          return new UnsupportedDomainError(e);
        if (e.error === "UnresolvableDid")
          return new UnresolvableDidError(e);
        if (e.error === "IncompatibleDidDoc")
          return new IncompatibleDidDocError(e);
      }
      return e;
    }
    return createAccount;
  }
  var createAppPassword = {};
  var hasRequiredCreateAppPassword;
  function requireCreateAppPassword() {
    if (hasRequiredCreateAppPassword) return createAppPassword;
    hasRequiredCreateAppPassword = 1;
    Object.defineProperty(createAppPassword, "__esModule", { value: true });
    createAppPassword.AccountTakedownError = void 0;
    createAppPassword.toKnownErr = toKnownErr;
    createAppPassword.isAppPassword = isAppPassword;
    createAppPassword.validateAppPassword = validateAppPassword;
    const xrpc_1 = requireDist$1();
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "com.atproto.server.createAppPassword";
    class AccountTakedownError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    createAppPassword.AccountTakedownError = AccountTakedownError;
    function toKnownErr(e) {
      if (e instanceof xrpc_1.XRPCError) {
        if (e.error === "AccountTakedown")
          return new AccountTakedownError(e);
      }
      return e;
    }
    const hashAppPassword = "appPassword";
    function isAppPassword(v) {
      return is$typed(v, id, hashAppPassword);
    }
    function validateAppPassword(v) {
      return validate(v, id, hashAppPassword);
    }
    return createAppPassword;
  }
  var createSession = {};
  var hasRequiredCreateSession;
  function requireCreateSession() {
    if (hasRequiredCreateSession) return createSession;
    hasRequiredCreateSession = 1;
    Object.defineProperty(createSession, "__esModule", { value: true });
    createSession.AuthFactorTokenRequiredError = createSession.AccountTakedownError = void 0;
    createSession.toKnownErr = toKnownErr;
    const xrpc_1 = requireDist$1();
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    class AccountTakedownError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    createSession.AccountTakedownError = AccountTakedownError;
    class AuthFactorTokenRequiredError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    createSession.AuthFactorTokenRequiredError = AuthFactorTokenRequiredError;
    function toKnownErr(e) {
      if (e instanceof xrpc_1.XRPCError) {
        if (e.error === "AccountTakedown")
          return new AccountTakedownError(e);
        if (e.error === "AuthFactorTokenRequired")
          return new AuthFactorTokenRequiredError(e);
      }
      return e;
    }
    return createSession;
  }
  var deleteAccount$2 = {};
  var hasRequiredDeleteAccount$2;
  function requireDeleteAccount$2() {
    if (hasRequiredDeleteAccount$2) return deleteAccount$2;
    hasRequiredDeleteAccount$2 = 1;
    Object.defineProperty(deleteAccount$2, "__esModule", { value: true });
    deleteAccount$2.InvalidTokenError = deleteAccount$2.ExpiredTokenError = void 0;
    deleteAccount$2.toKnownErr = toKnownErr;
    const xrpc_1 = requireDist$1();
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    class ExpiredTokenError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    deleteAccount$2.ExpiredTokenError = ExpiredTokenError;
    class InvalidTokenError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    deleteAccount$2.InvalidTokenError = InvalidTokenError;
    function toKnownErr(e) {
      if (e instanceof xrpc_1.XRPCError) {
        if (e.error === "ExpiredToken")
          return new ExpiredTokenError(e);
        if (e.error === "InvalidToken")
          return new InvalidTokenError(e);
      }
      return e;
    }
    return deleteAccount$2;
  }
  var getAccountInviteCodes = {};
  var hasRequiredGetAccountInviteCodes;
  function requireGetAccountInviteCodes() {
    if (hasRequiredGetAccountInviteCodes) return getAccountInviteCodes;
    hasRequiredGetAccountInviteCodes = 1;
    Object.defineProperty(getAccountInviteCodes, "__esModule", { value: true });
    getAccountInviteCodes.DuplicateCreateError = void 0;
    getAccountInviteCodes.toKnownErr = toKnownErr;
    const xrpc_1 = requireDist$1();
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    class DuplicateCreateError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    getAccountInviteCodes.DuplicateCreateError = DuplicateCreateError;
    function toKnownErr(e) {
      if (e instanceof xrpc_1.XRPCError) {
        if (e.error === "DuplicateCreate")
          return new DuplicateCreateError(e);
      }
      return e;
    }
    return getAccountInviteCodes;
  }
  var getServiceAuth = {};
  var hasRequiredGetServiceAuth;
  function requireGetServiceAuth() {
    if (hasRequiredGetServiceAuth) return getServiceAuth;
    hasRequiredGetServiceAuth = 1;
    Object.defineProperty(getServiceAuth, "__esModule", { value: true });
    getServiceAuth.BadExpirationError = void 0;
    getServiceAuth.toKnownErr = toKnownErr;
    const xrpc_1 = requireDist$1();
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    class BadExpirationError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    getServiceAuth.BadExpirationError = BadExpirationError;
    function toKnownErr(e) {
      if (e instanceof xrpc_1.XRPCError) {
        if (e.error === "BadExpiration")
          return new BadExpirationError(e);
      }
      return e;
    }
    return getServiceAuth;
  }
  var listAppPasswords = {};
  var hasRequiredListAppPasswords;
  function requireListAppPasswords() {
    if (hasRequiredListAppPasswords) return listAppPasswords;
    hasRequiredListAppPasswords = 1;
    Object.defineProperty(listAppPasswords, "__esModule", { value: true });
    listAppPasswords.AccountTakedownError = void 0;
    listAppPasswords.toKnownErr = toKnownErr;
    listAppPasswords.isAppPassword = isAppPassword;
    listAppPasswords.validateAppPassword = validateAppPassword;
    const xrpc_1 = requireDist$1();
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "com.atproto.server.listAppPasswords";
    class AccountTakedownError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    listAppPasswords.AccountTakedownError = AccountTakedownError;
    function toKnownErr(e) {
      if (e instanceof xrpc_1.XRPCError) {
        if (e.error === "AccountTakedown")
          return new AccountTakedownError(e);
      }
      return e;
    }
    const hashAppPassword = "appPassword";
    function isAppPassword(v) {
      return is$typed(v, id, hashAppPassword);
    }
    function validateAppPassword(v) {
      return validate(v, id, hashAppPassword);
    }
    return listAppPasswords;
  }
  var refreshSession = {};
  var hasRequiredRefreshSession;
  function requireRefreshSession() {
    if (hasRequiredRefreshSession) return refreshSession;
    hasRequiredRefreshSession = 1;
    Object.defineProperty(refreshSession, "__esModule", { value: true });
    refreshSession.AccountTakedownError = void 0;
    refreshSession.toKnownErr = toKnownErr;
    const xrpc_1 = requireDist$1();
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    class AccountTakedownError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    refreshSession.AccountTakedownError = AccountTakedownError;
    function toKnownErr(e) {
      if (e instanceof xrpc_1.XRPCError) {
        if (e.error === "AccountTakedown")
          return new AccountTakedownError(e);
      }
      return e;
    }
    return refreshSession;
  }
  var resetPassword = {};
  var hasRequiredResetPassword;
  function requireResetPassword() {
    if (hasRequiredResetPassword) return resetPassword;
    hasRequiredResetPassword = 1;
    Object.defineProperty(resetPassword, "__esModule", { value: true });
    resetPassword.InvalidTokenError = resetPassword.ExpiredTokenError = void 0;
    resetPassword.toKnownErr = toKnownErr;
    const xrpc_1 = requireDist$1();
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    class ExpiredTokenError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    resetPassword.ExpiredTokenError = ExpiredTokenError;
    class InvalidTokenError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    resetPassword.InvalidTokenError = InvalidTokenError;
    function toKnownErr(e) {
      if (e instanceof xrpc_1.XRPCError) {
        if (e.error === "ExpiredToken")
          return new ExpiredTokenError(e);
        if (e.error === "InvalidToken")
          return new InvalidTokenError(e);
      }
      return e;
    }
    return resetPassword;
  }
  var updateEmail = {};
  var hasRequiredUpdateEmail;
  function requireUpdateEmail() {
    if (hasRequiredUpdateEmail) return updateEmail;
    hasRequiredUpdateEmail = 1;
    Object.defineProperty(updateEmail, "__esModule", { value: true });
    updateEmail.TokenRequiredError = updateEmail.InvalidTokenError = updateEmail.ExpiredTokenError = void 0;
    updateEmail.toKnownErr = toKnownErr;
    const xrpc_1 = requireDist$1();
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    class ExpiredTokenError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    updateEmail.ExpiredTokenError = ExpiredTokenError;
    class InvalidTokenError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    updateEmail.InvalidTokenError = InvalidTokenError;
    class TokenRequiredError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    updateEmail.TokenRequiredError = TokenRequiredError;
    function toKnownErr(e) {
      if (e instanceof xrpc_1.XRPCError) {
        if (e.error === "ExpiredToken")
          return new ExpiredTokenError(e);
        if (e.error === "InvalidToken")
          return new InvalidTokenError(e);
        if (e.error === "TokenRequired")
          return new TokenRequiredError(e);
      }
      return e;
    }
    return updateEmail;
  }
  var getBlob = {};
  var hasRequiredGetBlob;
  function requireGetBlob() {
    if (hasRequiredGetBlob) return getBlob;
    hasRequiredGetBlob = 1;
    Object.defineProperty(getBlob, "__esModule", { value: true });
    getBlob.RepoDeactivatedError = getBlob.RepoSuspendedError = getBlob.RepoTakendownError = getBlob.RepoNotFoundError = getBlob.BlobNotFoundError = void 0;
    getBlob.toKnownErr = toKnownErr;
    const xrpc_1 = requireDist$1();
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    class BlobNotFoundError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    getBlob.BlobNotFoundError = BlobNotFoundError;
    class RepoNotFoundError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    getBlob.RepoNotFoundError = RepoNotFoundError;
    class RepoTakendownError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    getBlob.RepoTakendownError = RepoTakendownError;
    class RepoSuspendedError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    getBlob.RepoSuspendedError = RepoSuspendedError;
    class RepoDeactivatedError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    getBlob.RepoDeactivatedError = RepoDeactivatedError;
    function toKnownErr(e) {
      if (e instanceof xrpc_1.XRPCError) {
        if (e.error === "BlobNotFound")
          return new BlobNotFoundError(e);
        if (e.error === "RepoNotFound")
          return new RepoNotFoundError(e);
        if (e.error === "RepoTakendown")
          return new RepoTakendownError(e);
        if (e.error === "RepoSuspended")
          return new RepoSuspendedError(e);
        if (e.error === "RepoDeactivated")
          return new RepoDeactivatedError(e);
      }
      return e;
    }
    return getBlob;
  }
  var getBlocks$1 = {};
  var hasRequiredGetBlocks$1;
  function requireGetBlocks$1() {
    if (hasRequiredGetBlocks$1) return getBlocks$1;
    hasRequiredGetBlocks$1 = 1;
    Object.defineProperty(getBlocks$1, "__esModule", { value: true });
    getBlocks$1.RepoDeactivatedError = getBlocks$1.RepoSuspendedError = getBlocks$1.RepoTakendownError = getBlocks$1.RepoNotFoundError = getBlocks$1.BlockNotFoundError = void 0;
    getBlocks$1.toKnownErr = toKnownErr;
    const xrpc_1 = requireDist$1();
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    class BlockNotFoundError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    getBlocks$1.BlockNotFoundError = BlockNotFoundError;
    class RepoNotFoundError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    getBlocks$1.RepoNotFoundError = RepoNotFoundError;
    class RepoTakendownError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    getBlocks$1.RepoTakendownError = RepoTakendownError;
    class RepoSuspendedError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    getBlocks$1.RepoSuspendedError = RepoSuspendedError;
    class RepoDeactivatedError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    getBlocks$1.RepoDeactivatedError = RepoDeactivatedError;
    function toKnownErr(e) {
      if (e instanceof xrpc_1.XRPCError) {
        if (e.error === "BlockNotFound")
          return new BlockNotFoundError(e);
        if (e.error === "RepoNotFound")
          return new RepoNotFoundError(e);
        if (e.error === "RepoTakendown")
          return new RepoTakendownError(e);
        if (e.error === "RepoSuspended")
          return new RepoSuspendedError(e);
        if (e.error === "RepoDeactivated")
          return new RepoDeactivatedError(e);
      }
      return e;
    }
    return getBlocks$1;
  }
  var getHead = {};
  var hasRequiredGetHead;
  function requireGetHead() {
    if (hasRequiredGetHead) return getHead;
    hasRequiredGetHead = 1;
    Object.defineProperty(getHead, "__esModule", { value: true });
    getHead.HeadNotFoundError = void 0;
    getHead.toKnownErr = toKnownErr;
    const xrpc_1 = requireDist$1();
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    class HeadNotFoundError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    getHead.HeadNotFoundError = HeadNotFoundError;
    function toKnownErr(e) {
      if (e instanceof xrpc_1.XRPCError) {
        if (e.error === "HeadNotFound")
          return new HeadNotFoundError(e);
      }
      return e;
    }
    return getHead;
  }
  var getLatestCommit = {};
  var hasRequiredGetLatestCommit;
  function requireGetLatestCommit() {
    if (hasRequiredGetLatestCommit) return getLatestCommit;
    hasRequiredGetLatestCommit = 1;
    Object.defineProperty(getLatestCommit, "__esModule", { value: true });
    getLatestCommit.RepoDeactivatedError = getLatestCommit.RepoSuspendedError = getLatestCommit.RepoTakendownError = getLatestCommit.RepoNotFoundError = void 0;
    getLatestCommit.toKnownErr = toKnownErr;
    const xrpc_1 = requireDist$1();
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    class RepoNotFoundError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    getLatestCommit.RepoNotFoundError = RepoNotFoundError;
    class RepoTakendownError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    getLatestCommit.RepoTakendownError = RepoTakendownError;
    class RepoSuspendedError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    getLatestCommit.RepoSuspendedError = RepoSuspendedError;
    class RepoDeactivatedError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    getLatestCommit.RepoDeactivatedError = RepoDeactivatedError;
    function toKnownErr(e) {
      if (e instanceof xrpc_1.XRPCError) {
        if (e.error === "RepoNotFound")
          return new RepoNotFoundError(e);
        if (e.error === "RepoTakendown")
          return new RepoTakendownError(e);
        if (e.error === "RepoSuspended")
          return new RepoSuspendedError(e);
        if (e.error === "RepoDeactivated")
          return new RepoDeactivatedError(e);
      }
      return e;
    }
    return getLatestCommit;
  }
  var getRecord$1 = {};
  var hasRequiredGetRecord$1;
  function requireGetRecord$1() {
    if (hasRequiredGetRecord$1) return getRecord$1;
    hasRequiredGetRecord$1 = 1;
    Object.defineProperty(getRecord$1, "__esModule", { value: true });
    getRecord$1.RepoDeactivatedError = getRecord$1.RepoSuspendedError = getRecord$1.RepoTakendownError = getRecord$1.RepoNotFoundError = getRecord$1.RecordNotFoundError = void 0;
    getRecord$1.toKnownErr = toKnownErr;
    const xrpc_1 = requireDist$1();
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    class RecordNotFoundError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    getRecord$1.RecordNotFoundError = RecordNotFoundError;
    class RepoNotFoundError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    getRecord$1.RepoNotFoundError = RepoNotFoundError;
    class RepoTakendownError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    getRecord$1.RepoTakendownError = RepoTakendownError;
    class RepoSuspendedError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    getRecord$1.RepoSuspendedError = RepoSuspendedError;
    class RepoDeactivatedError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    getRecord$1.RepoDeactivatedError = RepoDeactivatedError;
    function toKnownErr(e) {
      if (e instanceof xrpc_1.XRPCError) {
        if (e.error === "RecordNotFound")
          return new RecordNotFoundError(e);
        if (e.error === "RepoNotFound")
          return new RepoNotFoundError(e);
        if (e.error === "RepoTakendown")
          return new RepoTakendownError(e);
        if (e.error === "RepoSuspended")
          return new RepoSuspendedError(e);
        if (e.error === "RepoDeactivated")
          return new RepoDeactivatedError(e);
      }
      return e;
    }
    return getRecord$1;
  }
  var getRepo$1 = {};
  var hasRequiredGetRepo$1;
  function requireGetRepo$1() {
    if (hasRequiredGetRepo$1) return getRepo$1;
    hasRequiredGetRepo$1 = 1;
    Object.defineProperty(getRepo$1, "__esModule", { value: true });
    getRepo$1.RepoDeactivatedError = getRepo$1.RepoSuspendedError = getRepo$1.RepoTakendownError = getRepo$1.RepoNotFoundError = void 0;
    getRepo$1.toKnownErr = toKnownErr;
    const xrpc_1 = requireDist$1();
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    class RepoNotFoundError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    getRepo$1.RepoNotFoundError = RepoNotFoundError;
    class RepoTakendownError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    getRepo$1.RepoTakendownError = RepoTakendownError;
    class RepoSuspendedError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    getRepo$1.RepoSuspendedError = RepoSuspendedError;
    class RepoDeactivatedError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    getRepo$1.RepoDeactivatedError = RepoDeactivatedError;
    function toKnownErr(e) {
      if (e instanceof xrpc_1.XRPCError) {
        if (e.error === "RepoNotFound")
          return new RepoNotFoundError(e);
        if (e.error === "RepoTakendown")
          return new RepoTakendownError(e);
        if (e.error === "RepoSuspended")
          return new RepoSuspendedError(e);
        if (e.error === "RepoDeactivated")
          return new RepoDeactivatedError(e);
      }
      return e;
    }
    return getRepo$1;
  }
  var getRepoStatus = {};
  var hasRequiredGetRepoStatus;
  function requireGetRepoStatus() {
    if (hasRequiredGetRepoStatus) return getRepoStatus;
    hasRequiredGetRepoStatus = 1;
    Object.defineProperty(getRepoStatus, "__esModule", { value: true });
    getRepoStatus.RepoNotFoundError = void 0;
    getRepoStatus.toKnownErr = toKnownErr;
    const xrpc_1 = requireDist$1();
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    class RepoNotFoundError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    getRepoStatus.RepoNotFoundError = RepoNotFoundError;
    function toKnownErr(e) {
      if (e instanceof xrpc_1.XRPCError) {
        if (e.error === "RepoNotFound")
          return new RepoNotFoundError(e);
      }
      return e;
    }
    return getRepoStatus;
  }
  var listBlobs = {};
  var hasRequiredListBlobs;
  function requireListBlobs() {
    if (hasRequiredListBlobs) return listBlobs;
    hasRequiredListBlobs = 1;
    Object.defineProperty(listBlobs, "__esModule", { value: true });
    listBlobs.RepoDeactivatedError = listBlobs.RepoSuspendedError = listBlobs.RepoTakendownError = listBlobs.RepoNotFoundError = void 0;
    listBlobs.toKnownErr = toKnownErr;
    const xrpc_1 = requireDist$1();
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    class RepoNotFoundError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    listBlobs.RepoNotFoundError = RepoNotFoundError;
    class RepoTakendownError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    listBlobs.RepoTakendownError = RepoTakendownError;
    class RepoSuspendedError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    listBlobs.RepoSuspendedError = RepoSuspendedError;
    class RepoDeactivatedError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    listBlobs.RepoDeactivatedError = RepoDeactivatedError;
    function toKnownErr(e) {
      if (e instanceof xrpc_1.XRPCError) {
        if (e.error === "RepoNotFound")
          return new RepoNotFoundError(e);
        if (e.error === "RepoTakendown")
          return new RepoTakendownError(e);
        if (e.error === "RepoSuspended")
          return new RepoSuspendedError(e);
        if (e.error === "RepoDeactivated")
          return new RepoDeactivatedError(e);
      }
      return e;
    }
    return listBlobs;
  }
  var getActorLikes = {};
  var hasRequiredGetActorLikes;
  function requireGetActorLikes() {
    if (hasRequiredGetActorLikes) return getActorLikes;
    hasRequiredGetActorLikes = 1;
    Object.defineProperty(getActorLikes, "__esModule", { value: true });
    getActorLikes.BlockedByActorError = getActorLikes.BlockedActorError = void 0;
    getActorLikes.toKnownErr = toKnownErr;
    const xrpc_1 = requireDist$1();
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    class BlockedActorError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    getActorLikes.BlockedActorError = BlockedActorError;
    class BlockedByActorError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    getActorLikes.BlockedByActorError = BlockedByActorError;
    function toKnownErr(e) {
      if (e instanceof xrpc_1.XRPCError) {
        if (e.error === "BlockedActor")
          return new BlockedActorError(e);
        if (e.error === "BlockedByActor")
          return new BlockedByActorError(e);
      }
      return e;
    }
    return getActorLikes;
  }
  var getAuthorFeed = {};
  var hasRequiredGetAuthorFeed;
  function requireGetAuthorFeed() {
    if (hasRequiredGetAuthorFeed) return getAuthorFeed;
    hasRequiredGetAuthorFeed = 1;
    Object.defineProperty(getAuthorFeed, "__esModule", { value: true });
    getAuthorFeed.BlockedByActorError = getAuthorFeed.BlockedActorError = void 0;
    getAuthorFeed.toKnownErr = toKnownErr;
    const xrpc_1 = requireDist$1();
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    class BlockedActorError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    getAuthorFeed.BlockedActorError = BlockedActorError;
    class BlockedByActorError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    getAuthorFeed.BlockedByActorError = BlockedByActorError;
    function toKnownErr(e) {
      if (e instanceof xrpc_1.XRPCError) {
        if (e.error === "BlockedActor")
          return new BlockedActorError(e);
        if (e.error === "BlockedByActor")
          return new BlockedByActorError(e);
      }
      return e;
    }
    return getAuthorFeed;
  }
  var getFeed = {};
  var hasRequiredGetFeed;
  function requireGetFeed() {
    if (hasRequiredGetFeed) return getFeed;
    hasRequiredGetFeed = 1;
    Object.defineProperty(getFeed, "__esModule", { value: true });
    getFeed.UnknownFeedError = void 0;
    getFeed.toKnownErr = toKnownErr;
    const xrpc_1 = requireDist$1();
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    class UnknownFeedError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    getFeed.UnknownFeedError = UnknownFeedError;
    function toKnownErr(e) {
      if (e instanceof xrpc_1.XRPCError) {
        if (e.error === "UnknownFeed")
          return new UnknownFeedError(e);
      }
      return e;
    }
    return getFeed;
  }
  var getFeedSkeleton = {};
  var hasRequiredGetFeedSkeleton;
  function requireGetFeedSkeleton() {
    if (hasRequiredGetFeedSkeleton) return getFeedSkeleton;
    hasRequiredGetFeedSkeleton = 1;
    Object.defineProperty(getFeedSkeleton, "__esModule", { value: true });
    getFeedSkeleton.UnknownFeedError = void 0;
    getFeedSkeleton.toKnownErr = toKnownErr;
    const xrpc_1 = requireDist$1();
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    class UnknownFeedError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    getFeedSkeleton.UnknownFeedError = UnknownFeedError;
    function toKnownErr(e) {
      if (e instanceof xrpc_1.XRPCError) {
        if (e.error === "UnknownFeed")
          return new UnknownFeedError(e);
      }
      return e;
    }
    return getFeedSkeleton;
  }
  var getListFeed = {};
  var hasRequiredGetListFeed;
  function requireGetListFeed() {
    if (hasRequiredGetListFeed) return getListFeed;
    hasRequiredGetListFeed = 1;
    Object.defineProperty(getListFeed, "__esModule", { value: true });
    getListFeed.UnknownListError = void 0;
    getListFeed.toKnownErr = toKnownErr;
    const xrpc_1 = requireDist$1();
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    class UnknownListError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    getListFeed.UnknownListError = UnknownListError;
    function toKnownErr(e) {
      if (e instanceof xrpc_1.XRPCError) {
        if (e.error === "UnknownList")
          return new UnknownListError(e);
      }
      return e;
    }
    return getListFeed;
  }
  var getPostThread = {};
  var hasRequiredGetPostThread;
  function requireGetPostThread() {
    if (hasRequiredGetPostThread) return getPostThread;
    hasRequiredGetPostThread = 1;
    Object.defineProperty(getPostThread, "__esModule", { value: true });
    getPostThread.NotFoundError = void 0;
    getPostThread.toKnownErr = toKnownErr;
    const xrpc_1 = requireDist$1();
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    class NotFoundError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    getPostThread.NotFoundError = NotFoundError;
    function toKnownErr(e) {
      if (e instanceof xrpc_1.XRPCError) {
        if (e.error === "NotFound")
          return new NotFoundError(e);
      }
      return e;
    }
    return getPostThread;
  }
  var searchPosts = {};
  var hasRequiredSearchPosts;
  function requireSearchPosts() {
    if (hasRequiredSearchPosts) return searchPosts;
    hasRequiredSearchPosts = 1;
    Object.defineProperty(searchPosts, "__esModule", { value: true });
    searchPosts.BadQueryStringError = void 0;
    searchPosts.toKnownErr = toKnownErr;
    const xrpc_1 = requireDist$1();
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    class BadQueryStringError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    searchPosts.BadQueryStringError = BadQueryStringError;
    function toKnownErr(e) {
      if (e instanceof xrpc_1.XRPCError) {
        if (e.error === "BadQueryString")
          return new BadQueryStringError(e);
      }
      return e;
    }
    return searchPosts;
  }
  var getRelationships = {};
  var hasRequiredGetRelationships;
  function requireGetRelationships() {
    if (hasRequiredGetRelationships) return getRelationships;
    hasRequiredGetRelationships = 1;
    Object.defineProperty(getRelationships, "__esModule", { value: true });
    getRelationships.ActorNotFoundError = void 0;
    getRelationships.toKnownErr = toKnownErr;
    const xrpc_1 = requireDist$1();
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    class ActorNotFoundError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    getRelationships.ActorNotFoundError = ActorNotFoundError;
    function toKnownErr(e) {
      if (e instanceof xrpc_1.XRPCError) {
        if (e.error === "ActorNotFound")
          return new ActorNotFoundError(e);
      }
      return e;
    }
    return getRelationships;
  }
  var searchActorsSkeleton = {};
  var hasRequiredSearchActorsSkeleton;
  function requireSearchActorsSkeleton() {
    if (hasRequiredSearchActorsSkeleton) return searchActorsSkeleton;
    hasRequiredSearchActorsSkeleton = 1;
    Object.defineProperty(searchActorsSkeleton, "__esModule", { value: true });
    searchActorsSkeleton.BadQueryStringError = void 0;
    searchActorsSkeleton.toKnownErr = toKnownErr;
    const xrpc_1 = requireDist$1();
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    class BadQueryStringError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    searchActorsSkeleton.BadQueryStringError = BadQueryStringError;
    function toKnownErr(e) {
      if (e instanceof xrpc_1.XRPCError) {
        if (e.error === "BadQueryString")
          return new BadQueryStringError(e);
      }
      return e;
    }
    return searchActorsSkeleton;
  }
  var searchPostsSkeleton = {};
  var hasRequiredSearchPostsSkeleton;
  function requireSearchPostsSkeleton() {
    if (hasRequiredSearchPostsSkeleton) return searchPostsSkeleton;
    hasRequiredSearchPostsSkeleton = 1;
    Object.defineProperty(searchPostsSkeleton, "__esModule", { value: true });
    searchPostsSkeleton.BadQueryStringError = void 0;
    searchPostsSkeleton.toKnownErr = toKnownErr;
    const xrpc_1 = requireDist$1();
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    class BadQueryStringError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    searchPostsSkeleton.BadQueryStringError = BadQueryStringError;
    function toKnownErr(e) {
      if (e instanceof xrpc_1.XRPCError) {
        if (e.error === "BadQueryString")
          return new BadQueryStringError(e);
      }
      return e;
    }
    return searchPostsSkeleton;
  }
  var searchStarterPacksSkeleton = {};
  var hasRequiredSearchStarterPacksSkeleton;
  function requireSearchStarterPacksSkeleton() {
    if (hasRequiredSearchStarterPacksSkeleton) return searchStarterPacksSkeleton;
    hasRequiredSearchStarterPacksSkeleton = 1;
    Object.defineProperty(searchStarterPacksSkeleton, "__esModule", { value: true });
    searchStarterPacksSkeleton.BadQueryStringError = void 0;
    searchStarterPacksSkeleton.toKnownErr = toKnownErr;
    const xrpc_1 = requireDist$1();
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    class BadQueryStringError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    searchStarterPacksSkeleton.BadQueryStringError = BadQueryStringError;
    function toKnownErr(e) {
      if (e instanceof xrpc_1.XRPCError) {
        if (e.error === "BadQueryString")
          return new BadQueryStringError(e);
      }
      return e;
    }
    return searchStarterPacksSkeleton;
  }
  var createTemplate = {};
  var hasRequiredCreateTemplate;
  function requireCreateTemplate() {
    if (hasRequiredCreateTemplate) return createTemplate;
    hasRequiredCreateTemplate = 1;
    Object.defineProperty(createTemplate, "__esModule", { value: true });
    createTemplate.DuplicateTemplateNameError = void 0;
    createTemplate.toKnownErr = toKnownErr;
    const xrpc_1 = requireDist$1();
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    class DuplicateTemplateNameError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    createTemplate.DuplicateTemplateNameError = DuplicateTemplateNameError;
    function toKnownErr(e) {
      if (e instanceof xrpc_1.XRPCError) {
        if (e.error === "DuplicateTemplateName")
          return new DuplicateTemplateNameError(e);
      }
      return e;
    }
    return createTemplate;
  }
  var updateTemplate = {};
  var hasRequiredUpdateTemplate;
  function requireUpdateTemplate() {
    if (hasRequiredUpdateTemplate) return updateTemplate;
    hasRequiredUpdateTemplate = 1;
    Object.defineProperty(updateTemplate, "__esModule", { value: true });
    updateTemplate.DuplicateTemplateNameError = void 0;
    updateTemplate.toKnownErr = toKnownErr;
    const xrpc_1 = requireDist$1();
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    class DuplicateTemplateNameError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    updateTemplate.DuplicateTemplateNameError = DuplicateTemplateNameError;
    function toKnownErr(e) {
      if (e instanceof xrpc_1.XRPCError) {
        if (e.error === "DuplicateTemplateName")
          return new DuplicateTemplateNameError(e);
      }
      return e;
    }
    return updateTemplate;
  }
  var emitEvent = {};
  var hasRequiredEmitEvent;
  function requireEmitEvent() {
    if (hasRequiredEmitEvent) return emitEvent;
    hasRequiredEmitEvent = 1;
    Object.defineProperty(emitEvent, "__esModule", { value: true });
    emitEvent.SubjectHasActionError = void 0;
    emitEvent.toKnownErr = toKnownErr;
    const xrpc_1 = requireDist$1();
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    class SubjectHasActionError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    emitEvent.SubjectHasActionError = SubjectHasActionError;
    function toKnownErr(e) {
      if (e instanceof xrpc_1.XRPCError) {
        if (e.error === "SubjectHasAction")
          return new SubjectHasActionError(e);
      }
      return e;
    }
    return emitEvent;
  }
  var getRecord = {};
  var hasRequiredGetRecord;
  function requireGetRecord() {
    if (hasRequiredGetRecord) return getRecord;
    hasRequiredGetRecord = 1;
    Object.defineProperty(getRecord, "__esModule", { value: true });
    getRecord.RecordNotFoundError = void 0;
    getRecord.toKnownErr = toKnownErr;
    const xrpc_1 = requireDist$1();
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    class RecordNotFoundError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    getRecord.RecordNotFoundError = RecordNotFoundError;
    function toKnownErr(e) {
      if (e instanceof xrpc_1.XRPCError) {
        if (e.error === "RecordNotFound")
          return new RecordNotFoundError(e);
      }
      return e;
    }
    return getRecord;
  }
  var getRepo = {};
  var hasRequiredGetRepo;
  function requireGetRepo() {
    if (hasRequiredGetRepo) return getRepo;
    hasRequiredGetRepo = 1;
    Object.defineProperty(getRepo, "__esModule", { value: true });
    getRepo.RepoNotFoundError = void 0;
    getRepo.toKnownErr = toKnownErr;
    const xrpc_1 = requireDist$1();
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    class RepoNotFoundError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    getRepo.RepoNotFoundError = RepoNotFoundError;
    function toKnownErr(e) {
      if (e instanceof xrpc_1.XRPCError) {
        if (e.error === "RepoNotFound")
          return new RepoNotFoundError(e);
      }
      return e;
    }
    return getRepo;
  }
  var deleteSet = {};
  var hasRequiredDeleteSet;
  function requireDeleteSet() {
    if (hasRequiredDeleteSet) return deleteSet;
    hasRequiredDeleteSet = 1;
    Object.defineProperty(deleteSet, "__esModule", { value: true });
    deleteSet.SetNotFoundError = void 0;
    deleteSet.toKnownErr = toKnownErr;
    const xrpc_1 = requireDist$1();
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    class SetNotFoundError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    deleteSet.SetNotFoundError = SetNotFoundError;
    function toKnownErr(e) {
      if (e instanceof xrpc_1.XRPCError) {
        if (e.error === "SetNotFound")
          return new SetNotFoundError(e);
      }
      return e;
    }
    return deleteSet;
  }
  var deleteValues = {};
  var hasRequiredDeleteValues;
  function requireDeleteValues() {
    if (hasRequiredDeleteValues) return deleteValues;
    hasRequiredDeleteValues = 1;
    Object.defineProperty(deleteValues, "__esModule", { value: true });
    deleteValues.SetNotFoundError = void 0;
    deleteValues.toKnownErr = toKnownErr;
    const xrpc_1 = requireDist$1();
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    class SetNotFoundError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    deleteValues.SetNotFoundError = SetNotFoundError;
    function toKnownErr(e) {
      if (e instanceof xrpc_1.XRPCError) {
        if (e.error === "SetNotFound")
          return new SetNotFoundError(e);
      }
      return e;
    }
    return deleteValues;
  }
  var getValues = {};
  var hasRequiredGetValues;
  function requireGetValues() {
    if (hasRequiredGetValues) return getValues;
    hasRequiredGetValues = 1;
    Object.defineProperty(getValues, "__esModule", { value: true });
    getValues.SetNotFoundError = void 0;
    getValues.toKnownErr = toKnownErr;
    const xrpc_1 = requireDist$1();
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    class SetNotFoundError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    getValues.SetNotFoundError = SetNotFoundError;
    function toKnownErr(e) {
      if (e instanceof xrpc_1.XRPCError) {
        if (e.error === "SetNotFound")
          return new SetNotFoundError(e);
      }
      return e;
    }
    return getValues;
  }
  var addMember = {};
  var hasRequiredAddMember;
  function requireAddMember() {
    if (hasRequiredAddMember) return addMember;
    hasRequiredAddMember = 1;
    Object.defineProperty(addMember, "__esModule", { value: true });
    addMember.MemberAlreadyExistsError = void 0;
    addMember.toKnownErr = toKnownErr;
    const xrpc_1 = requireDist$1();
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    class MemberAlreadyExistsError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    addMember.MemberAlreadyExistsError = MemberAlreadyExistsError;
    function toKnownErr(e) {
      if (e instanceof xrpc_1.XRPCError) {
        if (e.error === "MemberAlreadyExists")
          return new MemberAlreadyExistsError(e);
      }
      return e;
    }
    return addMember;
  }
  var deleteMember = {};
  var hasRequiredDeleteMember;
  function requireDeleteMember() {
    if (hasRequiredDeleteMember) return deleteMember;
    hasRequiredDeleteMember = 1;
    Object.defineProperty(deleteMember, "__esModule", { value: true });
    deleteMember.CannotDeleteSelfError = deleteMember.MemberNotFoundError = void 0;
    deleteMember.toKnownErr = toKnownErr;
    const xrpc_1 = requireDist$1();
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    class MemberNotFoundError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    deleteMember.MemberNotFoundError = MemberNotFoundError;
    class CannotDeleteSelfError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    deleteMember.CannotDeleteSelfError = CannotDeleteSelfError;
    function toKnownErr(e) {
      if (e instanceof xrpc_1.XRPCError) {
        if (e.error === "MemberNotFound")
          return new MemberNotFoundError(e);
        if (e.error === "CannotDeleteSelf")
          return new CannotDeleteSelfError(e);
      }
      return e;
    }
    return deleteMember;
  }
  var updateMember = {};
  var hasRequiredUpdateMember;
  function requireUpdateMember() {
    if (hasRequiredUpdateMember) return updateMember;
    hasRequiredUpdateMember = 1;
    Object.defineProperty(updateMember, "__esModule", { value: true });
    updateMember.MemberNotFoundError = void 0;
    updateMember.toKnownErr = toKnownErr;
    const xrpc_1 = requireDist$1();
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    class MemberNotFoundError extends xrpc_1.XRPCError {
      constructor(src2) {
        super(src2.status, src2.error, src2.message, src2.headers, { cause: src2 });
      }
    }
    updateMember.MemberNotFoundError = MemberNotFoundError;
    function toKnownErr(e) {
      if (e instanceof xrpc_1.XRPCError) {
        if (e.error === "MemberNotFound")
          return new MemberNotFoundError(e);
      }
      return e;
    }
    return updateMember;
  }
  var defs$j = {};
  var hasRequiredDefs$j;
  function requireDefs$j() {
    if (hasRequiredDefs$j) return defs$j;
    hasRequiredDefs$j = 1;
    Object.defineProperty(defs$j, "__esModule", { value: true });
    defs$j.isStatusAttr = isStatusAttr;
    defs$j.validateStatusAttr = validateStatusAttr;
    defs$j.isAccountView = isAccountView;
    defs$j.validateAccountView = validateAccountView;
    defs$j.isRepoRef = isRepoRef;
    defs$j.validateRepoRef = validateRepoRef;
    defs$j.isRepoBlobRef = isRepoBlobRef;
    defs$j.validateRepoBlobRef = validateRepoBlobRef;
    defs$j.isThreatSignature = isThreatSignature;
    defs$j.validateThreatSignature = validateThreatSignature;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "com.atproto.admin.defs";
    const hashStatusAttr = "statusAttr";
    function isStatusAttr(v) {
      return is$typed(v, id, hashStatusAttr);
    }
    function validateStatusAttr(v) {
      return validate(v, id, hashStatusAttr);
    }
    const hashAccountView = "accountView";
    function isAccountView(v) {
      return is$typed(v, id, hashAccountView);
    }
    function validateAccountView(v) {
      return validate(v, id, hashAccountView);
    }
    const hashRepoRef = "repoRef";
    function isRepoRef(v) {
      return is$typed(v, id, hashRepoRef);
    }
    function validateRepoRef(v) {
      return validate(v, id, hashRepoRef);
    }
    const hashRepoBlobRef = "repoBlobRef";
    function isRepoBlobRef(v) {
      return is$typed(v, id, hashRepoBlobRef);
    }
    function validateRepoBlobRef(v) {
      return validate(v, id, hashRepoBlobRef);
    }
    const hashThreatSignature = "threatSignature";
    function isThreatSignature(v) {
      return is$typed(v, id, hashThreatSignature);
    }
    function validateThreatSignature(v) {
      return validate(v, id, hashThreatSignature);
    }
    return defs$j;
  }
  var deleteAccount$1 = {};
  var hasRequiredDeleteAccount$1;
  function requireDeleteAccount$1() {
    if (hasRequiredDeleteAccount$1) return deleteAccount$1;
    hasRequiredDeleteAccount$1 = 1;
    Object.defineProperty(deleteAccount$1, "__esModule", { value: true });
    deleteAccount$1.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return deleteAccount$1;
  }
  var disableAccountInvites = {};
  var hasRequiredDisableAccountInvites;
  function requireDisableAccountInvites() {
    if (hasRequiredDisableAccountInvites) return disableAccountInvites;
    hasRequiredDisableAccountInvites = 1;
    Object.defineProperty(disableAccountInvites, "__esModule", { value: true });
    disableAccountInvites.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return disableAccountInvites;
  }
  var disableInviteCodes = {};
  var hasRequiredDisableInviteCodes;
  function requireDisableInviteCodes() {
    if (hasRequiredDisableInviteCodes) return disableInviteCodes;
    hasRequiredDisableInviteCodes = 1;
    Object.defineProperty(disableInviteCodes, "__esModule", { value: true });
    disableInviteCodes.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return disableInviteCodes;
  }
  var enableAccountInvites = {};
  var hasRequiredEnableAccountInvites;
  function requireEnableAccountInvites() {
    if (hasRequiredEnableAccountInvites) return enableAccountInvites;
    hasRequiredEnableAccountInvites = 1;
    Object.defineProperty(enableAccountInvites, "__esModule", { value: true });
    enableAccountInvites.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return enableAccountInvites;
  }
  var getAccountInfo = {};
  var hasRequiredGetAccountInfo;
  function requireGetAccountInfo() {
    if (hasRequiredGetAccountInfo) return getAccountInfo;
    hasRequiredGetAccountInfo = 1;
    Object.defineProperty(getAccountInfo, "__esModule", { value: true });
    getAccountInfo.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return getAccountInfo;
  }
  var getAccountInfos = {};
  var hasRequiredGetAccountInfos;
  function requireGetAccountInfos() {
    if (hasRequiredGetAccountInfos) return getAccountInfos;
    hasRequiredGetAccountInfos = 1;
    Object.defineProperty(getAccountInfos, "__esModule", { value: true });
    getAccountInfos.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return getAccountInfos;
  }
  var getInviteCodes = {};
  var hasRequiredGetInviteCodes;
  function requireGetInviteCodes() {
    if (hasRequiredGetInviteCodes) return getInviteCodes;
    hasRequiredGetInviteCodes = 1;
    Object.defineProperty(getInviteCodes, "__esModule", { value: true });
    getInviteCodes.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return getInviteCodes;
  }
  var getSubjectStatus = {};
  var hasRequiredGetSubjectStatus;
  function requireGetSubjectStatus() {
    if (hasRequiredGetSubjectStatus) return getSubjectStatus;
    hasRequiredGetSubjectStatus = 1;
    Object.defineProperty(getSubjectStatus, "__esModule", { value: true });
    getSubjectStatus.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return getSubjectStatus;
  }
  var searchAccounts$1 = {};
  var hasRequiredSearchAccounts$1;
  function requireSearchAccounts$1() {
    if (hasRequiredSearchAccounts$1) return searchAccounts$1;
    hasRequiredSearchAccounts$1 = 1;
    Object.defineProperty(searchAccounts$1, "__esModule", { value: true });
    searchAccounts$1.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return searchAccounts$1;
  }
  var sendEmail = {};
  var hasRequiredSendEmail;
  function requireSendEmail() {
    if (hasRequiredSendEmail) return sendEmail;
    hasRequiredSendEmail = 1;
    Object.defineProperty(sendEmail, "__esModule", { value: true });
    sendEmail.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return sendEmail;
  }
  var updateAccountEmail = {};
  var hasRequiredUpdateAccountEmail;
  function requireUpdateAccountEmail() {
    if (hasRequiredUpdateAccountEmail) return updateAccountEmail;
    hasRequiredUpdateAccountEmail = 1;
    Object.defineProperty(updateAccountEmail, "__esModule", { value: true });
    updateAccountEmail.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return updateAccountEmail;
  }
  var updateAccountHandle = {};
  var hasRequiredUpdateAccountHandle;
  function requireUpdateAccountHandle() {
    if (hasRequiredUpdateAccountHandle) return updateAccountHandle;
    hasRequiredUpdateAccountHandle = 1;
    Object.defineProperty(updateAccountHandle, "__esModule", { value: true });
    updateAccountHandle.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return updateAccountHandle;
  }
  var updateAccountPassword = {};
  var hasRequiredUpdateAccountPassword;
  function requireUpdateAccountPassword() {
    if (hasRequiredUpdateAccountPassword) return updateAccountPassword;
    hasRequiredUpdateAccountPassword = 1;
    Object.defineProperty(updateAccountPassword, "__esModule", { value: true });
    updateAccountPassword.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return updateAccountPassword;
  }
  var updateSubjectStatus = {};
  var hasRequiredUpdateSubjectStatus;
  function requireUpdateSubjectStatus() {
    if (hasRequiredUpdateSubjectStatus) return updateSubjectStatus;
    hasRequiredUpdateSubjectStatus = 1;
    Object.defineProperty(updateSubjectStatus, "__esModule", { value: true });
    updateSubjectStatus.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return updateSubjectStatus;
  }
  var getRecommendedDidCredentials = {};
  var hasRequiredGetRecommendedDidCredentials;
  function requireGetRecommendedDidCredentials() {
    if (hasRequiredGetRecommendedDidCredentials) return getRecommendedDidCredentials;
    hasRequiredGetRecommendedDidCredentials = 1;
    Object.defineProperty(getRecommendedDidCredentials, "__esModule", { value: true });
    getRecommendedDidCredentials.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return getRecommendedDidCredentials;
  }
  var requestPlcOperationSignature = {};
  var hasRequiredRequestPlcOperationSignature;
  function requireRequestPlcOperationSignature() {
    if (hasRequiredRequestPlcOperationSignature) return requestPlcOperationSignature;
    hasRequiredRequestPlcOperationSignature = 1;
    Object.defineProperty(requestPlcOperationSignature, "__esModule", { value: true });
    requestPlcOperationSignature.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return requestPlcOperationSignature;
  }
  var resolveHandle = {};
  var hasRequiredResolveHandle;
  function requireResolveHandle() {
    if (hasRequiredResolveHandle) return resolveHandle;
    hasRequiredResolveHandle = 1;
    Object.defineProperty(resolveHandle, "__esModule", { value: true });
    resolveHandle.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return resolveHandle;
  }
  var signPlcOperation = {};
  var hasRequiredSignPlcOperation;
  function requireSignPlcOperation() {
    if (hasRequiredSignPlcOperation) return signPlcOperation;
    hasRequiredSignPlcOperation = 1;
    Object.defineProperty(signPlcOperation, "__esModule", { value: true });
    signPlcOperation.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return signPlcOperation;
  }
  var submitPlcOperation = {};
  var hasRequiredSubmitPlcOperation;
  function requireSubmitPlcOperation() {
    if (hasRequiredSubmitPlcOperation) return submitPlcOperation;
    hasRequiredSubmitPlcOperation = 1;
    Object.defineProperty(submitPlcOperation, "__esModule", { value: true });
    submitPlcOperation.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return submitPlcOperation;
  }
  var updateHandle = {};
  var hasRequiredUpdateHandle;
  function requireUpdateHandle() {
    if (hasRequiredUpdateHandle) return updateHandle;
    hasRequiredUpdateHandle = 1;
    Object.defineProperty(updateHandle, "__esModule", { value: true });
    updateHandle.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return updateHandle;
  }
  var defs$i = {};
  var hasRequiredDefs$i;
  function requireDefs$i() {
    if (hasRequiredDefs$i) return defs$i;
    hasRequiredDefs$i = 1;
    Object.defineProperty(defs$i, "__esModule", { value: true });
    defs$i.isLabel = isLabel;
    defs$i.validateLabel = validateLabel;
    defs$i.isSelfLabels = isSelfLabels;
    defs$i.validateSelfLabels = validateSelfLabels;
    defs$i.isSelfLabel = isSelfLabel;
    defs$i.validateSelfLabel = validateSelfLabel;
    defs$i.isLabelValueDefinition = isLabelValueDefinition;
    defs$i.validateLabelValueDefinition = validateLabelValueDefinition;
    defs$i.isLabelValueDefinitionStrings = isLabelValueDefinitionStrings;
    defs$i.validateLabelValueDefinitionStrings = validateLabelValueDefinitionStrings;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "com.atproto.label.defs";
    const hashLabel = "label";
    function isLabel(v) {
      return is$typed(v, id, hashLabel);
    }
    function validateLabel(v) {
      return validate(v, id, hashLabel);
    }
    const hashSelfLabels = "selfLabels";
    function isSelfLabels(v) {
      return is$typed(v, id, hashSelfLabels);
    }
    function validateSelfLabels(v) {
      return validate(v, id, hashSelfLabels);
    }
    const hashSelfLabel = "selfLabel";
    function isSelfLabel(v) {
      return is$typed(v, id, hashSelfLabel);
    }
    function validateSelfLabel(v) {
      return validate(v, id, hashSelfLabel);
    }
    const hashLabelValueDefinition = "labelValueDefinition";
    function isLabelValueDefinition(v) {
      return is$typed(v, id, hashLabelValueDefinition);
    }
    function validateLabelValueDefinition(v) {
      return validate(v, id, hashLabelValueDefinition);
    }
    const hashLabelValueDefinitionStrings = "labelValueDefinitionStrings";
    function isLabelValueDefinitionStrings(v) {
      return is$typed(v, id, hashLabelValueDefinitionStrings);
    }
    function validateLabelValueDefinitionStrings(v) {
      return validate(v, id, hashLabelValueDefinitionStrings);
    }
    return defs$i;
  }
  var queryLabels = {};
  var hasRequiredQueryLabels;
  function requireQueryLabels() {
    if (hasRequiredQueryLabels) return queryLabels;
    hasRequiredQueryLabels = 1;
    Object.defineProperty(queryLabels, "__esModule", { value: true });
    queryLabels.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return queryLabels;
  }
  var subscribeLabels = {};
  var hasRequiredSubscribeLabels;
  function requireSubscribeLabels() {
    if (hasRequiredSubscribeLabels) return subscribeLabels;
    hasRequiredSubscribeLabels = 1;
    Object.defineProperty(subscribeLabels, "__esModule", { value: true });
    subscribeLabels.isLabels = isLabels;
    subscribeLabels.validateLabels = validateLabels;
    subscribeLabels.isInfo = isInfo;
    subscribeLabels.validateInfo = validateInfo;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "com.atproto.label.subscribeLabels";
    const hashLabels = "labels";
    function isLabels(v) {
      return is$typed(v, id, hashLabels);
    }
    function validateLabels(v) {
      return validate(v, id, hashLabels);
    }
    const hashInfo = "info";
    function isInfo(v) {
      return is$typed(v, id, hashInfo);
    }
    function validateInfo(v) {
      return validate(v, id, hashInfo);
    }
    return subscribeLabels;
  }
  var schema = {};
  var hasRequiredSchema;
  function requireSchema() {
    if (hasRequiredSchema) return schema;
    hasRequiredSchema = 1;
    Object.defineProperty(schema, "__esModule", { value: true });
    schema.isRecord = isRecord;
    schema.validateRecord = validateRecord;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "com.atproto.lexicon.schema";
    const hashRecord = "main";
    function isRecord(v) {
      return is$typed(v, id, hashRecord);
    }
    function validateRecord(v) {
      return validate(v, id, hashRecord, true);
    }
    return schema;
  }
  var createReport = {};
  var hasRequiredCreateReport;
  function requireCreateReport() {
    if (hasRequiredCreateReport) return createReport;
    hasRequiredCreateReport = 1;
    Object.defineProperty(createReport, "__esModule", { value: true });
    createReport.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return createReport;
  }
  var defs$h = {};
  var hasRequiredDefs$h;
  function requireDefs$h() {
    if (hasRequiredDefs$h) return defs$h;
    hasRequiredDefs$h = 1;
    Object.defineProperty(defs$h, "__esModule", { value: true });
    defs$h.REASONAPPEAL = defs$h.REASONOTHER = defs$h.REASONRUDE = defs$h.REASONSEXUAL = defs$h.REASONMISLEADING = defs$h.REASONVIOLATION = defs$h.REASONSPAM = void 0;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    const id = "com.atproto.moderation.defs";
    defs$h.REASONSPAM = `${id}#reasonSpam`;
    defs$h.REASONVIOLATION = `${id}#reasonViolation`;
    defs$h.REASONMISLEADING = `${id}#reasonMisleading`;
    defs$h.REASONSEXUAL = `${id}#reasonSexual`;
    defs$h.REASONRUDE = `${id}#reasonRude`;
    defs$h.REASONOTHER = `${id}#reasonOther`;
    defs$h.REASONAPPEAL = `${id}#reasonAppeal`;
    return defs$h;
  }
  var defs$g = {};
  var hasRequiredDefs$g;
  function requireDefs$g() {
    if (hasRequiredDefs$g) return defs$g;
    hasRequiredDefs$g = 1;
    Object.defineProperty(defs$g, "__esModule", { value: true });
    defs$g.isCommitMeta = isCommitMeta;
    defs$g.validateCommitMeta = validateCommitMeta;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "com.atproto.repo.defs";
    const hashCommitMeta = "commitMeta";
    function isCommitMeta(v) {
      return is$typed(v, id, hashCommitMeta);
    }
    function validateCommitMeta(v) {
      return validate(v, id, hashCommitMeta);
    }
    return defs$g;
  }
  var describeRepo = {};
  var hasRequiredDescribeRepo;
  function requireDescribeRepo() {
    if (hasRequiredDescribeRepo) return describeRepo;
    hasRequiredDescribeRepo = 1;
    Object.defineProperty(describeRepo, "__esModule", { value: true });
    describeRepo.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return describeRepo;
  }
  var importRepo = {};
  var hasRequiredImportRepo;
  function requireImportRepo() {
    if (hasRequiredImportRepo) return importRepo;
    hasRequiredImportRepo = 1;
    Object.defineProperty(importRepo, "__esModule", { value: true });
    importRepo.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return importRepo;
  }
  var listMissingBlobs = {};
  var hasRequiredListMissingBlobs;
  function requireListMissingBlobs() {
    if (hasRequiredListMissingBlobs) return listMissingBlobs;
    hasRequiredListMissingBlobs = 1;
    Object.defineProperty(listMissingBlobs, "__esModule", { value: true });
    listMissingBlobs.toKnownErr = toKnownErr;
    listMissingBlobs.isRecordBlob = isRecordBlob;
    listMissingBlobs.validateRecordBlob = validateRecordBlob;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "com.atproto.repo.listMissingBlobs";
    function toKnownErr(e) {
      return e;
    }
    const hashRecordBlob = "recordBlob";
    function isRecordBlob(v) {
      return is$typed(v, id, hashRecordBlob);
    }
    function validateRecordBlob(v) {
      return validate(v, id, hashRecordBlob);
    }
    return listMissingBlobs;
  }
  var listRecords = {};
  var hasRequiredListRecords;
  function requireListRecords() {
    if (hasRequiredListRecords) return listRecords;
    hasRequiredListRecords = 1;
    Object.defineProperty(listRecords, "__esModule", { value: true });
    listRecords.toKnownErr = toKnownErr;
    listRecords.isRecord = isRecord;
    listRecords.validateRecord = validateRecord;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "com.atproto.repo.listRecords";
    function toKnownErr(e) {
      return e;
    }
    const hashRecord = "record";
    function isRecord(v) {
      return is$typed(v, id, hashRecord);
    }
    function validateRecord(v) {
      return validate(v, id, hashRecord);
    }
    return listRecords;
  }
  var strongRef = {};
  var hasRequiredStrongRef;
  function requireStrongRef() {
    if (hasRequiredStrongRef) return strongRef;
    hasRequiredStrongRef = 1;
    Object.defineProperty(strongRef, "__esModule", { value: true });
    strongRef.isMain = isMain;
    strongRef.validateMain = validateMain;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "com.atproto.repo.strongRef";
    const hashMain = "main";
    function isMain(v) {
      return is$typed(v, id, hashMain);
    }
    function validateMain(v) {
      return validate(v, id, hashMain);
    }
    return strongRef;
  }
  var uploadBlob = {};
  var hasRequiredUploadBlob;
  function requireUploadBlob() {
    if (hasRequiredUploadBlob) return uploadBlob;
    hasRequiredUploadBlob = 1;
    Object.defineProperty(uploadBlob, "__esModule", { value: true });
    uploadBlob.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return uploadBlob;
  }
  var activateAccount = {};
  var hasRequiredActivateAccount;
  function requireActivateAccount() {
    if (hasRequiredActivateAccount) return activateAccount;
    hasRequiredActivateAccount = 1;
    Object.defineProperty(activateAccount, "__esModule", { value: true });
    activateAccount.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return activateAccount;
  }
  var checkAccountStatus = {};
  var hasRequiredCheckAccountStatus;
  function requireCheckAccountStatus() {
    if (hasRequiredCheckAccountStatus) return checkAccountStatus;
    hasRequiredCheckAccountStatus = 1;
    Object.defineProperty(checkAccountStatus, "__esModule", { value: true });
    checkAccountStatus.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return checkAccountStatus;
  }
  var createInviteCode = {};
  var hasRequiredCreateInviteCode;
  function requireCreateInviteCode() {
    if (hasRequiredCreateInviteCode) return createInviteCode;
    hasRequiredCreateInviteCode = 1;
    Object.defineProperty(createInviteCode, "__esModule", { value: true });
    createInviteCode.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return createInviteCode;
  }
  var createInviteCodes = {};
  var hasRequiredCreateInviteCodes;
  function requireCreateInviteCodes() {
    if (hasRequiredCreateInviteCodes) return createInviteCodes;
    hasRequiredCreateInviteCodes = 1;
    Object.defineProperty(createInviteCodes, "__esModule", { value: true });
    createInviteCodes.toKnownErr = toKnownErr;
    createInviteCodes.isAccountCodes = isAccountCodes;
    createInviteCodes.validateAccountCodes = validateAccountCodes;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "com.atproto.server.createInviteCodes";
    function toKnownErr(e) {
      return e;
    }
    const hashAccountCodes = "accountCodes";
    function isAccountCodes(v) {
      return is$typed(v, id, hashAccountCodes);
    }
    function validateAccountCodes(v) {
      return validate(v, id, hashAccountCodes);
    }
    return createInviteCodes;
  }
  var deactivateAccount = {};
  var hasRequiredDeactivateAccount;
  function requireDeactivateAccount() {
    if (hasRequiredDeactivateAccount) return deactivateAccount;
    hasRequiredDeactivateAccount = 1;
    Object.defineProperty(deactivateAccount, "__esModule", { value: true });
    deactivateAccount.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return deactivateAccount;
  }
  var defs$f = {};
  var hasRequiredDefs$f;
  function requireDefs$f() {
    if (hasRequiredDefs$f) return defs$f;
    hasRequiredDefs$f = 1;
    Object.defineProperty(defs$f, "__esModule", { value: true });
    defs$f.isInviteCode = isInviteCode;
    defs$f.validateInviteCode = validateInviteCode;
    defs$f.isInviteCodeUse = isInviteCodeUse;
    defs$f.validateInviteCodeUse = validateInviteCodeUse;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "com.atproto.server.defs";
    const hashInviteCode = "inviteCode";
    function isInviteCode(v) {
      return is$typed(v, id, hashInviteCode);
    }
    function validateInviteCode(v) {
      return validate(v, id, hashInviteCode);
    }
    const hashInviteCodeUse = "inviteCodeUse";
    function isInviteCodeUse(v) {
      return is$typed(v, id, hashInviteCodeUse);
    }
    function validateInviteCodeUse(v) {
      return validate(v, id, hashInviteCodeUse);
    }
    return defs$f;
  }
  var deleteSession = {};
  var hasRequiredDeleteSession;
  function requireDeleteSession() {
    if (hasRequiredDeleteSession) return deleteSession;
    hasRequiredDeleteSession = 1;
    Object.defineProperty(deleteSession, "__esModule", { value: true });
    deleteSession.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return deleteSession;
  }
  var describeServer = {};
  var hasRequiredDescribeServer;
  function requireDescribeServer() {
    if (hasRequiredDescribeServer) return describeServer;
    hasRequiredDescribeServer = 1;
    Object.defineProperty(describeServer, "__esModule", { value: true });
    describeServer.toKnownErr = toKnownErr;
    describeServer.isLinks = isLinks;
    describeServer.validateLinks = validateLinks;
    describeServer.isContact = isContact;
    describeServer.validateContact = validateContact;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "com.atproto.server.describeServer";
    function toKnownErr(e) {
      return e;
    }
    const hashLinks = "links";
    function isLinks(v) {
      return is$typed(v, id, hashLinks);
    }
    function validateLinks(v) {
      return validate(v, id, hashLinks);
    }
    const hashContact = "contact";
    function isContact(v) {
      return is$typed(v, id, hashContact);
    }
    function validateContact(v) {
      return validate(v, id, hashContact);
    }
    return describeServer;
  }
  var getSession = {};
  var hasRequiredGetSession;
  function requireGetSession() {
    if (hasRequiredGetSession) return getSession;
    hasRequiredGetSession = 1;
    Object.defineProperty(getSession, "__esModule", { value: true });
    getSession.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return getSession;
  }
  var requestAccountDelete = {};
  var hasRequiredRequestAccountDelete;
  function requireRequestAccountDelete() {
    if (hasRequiredRequestAccountDelete) return requestAccountDelete;
    hasRequiredRequestAccountDelete = 1;
    Object.defineProperty(requestAccountDelete, "__esModule", { value: true });
    requestAccountDelete.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return requestAccountDelete;
  }
  var requestEmailConfirmation = {};
  var hasRequiredRequestEmailConfirmation;
  function requireRequestEmailConfirmation() {
    if (hasRequiredRequestEmailConfirmation) return requestEmailConfirmation;
    hasRequiredRequestEmailConfirmation = 1;
    Object.defineProperty(requestEmailConfirmation, "__esModule", { value: true });
    requestEmailConfirmation.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return requestEmailConfirmation;
  }
  var requestEmailUpdate = {};
  var hasRequiredRequestEmailUpdate;
  function requireRequestEmailUpdate() {
    if (hasRequiredRequestEmailUpdate) return requestEmailUpdate;
    hasRequiredRequestEmailUpdate = 1;
    Object.defineProperty(requestEmailUpdate, "__esModule", { value: true });
    requestEmailUpdate.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return requestEmailUpdate;
  }
  var requestPasswordReset = {};
  var hasRequiredRequestPasswordReset;
  function requireRequestPasswordReset() {
    if (hasRequiredRequestPasswordReset) return requestPasswordReset;
    hasRequiredRequestPasswordReset = 1;
    Object.defineProperty(requestPasswordReset, "__esModule", { value: true });
    requestPasswordReset.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return requestPasswordReset;
  }
  var reserveSigningKey = {};
  var hasRequiredReserveSigningKey;
  function requireReserveSigningKey() {
    if (hasRequiredReserveSigningKey) return reserveSigningKey;
    hasRequiredReserveSigningKey = 1;
    Object.defineProperty(reserveSigningKey, "__esModule", { value: true });
    reserveSigningKey.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return reserveSigningKey;
  }
  var revokeAppPassword = {};
  var hasRequiredRevokeAppPassword;
  function requireRevokeAppPassword() {
    if (hasRequiredRevokeAppPassword) return revokeAppPassword;
    hasRequiredRevokeAppPassword = 1;
    Object.defineProperty(revokeAppPassword, "__esModule", { value: true });
    revokeAppPassword.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return revokeAppPassword;
  }
  var getCheckout = {};
  var hasRequiredGetCheckout;
  function requireGetCheckout() {
    if (hasRequiredGetCheckout) return getCheckout;
    hasRequiredGetCheckout = 1;
    Object.defineProperty(getCheckout, "__esModule", { value: true });
    getCheckout.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return getCheckout;
  }
  var listRepos = {};
  var hasRequiredListRepos;
  function requireListRepos() {
    if (hasRequiredListRepos) return listRepos;
    hasRequiredListRepos = 1;
    Object.defineProperty(listRepos, "__esModule", { value: true });
    listRepos.toKnownErr = toKnownErr;
    listRepos.isRepo = isRepo;
    listRepos.validateRepo = validateRepo;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "com.atproto.sync.listRepos";
    function toKnownErr(e) {
      return e;
    }
    const hashRepo = "repo";
    function isRepo(v) {
      return is$typed(v, id, hashRepo);
    }
    function validateRepo(v) {
      return validate(v, id, hashRepo);
    }
    return listRepos;
  }
  var notifyOfUpdate = {};
  var hasRequiredNotifyOfUpdate;
  function requireNotifyOfUpdate() {
    if (hasRequiredNotifyOfUpdate) return notifyOfUpdate;
    hasRequiredNotifyOfUpdate = 1;
    Object.defineProperty(notifyOfUpdate, "__esModule", { value: true });
    notifyOfUpdate.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return notifyOfUpdate;
  }
  var requestCrawl = {};
  var hasRequiredRequestCrawl;
  function requireRequestCrawl() {
    if (hasRequiredRequestCrawl) return requestCrawl;
    hasRequiredRequestCrawl = 1;
    Object.defineProperty(requestCrawl, "__esModule", { value: true });
    requestCrawl.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return requestCrawl;
  }
  var subscribeRepos = {};
  var hasRequiredSubscribeRepos;
  function requireSubscribeRepos() {
    if (hasRequiredSubscribeRepos) return subscribeRepos;
    hasRequiredSubscribeRepos = 1;
    Object.defineProperty(subscribeRepos, "__esModule", { value: true });
    subscribeRepos.isCommit = isCommit;
    subscribeRepos.validateCommit = validateCommit;
    subscribeRepos.isIdentity = isIdentity;
    subscribeRepos.validateIdentity = validateIdentity;
    subscribeRepos.isAccount = isAccount;
    subscribeRepos.validateAccount = validateAccount;
    subscribeRepos.isHandle = isHandle;
    subscribeRepos.validateHandle = validateHandle;
    subscribeRepos.isMigrate = isMigrate;
    subscribeRepos.validateMigrate = validateMigrate;
    subscribeRepos.isTombstone = isTombstone;
    subscribeRepos.validateTombstone = validateTombstone;
    subscribeRepos.isInfo = isInfo;
    subscribeRepos.validateInfo = validateInfo;
    subscribeRepos.isRepoOp = isRepoOp;
    subscribeRepos.validateRepoOp = validateRepoOp;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "com.atproto.sync.subscribeRepos";
    const hashCommit = "commit";
    function isCommit(v) {
      return is$typed(v, id, hashCommit);
    }
    function validateCommit(v) {
      return validate(v, id, hashCommit);
    }
    const hashIdentity = "identity";
    function isIdentity(v) {
      return is$typed(v, id, hashIdentity);
    }
    function validateIdentity(v) {
      return validate(v, id, hashIdentity);
    }
    const hashAccount = "account";
    function isAccount(v) {
      return is$typed(v, id, hashAccount);
    }
    function validateAccount(v) {
      return validate(v, id, hashAccount);
    }
    const hashHandle = "handle";
    function isHandle(v) {
      return is$typed(v, id, hashHandle);
    }
    function validateHandle(v) {
      return validate(v, id, hashHandle);
    }
    const hashMigrate = "migrate";
    function isMigrate(v) {
      return is$typed(v, id, hashMigrate);
    }
    function validateMigrate(v) {
      return validate(v, id, hashMigrate);
    }
    const hashTombstone = "tombstone";
    function isTombstone(v) {
      return is$typed(v, id, hashTombstone);
    }
    function validateTombstone(v) {
      return validate(v, id, hashTombstone);
    }
    const hashInfo = "info";
    function isInfo(v) {
      return is$typed(v, id, hashInfo);
    }
    function validateInfo(v) {
      return validate(v, id, hashInfo);
    }
    const hashRepoOp = "repoOp";
    function isRepoOp(v) {
      return is$typed(v, id, hashRepoOp);
    }
    function validateRepoOp(v) {
      return validate(v, id, hashRepoOp);
    }
    return subscribeRepos;
  }
  var addReservedHandle = {};
  var hasRequiredAddReservedHandle;
  function requireAddReservedHandle() {
    if (hasRequiredAddReservedHandle) return addReservedHandle;
    hasRequiredAddReservedHandle = 1;
    Object.defineProperty(addReservedHandle, "__esModule", { value: true });
    addReservedHandle.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return addReservedHandle;
  }
  var checkSignupQueue = {};
  var hasRequiredCheckSignupQueue;
  function requireCheckSignupQueue() {
    if (hasRequiredCheckSignupQueue) return checkSignupQueue;
    hasRequiredCheckSignupQueue = 1;
    Object.defineProperty(checkSignupQueue, "__esModule", { value: true });
    checkSignupQueue.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return checkSignupQueue;
  }
  var fetchLabels = {};
  var hasRequiredFetchLabels;
  function requireFetchLabels() {
    if (hasRequiredFetchLabels) return fetchLabels;
    hasRequiredFetchLabels = 1;
    Object.defineProperty(fetchLabels, "__esModule", { value: true });
    fetchLabels.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return fetchLabels;
  }
  var requestPhoneVerification = {};
  var hasRequiredRequestPhoneVerification;
  function requireRequestPhoneVerification() {
    if (hasRequiredRequestPhoneVerification) return requestPhoneVerification;
    hasRequiredRequestPhoneVerification = 1;
    Object.defineProperty(requestPhoneVerification, "__esModule", { value: true });
    requestPhoneVerification.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return requestPhoneVerification;
  }
  var defs$e = {};
  var hasRequiredDefs$e;
  function requireDefs$e() {
    if (hasRequiredDefs$e) return defs$e;
    hasRequiredDefs$e = 1;
    Object.defineProperty(defs$e, "__esModule", { value: true });
    defs$e.isProfileViewBasic = isProfileViewBasic;
    defs$e.validateProfileViewBasic = validateProfileViewBasic;
    defs$e.isProfileView = isProfileView;
    defs$e.validateProfileView = validateProfileView;
    defs$e.isProfileViewDetailed = isProfileViewDetailed;
    defs$e.validateProfileViewDetailed = validateProfileViewDetailed;
    defs$e.isProfileAssociated = isProfileAssociated;
    defs$e.validateProfileAssociated = validateProfileAssociated;
    defs$e.isProfileAssociatedChat = isProfileAssociatedChat;
    defs$e.validateProfileAssociatedChat = validateProfileAssociatedChat;
    defs$e.isViewerState = isViewerState;
    defs$e.validateViewerState = validateViewerState;
    defs$e.isKnownFollowers = isKnownFollowers;
    defs$e.validateKnownFollowers = validateKnownFollowers;
    defs$e.isAdultContentPref = isAdultContentPref;
    defs$e.validateAdultContentPref = validateAdultContentPref;
    defs$e.isContentLabelPref = isContentLabelPref;
    defs$e.validateContentLabelPref = validateContentLabelPref;
    defs$e.isSavedFeed = isSavedFeed;
    defs$e.validateSavedFeed = validateSavedFeed;
    defs$e.isSavedFeedsPrefV2 = isSavedFeedsPrefV2;
    defs$e.validateSavedFeedsPrefV2 = validateSavedFeedsPrefV2;
    defs$e.isSavedFeedsPref = isSavedFeedsPref;
    defs$e.validateSavedFeedsPref = validateSavedFeedsPref;
    defs$e.isPersonalDetailsPref = isPersonalDetailsPref;
    defs$e.validatePersonalDetailsPref = validatePersonalDetailsPref;
    defs$e.isFeedViewPref = isFeedViewPref;
    defs$e.validateFeedViewPref = validateFeedViewPref;
    defs$e.isThreadViewPref = isThreadViewPref;
    defs$e.validateThreadViewPref = validateThreadViewPref;
    defs$e.isInterestsPref = isInterestsPref;
    defs$e.validateInterestsPref = validateInterestsPref;
    defs$e.isMutedWord = isMutedWord;
    defs$e.validateMutedWord = validateMutedWord;
    defs$e.isMutedWordsPref = isMutedWordsPref;
    defs$e.validateMutedWordsPref = validateMutedWordsPref;
    defs$e.isHiddenPostsPref = isHiddenPostsPref;
    defs$e.validateHiddenPostsPref = validateHiddenPostsPref;
    defs$e.isLabelersPref = isLabelersPref;
    defs$e.validateLabelersPref = validateLabelersPref;
    defs$e.isLabelerPrefItem = isLabelerPrefItem;
    defs$e.validateLabelerPrefItem = validateLabelerPrefItem;
    defs$e.isBskyAppStatePref = isBskyAppStatePref;
    defs$e.validateBskyAppStatePref = validateBskyAppStatePref;
    defs$e.isBskyAppProgressGuide = isBskyAppProgressGuide;
    defs$e.validateBskyAppProgressGuide = validateBskyAppProgressGuide;
    defs$e.isNux = isNux;
    defs$e.validateNux = validateNux;
    defs$e.isPostInteractionSettingsPref = isPostInteractionSettingsPref;
    defs$e.validatePostInteractionSettingsPref = validatePostInteractionSettingsPref;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "app.bsky.actor.defs";
    const hashProfileViewBasic = "profileViewBasic";
    function isProfileViewBasic(v) {
      return is$typed(v, id, hashProfileViewBasic);
    }
    function validateProfileViewBasic(v) {
      return validate(v, id, hashProfileViewBasic);
    }
    const hashProfileView = "profileView";
    function isProfileView(v) {
      return is$typed(v, id, hashProfileView);
    }
    function validateProfileView(v) {
      return validate(v, id, hashProfileView);
    }
    const hashProfileViewDetailed = "profileViewDetailed";
    function isProfileViewDetailed(v) {
      return is$typed(v, id, hashProfileViewDetailed);
    }
    function validateProfileViewDetailed(v) {
      return validate(v, id, hashProfileViewDetailed);
    }
    const hashProfileAssociated = "profileAssociated";
    function isProfileAssociated(v) {
      return is$typed(v, id, hashProfileAssociated);
    }
    function validateProfileAssociated(v) {
      return validate(v, id, hashProfileAssociated);
    }
    const hashProfileAssociatedChat = "profileAssociatedChat";
    function isProfileAssociatedChat(v) {
      return is$typed(v, id, hashProfileAssociatedChat);
    }
    function validateProfileAssociatedChat(v) {
      return validate(v, id, hashProfileAssociatedChat);
    }
    const hashViewerState = "viewerState";
    function isViewerState(v) {
      return is$typed(v, id, hashViewerState);
    }
    function validateViewerState(v) {
      return validate(v, id, hashViewerState);
    }
    const hashKnownFollowers = "knownFollowers";
    function isKnownFollowers(v) {
      return is$typed(v, id, hashKnownFollowers);
    }
    function validateKnownFollowers(v) {
      return validate(v, id, hashKnownFollowers);
    }
    const hashAdultContentPref = "adultContentPref";
    function isAdultContentPref(v) {
      return is$typed(v, id, hashAdultContentPref);
    }
    function validateAdultContentPref(v) {
      return validate(v, id, hashAdultContentPref);
    }
    const hashContentLabelPref = "contentLabelPref";
    function isContentLabelPref(v) {
      return is$typed(v, id, hashContentLabelPref);
    }
    function validateContentLabelPref(v) {
      return validate(v, id, hashContentLabelPref);
    }
    const hashSavedFeed = "savedFeed";
    function isSavedFeed(v) {
      return is$typed(v, id, hashSavedFeed);
    }
    function validateSavedFeed(v) {
      return validate(v, id, hashSavedFeed);
    }
    const hashSavedFeedsPrefV2 = "savedFeedsPrefV2";
    function isSavedFeedsPrefV2(v) {
      return is$typed(v, id, hashSavedFeedsPrefV2);
    }
    function validateSavedFeedsPrefV2(v) {
      return validate(v, id, hashSavedFeedsPrefV2);
    }
    const hashSavedFeedsPref = "savedFeedsPref";
    function isSavedFeedsPref(v) {
      return is$typed(v, id, hashSavedFeedsPref);
    }
    function validateSavedFeedsPref(v) {
      return validate(v, id, hashSavedFeedsPref);
    }
    const hashPersonalDetailsPref = "personalDetailsPref";
    function isPersonalDetailsPref(v) {
      return is$typed(v, id, hashPersonalDetailsPref);
    }
    function validatePersonalDetailsPref(v) {
      return validate(v, id, hashPersonalDetailsPref);
    }
    const hashFeedViewPref = "feedViewPref";
    function isFeedViewPref(v) {
      return is$typed(v, id, hashFeedViewPref);
    }
    function validateFeedViewPref(v) {
      return validate(v, id, hashFeedViewPref);
    }
    const hashThreadViewPref = "threadViewPref";
    function isThreadViewPref(v) {
      return is$typed(v, id, hashThreadViewPref);
    }
    function validateThreadViewPref(v) {
      return validate(v, id, hashThreadViewPref);
    }
    const hashInterestsPref = "interestsPref";
    function isInterestsPref(v) {
      return is$typed(v, id, hashInterestsPref);
    }
    function validateInterestsPref(v) {
      return validate(v, id, hashInterestsPref);
    }
    const hashMutedWord = "mutedWord";
    function isMutedWord(v) {
      return is$typed(v, id, hashMutedWord);
    }
    function validateMutedWord(v) {
      return validate(v, id, hashMutedWord);
    }
    const hashMutedWordsPref = "mutedWordsPref";
    function isMutedWordsPref(v) {
      return is$typed(v, id, hashMutedWordsPref);
    }
    function validateMutedWordsPref(v) {
      return validate(v, id, hashMutedWordsPref);
    }
    const hashHiddenPostsPref = "hiddenPostsPref";
    function isHiddenPostsPref(v) {
      return is$typed(v, id, hashHiddenPostsPref);
    }
    function validateHiddenPostsPref(v) {
      return validate(v, id, hashHiddenPostsPref);
    }
    const hashLabelersPref = "labelersPref";
    function isLabelersPref(v) {
      return is$typed(v, id, hashLabelersPref);
    }
    function validateLabelersPref(v) {
      return validate(v, id, hashLabelersPref);
    }
    const hashLabelerPrefItem = "labelerPrefItem";
    function isLabelerPrefItem(v) {
      return is$typed(v, id, hashLabelerPrefItem);
    }
    function validateLabelerPrefItem(v) {
      return validate(v, id, hashLabelerPrefItem);
    }
    const hashBskyAppStatePref = "bskyAppStatePref";
    function isBskyAppStatePref(v) {
      return is$typed(v, id, hashBskyAppStatePref);
    }
    function validateBskyAppStatePref(v) {
      return validate(v, id, hashBskyAppStatePref);
    }
    const hashBskyAppProgressGuide = "bskyAppProgressGuide";
    function isBskyAppProgressGuide(v) {
      return is$typed(v, id, hashBskyAppProgressGuide);
    }
    function validateBskyAppProgressGuide(v) {
      return validate(v, id, hashBskyAppProgressGuide);
    }
    const hashNux = "nux";
    function isNux(v) {
      return is$typed(v, id, hashNux);
    }
    function validateNux(v) {
      return validate(v, id, hashNux);
    }
    const hashPostInteractionSettingsPref = "postInteractionSettingsPref";
    function isPostInteractionSettingsPref(v) {
      return is$typed(v, id, hashPostInteractionSettingsPref);
    }
    function validatePostInteractionSettingsPref(v) {
      return validate(v, id, hashPostInteractionSettingsPref);
    }
    return defs$e;
  }
  var getPreferences = {};
  var hasRequiredGetPreferences;
  function requireGetPreferences() {
    if (hasRequiredGetPreferences) return getPreferences;
    hasRequiredGetPreferences = 1;
    Object.defineProperty(getPreferences, "__esModule", { value: true });
    getPreferences.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return getPreferences;
  }
  var getProfile = {};
  var hasRequiredGetProfile;
  function requireGetProfile() {
    if (hasRequiredGetProfile) return getProfile;
    hasRequiredGetProfile = 1;
    Object.defineProperty(getProfile, "__esModule", { value: true });
    getProfile.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return getProfile;
  }
  var getProfiles = {};
  var hasRequiredGetProfiles;
  function requireGetProfiles() {
    if (hasRequiredGetProfiles) return getProfiles;
    hasRequiredGetProfiles = 1;
    Object.defineProperty(getProfiles, "__esModule", { value: true });
    getProfiles.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return getProfiles;
  }
  var getSuggestions = {};
  var hasRequiredGetSuggestions;
  function requireGetSuggestions() {
    if (hasRequiredGetSuggestions) return getSuggestions;
    hasRequiredGetSuggestions = 1;
    Object.defineProperty(getSuggestions, "__esModule", { value: true });
    getSuggestions.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return getSuggestions;
  }
  var profile$1 = {};
  var hasRequiredProfile$1;
  function requireProfile$1() {
    if (hasRequiredProfile$1) return profile$1;
    hasRequiredProfile$1 = 1;
    Object.defineProperty(profile$1, "__esModule", { value: true });
    profile$1.isRecord = isRecord;
    profile$1.validateRecord = validateRecord;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "app.bsky.actor.profile";
    const hashRecord = "main";
    function isRecord(v) {
      return is$typed(v, id, hashRecord);
    }
    function validateRecord(v) {
      return validate(v, id, hashRecord, true);
    }
    return profile$1;
  }
  var putPreferences$1 = {};
  var hasRequiredPutPreferences$1;
  function requirePutPreferences$1() {
    if (hasRequiredPutPreferences$1) return putPreferences$1;
    hasRequiredPutPreferences$1 = 1;
    Object.defineProperty(putPreferences$1, "__esModule", { value: true });
    putPreferences$1.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return putPreferences$1;
  }
  var searchActors = {};
  var hasRequiredSearchActors;
  function requireSearchActors() {
    if (hasRequiredSearchActors) return searchActors;
    hasRequiredSearchActors = 1;
    Object.defineProperty(searchActors, "__esModule", { value: true });
    searchActors.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return searchActors;
  }
  var searchActorsTypeahead = {};
  var hasRequiredSearchActorsTypeahead;
  function requireSearchActorsTypeahead() {
    if (hasRequiredSearchActorsTypeahead) return searchActorsTypeahead;
    hasRequiredSearchActorsTypeahead = 1;
    Object.defineProperty(searchActorsTypeahead, "__esModule", { value: true });
    searchActorsTypeahead.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return searchActorsTypeahead;
  }
  var defs$d = {};
  var hasRequiredDefs$d;
  function requireDefs$d() {
    if (hasRequiredDefs$d) return defs$d;
    hasRequiredDefs$d = 1;
    Object.defineProperty(defs$d, "__esModule", { value: true });
    defs$d.isAspectRatio = isAspectRatio;
    defs$d.validateAspectRatio = validateAspectRatio;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "app.bsky.embed.defs";
    const hashAspectRatio = "aspectRatio";
    function isAspectRatio(v) {
      return is$typed(v, id, hashAspectRatio);
    }
    function validateAspectRatio(v) {
      return validate(v, id, hashAspectRatio);
    }
    return defs$d;
  }
  var external = {};
  var hasRequiredExternal;
  function requireExternal() {
    if (hasRequiredExternal) return external;
    hasRequiredExternal = 1;
    Object.defineProperty(external, "__esModule", { value: true });
    external.isMain = isMain;
    external.validateMain = validateMain;
    external.isExternal = isExternal;
    external.validateExternal = validateExternal;
    external.isView = isView;
    external.validateView = validateView;
    external.isViewExternal = isViewExternal;
    external.validateViewExternal = validateViewExternal;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "app.bsky.embed.external";
    const hashMain = "main";
    function isMain(v) {
      return is$typed(v, id, hashMain);
    }
    function validateMain(v) {
      return validate(v, id, hashMain);
    }
    const hashExternal = "external";
    function isExternal(v) {
      return is$typed(v, id, hashExternal);
    }
    function validateExternal(v) {
      return validate(v, id, hashExternal);
    }
    const hashView = "view";
    function isView(v) {
      return is$typed(v, id, hashView);
    }
    function validateView(v) {
      return validate(v, id, hashView);
    }
    const hashViewExternal = "viewExternal";
    function isViewExternal(v) {
      return is$typed(v, id, hashViewExternal);
    }
    function validateViewExternal(v) {
      return validate(v, id, hashViewExternal);
    }
    return external;
  }
  var images = {};
  var hasRequiredImages;
  function requireImages() {
    if (hasRequiredImages) return images;
    hasRequiredImages = 1;
    Object.defineProperty(images, "__esModule", { value: true });
    images.isMain = isMain;
    images.validateMain = validateMain;
    images.isImage = isImage;
    images.validateImage = validateImage;
    images.isView = isView;
    images.validateView = validateView;
    images.isViewImage = isViewImage;
    images.validateViewImage = validateViewImage;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "app.bsky.embed.images";
    const hashMain = "main";
    function isMain(v) {
      return is$typed(v, id, hashMain);
    }
    function validateMain(v) {
      return validate(v, id, hashMain);
    }
    const hashImage = "image";
    function isImage(v) {
      return is$typed(v, id, hashImage);
    }
    function validateImage(v) {
      return validate(v, id, hashImage);
    }
    const hashView = "view";
    function isView(v) {
      return is$typed(v, id, hashView);
    }
    function validateView(v) {
      return validate(v, id, hashView);
    }
    const hashViewImage = "viewImage";
    function isViewImage(v) {
      return is$typed(v, id, hashViewImage);
    }
    function validateViewImage(v) {
      return validate(v, id, hashViewImage);
    }
    return images;
  }
  var record = {};
  var hasRequiredRecord;
  function requireRecord() {
    if (hasRequiredRecord) return record;
    hasRequiredRecord = 1;
    Object.defineProperty(record, "__esModule", { value: true });
    record.isMain = isMain;
    record.validateMain = validateMain;
    record.isView = isView;
    record.validateView = validateView;
    record.isViewRecord = isViewRecord;
    record.validateViewRecord = validateViewRecord;
    record.isViewNotFound = isViewNotFound;
    record.validateViewNotFound = validateViewNotFound;
    record.isViewBlocked = isViewBlocked;
    record.validateViewBlocked = validateViewBlocked;
    record.isViewDetached = isViewDetached;
    record.validateViewDetached = validateViewDetached;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "app.bsky.embed.record";
    const hashMain = "main";
    function isMain(v) {
      return is$typed(v, id, hashMain);
    }
    function validateMain(v) {
      return validate(v, id, hashMain);
    }
    const hashView = "view";
    function isView(v) {
      return is$typed(v, id, hashView);
    }
    function validateView(v) {
      return validate(v, id, hashView);
    }
    const hashViewRecord = "viewRecord";
    function isViewRecord(v) {
      return is$typed(v, id, hashViewRecord);
    }
    function validateViewRecord(v) {
      return validate(v, id, hashViewRecord);
    }
    const hashViewNotFound = "viewNotFound";
    function isViewNotFound(v) {
      return is$typed(v, id, hashViewNotFound);
    }
    function validateViewNotFound(v) {
      return validate(v, id, hashViewNotFound);
    }
    const hashViewBlocked = "viewBlocked";
    function isViewBlocked(v) {
      return is$typed(v, id, hashViewBlocked);
    }
    function validateViewBlocked(v) {
      return validate(v, id, hashViewBlocked);
    }
    const hashViewDetached = "viewDetached";
    function isViewDetached(v) {
      return is$typed(v, id, hashViewDetached);
    }
    function validateViewDetached(v) {
      return validate(v, id, hashViewDetached);
    }
    return record;
  }
  var recordWithMedia = {};
  var hasRequiredRecordWithMedia;
  function requireRecordWithMedia() {
    if (hasRequiredRecordWithMedia) return recordWithMedia;
    hasRequiredRecordWithMedia = 1;
    Object.defineProperty(recordWithMedia, "__esModule", { value: true });
    recordWithMedia.isMain = isMain;
    recordWithMedia.validateMain = validateMain;
    recordWithMedia.isView = isView;
    recordWithMedia.validateView = validateView;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "app.bsky.embed.recordWithMedia";
    const hashMain = "main";
    function isMain(v) {
      return is$typed(v, id, hashMain);
    }
    function validateMain(v) {
      return validate(v, id, hashMain);
    }
    const hashView = "view";
    function isView(v) {
      return is$typed(v, id, hashView);
    }
    function validateView(v) {
      return validate(v, id, hashView);
    }
    return recordWithMedia;
  }
  var video = {};
  var hasRequiredVideo;
  function requireVideo() {
    if (hasRequiredVideo) return video;
    hasRequiredVideo = 1;
    Object.defineProperty(video, "__esModule", { value: true });
    video.isMain = isMain;
    video.validateMain = validateMain;
    video.isCaption = isCaption;
    video.validateCaption = validateCaption;
    video.isView = isView;
    video.validateView = validateView;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "app.bsky.embed.video";
    const hashMain = "main";
    function isMain(v) {
      return is$typed(v, id, hashMain);
    }
    function validateMain(v) {
      return validate(v, id, hashMain);
    }
    const hashCaption = "caption";
    function isCaption(v) {
      return is$typed(v, id, hashCaption);
    }
    function validateCaption(v) {
      return validate(v, id, hashCaption);
    }
    const hashView = "view";
    function isView(v) {
      return is$typed(v, id, hashView);
    }
    function validateView(v) {
      return validate(v, id, hashView);
    }
    return video;
  }
  var defs$c = {};
  var hasRequiredDefs$c;
  function requireDefs$c() {
    if (hasRequiredDefs$c) return defs$c;
    hasRequiredDefs$c = 1;
    Object.defineProperty(defs$c, "__esModule", { value: true });
    defs$c.INTERACTIONSHARE = defs$c.INTERACTIONQUOTE = defs$c.INTERACTIONREPLY = defs$c.INTERACTIONREPOST = defs$c.INTERACTIONLIKE = defs$c.INTERACTIONSEEN = defs$c.CONTENTMODEVIDEO = defs$c.CONTENTMODEUNSPECIFIED = defs$c.CLICKTHROUGHEMBED = defs$c.CLICKTHROUGHREPOSTER = defs$c.CLICKTHROUGHAUTHOR = defs$c.CLICKTHROUGHITEM = defs$c.REQUESTMORE = defs$c.REQUESTLESS = void 0;
    defs$c.isPostView = isPostView;
    defs$c.validatePostView = validatePostView;
    defs$c.isViewerState = isViewerState;
    defs$c.validateViewerState = validateViewerState;
    defs$c.isThreadContext = isThreadContext;
    defs$c.validateThreadContext = validateThreadContext;
    defs$c.isFeedViewPost = isFeedViewPost;
    defs$c.validateFeedViewPost = validateFeedViewPost;
    defs$c.isReplyRef = isReplyRef;
    defs$c.validateReplyRef = validateReplyRef;
    defs$c.isReasonRepost = isReasonRepost;
    defs$c.validateReasonRepost = validateReasonRepost;
    defs$c.isReasonPin = isReasonPin;
    defs$c.validateReasonPin = validateReasonPin;
    defs$c.isThreadViewPost = isThreadViewPost;
    defs$c.validateThreadViewPost = validateThreadViewPost;
    defs$c.isNotFoundPost = isNotFoundPost;
    defs$c.validateNotFoundPost = validateNotFoundPost;
    defs$c.isBlockedPost = isBlockedPost;
    defs$c.validateBlockedPost = validateBlockedPost;
    defs$c.isBlockedAuthor = isBlockedAuthor;
    defs$c.validateBlockedAuthor = validateBlockedAuthor;
    defs$c.isGeneratorView = isGeneratorView;
    defs$c.validateGeneratorView = validateGeneratorView;
    defs$c.isGeneratorViewerState = isGeneratorViewerState;
    defs$c.validateGeneratorViewerState = validateGeneratorViewerState;
    defs$c.isSkeletonFeedPost = isSkeletonFeedPost;
    defs$c.validateSkeletonFeedPost = validateSkeletonFeedPost;
    defs$c.isSkeletonReasonRepost = isSkeletonReasonRepost;
    defs$c.validateSkeletonReasonRepost = validateSkeletonReasonRepost;
    defs$c.isSkeletonReasonPin = isSkeletonReasonPin;
    defs$c.validateSkeletonReasonPin = validateSkeletonReasonPin;
    defs$c.isThreadgateView = isThreadgateView;
    defs$c.validateThreadgateView = validateThreadgateView;
    defs$c.isInteraction = isInteraction;
    defs$c.validateInteraction = validateInteraction;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "app.bsky.feed.defs";
    const hashPostView = "postView";
    function isPostView(v) {
      return is$typed(v, id, hashPostView);
    }
    function validatePostView(v) {
      return validate(v, id, hashPostView);
    }
    const hashViewerState = "viewerState";
    function isViewerState(v) {
      return is$typed(v, id, hashViewerState);
    }
    function validateViewerState(v) {
      return validate(v, id, hashViewerState);
    }
    const hashThreadContext = "threadContext";
    function isThreadContext(v) {
      return is$typed(v, id, hashThreadContext);
    }
    function validateThreadContext(v) {
      return validate(v, id, hashThreadContext);
    }
    const hashFeedViewPost = "feedViewPost";
    function isFeedViewPost(v) {
      return is$typed(v, id, hashFeedViewPost);
    }
    function validateFeedViewPost(v) {
      return validate(v, id, hashFeedViewPost);
    }
    const hashReplyRef = "replyRef";
    function isReplyRef(v) {
      return is$typed(v, id, hashReplyRef);
    }
    function validateReplyRef(v) {
      return validate(v, id, hashReplyRef);
    }
    const hashReasonRepost = "reasonRepost";
    function isReasonRepost(v) {
      return is$typed(v, id, hashReasonRepost);
    }
    function validateReasonRepost(v) {
      return validate(v, id, hashReasonRepost);
    }
    const hashReasonPin = "reasonPin";
    function isReasonPin(v) {
      return is$typed(v, id, hashReasonPin);
    }
    function validateReasonPin(v) {
      return validate(v, id, hashReasonPin);
    }
    const hashThreadViewPost = "threadViewPost";
    function isThreadViewPost(v) {
      return is$typed(v, id, hashThreadViewPost);
    }
    function validateThreadViewPost(v) {
      return validate(v, id, hashThreadViewPost);
    }
    const hashNotFoundPost = "notFoundPost";
    function isNotFoundPost(v) {
      return is$typed(v, id, hashNotFoundPost);
    }
    function validateNotFoundPost(v) {
      return validate(v, id, hashNotFoundPost);
    }
    const hashBlockedPost = "blockedPost";
    function isBlockedPost(v) {
      return is$typed(v, id, hashBlockedPost);
    }
    function validateBlockedPost(v) {
      return validate(v, id, hashBlockedPost);
    }
    const hashBlockedAuthor = "blockedAuthor";
    function isBlockedAuthor(v) {
      return is$typed(v, id, hashBlockedAuthor);
    }
    function validateBlockedAuthor(v) {
      return validate(v, id, hashBlockedAuthor);
    }
    const hashGeneratorView = "generatorView";
    function isGeneratorView(v) {
      return is$typed(v, id, hashGeneratorView);
    }
    function validateGeneratorView(v) {
      return validate(v, id, hashGeneratorView);
    }
    const hashGeneratorViewerState = "generatorViewerState";
    function isGeneratorViewerState(v) {
      return is$typed(v, id, hashGeneratorViewerState);
    }
    function validateGeneratorViewerState(v) {
      return validate(v, id, hashGeneratorViewerState);
    }
    const hashSkeletonFeedPost = "skeletonFeedPost";
    function isSkeletonFeedPost(v) {
      return is$typed(v, id, hashSkeletonFeedPost);
    }
    function validateSkeletonFeedPost(v) {
      return validate(v, id, hashSkeletonFeedPost);
    }
    const hashSkeletonReasonRepost = "skeletonReasonRepost";
    function isSkeletonReasonRepost(v) {
      return is$typed(v, id, hashSkeletonReasonRepost);
    }
    function validateSkeletonReasonRepost(v) {
      return validate(v, id, hashSkeletonReasonRepost);
    }
    const hashSkeletonReasonPin = "skeletonReasonPin";
    function isSkeletonReasonPin(v) {
      return is$typed(v, id, hashSkeletonReasonPin);
    }
    function validateSkeletonReasonPin(v) {
      return validate(v, id, hashSkeletonReasonPin);
    }
    const hashThreadgateView = "threadgateView";
    function isThreadgateView(v) {
      return is$typed(v, id, hashThreadgateView);
    }
    function validateThreadgateView(v) {
      return validate(v, id, hashThreadgateView);
    }
    const hashInteraction = "interaction";
    function isInteraction(v) {
      return is$typed(v, id, hashInteraction);
    }
    function validateInteraction(v) {
      return validate(v, id, hashInteraction);
    }
    defs$c.REQUESTLESS = `${id}#requestLess`;
    defs$c.REQUESTMORE = `${id}#requestMore`;
    defs$c.CLICKTHROUGHITEM = `${id}#clickthroughItem`;
    defs$c.CLICKTHROUGHAUTHOR = `${id}#clickthroughAuthor`;
    defs$c.CLICKTHROUGHREPOSTER = `${id}#clickthroughReposter`;
    defs$c.CLICKTHROUGHEMBED = `${id}#clickthroughEmbed`;
    defs$c.CONTENTMODEUNSPECIFIED = `${id}#contentModeUnspecified`;
    defs$c.CONTENTMODEVIDEO = `${id}#contentModeVideo`;
    defs$c.INTERACTIONSEEN = `${id}#interactionSeen`;
    defs$c.INTERACTIONLIKE = `${id}#interactionLike`;
    defs$c.INTERACTIONREPOST = `${id}#interactionRepost`;
    defs$c.INTERACTIONREPLY = `${id}#interactionReply`;
    defs$c.INTERACTIONQUOTE = `${id}#interactionQuote`;
    defs$c.INTERACTIONSHARE = `${id}#interactionShare`;
    return defs$c;
  }
  var describeFeedGenerator = {};
  var hasRequiredDescribeFeedGenerator;
  function requireDescribeFeedGenerator() {
    if (hasRequiredDescribeFeedGenerator) return describeFeedGenerator;
    hasRequiredDescribeFeedGenerator = 1;
    Object.defineProperty(describeFeedGenerator, "__esModule", { value: true });
    describeFeedGenerator.toKnownErr = toKnownErr;
    describeFeedGenerator.isFeed = isFeed;
    describeFeedGenerator.validateFeed = validateFeed;
    describeFeedGenerator.isLinks = isLinks;
    describeFeedGenerator.validateLinks = validateLinks;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "app.bsky.feed.describeFeedGenerator";
    function toKnownErr(e) {
      return e;
    }
    const hashFeed = "feed";
    function isFeed(v) {
      return is$typed(v, id, hashFeed);
    }
    function validateFeed(v) {
      return validate(v, id, hashFeed);
    }
    const hashLinks = "links";
    function isLinks(v) {
      return is$typed(v, id, hashLinks);
    }
    function validateLinks(v) {
      return validate(v, id, hashLinks);
    }
    return describeFeedGenerator;
  }
  var generator = {};
  var hasRequiredGenerator;
  function requireGenerator() {
    if (hasRequiredGenerator) return generator;
    hasRequiredGenerator = 1;
    Object.defineProperty(generator, "__esModule", { value: true });
    generator.isRecord = isRecord;
    generator.validateRecord = validateRecord;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "app.bsky.feed.generator";
    const hashRecord = "main";
    function isRecord(v) {
      return is$typed(v, id, hashRecord);
    }
    function validateRecord(v) {
      return validate(v, id, hashRecord, true);
    }
    return generator;
  }
  var getActorFeeds = {};
  var hasRequiredGetActorFeeds;
  function requireGetActorFeeds() {
    if (hasRequiredGetActorFeeds) return getActorFeeds;
    hasRequiredGetActorFeeds = 1;
    Object.defineProperty(getActorFeeds, "__esModule", { value: true });
    getActorFeeds.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return getActorFeeds;
  }
  var getFeedGenerator = {};
  var hasRequiredGetFeedGenerator;
  function requireGetFeedGenerator() {
    if (hasRequiredGetFeedGenerator) return getFeedGenerator;
    hasRequiredGetFeedGenerator = 1;
    Object.defineProperty(getFeedGenerator, "__esModule", { value: true });
    getFeedGenerator.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return getFeedGenerator;
  }
  var getFeedGenerators = {};
  var hasRequiredGetFeedGenerators;
  function requireGetFeedGenerators() {
    if (hasRequiredGetFeedGenerators) return getFeedGenerators;
    hasRequiredGetFeedGenerators = 1;
    Object.defineProperty(getFeedGenerators, "__esModule", { value: true });
    getFeedGenerators.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return getFeedGenerators;
  }
  var getLikes = {};
  var hasRequiredGetLikes;
  function requireGetLikes() {
    if (hasRequiredGetLikes) return getLikes;
    hasRequiredGetLikes = 1;
    Object.defineProperty(getLikes, "__esModule", { value: true });
    getLikes.toKnownErr = toKnownErr;
    getLikes.isLike = isLike;
    getLikes.validateLike = validateLike;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "app.bsky.feed.getLikes";
    function toKnownErr(e) {
      return e;
    }
    const hashLike = "like";
    function isLike(v) {
      return is$typed(v, id, hashLike);
    }
    function validateLike(v) {
      return validate(v, id, hashLike);
    }
    return getLikes;
  }
  var getPosts = {};
  var hasRequiredGetPosts;
  function requireGetPosts() {
    if (hasRequiredGetPosts) return getPosts;
    hasRequiredGetPosts = 1;
    Object.defineProperty(getPosts, "__esModule", { value: true });
    getPosts.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return getPosts;
  }
  var getQuotes = {};
  var hasRequiredGetQuotes;
  function requireGetQuotes() {
    if (hasRequiredGetQuotes) return getQuotes;
    hasRequiredGetQuotes = 1;
    Object.defineProperty(getQuotes, "__esModule", { value: true });
    getQuotes.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return getQuotes;
  }
  var getRepostedBy = {};
  var hasRequiredGetRepostedBy;
  function requireGetRepostedBy() {
    if (hasRequiredGetRepostedBy) return getRepostedBy;
    hasRequiredGetRepostedBy = 1;
    Object.defineProperty(getRepostedBy, "__esModule", { value: true });
    getRepostedBy.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return getRepostedBy;
  }
  var getSuggestedFeeds = {};
  var hasRequiredGetSuggestedFeeds;
  function requireGetSuggestedFeeds() {
    if (hasRequiredGetSuggestedFeeds) return getSuggestedFeeds;
    hasRequiredGetSuggestedFeeds = 1;
    Object.defineProperty(getSuggestedFeeds, "__esModule", { value: true });
    getSuggestedFeeds.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return getSuggestedFeeds;
  }
  var getTimeline = {};
  var hasRequiredGetTimeline;
  function requireGetTimeline() {
    if (hasRequiredGetTimeline) return getTimeline;
    hasRequiredGetTimeline = 1;
    Object.defineProperty(getTimeline, "__esModule", { value: true });
    getTimeline.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return getTimeline;
  }
  var like = {};
  var hasRequiredLike;
  function requireLike() {
    if (hasRequiredLike) return like;
    hasRequiredLike = 1;
    Object.defineProperty(like, "__esModule", { value: true });
    like.isRecord = isRecord;
    like.validateRecord = validateRecord;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "app.bsky.feed.like";
    const hashRecord = "main";
    function isRecord(v) {
      return is$typed(v, id, hashRecord);
    }
    function validateRecord(v) {
      return validate(v, id, hashRecord, true);
    }
    return like;
  }
  var post$1 = {};
  var hasRequiredPost$1;
  function requirePost$1() {
    if (hasRequiredPost$1) return post$1;
    hasRequiredPost$1 = 1;
    Object.defineProperty(post$1, "__esModule", { value: true });
    post$1.isRecord = isRecord;
    post$1.validateRecord = validateRecord;
    post$1.isReplyRef = isReplyRef;
    post$1.validateReplyRef = validateReplyRef;
    post$1.isEntity = isEntity;
    post$1.validateEntity = validateEntity;
    post$1.isTextSlice = isTextSlice;
    post$1.validateTextSlice = validateTextSlice;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "app.bsky.feed.post";
    const hashRecord = "main";
    function isRecord(v) {
      return is$typed(v, id, hashRecord);
    }
    function validateRecord(v) {
      return validate(v, id, hashRecord, true);
    }
    const hashReplyRef = "replyRef";
    function isReplyRef(v) {
      return is$typed(v, id, hashReplyRef);
    }
    function validateReplyRef(v) {
      return validate(v, id, hashReplyRef);
    }
    const hashEntity = "entity";
    function isEntity(v) {
      return is$typed(v, id, hashEntity);
    }
    function validateEntity(v) {
      return validate(v, id, hashEntity);
    }
    const hashTextSlice = "textSlice";
    function isTextSlice(v) {
      return is$typed(v, id, hashTextSlice);
    }
    function validateTextSlice(v) {
      return validate(v, id, hashTextSlice);
    }
    return post$1;
  }
  var postgate = {};
  var hasRequiredPostgate;
  function requirePostgate() {
    if (hasRequiredPostgate) return postgate;
    hasRequiredPostgate = 1;
    Object.defineProperty(postgate, "__esModule", { value: true });
    postgate.isRecord = isRecord;
    postgate.validateRecord = validateRecord;
    postgate.isDisableRule = isDisableRule;
    postgate.validateDisableRule = validateDisableRule;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "app.bsky.feed.postgate";
    const hashRecord = "main";
    function isRecord(v) {
      return is$typed(v, id, hashRecord);
    }
    function validateRecord(v) {
      return validate(v, id, hashRecord, true);
    }
    const hashDisableRule = "disableRule";
    function isDisableRule(v) {
      return is$typed(v, id, hashDisableRule);
    }
    function validateDisableRule(v) {
      return validate(v, id, hashDisableRule);
    }
    return postgate;
  }
  var repost = {};
  var hasRequiredRepost;
  function requireRepost() {
    if (hasRequiredRepost) return repost;
    hasRequiredRepost = 1;
    Object.defineProperty(repost, "__esModule", { value: true });
    repost.isRecord = isRecord;
    repost.validateRecord = validateRecord;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "app.bsky.feed.repost";
    const hashRecord = "main";
    function isRecord(v) {
      return is$typed(v, id, hashRecord);
    }
    function validateRecord(v) {
      return validate(v, id, hashRecord, true);
    }
    return repost;
  }
  var sendInteractions = {};
  var hasRequiredSendInteractions;
  function requireSendInteractions() {
    if (hasRequiredSendInteractions) return sendInteractions;
    hasRequiredSendInteractions = 1;
    Object.defineProperty(sendInteractions, "__esModule", { value: true });
    sendInteractions.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return sendInteractions;
  }
  var threadgate = {};
  var hasRequiredThreadgate;
  function requireThreadgate() {
    if (hasRequiredThreadgate) return threadgate;
    hasRequiredThreadgate = 1;
    Object.defineProperty(threadgate, "__esModule", { value: true });
    threadgate.isRecord = isRecord;
    threadgate.validateRecord = validateRecord;
    threadgate.isMentionRule = isMentionRule;
    threadgate.validateMentionRule = validateMentionRule;
    threadgate.isFollowerRule = isFollowerRule;
    threadgate.validateFollowerRule = validateFollowerRule;
    threadgate.isFollowingRule = isFollowingRule;
    threadgate.validateFollowingRule = validateFollowingRule;
    threadgate.isListRule = isListRule;
    threadgate.validateListRule = validateListRule;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "app.bsky.feed.threadgate";
    const hashRecord = "main";
    function isRecord(v) {
      return is$typed(v, id, hashRecord);
    }
    function validateRecord(v) {
      return validate(v, id, hashRecord, true);
    }
    const hashMentionRule = "mentionRule";
    function isMentionRule(v) {
      return is$typed(v, id, hashMentionRule);
    }
    function validateMentionRule(v) {
      return validate(v, id, hashMentionRule);
    }
    const hashFollowerRule = "followerRule";
    function isFollowerRule(v) {
      return is$typed(v, id, hashFollowerRule);
    }
    function validateFollowerRule(v) {
      return validate(v, id, hashFollowerRule);
    }
    const hashFollowingRule = "followingRule";
    function isFollowingRule(v) {
      return is$typed(v, id, hashFollowingRule);
    }
    function validateFollowingRule(v) {
      return validate(v, id, hashFollowingRule);
    }
    const hashListRule = "listRule";
    function isListRule(v) {
      return is$typed(v, id, hashListRule);
    }
    function validateListRule(v) {
      return validate(v, id, hashListRule);
    }
    return threadgate;
  }
  var block = {};
  var hasRequiredBlock;
  function requireBlock() {
    if (hasRequiredBlock) return block;
    hasRequiredBlock = 1;
    Object.defineProperty(block, "__esModule", { value: true });
    block.isRecord = isRecord;
    block.validateRecord = validateRecord;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "app.bsky.graph.block";
    const hashRecord = "main";
    function isRecord(v) {
      return is$typed(v, id, hashRecord);
    }
    function validateRecord(v) {
      return validate(v, id, hashRecord, true);
    }
    return block;
  }
  var defs$b = {};
  var hasRequiredDefs$b;
  function requireDefs$b() {
    if (hasRequiredDefs$b) return defs$b;
    hasRequiredDefs$b = 1;
    Object.defineProperty(defs$b, "__esModule", { value: true });
    defs$b.REFERENCELIST = defs$b.CURATELIST = defs$b.MODLIST = void 0;
    defs$b.isListViewBasic = isListViewBasic;
    defs$b.validateListViewBasic = validateListViewBasic;
    defs$b.isListView = isListView;
    defs$b.validateListView = validateListView;
    defs$b.isListItemView = isListItemView;
    defs$b.validateListItemView = validateListItemView;
    defs$b.isStarterPackView = isStarterPackView;
    defs$b.validateStarterPackView = validateStarterPackView;
    defs$b.isStarterPackViewBasic = isStarterPackViewBasic;
    defs$b.validateStarterPackViewBasic = validateStarterPackViewBasic;
    defs$b.isListViewerState = isListViewerState;
    defs$b.validateListViewerState = validateListViewerState;
    defs$b.isNotFoundActor = isNotFoundActor;
    defs$b.validateNotFoundActor = validateNotFoundActor;
    defs$b.isRelationship = isRelationship;
    defs$b.validateRelationship = validateRelationship;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "app.bsky.graph.defs";
    const hashListViewBasic = "listViewBasic";
    function isListViewBasic(v) {
      return is$typed(v, id, hashListViewBasic);
    }
    function validateListViewBasic(v) {
      return validate(v, id, hashListViewBasic);
    }
    const hashListView = "listView";
    function isListView(v) {
      return is$typed(v, id, hashListView);
    }
    function validateListView(v) {
      return validate(v, id, hashListView);
    }
    const hashListItemView = "listItemView";
    function isListItemView(v) {
      return is$typed(v, id, hashListItemView);
    }
    function validateListItemView(v) {
      return validate(v, id, hashListItemView);
    }
    const hashStarterPackView = "starterPackView";
    function isStarterPackView(v) {
      return is$typed(v, id, hashStarterPackView);
    }
    function validateStarterPackView(v) {
      return validate(v, id, hashStarterPackView);
    }
    const hashStarterPackViewBasic = "starterPackViewBasic";
    function isStarterPackViewBasic(v) {
      return is$typed(v, id, hashStarterPackViewBasic);
    }
    function validateStarterPackViewBasic(v) {
      return validate(v, id, hashStarterPackViewBasic);
    }
    defs$b.MODLIST = `${id}#modlist`;
    defs$b.CURATELIST = `${id}#curatelist`;
    defs$b.REFERENCELIST = `${id}#referencelist`;
    const hashListViewerState = "listViewerState";
    function isListViewerState(v) {
      return is$typed(v, id, hashListViewerState);
    }
    function validateListViewerState(v) {
      return validate(v, id, hashListViewerState);
    }
    const hashNotFoundActor = "notFoundActor";
    function isNotFoundActor(v) {
      return is$typed(v, id, hashNotFoundActor);
    }
    function validateNotFoundActor(v) {
      return validate(v, id, hashNotFoundActor);
    }
    const hashRelationship = "relationship";
    function isRelationship(v) {
      return is$typed(v, id, hashRelationship);
    }
    function validateRelationship(v) {
      return validate(v, id, hashRelationship);
    }
    return defs$b;
  }
  var follow = {};
  var hasRequiredFollow;
  function requireFollow() {
    if (hasRequiredFollow) return follow;
    hasRequiredFollow = 1;
    Object.defineProperty(follow, "__esModule", { value: true });
    follow.isRecord = isRecord;
    follow.validateRecord = validateRecord;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "app.bsky.graph.follow";
    const hashRecord = "main";
    function isRecord(v) {
      return is$typed(v, id, hashRecord);
    }
    function validateRecord(v) {
      return validate(v, id, hashRecord, true);
    }
    return follow;
  }
  var getActorStarterPacks = {};
  var hasRequiredGetActorStarterPacks;
  function requireGetActorStarterPacks() {
    if (hasRequiredGetActorStarterPacks) return getActorStarterPacks;
    hasRequiredGetActorStarterPacks = 1;
    Object.defineProperty(getActorStarterPacks, "__esModule", { value: true });
    getActorStarterPacks.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return getActorStarterPacks;
  }
  var getBlocks = {};
  var hasRequiredGetBlocks;
  function requireGetBlocks() {
    if (hasRequiredGetBlocks) return getBlocks;
    hasRequiredGetBlocks = 1;
    Object.defineProperty(getBlocks, "__esModule", { value: true });
    getBlocks.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return getBlocks;
  }
  var getFollowers = {};
  var hasRequiredGetFollowers;
  function requireGetFollowers() {
    if (hasRequiredGetFollowers) return getFollowers;
    hasRequiredGetFollowers = 1;
    Object.defineProperty(getFollowers, "__esModule", { value: true });
    getFollowers.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return getFollowers;
  }
  var getFollows = {};
  var hasRequiredGetFollows;
  function requireGetFollows() {
    if (hasRequiredGetFollows) return getFollows;
    hasRequiredGetFollows = 1;
    Object.defineProperty(getFollows, "__esModule", { value: true });
    getFollows.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return getFollows;
  }
  var getKnownFollowers = {};
  var hasRequiredGetKnownFollowers;
  function requireGetKnownFollowers() {
    if (hasRequiredGetKnownFollowers) return getKnownFollowers;
    hasRequiredGetKnownFollowers = 1;
    Object.defineProperty(getKnownFollowers, "__esModule", { value: true });
    getKnownFollowers.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return getKnownFollowers;
  }
  var getList = {};
  var hasRequiredGetList;
  function requireGetList() {
    if (hasRequiredGetList) return getList;
    hasRequiredGetList = 1;
    Object.defineProperty(getList, "__esModule", { value: true });
    getList.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return getList;
  }
  var getListBlocks = {};
  var hasRequiredGetListBlocks;
  function requireGetListBlocks() {
    if (hasRequiredGetListBlocks) return getListBlocks;
    hasRequiredGetListBlocks = 1;
    Object.defineProperty(getListBlocks, "__esModule", { value: true });
    getListBlocks.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return getListBlocks;
  }
  var getListMutes = {};
  var hasRequiredGetListMutes;
  function requireGetListMutes() {
    if (hasRequiredGetListMutes) return getListMutes;
    hasRequiredGetListMutes = 1;
    Object.defineProperty(getListMutes, "__esModule", { value: true });
    getListMutes.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return getListMutes;
  }
  var getLists = {};
  var hasRequiredGetLists;
  function requireGetLists() {
    if (hasRequiredGetLists) return getLists;
    hasRequiredGetLists = 1;
    Object.defineProperty(getLists, "__esModule", { value: true });
    getLists.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return getLists;
  }
  var getMutes = {};
  var hasRequiredGetMutes;
  function requireGetMutes() {
    if (hasRequiredGetMutes) return getMutes;
    hasRequiredGetMutes = 1;
    Object.defineProperty(getMutes, "__esModule", { value: true });
    getMutes.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return getMutes;
  }
  var getStarterPack = {};
  var hasRequiredGetStarterPack;
  function requireGetStarterPack() {
    if (hasRequiredGetStarterPack) return getStarterPack;
    hasRequiredGetStarterPack = 1;
    Object.defineProperty(getStarterPack, "__esModule", { value: true });
    getStarterPack.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return getStarterPack;
  }
  var getStarterPacks = {};
  var hasRequiredGetStarterPacks;
  function requireGetStarterPacks() {
    if (hasRequiredGetStarterPacks) return getStarterPacks;
    hasRequiredGetStarterPacks = 1;
    Object.defineProperty(getStarterPacks, "__esModule", { value: true });
    getStarterPacks.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return getStarterPacks;
  }
  var getSuggestedFollowsByActor = {};
  var hasRequiredGetSuggestedFollowsByActor;
  function requireGetSuggestedFollowsByActor() {
    if (hasRequiredGetSuggestedFollowsByActor) return getSuggestedFollowsByActor;
    hasRequiredGetSuggestedFollowsByActor = 1;
    Object.defineProperty(getSuggestedFollowsByActor, "__esModule", { value: true });
    getSuggestedFollowsByActor.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return getSuggestedFollowsByActor;
  }
  var list = {};
  var hasRequiredList;
  function requireList() {
    if (hasRequiredList) return list;
    hasRequiredList = 1;
    Object.defineProperty(list, "__esModule", { value: true });
    list.isRecord = isRecord;
    list.validateRecord = validateRecord;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "app.bsky.graph.list";
    const hashRecord = "main";
    function isRecord(v) {
      return is$typed(v, id, hashRecord);
    }
    function validateRecord(v) {
      return validate(v, id, hashRecord, true);
    }
    return list;
  }
  var listblock = {};
  var hasRequiredListblock;
  function requireListblock() {
    if (hasRequiredListblock) return listblock;
    hasRequiredListblock = 1;
    Object.defineProperty(listblock, "__esModule", { value: true });
    listblock.isRecord = isRecord;
    listblock.validateRecord = validateRecord;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "app.bsky.graph.listblock";
    const hashRecord = "main";
    function isRecord(v) {
      return is$typed(v, id, hashRecord);
    }
    function validateRecord(v) {
      return validate(v, id, hashRecord, true);
    }
    return listblock;
  }
  var listitem = {};
  var hasRequiredListitem;
  function requireListitem() {
    if (hasRequiredListitem) return listitem;
    hasRequiredListitem = 1;
    Object.defineProperty(listitem, "__esModule", { value: true });
    listitem.isRecord = isRecord;
    listitem.validateRecord = validateRecord;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "app.bsky.graph.listitem";
    const hashRecord = "main";
    function isRecord(v) {
      return is$typed(v, id, hashRecord);
    }
    function validateRecord(v) {
      return validate(v, id, hashRecord, true);
    }
    return listitem;
  }
  var muteActor = {};
  var hasRequiredMuteActor;
  function requireMuteActor() {
    if (hasRequiredMuteActor) return muteActor;
    hasRequiredMuteActor = 1;
    Object.defineProperty(muteActor, "__esModule", { value: true });
    muteActor.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return muteActor;
  }
  var muteActorList = {};
  var hasRequiredMuteActorList;
  function requireMuteActorList() {
    if (hasRequiredMuteActorList) return muteActorList;
    hasRequiredMuteActorList = 1;
    Object.defineProperty(muteActorList, "__esModule", { value: true });
    muteActorList.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return muteActorList;
  }
  var muteThread = {};
  var hasRequiredMuteThread;
  function requireMuteThread() {
    if (hasRequiredMuteThread) return muteThread;
    hasRequiredMuteThread = 1;
    Object.defineProperty(muteThread, "__esModule", { value: true });
    muteThread.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return muteThread;
  }
  var searchStarterPacks = {};
  var hasRequiredSearchStarterPacks;
  function requireSearchStarterPacks() {
    if (hasRequiredSearchStarterPacks) return searchStarterPacks;
    hasRequiredSearchStarterPacks = 1;
    Object.defineProperty(searchStarterPacks, "__esModule", { value: true });
    searchStarterPacks.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return searchStarterPacks;
  }
  var starterpack = {};
  var hasRequiredStarterpack;
  function requireStarterpack() {
    if (hasRequiredStarterpack) return starterpack;
    hasRequiredStarterpack = 1;
    Object.defineProperty(starterpack, "__esModule", { value: true });
    starterpack.isRecord = isRecord;
    starterpack.validateRecord = validateRecord;
    starterpack.isFeedItem = isFeedItem;
    starterpack.validateFeedItem = validateFeedItem;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "app.bsky.graph.starterpack";
    const hashRecord = "main";
    function isRecord(v) {
      return is$typed(v, id, hashRecord);
    }
    function validateRecord(v) {
      return validate(v, id, hashRecord, true);
    }
    const hashFeedItem = "feedItem";
    function isFeedItem(v) {
      return is$typed(v, id, hashFeedItem);
    }
    function validateFeedItem(v) {
      return validate(v, id, hashFeedItem);
    }
    return starterpack;
  }
  var unmuteActor = {};
  var hasRequiredUnmuteActor;
  function requireUnmuteActor() {
    if (hasRequiredUnmuteActor) return unmuteActor;
    hasRequiredUnmuteActor = 1;
    Object.defineProperty(unmuteActor, "__esModule", { value: true });
    unmuteActor.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return unmuteActor;
  }
  var unmuteActorList = {};
  var hasRequiredUnmuteActorList;
  function requireUnmuteActorList() {
    if (hasRequiredUnmuteActorList) return unmuteActorList;
    hasRequiredUnmuteActorList = 1;
    Object.defineProperty(unmuteActorList, "__esModule", { value: true });
    unmuteActorList.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return unmuteActorList;
  }
  var unmuteThread = {};
  var hasRequiredUnmuteThread;
  function requireUnmuteThread() {
    if (hasRequiredUnmuteThread) return unmuteThread;
    hasRequiredUnmuteThread = 1;
    Object.defineProperty(unmuteThread, "__esModule", { value: true });
    unmuteThread.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return unmuteThread;
  }
  var defs$a = {};
  var hasRequiredDefs$a;
  function requireDefs$a() {
    if (hasRequiredDefs$a) return defs$a;
    hasRequiredDefs$a = 1;
    Object.defineProperty(defs$a, "__esModule", { value: true });
    defs$a.isLabelerView = isLabelerView;
    defs$a.validateLabelerView = validateLabelerView;
    defs$a.isLabelerViewDetailed = isLabelerViewDetailed;
    defs$a.validateLabelerViewDetailed = validateLabelerViewDetailed;
    defs$a.isLabelerViewerState = isLabelerViewerState;
    defs$a.validateLabelerViewerState = validateLabelerViewerState;
    defs$a.isLabelerPolicies = isLabelerPolicies;
    defs$a.validateLabelerPolicies = validateLabelerPolicies;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "app.bsky.labeler.defs";
    const hashLabelerView = "labelerView";
    function isLabelerView(v) {
      return is$typed(v, id, hashLabelerView);
    }
    function validateLabelerView(v) {
      return validate(v, id, hashLabelerView);
    }
    const hashLabelerViewDetailed = "labelerViewDetailed";
    function isLabelerViewDetailed(v) {
      return is$typed(v, id, hashLabelerViewDetailed);
    }
    function validateLabelerViewDetailed(v) {
      return validate(v, id, hashLabelerViewDetailed);
    }
    const hashLabelerViewerState = "labelerViewerState";
    function isLabelerViewerState(v) {
      return is$typed(v, id, hashLabelerViewerState);
    }
    function validateLabelerViewerState(v) {
      return validate(v, id, hashLabelerViewerState);
    }
    const hashLabelerPolicies = "labelerPolicies";
    function isLabelerPolicies(v) {
      return is$typed(v, id, hashLabelerPolicies);
    }
    function validateLabelerPolicies(v) {
      return validate(v, id, hashLabelerPolicies);
    }
    return defs$a;
  }
  var getServices = {};
  var hasRequiredGetServices;
  function requireGetServices() {
    if (hasRequiredGetServices) return getServices;
    hasRequiredGetServices = 1;
    Object.defineProperty(getServices, "__esModule", { value: true });
    getServices.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return getServices;
  }
  var service = {};
  var hasRequiredService;
  function requireService() {
    if (hasRequiredService) return service;
    hasRequiredService = 1;
    Object.defineProperty(service, "__esModule", { value: true });
    service.isRecord = isRecord;
    service.validateRecord = validateRecord;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "app.bsky.labeler.service";
    const hashRecord = "main";
    function isRecord(v) {
      return is$typed(v, id, hashRecord);
    }
    function validateRecord(v) {
      return validate(v, id, hashRecord, true);
    }
    return service;
  }
  var getUnreadCount = {};
  var hasRequiredGetUnreadCount;
  function requireGetUnreadCount() {
    if (hasRequiredGetUnreadCount) return getUnreadCount;
    hasRequiredGetUnreadCount = 1;
    Object.defineProperty(getUnreadCount, "__esModule", { value: true });
    getUnreadCount.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return getUnreadCount;
  }
  var listNotifications = {};
  var hasRequiredListNotifications;
  function requireListNotifications() {
    if (hasRequiredListNotifications) return listNotifications;
    hasRequiredListNotifications = 1;
    Object.defineProperty(listNotifications, "__esModule", { value: true });
    listNotifications.toKnownErr = toKnownErr;
    listNotifications.isNotification = isNotification;
    listNotifications.validateNotification = validateNotification;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "app.bsky.notification.listNotifications";
    function toKnownErr(e) {
      return e;
    }
    const hashNotification = "notification";
    function isNotification(v) {
      return is$typed(v, id, hashNotification);
    }
    function validateNotification(v) {
      return validate(v, id, hashNotification);
    }
    return listNotifications;
  }
  var putPreferences = {};
  var hasRequiredPutPreferences;
  function requirePutPreferences() {
    if (hasRequiredPutPreferences) return putPreferences;
    hasRequiredPutPreferences = 1;
    Object.defineProperty(putPreferences, "__esModule", { value: true });
    putPreferences.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return putPreferences;
  }
  var registerPush = {};
  var hasRequiredRegisterPush;
  function requireRegisterPush() {
    if (hasRequiredRegisterPush) return registerPush;
    hasRequiredRegisterPush = 1;
    Object.defineProperty(registerPush, "__esModule", { value: true });
    registerPush.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return registerPush;
  }
  var updateSeen = {};
  var hasRequiredUpdateSeen;
  function requireUpdateSeen() {
    if (hasRequiredUpdateSeen) return updateSeen;
    hasRequiredUpdateSeen = 1;
    Object.defineProperty(updateSeen, "__esModule", { value: true });
    updateSeen.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return updateSeen;
  }
  var facet = {};
  var hasRequiredFacet;
  function requireFacet() {
    if (hasRequiredFacet) return facet;
    hasRequiredFacet = 1;
    Object.defineProperty(facet, "__esModule", { value: true });
    facet.isMain = isMain;
    facet.validateMain = validateMain;
    facet.isMention = isMention;
    facet.validateMention = validateMention;
    facet.isLink = isLink;
    facet.validateLink = validateLink;
    facet.isTag = isTag;
    facet.validateTag = validateTag;
    facet.isByteSlice = isByteSlice;
    facet.validateByteSlice = validateByteSlice;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "app.bsky.richtext.facet";
    const hashMain = "main";
    function isMain(v) {
      return is$typed(v, id, hashMain);
    }
    function validateMain(v) {
      return validate(v, id, hashMain);
    }
    const hashMention = "mention";
    function isMention(v) {
      return is$typed(v, id, hashMention);
    }
    function validateMention(v) {
      return validate(v, id, hashMention);
    }
    const hashLink = "link";
    function isLink(v) {
      return is$typed(v, id, hashLink);
    }
    function validateLink(v) {
      return validate(v, id, hashLink);
    }
    const hashTag = "tag";
    function isTag(v) {
      return is$typed(v, id, hashTag);
    }
    function validateTag(v) {
      return validate(v, id, hashTag);
    }
    const hashByteSlice = "byteSlice";
    function isByteSlice(v) {
      return is$typed(v, id, hashByteSlice);
    }
    function validateByteSlice(v) {
      return validate(v, id, hashByteSlice);
    }
    return facet;
  }
  var defs$9 = {};
  var hasRequiredDefs$9;
  function requireDefs$9() {
    if (hasRequiredDefs$9) return defs$9;
    hasRequiredDefs$9 = 1;
    Object.defineProperty(defs$9, "__esModule", { value: true });
    defs$9.isSkeletonSearchPost = isSkeletonSearchPost;
    defs$9.validateSkeletonSearchPost = validateSkeletonSearchPost;
    defs$9.isSkeletonSearchActor = isSkeletonSearchActor;
    defs$9.validateSkeletonSearchActor = validateSkeletonSearchActor;
    defs$9.isSkeletonSearchStarterPack = isSkeletonSearchStarterPack;
    defs$9.validateSkeletonSearchStarterPack = validateSkeletonSearchStarterPack;
    defs$9.isTrendingTopic = isTrendingTopic;
    defs$9.validateTrendingTopic = validateTrendingTopic;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "app.bsky.unspecced.defs";
    const hashSkeletonSearchPost = "skeletonSearchPost";
    function isSkeletonSearchPost(v) {
      return is$typed(v, id, hashSkeletonSearchPost);
    }
    function validateSkeletonSearchPost(v) {
      return validate(v, id, hashSkeletonSearchPost);
    }
    const hashSkeletonSearchActor = "skeletonSearchActor";
    function isSkeletonSearchActor(v) {
      return is$typed(v, id, hashSkeletonSearchActor);
    }
    function validateSkeletonSearchActor(v) {
      return validate(v, id, hashSkeletonSearchActor);
    }
    const hashSkeletonSearchStarterPack = "skeletonSearchStarterPack";
    function isSkeletonSearchStarterPack(v) {
      return is$typed(v, id, hashSkeletonSearchStarterPack);
    }
    function validateSkeletonSearchStarterPack(v) {
      return validate(v, id, hashSkeletonSearchStarterPack);
    }
    const hashTrendingTopic = "trendingTopic";
    function isTrendingTopic(v) {
      return is$typed(v, id, hashTrendingTopic);
    }
    function validateTrendingTopic(v) {
      return validate(v, id, hashTrendingTopic);
    }
    return defs$9;
  }
  var getConfig$1 = {};
  var hasRequiredGetConfig$1;
  function requireGetConfig$1() {
    if (hasRequiredGetConfig$1) return getConfig$1;
    hasRequiredGetConfig$1 = 1;
    Object.defineProperty(getConfig$1, "__esModule", { value: true });
    getConfig$1.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return getConfig$1;
  }
  var getPopularFeedGenerators = {};
  var hasRequiredGetPopularFeedGenerators;
  function requireGetPopularFeedGenerators() {
    if (hasRequiredGetPopularFeedGenerators) return getPopularFeedGenerators;
    hasRequiredGetPopularFeedGenerators = 1;
    Object.defineProperty(getPopularFeedGenerators, "__esModule", { value: true });
    getPopularFeedGenerators.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return getPopularFeedGenerators;
  }
  var getSuggestionsSkeleton = {};
  var hasRequiredGetSuggestionsSkeleton;
  function requireGetSuggestionsSkeleton() {
    if (hasRequiredGetSuggestionsSkeleton) return getSuggestionsSkeleton;
    hasRequiredGetSuggestionsSkeleton = 1;
    Object.defineProperty(getSuggestionsSkeleton, "__esModule", { value: true });
    getSuggestionsSkeleton.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return getSuggestionsSkeleton;
  }
  var getTaggedSuggestions = {};
  var hasRequiredGetTaggedSuggestions;
  function requireGetTaggedSuggestions() {
    if (hasRequiredGetTaggedSuggestions) return getTaggedSuggestions;
    hasRequiredGetTaggedSuggestions = 1;
    Object.defineProperty(getTaggedSuggestions, "__esModule", { value: true });
    getTaggedSuggestions.toKnownErr = toKnownErr;
    getTaggedSuggestions.isSuggestion = isSuggestion;
    getTaggedSuggestions.validateSuggestion = validateSuggestion;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "app.bsky.unspecced.getTaggedSuggestions";
    function toKnownErr(e) {
      return e;
    }
    const hashSuggestion = "suggestion";
    function isSuggestion(v) {
      return is$typed(v, id, hashSuggestion);
    }
    function validateSuggestion(v) {
      return validate(v, id, hashSuggestion);
    }
    return getTaggedSuggestions;
  }
  var getTrendingTopics = {};
  var hasRequiredGetTrendingTopics;
  function requireGetTrendingTopics() {
    if (hasRequiredGetTrendingTopics) return getTrendingTopics;
    hasRequiredGetTrendingTopics = 1;
    Object.defineProperty(getTrendingTopics, "__esModule", { value: true });
    getTrendingTopics.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return getTrendingTopics;
  }
  var defs$8 = {};
  var hasRequiredDefs$8;
  function requireDefs$8() {
    if (hasRequiredDefs$8) return defs$8;
    hasRequiredDefs$8 = 1;
    Object.defineProperty(defs$8, "__esModule", { value: true });
    defs$8.isJobStatus = isJobStatus;
    defs$8.validateJobStatus = validateJobStatus;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "app.bsky.video.defs";
    const hashJobStatus = "jobStatus";
    function isJobStatus(v) {
      return is$typed(v, id, hashJobStatus);
    }
    function validateJobStatus(v) {
      return validate(v, id, hashJobStatus);
    }
    return defs$8;
  }
  var getJobStatus = {};
  var hasRequiredGetJobStatus;
  function requireGetJobStatus() {
    if (hasRequiredGetJobStatus) return getJobStatus;
    hasRequiredGetJobStatus = 1;
    Object.defineProperty(getJobStatus, "__esModule", { value: true });
    getJobStatus.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return getJobStatus;
  }
  var getUploadLimits = {};
  var hasRequiredGetUploadLimits;
  function requireGetUploadLimits() {
    if (hasRequiredGetUploadLimits) return getUploadLimits;
    hasRequiredGetUploadLimits = 1;
    Object.defineProperty(getUploadLimits, "__esModule", { value: true });
    getUploadLimits.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return getUploadLimits;
  }
  var uploadVideo = {};
  var hasRequiredUploadVideo;
  function requireUploadVideo() {
    if (hasRequiredUploadVideo) return uploadVideo;
    hasRequiredUploadVideo = 1;
    Object.defineProperty(uploadVideo, "__esModule", { value: true });
    uploadVideo.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return uploadVideo;
  }
  var declaration = {};
  var hasRequiredDeclaration;
  function requireDeclaration() {
    if (hasRequiredDeclaration) return declaration;
    hasRequiredDeclaration = 1;
    Object.defineProperty(declaration, "__esModule", { value: true });
    declaration.isRecord = isRecord;
    declaration.validateRecord = validateRecord;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "chat.bsky.actor.declaration";
    const hashRecord = "main";
    function isRecord(v) {
      return is$typed(v, id, hashRecord);
    }
    function validateRecord(v) {
      return validate(v, id, hashRecord, true);
    }
    return declaration;
  }
  var defs$7 = {};
  var hasRequiredDefs$7;
  function requireDefs$7() {
    if (hasRequiredDefs$7) return defs$7;
    hasRequiredDefs$7 = 1;
    Object.defineProperty(defs$7, "__esModule", { value: true });
    defs$7.isProfileViewBasic = isProfileViewBasic;
    defs$7.validateProfileViewBasic = validateProfileViewBasic;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "chat.bsky.actor.defs";
    const hashProfileViewBasic = "profileViewBasic";
    function isProfileViewBasic(v) {
      return is$typed(v, id, hashProfileViewBasic);
    }
    function validateProfileViewBasic(v) {
      return validate(v, id, hashProfileViewBasic);
    }
    return defs$7;
  }
  var deleteAccount = {};
  var hasRequiredDeleteAccount;
  function requireDeleteAccount() {
    if (hasRequiredDeleteAccount) return deleteAccount;
    hasRequiredDeleteAccount = 1;
    Object.defineProperty(deleteAccount, "__esModule", { value: true });
    deleteAccount.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return deleteAccount;
  }
  var exportAccountData = {};
  var hasRequiredExportAccountData;
  function requireExportAccountData() {
    if (hasRequiredExportAccountData) return exportAccountData;
    hasRequiredExportAccountData = 1;
    Object.defineProperty(exportAccountData, "__esModule", { value: true });
    exportAccountData.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return exportAccountData;
  }
  var defs$6 = {};
  var hasRequiredDefs$6;
  function requireDefs$6() {
    if (hasRequiredDefs$6) return defs$6;
    hasRequiredDefs$6 = 1;
    Object.defineProperty(defs$6, "__esModule", { value: true });
    defs$6.isMessageRef = isMessageRef;
    defs$6.validateMessageRef = validateMessageRef;
    defs$6.isMessageInput = isMessageInput;
    defs$6.validateMessageInput = validateMessageInput;
    defs$6.isMessageView = isMessageView;
    defs$6.validateMessageView = validateMessageView;
    defs$6.isDeletedMessageView = isDeletedMessageView;
    defs$6.validateDeletedMessageView = validateDeletedMessageView;
    defs$6.isMessageViewSender = isMessageViewSender;
    defs$6.validateMessageViewSender = validateMessageViewSender;
    defs$6.isConvoView = isConvoView;
    defs$6.validateConvoView = validateConvoView;
    defs$6.isLogBeginConvo = isLogBeginConvo;
    defs$6.validateLogBeginConvo = validateLogBeginConvo;
    defs$6.isLogLeaveConvo = isLogLeaveConvo;
    defs$6.validateLogLeaveConvo = validateLogLeaveConvo;
    defs$6.isLogCreateMessage = isLogCreateMessage;
    defs$6.validateLogCreateMessage = validateLogCreateMessage;
    defs$6.isLogDeleteMessage = isLogDeleteMessage;
    defs$6.validateLogDeleteMessage = validateLogDeleteMessage;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "chat.bsky.convo.defs";
    const hashMessageRef = "messageRef";
    function isMessageRef(v) {
      return is$typed(v, id, hashMessageRef);
    }
    function validateMessageRef(v) {
      return validate(v, id, hashMessageRef);
    }
    const hashMessageInput = "messageInput";
    function isMessageInput(v) {
      return is$typed(v, id, hashMessageInput);
    }
    function validateMessageInput(v) {
      return validate(v, id, hashMessageInput);
    }
    const hashMessageView = "messageView";
    function isMessageView(v) {
      return is$typed(v, id, hashMessageView);
    }
    function validateMessageView(v) {
      return validate(v, id, hashMessageView);
    }
    const hashDeletedMessageView = "deletedMessageView";
    function isDeletedMessageView(v) {
      return is$typed(v, id, hashDeletedMessageView);
    }
    function validateDeletedMessageView(v) {
      return validate(v, id, hashDeletedMessageView);
    }
    const hashMessageViewSender = "messageViewSender";
    function isMessageViewSender(v) {
      return is$typed(v, id, hashMessageViewSender);
    }
    function validateMessageViewSender(v) {
      return validate(v, id, hashMessageViewSender);
    }
    const hashConvoView = "convoView";
    function isConvoView(v) {
      return is$typed(v, id, hashConvoView);
    }
    function validateConvoView(v) {
      return validate(v, id, hashConvoView);
    }
    const hashLogBeginConvo = "logBeginConvo";
    function isLogBeginConvo(v) {
      return is$typed(v, id, hashLogBeginConvo);
    }
    function validateLogBeginConvo(v) {
      return validate(v, id, hashLogBeginConvo);
    }
    const hashLogLeaveConvo = "logLeaveConvo";
    function isLogLeaveConvo(v) {
      return is$typed(v, id, hashLogLeaveConvo);
    }
    function validateLogLeaveConvo(v) {
      return validate(v, id, hashLogLeaveConvo);
    }
    const hashLogCreateMessage = "logCreateMessage";
    function isLogCreateMessage(v) {
      return is$typed(v, id, hashLogCreateMessage);
    }
    function validateLogCreateMessage(v) {
      return validate(v, id, hashLogCreateMessage);
    }
    const hashLogDeleteMessage = "logDeleteMessage";
    function isLogDeleteMessage(v) {
      return is$typed(v, id, hashLogDeleteMessage);
    }
    function validateLogDeleteMessage(v) {
      return validate(v, id, hashLogDeleteMessage);
    }
    return defs$6;
  }
  var deleteMessageForSelf = {};
  var hasRequiredDeleteMessageForSelf;
  function requireDeleteMessageForSelf() {
    if (hasRequiredDeleteMessageForSelf) return deleteMessageForSelf;
    hasRequiredDeleteMessageForSelf = 1;
    Object.defineProperty(deleteMessageForSelf, "__esModule", { value: true });
    deleteMessageForSelf.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return deleteMessageForSelf;
  }
  var getConvo = {};
  var hasRequiredGetConvo;
  function requireGetConvo() {
    if (hasRequiredGetConvo) return getConvo;
    hasRequiredGetConvo = 1;
    Object.defineProperty(getConvo, "__esModule", { value: true });
    getConvo.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return getConvo;
  }
  var getConvoForMembers = {};
  var hasRequiredGetConvoForMembers;
  function requireGetConvoForMembers() {
    if (hasRequiredGetConvoForMembers) return getConvoForMembers;
    hasRequiredGetConvoForMembers = 1;
    Object.defineProperty(getConvoForMembers, "__esModule", { value: true });
    getConvoForMembers.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return getConvoForMembers;
  }
  var getLog = {};
  var hasRequiredGetLog;
  function requireGetLog() {
    if (hasRequiredGetLog) return getLog;
    hasRequiredGetLog = 1;
    Object.defineProperty(getLog, "__esModule", { value: true });
    getLog.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return getLog;
  }
  var getMessages = {};
  var hasRequiredGetMessages;
  function requireGetMessages() {
    if (hasRequiredGetMessages) return getMessages;
    hasRequiredGetMessages = 1;
    Object.defineProperty(getMessages, "__esModule", { value: true });
    getMessages.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return getMessages;
  }
  var leaveConvo = {};
  var hasRequiredLeaveConvo;
  function requireLeaveConvo() {
    if (hasRequiredLeaveConvo) return leaveConvo;
    hasRequiredLeaveConvo = 1;
    Object.defineProperty(leaveConvo, "__esModule", { value: true });
    leaveConvo.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return leaveConvo;
  }
  var listConvos = {};
  var hasRequiredListConvos;
  function requireListConvos() {
    if (hasRequiredListConvos) return listConvos;
    hasRequiredListConvos = 1;
    Object.defineProperty(listConvos, "__esModule", { value: true });
    listConvos.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return listConvos;
  }
  var muteConvo = {};
  var hasRequiredMuteConvo;
  function requireMuteConvo() {
    if (hasRequiredMuteConvo) return muteConvo;
    hasRequiredMuteConvo = 1;
    Object.defineProperty(muteConvo, "__esModule", { value: true });
    muteConvo.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return muteConvo;
  }
  var sendMessage = {};
  var hasRequiredSendMessage;
  function requireSendMessage() {
    if (hasRequiredSendMessage) return sendMessage;
    hasRequiredSendMessage = 1;
    Object.defineProperty(sendMessage, "__esModule", { value: true });
    sendMessage.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return sendMessage;
  }
  var sendMessageBatch = {};
  var hasRequiredSendMessageBatch;
  function requireSendMessageBatch() {
    if (hasRequiredSendMessageBatch) return sendMessageBatch;
    hasRequiredSendMessageBatch = 1;
    Object.defineProperty(sendMessageBatch, "__esModule", { value: true });
    sendMessageBatch.toKnownErr = toKnownErr;
    sendMessageBatch.isBatchItem = isBatchItem;
    sendMessageBatch.validateBatchItem = validateBatchItem;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "chat.bsky.convo.sendMessageBatch";
    function toKnownErr(e) {
      return e;
    }
    const hashBatchItem = "batchItem";
    function isBatchItem(v) {
      return is$typed(v, id, hashBatchItem);
    }
    function validateBatchItem(v) {
      return validate(v, id, hashBatchItem);
    }
    return sendMessageBatch;
  }
  var unmuteConvo = {};
  var hasRequiredUnmuteConvo;
  function requireUnmuteConvo() {
    if (hasRequiredUnmuteConvo) return unmuteConvo;
    hasRequiredUnmuteConvo = 1;
    Object.defineProperty(unmuteConvo, "__esModule", { value: true });
    unmuteConvo.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return unmuteConvo;
  }
  var updateRead = {};
  var hasRequiredUpdateRead;
  function requireUpdateRead() {
    if (hasRequiredUpdateRead) return updateRead;
    hasRequiredUpdateRead = 1;
    Object.defineProperty(updateRead, "__esModule", { value: true });
    updateRead.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return updateRead;
  }
  var getActorMetadata = {};
  var hasRequiredGetActorMetadata;
  function requireGetActorMetadata() {
    if (hasRequiredGetActorMetadata) return getActorMetadata;
    hasRequiredGetActorMetadata = 1;
    Object.defineProperty(getActorMetadata, "__esModule", { value: true });
    getActorMetadata.toKnownErr = toKnownErr;
    getActorMetadata.isMetadata = isMetadata;
    getActorMetadata.validateMetadata = validateMetadata;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "chat.bsky.moderation.getActorMetadata";
    function toKnownErr(e) {
      return e;
    }
    const hashMetadata = "metadata";
    function isMetadata(v) {
      return is$typed(v, id, hashMetadata);
    }
    function validateMetadata(v) {
      return validate(v, id, hashMetadata);
    }
    return getActorMetadata;
  }
  var getMessageContext = {};
  var hasRequiredGetMessageContext;
  function requireGetMessageContext() {
    if (hasRequiredGetMessageContext) return getMessageContext;
    hasRequiredGetMessageContext = 1;
    Object.defineProperty(getMessageContext, "__esModule", { value: true });
    getMessageContext.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return getMessageContext;
  }
  var updateActorAccess = {};
  var hasRequiredUpdateActorAccess;
  function requireUpdateActorAccess() {
    if (hasRequiredUpdateActorAccess) return updateActorAccess;
    hasRequiredUpdateActorAccess = 1;
    Object.defineProperty(updateActorAccess, "__esModule", { value: true });
    updateActorAccess.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return updateActorAccess;
  }
  var defs$5 = {};
  var hasRequiredDefs$5;
  function requireDefs$5() {
    if (hasRequiredDefs$5) return defs$5;
    hasRequiredDefs$5 = 1;
    Object.defineProperty(defs$5, "__esModule", { value: true });
    defs$5.isTemplateView = isTemplateView;
    defs$5.validateTemplateView = validateTemplateView;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "tools.ozone.communication.defs";
    const hashTemplateView = "templateView";
    function isTemplateView(v) {
      return is$typed(v, id, hashTemplateView);
    }
    function validateTemplateView(v) {
      return validate(v, id, hashTemplateView);
    }
    return defs$5;
  }
  var deleteTemplate = {};
  var hasRequiredDeleteTemplate;
  function requireDeleteTemplate() {
    if (hasRequiredDeleteTemplate) return deleteTemplate;
    hasRequiredDeleteTemplate = 1;
    Object.defineProperty(deleteTemplate, "__esModule", { value: true });
    deleteTemplate.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return deleteTemplate;
  }
  var listTemplates = {};
  var hasRequiredListTemplates;
  function requireListTemplates() {
    if (hasRequiredListTemplates) return listTemplates;
    hasRequiredListTemplates = 1;
    Object.defineProperty(listTemplates, "__esModule", { value: true });
    listTemplates.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return listTemplates;
  }
  var defs$4 = {};
  var hasRequiredDefs$4;
  function requireDefs$4() {
    if (hasRequiredDefs$4) return defs$4;
    hasRequiredDefs$4 = 1;
    Object.defineProperty(defs$4, "__esModule", { value: true });
    defs$4.REVIEWNONE = defs$4.REVIEWCLOSED = defs$4.REVIEWESCALATED = defs$4.REVIEWOPEN = void 0;
    defs$4.isModEventView = isModEventView;
    defs$4.validateModEventView = validateModEventView;
    defs$4.isModEventViewDetail = isModEventViewDetail;
    defs$4.validateModEventViewDetail = validateModEventViewDetail;
    defs$4.isSubjectStatusView = isSubjectStatusView;
    defs$4.validateSubjectStatusView = validateSubjectStatusView;
    defs$4.isAccountStats = isAccountStats;
    defs$4.validateAccountStats = validateAccountStats;
    defs$4.isRecordsStats = isRecordsStats;
    defs$4.validateRecordsStats = validateRecordsStats;
    defs$4.isModEventTakedown = isModEventTakedown;
    defs$4.validateModEventTakedown = validateModEventTakedown;
    defs$4.isModEventReverseTakedown = isModEventReverseTakedown;
    defs$4.validateModEventReverseTakedown = validateModEventReverseTakedown;
    defs$4.isModEventResolveAppeal = isModEventResolveAppeal;
    defs$4.validateModEventResolveAppeal = validateModEventResolveAppeal;
    defs$4.isModEventComment = isModEventComment;
    defs$4.validateModEventComment = validateModEventComment;
    defs$4.isModEventReport = isModEventReport;
    defs$4.validateModEventReport = validateModEventReport;
    defs$4.isModEventLabel = isModEventLabel;
    defs$4.validateModEventLabel = validateModEventLabel;
    defs$4.isModEventPriorityScore = isModEventPriorityScore;
    defs$4.validateModEventPriorityScore = validateModEventPriorityScore;
    defs$4.isModEventAcknowledge = isModEventAcknowledge;
    defs$4.validateModEventAcknowledge = validateModEventAcknowledge;
    defs$4.isModEventEscalate = isModEventEscalate;
    defs$4.validateModEventEscalate = validateModEventEscalate;
    defs$4.isModEventMute = isModEventMute;
    defs$4.validateModEventMute = validateModEventMute;
    defs$4.isModEventUnmute = isModEventUnmute;
    defs$4.validateModEventUnmute = validateModEventUnmute;
    defs$4.isModEventMuteReporter = isModEventMuteReporter;
    defs$4.validateModEventMuteReporter = validateModEventMuteReporter;
    defs$4.isModEventUnmuteReporter = isModEventUnmuteReporter;
    defs$4.validateModEventUnmuteReporter = validateModEventUnmuteReporter;
    defs$4.isModEventEmail = isModEventEmail;
    defs$4.validateModEventEmail = validateModEventEmail;
    defs$4.isModEventDivert = isModEventDivert;
    defs$4.validateModEventDivert = validateModEventDivert;
    defs$4.isModEventTag = isModEventTag;
    defs$4.validateModEventTag = validateModEventTag;
    defs$4.isAccountEvent = isAccountEvent;
    defs$4.validateAccountEvent = validateAccountEvent;
    defs$4.isIdentityEvent = isIdentityEvent;
    defs$4.validateIdentityEvent = validateIdentityEvent;
    defs$4.isRecordEvent = isRecordEvent;
    defs$4.validateRecordEvent = validateRecordEvent;
    defs$4.isRepoView = isRepoView;
    defs$4.validateRepoView = validateRepoView;
    defs$4.isRepoViewDetail = isRepoViewDetail;
    defs$4.validateRepoViewDetail = validateRepoViewDetail;
    defs$4.isRepoViewNotFound = isRepoViewNotFound;
    defs$4.validateRepoViewNotFound = validateRepoViewNotFound;
    defs$4.isRecordView = isRecordView;
    defs$4.validateRecordView = validateRecordView;
    defs$4.isRecordViewDetail = isRecordViewDetail;
    defs$4.validateRecordViewDetail = validateRecordViewDetail;
    defs$4.isRecordViewNotFound = isRecordViewNotFound;
    defs$4.validateRecordViewNotFound = validateRecordViewNotFound;
    defs$4.isModeration = isModeration;
    defs$4.validateModeration = validateModeration;
    defs$4.isModerationDetail = isModerationDetail;
    defs$4.validateModerationDetail = validateModerationDetail;
    defs$4.isBlobView = isBlobView;
    defs$4.validateBlobView = validateBlobView;
    defs$4.isImageDetails = isImageDetails;
    defs$4.validateImageDetails = validateImageDetails;
    defs$4.isVideoDetails = isVideoDetails;
    defs$4.validateVideoDetails = validateVideoDetails;
    defs$4.isAccountHosting = isAccountHosting;
    defs$4.validateAccountHosting = validateAccountHosting;
    defs$4.isRecordHosting = isRecordHosting;
    defs$4.validateRecordHosting = validateRecordHosting;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "tools.ozone.moderation.defs";
    const hashModEventView = "modEventView";
    function isModEventView(v) {
      return is$typed(v, id, hashModEventView);
    }
    function validateModEventView(v) {
      return validate(v, id, hashModEventView);
    }
    const hashModEventViewDetail = "modEventViewDetail";
    function isModEventViewDetail(v) {
      return is$typed(v, id, hashModEventViewDetail);
    }
    function validateModEventViewDetail(v) {
      return validate(v, id, hashModEventViewDetail);
    }
    const hashSubjectStatusView = "subjectStatusView";
    function isSubjectStatusView(v) {
      return is$typed(v, id, hashSubjectStatusView);
    }
    function validateSubjectStatusView(v) {
      return validate(v, id, hashSubjectStatusView);
    }
    const hashAccountStats = "accountStats";
    function isAccountStats(v) {
      return is$typed(v, id, hashAccountStats);
    }
    function validateAccountStats(v) {
      return validate(v, id, hashAccountStats);
    }
    const hashRecordsStats = "recordsStats";
    function isRecordsStats(v) {
      return is$typed(v, id, hashRecordsStats);
    }
    function validateRecordsStats(v) {
      return validate(v, id, hashRecordsStats);
    }
    defs$4.REVIEWOPEN = `${id}#reviewOpen`;
    defs$4.REVIEWESCALATED = `${id}#reviewEscalated`;
    defs$4.REVIEWCLOSED = `${id}#reviewClosed`;
    defs$4.REVIEWNONE = `${id}#reviewNone`;
    const hashModEventTakedown = "modEventTakedown";
    function isModEventTakedown(v) {
      return is$typed(v, id, hashModEventTakedown);
    }
    function validateModEventTakedown(v) {
      return validate(v, id, hashModEventTakedown);
    }
    const hashModEventReverseTakedown = "modEventReverseTakedown";
    function isModEventReverseTakedown(v) {
      return is$typed(v, id, hashModEventReverseTakedown);
    }
    function validateModEventReverseTakedown(v) {
      return validate(v, id, hashModEventReverseTakedown);
    }
    const hashModEventResolveAppeal = "modEventResolveAppeal";
    function isModEventResolveAppeal(v) {
      return is$typed(v, id, hashModEventResolveAppeal);
    }
    function validateModEventResolveAppeal(v) {
      return validate(v, id, hashModEventResolveAppeal);
    }
    const hashModEventComment = "modEventComment";
    function isModEventComment(v) {
      return is$typed(v, id, hashModEventComment);
    }
    function validateModEventComment(v) {
      return validate(v, id, hashModEventComment);
    }
    const hashModEventReport = "modEventReport";
    function isModEventReport(v) {
      return is$typed(v, id, hashModEventReport);
    }
    function validateModEventReport(v) {
      return validate(v, id, hashModEventReport);
    }
    const hashModEventLabel = "modEventLabel";
    function isModEventLabel(v) {
      return is$typed(v, id, hashModEventLabel);
    }
    function validateModEventLabel(v) {
      return validate(v, id, hashModEventLabel);
    }
    const hashModEventPriorityScore = "modEventPriorityScore";
    function isModEventPriorityScore(v) {
      return is$typed(v, id, hashModEventPriorityScore);
    }
    function validateModEventPriorityScore(v) {
      return validate(v, id, hashModEventPriorityScore);
    }
    const hashModEventAcknowledge = "modEventAcknowledge";
    function isModEventAcknowledge(v) {
      return is$typed(v, id, hashModEventAcknowledge);
    }
    function validateModEventAcknowledge(v) {
      return validate(v, id, hashModEventAcknowledge);
    }
    const hashModEventEscalate = "modEventEscalate";
    function isModEventEscalate(v) {
      return is$typed(v, id, hashModEventEscalate);
    }
    function validateModEventEscalate(v) {
      return validate(v, id, hashModEventEscalate);
    }
    const hashModEventMute = "modEventMute";
    function isModEventMute(v) {
      return is$typed(v, id, hashModEventMute);
    }
    function validateModEventMute(v) {
      return validate(v, id, hashModEventMute);
    }
    const hashModEventUnmute = "modEventUnmute";
    function isModEventUnmute(v) {
      return is$typed(v, id, hashModEventUnmute);
    }
    function validateModEventUnmute(v) {
      return validate(v, id, hashModEventUnmute);
    }
    const hashModEventMuteReporter = "modEventMuteReporter";
    function isModEventMuteReporter(v) {
      return is$typed(v, id, hashModEventMuteReporter);
    }
    function validateModEventMuteReporter(v) {
      return validate(v, id, hashModEventMuteReporter);
    }
    const hashModEventUnmuteReporter = "modEventUnmuteReporter";
    function isModEventUnmuteReporter(v) {
      return is$typed(v, id, hashModEventUnmuteReporter);
    }
    function validateModEventUnmuteReporter(v) {
      return validate(v, id, hashModEventUnmuteReporter);
    }
    const hashModEventEmail = "modEventEmail";
    function isModEventEmail(v) {
      return is$typed(v, id, hashModEventEmail);
    }
    function validateModEventEmail(v) {
      return validate(v, id, hashModEventEmail);
    }
    const hashModEventDivert = "modEventDivert";
    function isModEventDivert(v) {
      return is$typed(v, id, hashModEventDivert);
    }
    function validateModEventDivert(v) {
      return validate(v, id, hashModEventDivert);
    }
    const hashModEventTag = "modEventTag";
    function isModEventTag(v) {
      return is$typed(v, id, hashModEventTag);
    }
    function validateModEventTag(v) {
      return validate(v, id, hashModEventTag);
    }
    const hashAccountEvent = "accountEvent";
    function isAccountEvent(v) {
      return is$typed(v, id, hashAccountEvent);
    }
    function validateAccountEvent(v) {
      return validate(v, id, hashAccountEvent);
    }
    const hashIdentityEvent = "identityEvent";
    function isIdentityEvent(v) {
      return is$typed(v, id, hashIdentityEvent);
    }
    function validateIdentityEvent(v) {
      return validate(v, id, hashIdentityEvent);
    }
    const hashRecordEvent = "recordEvent";
    function isRecordEvent(v) {
      return is$typed(v, id, hashRecordEvent);
    }
    function validateRecordEvent(v) {
      return validate(v, id, hashRecordEvent);
    }
    const hashRepoView = "repoView";
    function isRepoView(v) {
      return is$typed(v, id, hashRepoView);
    }
    function validateRepoView(v) {
      return validate(v, id, hashRepoView);
    }
    const hashRepoViewDetail = "repoViewDetail";
    function isRepoViewDetail(v) {
      return is$typed(v, id, hashRepoViewDetail);
    }
    function validateRepoViewDetail(v) {
      return validate(v, id, hashRepoViewDetail);
    }
    const hashRepoViewNotFound = "repoViewNotFound";
    function isRepoViewNotFound(v) {
      return is$typed(v, id, hashRepoViewNotFound);
    }
    function validateRepoViewNotFound(v) {
      return validate(v, id, hashRepoViewNotFound);
    }
    const hashRecordView = "recordView";
    function isRecordView(v) {
      return is$typed(v, id, hashRecordView);
    }
    function validateRecordView(v) {
      return validate(v, id, hashRecordView);
    }
    const hashRecordViewDetail = "recordViewDetail";
    function isRecordViewDetail(v) {
      return is$typed(v, id, hashRecordViewDetail);
    }
    function validateRecordViewDetail(v) {
      return validate(v, id, hashRecordViewDetail);
    }
    const hashRecordViewNotFound = "recordViewNotFound";
    function isRecordViewNotFound(v) {
      return is$typed(v, id, hashRecordViewNotFound);
    }
    function validateRecordViewNotFound(v) {
      return validate(v, id, hashRecordViewNotFound);
    }
    const hashModeration = "moderation";
    function isModeration(v) {
      return is$typed(v, id, hashModeration);
    }
    function validateModeration(v) {
      return validate(v, id, hashModeration);
    }
    const hashModerationDetail = "moderationDetail";
    function isModerationDetail(v) {
      return is$typed(v, id, hashModerationDetail);
    }
    function validateModerationDetail(v) {
      return validate(v, id, hashModerationDetail);
    }
    const hashBlobView = "blobView";
    function isBlobView(v) {
      return is$typed(v, id, hashBlobView);
    }
    function validateBlobView(v) {
      return validate(v, id, hashBlobView);
    }
    const hashImageDetails = "imageDetails";
    function isImageDetails(v) {
      return is$typed(v, id, hashImageDetails);
    }
    function validateImageDetails(v) {
      return validate(v, id, hashImageDetails);
    }
    const hashVideoDetails = "videoDetails";
    function isVideoDetails(v) {
      return is$typed(v, id, hashVideoDetails);
    }
    function validateVideoDetails(v) {
      return validate(v, id, hashVideoDetails);
    }
    const hashAccountHosting = "accountHosting";
    function isAccountHosting(v) {
      return is$typed(v, id, hashAccountHosting);
    }
    function validateAccountHosting(v) {
      return validate(v, id, hashAccountHosting);
    }
    const hashRecordHosting = "recordHosting";
    function isRecordHosting(v) {
      return is$typed(v, id, hashRecordHosting);
    }
    function validateRecordHosting(v) {
      return validate(v, id, hashRecordHosting);
    }
    return defs$4;
  }
  var getEvent = {};
  var hasRequiredGetEvent;
  function requireGetEvent() {
    if (hasRequiredGetEvent) return getEvent;
    hasRequiredGetEvent = 1;
    Object.defineProperty(getEvent, "__esModule", { value: true });
    getEvent.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return getEvent;
  }
  var getRecords = {};
  var hasRequiredGetRecords;
  function requireGetRecords() {
    if (hasRequiredGetRecords) return getRecords;
    hasRequiredGetRecords = 1;
    Object.defineProperty(getRecords, "__esModule", { value: true });
    getRecords.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return getRecords;
  }
  var getRepos = {};
  var hasRequiredGetRepos;
  function requireGetRepos() {
    if (hasRequiredGetRepos) return getRepos;
    hasRequiredGetRepos = 1;
    Object.defineProperty(getRepos, "__esModule", { value: true });
    getRepos.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return getRepos;
  }
  var queryEvents = {};
  var hasRequiredQueryEvents;
  function requireQueryEvents() {
    if (hasRequiredQueryEvents) return queryEvents;
    hasRequiredQueryEvents = 1;
    Object.defineProperty(queryEvents, "__esModule", { value: true });
    queryEvents.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return queryEvents;
  }
  var queryStatuses = {};
  var hasRequiredQueryStatuses;
  function requireQueryStatuses() {
    if (hasRequiredQueryStatuses) return queryStatuses;
    hasRequiredQueryStatuses = 1;
    Object.defineProperty(queryStatuses, "__esModule", { value: true });
    queryStatuses.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return queryStatuses;
  }
  var searchRepos = {};
  var hasRequiredSearchRepos;
  function requireSearchRepos() {
    if (hasRequiredSearchRepos) return searchRepos;
    hasRequiredSearchRepos = 1;
    Object.defineProperty(searchRepos, "__esModule", { value: true });
    searchRepos.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return searchRepos;
  }
  var getConfig = {};
  var hasRequiredGetConfig;
  function requireGetConfig() {
    if (hasRequiredGetConfig) return getConfig;
    hasRequiredGetConfig = 1;
    Object.defineProperty(getConfig, "__esModule", { value: true });
    getConfig.toKnownErr = toKnownErr;
    getConfig.isServiceConfig = isServiceConfig;
    getConfig.validateServiceConfig = validateServiceConfig;
    getConfig.isViewerConfig = isViewerConfig;
    getConfig.validateViewerConfig = validateViewerConfig;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "tools.ozone.server.getConfig";
    function toKnownErr(e) {
      return e;
    }
    const hashServiceConfig = "serviceConfig";
    function isServiceConfig(v) {
      return is$typed(v, id, hashServiceConfig);
    }
    function validateServiceConfig(v) {
      return validate(v, id, hashServiceConfig);
    }
    const hashViewerConfig = "viewerConfig";
    function isViewerConfig(v) {
      return is$typed(v, id, hashViewerConfig);
    }
    function validateViewerConfig(v) {
      return validate(v, id, hashViewerConfig);
    }
    return getConfig;
  }
  var addValues = {};
  var hasRequiredAddValues;
  function requireAddValues() {
    if (hasRequiredAddValues) return addValues;
    hasRequiredAddValues = 1;
    Object.defineProperty(addValues, "__esModule", { value: true });
    addValues.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return addValues;
  }
  var defs$3 = {};
  var hasRequiredDefs$3;
  function requireDefs$3() {
    if (hasRequiredDefs$3) return defs$3;
    hasRequiredDefs$3 = 1;
    Object.defineProperty(defs$3, "__esModule", { value: true });
    defs$3.isSet = isSet;
    defs$3.validateSet = validateSet;
    defs$3.isSetView = isSetView;
    defs$3.validateSetView = validateSetView;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "tools.ozone.set.defs";
    const hashSet = "set";
    function isSet(v) {
      return is$typed(v, id, hashSet);
    }
    function validateSet(v) {
      return validate(v, id, hashSet);
    }
    const hashSetView = "setView";
    function isSetView(v) {
      return is$typed(v, id, hashSetView);
    }
    function validateSetView(v) {
      return validate(v, id, hashSetView);
    }
    return defs$3;
  }
  var querySets = {};
  var hasRequiredQuerySets;
  function requireQuerySets() {
    if (hasRequiredQuerySets) return querySets;
    hasRequiredQuerySets = 1;
    Object.defineProperty(querySets, "__esModule", { value: true });
    querySets.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return querySets;
  }
  var upsertSet = {};
  var hasRequiredUpsertSet;
  function requireUpsertSet() {
    if (hasRequiredUpsertSet) return upsertSet;
    hasRequiredUpsertSet = 1;
    Object.defineProperty(upsertSet, "__esModule", { value: true });
    upsertSet.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return upsertSet;
  }
  var defs$2 = {};
  var hasRequiredDefs$2;
  function requireDefs$2() {
    if (hasRequiredDefs$2) return defs$2;
    hasRequiredDefs$2 = 1;
    Object.defineProperty(defs$2, "__esModule", { value: true });
    defs$2.isOption = isOption;
    defs$2.validateOption = validateOption;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "tools.ozone.setting.defs";
    const hashOption = "option";
    function isOption(v) {
      return is$typed(v, id, hashOption);
    }
    function validateOption(v) {
      return validate(v, id, hashOption);
    }
    return defs$2;
  }
  var listOptions = {};
  var hasRequiredListOptions;
  function requireListOptions() {
    if (hasRequiredListOptions) return listOptions;
    hasRequiredListOptions = 1;
    Object.defineProperty(listOptions, "__esModule", { value: true });
    listOptions.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return listOptions;
  }
  var removeOptions = {};
  var hasRequiredRemoveOptions;
  function requireRemoveOptions() {
    if (hasRequiredRemoveOptions) return removeOptions;
    hasRequiredRemoveOptions = 1;
    Object.defineProperty(removeOptions, "__esModule", { value: true });
    removeOptions.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return removeOptions;
  }
  var upsertOption = {};
  var hasRequiredUpsertOption;
  function requireUpsertOption() {
    if (hasRequiredUpsertOption) return upsertOption;
    hasRequiredUpsertOption = 1;
    Object.defineProperty(upsertOption, "__esModule", { value: true });
    upsertOption.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return upsertOption;
  }
  var defs$1 = {};
  var hasRequiredDefs$1;
  function requireDefs$1() {
    if (hasRequiredDefs$1) return defs$1;
    hasRequiredDefs$1 = 1;
    Object.defineProperty(defs$1, "__esModule", { value: true });
    defs$1.isSigDetail = isSigDetail;
    defs$1.validateSigDetail = validateSigDetail;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "tools.ozone.signature.defs";
    const hashSigDetail = "sigDetail";
    function isSigDetail(v) {
      return is$typed(v, id, hashSigDetail);
    }
    function validateSigDetail(v) {
      return validate(v, id, hashSigDetail);
    }
    return defs$1;
  }
  var findCorrelation = {};
  var hasRequiredFindCorrelation;
  function requireFindCorrelation() {
    if (hasRequiredFindCorrelation) return findCorrelation;
    hasRequiredFindCorrelation = 1;
    Object.defineProperty(findCorrelation, "__esModule", { value: true });
    findCorrelation.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return findCorrelation;
  }
  var findRelatedAccounts = {};
  var hasRequiredFindRelatedAccounts;
  function requireFindRelatedAccounts() {
    if (hasRequiredFindRelatedAccounts) return findRelatedAccounts;
    hasRequiredFindRelatedAccounts = 1;
    Object.defineProperty(findRelatedAccounts, "__esModule", { value: true });
    findRelatedAccounts.toKnownErr = toKnownErr;
    findRelatedAccounts.isRelatedAccount = isRelatedAccount;
    findRelatedAccounts.validateRelatedAccount = validateRelatedAccount;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "tools.ozone.signature.findRelatedAccounts";
    function toKnownErr(e) {
      return e;
    }
    const hashRelatedAccount = "relatedAccount";
    function isRelatedAccount(v) {
      return is$typed(v, id, hashRelatedAccount);
    }
    function validateRelatedAccount(v) {
      return validate(v, id, hashRelatedAccount);
    }
    return findRelatedAccounts;
  }
  var searchAccounts = {};
  var hasRequiredSearchAccounts;
  function requireSearchAccounts() {
    if (hasRequiredSearchAccounts) return searchAccounts;
    hasRequiredSearchAccounts = 1;
    Object.defineProperty(searchAccounts, "__esModule", { value: true });
    searchAccounts.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return searchAccounts;
  }
  var defs = {};
  var hasRequiredDefs;
  function requireDefs() {
    if (hasRequiredDefs) return defs;
    hasRequiredDefs = 1;
    Object.defineProperty(defs, "__esModule", { value: true });
    defs.ROLETRIAGE = defs.ROLEMODERATOR = defs.ROLEADMIN = void 0;
    defs.isMember = isMember;
    defs.validateMember = validateMember;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    const is$typed = util_1.is$typed, validate = lexicons_1.validate;
    const id = "tools.ozone.team.defs";
    const hashMember = "member";
    function isMember(v) {
      return is$typed(v, id, hashMember);
    }
    function validateMember(v) {
      return validate(v, id, hashMember);
    }
    defs.ROLEADMIN = `${id}#roleAdmin`;
    defs.ROLEMODERATOR = `${id}#roleModerator`;
    defs.ROLETRIAGE = `${id}#roleTriage`;
    return defs;
  }
  var listMembers = {};
  var hasRequiredListMembers;
  function requireListMembers() {
    if (hasRequiredListMembers) return listMembers;
    hasRequiredListMembers = 1;
    Object.defineProperty(listMembers, "__esModule", { value: true });
    listMembers.toKnownErr = toKnownErr;
    const lexicons_1 = requireLexicons();
    const util_1 = requireUtil$5();
    util_1.is$typed;
    lexicons_1.validate;
    function toKnownErr(e) {
      return e;
    }
    return listMembers;
  }
  var hasRequiredClient;
  function requireClient() {
    if (hasRequiredClient) return client$1;
    hasRequiredClient = 1;
    var __createBinding = client$1 && client$1.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = client$1 && client$1.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = client$1 && client$1.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(client$1, "__esModule", { value: true });
    client$1.ComAtprotoServerDeleteAccount = client$1.ComAtprotoServerDefs = client$1.ComAtprotoServerDeactivateAccount = client$1.ComAtprotoServerCreateSession = client$1.ComAtprotoServerCreateInviteCodes = client$1.ComAtprotoServerCreateInviteCode = client$1.ComAtprotoServerCreateAppPassword = client$1.ComAtprotoServerCreateAccount = client$1.ComAtprotoServerConfirmEmail = client$1.ComAtprotoServerCheckAccountStatus = client$1.ComAtprotoServerActivateAccount = client$1.ComAtprotoRepoUploadBlob = client$1.ComAtprotoRepoStrongRef = client$1.ComAtprotoRepoPutRecord = client$1.ComAtprotoRepoListRecords = client$1.ComAtprotoRepoListMissingBlobs = client$1.ComAtprotoRepoImportRepo = client$1.ComAtprotoRepoGetRecord = client$1.ComAtprotoRepoDescribeRepo = client$1.ComAtprotoRepoDeleteRecord = client$1.ComAtprotoRepoDefs = client$1.ComAtprotoRepoCreateRecord = client$1.ComAtprotoRepoApplyWrites = client$1.ComAtprotoModerationDefs = client$1.ComAtprotoModerationCreateReport = client$1.ComAtprotoLexiconSchema = client$1.ComAtprotoLabelSubscribeLabels = client$1.ComAtprotoLabelQueryLabels = client$1.ComAtprotoLabelDefs = client$1.ComAtprotoIdentityUpdateHandle = client$1.ComAtprotoIdentitySubmitPlcOperation = client$1.ComAtprotoIdentitySignPlcOperation = client$1.ComAtprotoIdentityResolveHandle = client$1.ComAtprotoIdentityRequestPlcOperationSignature = client$1.ComAtprotoIdentityGetRecommendedDidCredentials = client$1.ComAtprotoAdminUpdateSubjectStatus = client$1.ComAtprotoAdminUpdateAccountPassword = client$1.ComAtprotoAdminUpdateAccountHandle = client$1.ComAtprotoAdminUpdateAccountEmail = client$1.ComAtprotoAdminSendEmail = client$1.ComAtprotoAdminSearchAccounts = client$1.ComAtprotoAdminGetSubjectStatus = client$1.ComAtprotoAdminGetInviteCodes = client$1.ComAtprotoAdminGetAccountInfos = client$1.ComAtprotoAdminGetAccountInfo = client$1.ComAtprotoAdminEnableAccountInvites = client$1.ComAtprotoAdminDisableInviteCodes = client$1.ComAtprotoAdminDisableAccountInvites = client$1.ComAtprotoAdminDeleteAccount = client$1.ComAtprotoAdminDefs = void 0;
    client$1.AppBskyFeedGenerator = client$1.AppBskyFeedDescribeFeedGenerator = client$1.AppBskyFeedDefs = client$1.AppBskyEmbedVideo = client$1.AppBskyEmbedRecordWithMedia = client$1.AppBskyEmbedRecord = client$1.AppBskyEmbedImages = client$1.AppBskyEmbedExternal = client$1.AppBskyEmbedDefs = client$1.AppBskyActorSearchActorsTypeahead = client$1.AppBskyActorSearchActors = client$1.AppBskyActorPutPreferences = client$1.AppBskyActorProfile = client$1.AppBskyActorGetSuggestions = client$1.AppBskyActorGetProfiles = client$1.AppBskyActorGetProfile = client$1.AppBskyActorGetPreferences = client$1.AppBskyActorDefs = client$1.ComAtprotoTempRequestPhoneVerification = client$1.ComAtprotoTempFetchLabels = client$1.ComAtprotoTempCheckSignupQueue = client$1.ComAtprotoTempAddReservedHandle = client$1.ComAtprotoSyncSubscribeRepos = client$1.ComAtprotoSyncRequestCrawl = client$1.ComAtprotoSyncNotifyOfUpdate = client$1.ComAtprotoSyncListRepos = client$1.ComAtprotoSyncListBlobs = client$1.ComAtprotoSyncGetRepoStatus = client$1.ComAtprotoSyncGetRepo = client$1.ComAtprotoSyncGetRecord = client$1.ComAtprotoSyncGetLatestCommit = client$1.ComAtprotoSyncGetHead = client$1.ComAtprotoSyncGetCheckout = client$1.ComAtprotoSyncGetBlocks = client$1.ComAtprotoSyncGetBlob = client$1.ComAtprotoServerUpdateEmail = client$1.ComAtprotoServerRevokeAppPassword = client$1.ComAtprotoServerResetPassword = client$1.ComAtprotoServerReserveSigningKey = client$1.ComAtprotoServerRequestPasswordReset = client$1.ComAtprotoServerRequestEmailUpdate = client$1.ComAtprotoServerRequestEmailConfirmation = client$1.ComAtprotoServerRequestAccountDelete = client$1.ComAtprotoServerRefreshSession = client$1.ComAtprotoServerListAppPasswords = client$1.ComAtprotoServerGetSession = client$1.ComAtprotoServerGetServiceAuth = client$1.ComAtprotoServerGetAccountInviteCodes = client$1.ComAtprotoServerDescribeServer = client$1.ComAtprotoServerDeleteSession = void 0;
    client$1.AppBskyGraphUnmuteThread = client$1.AppBskyGraphUnmuteActorList = client$1.AppBskyGraphUnmuteActor = client$1.AppBskyGraphStarterpack = client$1.AppBskyGraphSearchStarterPacks = client$1.AppBskyGraphMuteThread = client$1.AppBskyGraphMuteActorList = client$1.AppBskyGraphMuteActor = client$1.AppBskyGraphListitem = client$1.AppBskyGraphListblock = client$1.AppBskyGraphList = client$1.AppBskyGraphGetSuggestedFollowsByActor = client$1.AppBskyGraphGetStarterPacks = client$1.AppBskyGraphGetStarterPack = client$1.AppBskyGraphGetRelationships = client$1.AppBskyGraphGetMutes = client$1.AppBskyGraphGetLists = client$1.AppBskyGraphGetListMutes = client$1.AppBskyGraphGetListBlocks = client$1.AppBskyGraphGetList = client$1.AppBskyGraphGetKnownFollowers = client$1.AppBskyGraphGetFollows = client$1.AppBskyGraphGetFollowers = client$1.AppBskyGraphGetBlocks = client$1.AppBskyGraphGetActorStarterPacks = client$1.AppBskyGraphFollow = client$1.AppBskyGraphDefs = client$1.AppBskyGraphBlock = client$1.AppBskyFeedThreadgate = client$1.AppBskyFeedSendInteractions = client$1.AppBskyFeedSearchPosts = client$1.AppBskyFeedRepost = client$1.AppBskyFeedPostgate = client$1.AppBskyFeedPost = client$1.AppBskyFeedLike = client$1.AppBskyFeedGetTimeline = client$1.AppBskyFeedGetSuggestedFeeds = client$1.AppBskyFeedGetRepostedBy = client$1.AppBskyFeedGetQuotes = client$1.AppBskyFeedGetPosts = client$1.AppBskyFeedGetPostThread = client$1.AppBskyFeedGetListFeed = client$1.AppBskyFeedGetLikes = client$1.AppBskyFeedGetFeedSkeleton = client$1.AppBskyFeedGetFeedGenerators = client$1.AppBskyFeedGetFeedGenerator = client$1.AppBskyFeedGetFeed = client$1.AppBskyFeedGetAuthorFeed = client$1.AppBskyFeedGetActorLikes = client$1.AppBskyFeedGetActorFeeds = void 0;
    client$1.ToolsOzoneModerationGetEvent = client$1.ToolsOzoneModerationEmitEvent = client$1.ToolsOzoneModerationDefs = client$1.ToolsOzoneCommunicationUpdateTemplate = client$1.ToolsOzoneCommunicationListTemplates = client$1.ToolsOzoneCommunicationDeleteTemplate = client$1.ToolsOzoneCommunicationDefs = client$1.ToolsOzoneCommunicationCreateTemplate = client$1.ChatBskyModerationUpdateActorAccess = client$1.ChatBskyModerationGetMessageContext = client$1.ChatBskyModerationGetActorMetadata = client$1.ChatBskyConvoUpdateRead = client$1.ChatBskyConvoUnmuteConvo = client$1.ChatBskyConvoSendMessageBatch = client$1.ChatBskyConvoSendMessage = client$1.ChatBskyConvoMuteConvo = client$1.ChatBskyConvoListConvos = client$1.ChatBskyConvoLeaveConvo = client$1.ChatBskyConvoGetMessages = client$1.ChatBskyConvoGetLog = client$1.ChatBskyConvoGetConvoForMembers = client$1.ChatBskyConvoGetConvo = client$1.ChatBskyConvoDeleteMessageForSelf = client$1.ChatBskyConvoDefs = client$1.ChatBskyActorExportAccountData = client$1.ChatBskyActorDeleteAccount = client$1.ChatBskyActorDefs = client$1.ChatBskyActorDeclaration = client$1.AppBskyVideoUploadVideo = client$1.AppBskyVideoGetUploadLimits = client$1.AppBskyVideoGetJobStatus = client$1.AppBskyVideoDefs = client$1.AppBskyUnspeccedSearchStarterPacksSkeleton = client$1.AppBskyUnspeccedSearchPostsSkeleton = client$1.AppBskyUnspeccedSearchActorsSkeleton = client$1.AppBskyUnspeccedGetTrendingTopics = client$1.AppBskyUnspeccedGetTaggedSuggestions = client$1.AppBskyUnspeccedGetSuggestionsSkeleton = client$1.AppBskyUnspeccedGetPopularFeedGenerators = client$1.AppBskyUnspeccedGetConfig = client$1.AppBskyUnspeccedDefs = client$1.AppBskyRichtextFacet = client$1.AppBskyNotificationUpdateSeen = client$1.AppBskyNotificationRegisterPush = client$1.AppBskyNotificationPutPreferences = client$1.AppBskyNotificationListNotifications = client$1.AppBskyNotificationGetUnreadCount = client$1.AppBskyLabelerService = client$1.AppBskyLabelerGetServices = client$1.AppBskyLabelerDefs = void 0;
    client$1.ProfileRecord = client$1.AppBskyActorNS = client$1.AppBskyNS = client$1.AppNS = client$1.ComAtprotoTempNS = client$1.ComAtprotoSyncNS = client$1.ComAtprotoServerNS = client$1.ComAtprotoRepoNS = client$1.ComAtprotoModerationNS = client$1.SchemaRecord = client$1.ComAtprotoLexiconNS = client$1.ComAtprotoLabelNS = client$1.ComAtprotoIdentityNS = client$1.ComAtprotoAdminNS = client$1.ComAtprotoNS = client$1.ComNS = client$1.AtpBaseClient = client$1.TOOLS_OZONE_TEAM = client$1.TOOLS_OZONE_MODERATION = client$1.APP_BSKY_GRAPH = client$1.APP_BSKY_FEED = client$1.COM_ATPROTO_MODERATION = client$1.ToolsOzoneTeamUpdateMember = client$1.ToolsOzoneTeamListMembers = client$1.ToolsOzoneTeamDeleteMember = client$1.ToolsOzoneTeamDefs = client$1.ToolsOzoneTeamAddMember = client$1.ToolsOzoneSignatureSearchAccounts = client$1.ToolsOzoneSignatureFindRelatedAccounts = client$1.ToolsOzoneSignatureFindCorrelation = client$1.ToolsOzoneSignatureDefs = client$1.ToolsOzoneSettingUpsertOption = client$1.ToolsOzoneSettingRemoveOptions = client$1.ToolsOzoneSettingListOptions = client$1.ToolsOzoneSettingDefs = client$1.ToolsOzoneSetUpsertSet = client$1.ToolsOzoneSetQuerySets = client$1.ToolsOzoneSetGetValues = client$1.ToolsOzoneSetDeleteValues = client$1.ToolsOzoneSetDeleteSet = client$1.ToolsOzoneSetDefs = client$1.ToolsOzoneSetAddValues = client$1.ToolsOzoneServerGetConfig = client$1.ToolsOzoneModerationSearchRepos = client$1.ToolsOzoneModerationQueryStatuses = client$1.ToolsOzoneModerationQueryEvents = client$1.ToolsOzoneModerationGetRepos = client$1.ToolsOzoneModerationGetRepo = client$1.ToolsOzoneModerationGetRecords = client$1.ToolsOzoneModerationGetRecord = void 0;
    client$1.ToolsOzoneTeamNS = client$1.ToolsOzoneSignatureNS = client$1.ToolsOzoneSettingNS = client$1.ToolsOzoneSetNS = client$1.ToolsOzoneServerNS = client$1.ToolsOzoneModerationNS = client$1.ToolsOzoneCommunicationNS = client$1.ToolsOzoneNS = client$1.ToolsNS = client$1.ChatBskyModerationNS = client$1.ChatBskyConvoNS = client$1.DeclarationRecord = client$1.ChatBskyActorNS = client$1.ChatBskyNS = client$1.ChatNS = client$1.AppBskyVideoNS = client$1.AppBskyUnspeccedNS = client$1.AppBskyRichtextNS = client$1.AppBskyNotificationNS = client$1.ServiceRecord = client$1.AppBskyLabelerNS = client$1.StarterpackRecord = client$1.ListitemRecord = client$1.ListblockRecord = client$1.ListRecord = client$1.FollowRecord = client$1.BlockRecord = client$1.AppBskyGraphNS = client$1.ThreadgateRecord = client$1.RepostRecord = client$1.PostgateRecord = client$1.PostRecord = client$1.LikeRecord = client$1.GeneratorRecord = client$1.AppBskyFeedNS = client$1.AppBskyEmbedNS = void 0;
    const xrpc_1 = requireDist$1();
    const lexicons_js_1 = requireLexicons();
    const ComAtprotoRepoApplyWrites = __importStar(requireApplyWrites());
    const ComAtprotoRepoCreateRecord = __importStar(requireCreateRecord());
    const ComAtprotoRepoDeleteRecord = __importStar(requireDeleteRecord());
    const ComAtprotoRepoGetRecord = __importStar(requireGetRecord$2());
    const ComAtprotoRepoPutRecord = __importStar(requirePutRecord());
    const ComAtprotoServerConfirmEmail = __importStar(requireConfirmEmail());
    const ComAtprotoServerCreateAccount = __importStar(requireCreateAccount());
    const ComAtprotoServerCreateAppPassword = __importStar(requireCreateAppPassword());
    const ComAtprotoServerCreateSession = __importStar(requireCreateSession());
    const ComAtprotoServerDeleteAccount = __importStar(requireDeleteAccount$2());
    const ComAtprotoServerGetAccountInviteCodes = __importStar(requireGetAccountInviteCodes());
    const ComAtprotoServerGetServiceAuth = __importStar(requireGetServiceAuth());
    const ComAtprotoServerListAppPasswords = __importStar(requireListAppPasswords());
    const ComAtprotoServerRefreshSession = __importStar(requireRefreshSession());
    const ComAtprotoServerResetPassword = __importStar(requireResetPassword());
    const ComAtprotoServerUpdateEmail = __importStar(requireUpdateEmail());
    const ComAtprotoSyncGetBlob = __importStar(requireGetBlob());
    const ComAtprotoSyncGetBlocks = __importStar(requireGetBlocks$1());
    const ComAtprotoSyncGetHead = __importStar(requireGetHead());
    const ComAtprotoSyncGetLatestCommit = __importStar(requireGetLatestCommit());
    const ComAtprotoSyncGetRecord = __importStar(requireGetRecord$1());
    const ComAtprotoSyncGetRepo = __importStar(requireGetRepo$1());
    const ComAtprotoSyncGetRepoStatus = __importStar(requireGetRepoStatus());
    const ComAtprotoSyncListBlobs = __importStar(requireListBlobs());
    const AppBskyFeedGetActorLikes = __importStar(requireGetActorLikes());
    const AppBskyFeedGetAuthorFeed = __importStar(requireGetAuthorFeed());
    const AppBskyFeedGetFeed = __importStar(requireGetFeed());
    const AppBskyFeedGetFeedSkeleton = __importStar(requireGetFeedSkeleton());
    const AppBskyFeedGetListFeed = __importStar(requireGetListFeed());
    const AppBskyFeedGetPostThread = __importStar(requireGetPostThread());
    const AppBskyFeedSearchPosts = __importStar(requireSearchPosts());
    const AppBskyGraphGetRelationships = __importStar(requireGetRelationships());
    const AppBskyUnspeccedSearchActorsSkeleton = __importStar(requireSearchActorsSkeleton());
    const AppBskyUnspeccedSearchPostsSkeleton = __importStar(requireSearchPostsSkeleton());
    const AppBskyUnspeccedSearchStarterPacksSkeleton = __importStar(requireSearchStarterPacksSkeleton());
    const ToolsOzoneCommunicationCreateTemplate = __importStar(requireCreateTemplate());
    const ToolsOzoneCommunicationUpdateTemplate = __importStar(requireUpdateTemplate());
    const ToolsOzoneModerationEmitEvent = __importStar(requireEmitEvent());
    const ToolsOzoneModerationGetRecord = __importStar(requireGetRecord());
    const ToolsOzoneModerationGetRepo = __importStar(requireGetRepo());
    const ToolsOzoneSetDeleteSet = __importStar(requireDeleteSet());
    const ToolsOzoneSetDeleteValues = __importStar(requireDeleteValues());
    const ToolsOzoneSetGetValues = __importStar(requireGetValues());
    const ToolsOzoneTeamAddMember = __importStar(requireAddMember());
    const ToolsOzoneTeamDeleteMember = __importStar(requireDeleteMember());
    const ToolsOzoneTeamUpdateMember = __importStar(requireUpdateMember());
    client$1.ComAtprotoAdminDefs = __importStar(requireDefs$j());
    client$1.ComAtprotoAdminDeleteAccount = __importStar(requireDeleteAccount$1());
    client$1.ComAtprotoAdminDisableAccountInvites = __importStar(requireDisableAccountInvites());
    client$1.ComAtprotoAdminDisableInviteCodes = __importStar(requireDisableInviteCodes());
    client$1.ComAtprotoAdminEnableAccountInvites = __importStar(requireEnableAccountInvites());
    client$1.ComAtprotoAdminGetAccountInfo = __importStar(requireGetAccountInfo());
    client$1.ComAtprotoAdminGetAccountInfos = __importStar(requireGetAccountInfos());
    client$1.ComAtprotoAdminGetInviteCodes = __importStar(requireGetInviteCodes());
    client$1.ComAtprotoAdminGetSubjectStatus = __importStar(requireGetSubjectStatus());
    client$1.ComAtprotoAdminSearchAccounts = __importStar(requireSearchAccounts$1());
    client$1.ComAtprotoAdminSendEmail = __importStar(requireSendEmail());
    client$1.ComAtprotoAdminUpdateAccountEmail = __importStar(requireUpdateAccountEmail());
    client$1.ComAtprotoAdminUpdateAccountHandle = __importStar(requireUpdateAccountHandle());
    client$1.ComAtprotoAdminUpdateAccountPassword = __importStar(requireUpdateAccountPassword());
    client$1.ComAtprotoAdminUpdateSubjectStatus = __importStar(requireUpdateSubjectStatus());
    client$1.ComAtprotoIdentityGetRecommendedDidCredentials = __importStar(requireGetRecommendedDidCredentials());
    client$1.ComAtprotoIdentityRequestPlcOperationSignature = __importStar(requireRequestPlcOperationSignature());
    client$1.ComAtprotoIdentityResolveHandle = __importStar(requireResolveHandle());
    client$1.ComAtprotoIdentitySignPlcOperation = __importStar(requireSignPlcOperation());
    client$1.ComAtprotoIdentitySubmitPlcOperation = __importStar(requireSubmitPlcOperation());
    client$1.ComAtprotoIdentityUpdateHandle = __importStar(requireUpdateHandle());
    client$1.ComAtprotoLabelDefs = __importStar(requireDefs$i());
    client$1.ComAtprotoLabelQueryLabels = __importStar(requireQueryLabels());
    client$1.ComAtprotoLabelSubscribeLabels = __importStar(requireSubscribeLabels());
    client$1.ComAtprotoLexiconSchema = __importStar(requireSchema());
    client$1.ComAtprotoModerationCreateReport = __importStar(requireCreateReport());
    client$1.ComAtprotoModerationDefs = __importStar(requireDefs$h());
    client$1.ComAtprotoRepoApplyWrites = __importStar(requireApplyWrites());
    client$1.ComAtprotoRepoCreateRecord = __importStar(requireCreateRecord());
    client$1.ComAtprotoRepoDefs = __importStar(requireDefs$g());
    client$1.ComAtprotoRepoDeleteRecord = __importStar(requireDeleteRecord());
    client$1.ComAtprotoRepoDescribeRepo = __importStar(requireDescribeRepo());
    client$1.ComAtprotoRepoGetRecord = __importStar(requireGetRecord$2());
    client$1.ComAtprotoRepoImportRepo = __importStar(requireImportRepo());
    client$1.ComAtprotoRepoListMissingBlobs = __importStar(requireListMissingBlobs());
    client$1.ComAtprotoRepoListRecords = __importStar(requireListRecords());
    client$1.ComAtprotoRepoPutRecord = __importStar(requirePutRecord());
    client$1.ComAtprotoRepoStrongRef = __importStar(requireStrongRef());
    client$1.ComAtprotoRepoUploadBlob = __importStar(requireUploadBlob());
    client$1.ComAtprotoServerActivateAccount = __importStar(requireActivateAccount());
    client$1.ComAtprotoServerCheckAccountStatus = __importStar(requireCheckAccountStatus());
    client$1.ComAtprotoServerConfirmEmail = __importStar(requireConfirmEmail());
    client$1.ComAtprotoServerCreateAccount = __importStar(requireCreateAccount());
    client$1.ComAtprotoServerCreateAppPassword = __importStar(requireCreateAppPassword());
    client$1.ComAtprotoServerCreateInviteCode = __importStar(requireCreateInviteCode());
    client$1.ComAtprotoServerCreateInviteCodes = __importStar(requireCreateInviteCodes());
    client$1.ComAtprotoServerCreateSession = __importStar(requireCreateSession());
    client$1.ComAtprotoServerDeactivateAccount = __importStar(requireDeactivateAccount());
    client$1.ComAtprotoServerDefs = __importStar(requireDefs$f());
    client$1.ComAtprotoServerDeleteAccount = __importStar(requireDeleteAccount$2());
    client$1.ComAtprotoServerDeleteSession = __importStar(requireDeleteSession());
    client$1.ComAtprotoServerDescribeServer = __importStar(requireDescribeServer());
    client$1.ComAtprotoServerGetAccountInviteCodes = __importStar(requireGetAccountInviteCodes());
    client$1.ComAtprotoServerGetServiceAuth = __importStar(requireGetServiceAuth());
    client$1.ComAtprotoServerGetSession = __importStar(requireGetSession());
    client$1.ComAtprotoServerListAppPasswords = __importStar(requireListAppPasswords());
    client$1.ComAtprotoServerRefreshSession = __importStar(requireRefreshSession());
    client$1.ComAtprotoServerRequestAccountDelete = __importStar(requireRequestAccountDelete());
    client$1.ComAtprotoServerRequestEmailConfirmation = __importStar(requireRequestEmailConfirmation());
    client$1.ComAtprotoServerRequestEmailUpdate = __importStar(requireRequestEmailUpdate());
    client$1.ComAtprotoServerRequestPasswordReset = __importStar(requireRequestPasswordReset());
    client$1.ComAtprotoServerReserveSigningKey = __importStar(requireReserveSigningKey());
    client$1.ComAtprotoServerResetPassword = __importStar(requireResetPassword());
    client$1.ComAtprotoServerRevokeAppPassword = __importStar(requireRevokeAppPassword());
    client$1.ComAtprotoServerUpdateEmail = __importStar(requireUpdateEmail());
    client$1.ComAtprotoSyncGetBlob = __importStar(requireGetBlob());
    client$1.ComAtprotoSyncGetBlocks = __importStar(requireGetBlocks$1());
    client$1.ComAtprotoSyncGetCheckout = __importStar(requireGetCheckout());
    client$1.ComAtprotoSyncGetHead = __importStar(requireGetHead());
    client$1.ComAtprotoSyncGetLatestCommit = __importStar(requireGetLatestCommit());
    client$1.ComAtprotoSyncGetRecord = __importStar(requireGetRecord$1());
    client$1.ComAtprotoSyncGetRepo = __importStar(requireGetRepo$1());
    client$1.ComAtprotoSyncGetRepoStatus = __importStar(requireGetRepoStatus());
    client$1.ComAtprotoSyncListBlobs = __importStar(requireListBlobs());
    client$1.ComAtprotoSyncListRepos = __importStar(requireListRepos());
    client$1.ComAtprotoSyncNotifyOfUpdate = __importStar(requireNotifyOfUpdate());
    client$1.ComAtprotoSyncRequestCrawl = __importStar(requireRequestCrawl());
    client$1.ComAtprotoSyncSubscribeRepos = __importStar(requireSubscribeRepos());
    client$1.ComAtprotoTempAddReservedHandle = __importStar(requireAddReservedHandle());
    client$1.ComAtprotoTempCheckSignupQueue = __importStar(requireCheckSignupQueue());
    client$1.ComAtprotoTempFetchLabels = __importStar(requireFetchLabels());
    client$1.ComAtprotoTempRequestPhoneVerification = __importStar(requireRequestPhoneVerification());
    client$1.AppBskyActorDefs = __importStar(requireDefs$e());
    client$1.AppBskyActorGetPreferences = __importStar(requireGetPreferences());
    client$1.AppBskyActorGetProfile = __importStar(requireGetProfile());
    client$1.AppBskyActorGetProfiles = __importStar(requireGetProfiles());
    client$1.AppBskyActorGetSuggestions = __importStar(requireGetSuggestions());
    client$1.AppBskyActorProfile = __importStar(requireProfile$1());
    client$1.AppBskyActorPutPreferences = __importStar(requirePutPreferences$1());
    client$1.AppBskyActorSearchActors = __importStar(requireSearchActors());
    client$1.AppBskyActorSearchActorsTypeahead = __importStar(requireSearchActorsTypeahead());
    client$1.AppBskyEmbedDefs = __importStar(requireDefs$d());
    client$1.AppBskyEmbedExternal = __importStar(requireExternal());
    client$1.AppBskyEmbedImages = __importStar(requireImages());
    client$1.AppBskyEmbedRecord = __importStar(requireRecord());
    client$1.AppBskyEmbedRecordWithMedia = __importStar(requireRecordWithMedia());
    client$1.AppBskyEmbedVideo = __importStar(requireVideo());
    client$1.AppBskyFeedDefs = __importStar(requireDefs$c());
    client$1.AppBskyFeedDescribeFeedGenerator = __importStar(requireDescribeFeedGenerator());
    client$1.AppBskyFeedGenerator = __importStar(requireGenerator());
    client$1.AppBskyFeedGetActorFeeds = __importStar(requireGetActorFeeds());
    client$1.AppBskyFeedGetActorLikes = __importStar(requireGetActorLikes());
    client$1.AppBskyFeedGetAuthorFeed = __importStar(requireGetAuthorFeed());
    client$1.AppBskyFeedGetFeed = __importStar(requireGetFeed());
    client$1.AppBskyFeedGetFeedGenerator = __importStar(requireGetFeedGenerator());
    client$1.AppBskyFeedGetFeedGenerators = __importStar(requireGetFeedGenerators());
    client$1.AppBskyFeedGetFeedSkeleton = __importStar(requireGetFeedSkeleton());
    client$1.AppBskyFeedGetLikes = __importStar(requireGetLikes());
    client$1.AppBskyFeedGetListFeed = __importStar(requireGetListFeed());
    client$1.AppBskyFeedGetPostThread = __importStar(requireGetPostThread());
    client$1.AppBskyFeedGetPosts = __importStar(requireGetPosts());
    client$1.AppBskyFeedGetQuotes = __importStar(requireGetQuotes());
    client$1.AppBskyFeedGetRepostedBy = __importStar(requireGetRepostedBy());
    client$1.AppBskyFeedGetSuggestedFeeds = __importStar(requireGetSuggestedFeeds());
    client$1.AppBskyFeedGetTimeline = __importStar(requireGetTimeline());
    client$1.AppBskyFeedLike = __importStar(requireLike());
    client$1.AppBskyFeedPost = __importStar(requirePost$1());
    client$1.AppBskyFeedPostgate = __importStar(requirePostgate());
    client$1.AppBskyFeedRepost = __importStar(requireRepost());
    client$1.AppBskyFeedSearchPosts = __importStar(requireSearchPosts());
    client$1.AppBskyFeedSendInteractions = __importStar(requireSendInteractions());
    client$1.AppBskyFeedThreadgate = __importStar(requireThreadgate());
    client$1.AppBskyGraphBlock = __importStar(requireBlock());
    client$1.AppBskyGraphDefs = __importStar(requireDefs$b());
    client$1.AppBskyGraphFollow = __importStar(requireFollow());
    client$1.AppBskyGraphGetActorStarterPacks = __importStar(requireGetActorStarterPacks());
    client$1.AppBskyGraphGetBlocks = __importStar(requireGetBlocks());
    client$1.AppBskyGraphGetFollowers = __importStar(requireGetFollowers());
    client$1.AppBskyGraphGetFollows = __importStar(requireGetFollows());
    client$1.AppBskyGraphGetKnownFollowers = __importStar(requireGetKnownFollowers());
    client$1.AppBskyGraphGetList = __importStar(requireGetList());
    client$1.AppBskyGraphGetListBlocks = __importStar(requireGetListBlocks());
    client$1.AppBskyGraphGetListMutes = __importStar(requireGetListMutes());
    client$1.AppBskyGraphGetLists = __importStar(requireGetLists());
    client$1.AppBskyGraphGetMutes = __importStar(requireGetMutes());
    client$1.AppBskyGraphGetRelationships = __importStar(requireGetRelationships());
    client$1.AppBskyGraphGetStarterPack = __importStar(requireGetStarterPack());
    client$1.AppBskyGraphGetStarterPacks = __importStar(requireGetStarterPacks());
    client$1.AppBskyGraphGetSuggestedFollowsByActor = __importStar(requireGetSuggestedFollowsByActor());
    client$1.AppBskyGraphList = __importStar(requireList());
    client$1.AppBskyGraphListblock = __importStar(requireListblock());
    client$1.AppBskyGraphListitem = __importStar(requireListitem());
    client$1.AppBskyGraphMuteActor = __importStar(requireMuteActor());
    client$1.AppBskyGraphMuteActorList = __importStar(requireMuteActorList());
    client$1.AppBskyGraphMuteThread = __importStar(requireMuteThread());
    client$1.AppBskyGraphSearchStarterPacks = __importStar(requireSearchStarterPacks());
    client$1.AppBskyGraphStarterpack = __importStar(requireStarterpack());
    client$1.AppBskyGraphUnmuteActor = __importStar(requireUnmuteActor());
    client$1.AppBskyGraphUnmuteActorList = __importStar(requireUnmuteActorList());
    client$1.AppBskyGraphUnmuteThread = __importStar(requireUnmuteThread());
    client$1.AppBskyLabelerDefs = __importStar(requireDefs$a());
    client$1.AppBskyLabelerGetServices = __importStar(requireGetServices());
    client$1.AppBskyLabelerService = __importStar(requireService());
    client$1.AppBskyNotificationGetUnreadCount = __importStar(requireGetUnreadCount());
    client$1.AppBskyNotificationListNotifications = __importStar(requireListNotifications());
    client$1.AppBskyNotificationPutPreferences = __importStar(requirePutPreferences());
    client$1.AppBskyNotificationRegisterPush = __importStar(requireRegisterPush());
    client$1.AppBskyNotificationUpdateSeen = __importStar(requireUpdateSeen());
    client$1.AppBskyRichtextFacet = __importStar(requireFacet());
    client$1.AppBskyUnspeccedDefs = __importStar(requireDefs$9());
    client$1.AppBskyUnspeccedGetConfig = __importStar(requireGetConfig$1());
    client$1.AppBskyUnspeccedGetPopularFeedGenerators = __importStar(requireGetPopularFeedGenerators());
    client$1.AppBskyUnspeccedGetSuggestionsSkeleton = __importStar(requireGetSuggestionsSkeleton());
    client$1.AppBskyUnspeccedGetTaggedSuggestions = __importStar(requireGetTaggedSuggestions());
    client$1.AppBskyUnspeccedGetTrendingTopics = __importStar(requireGetTrendingTopics());
    client$1.AppBskyUnspeccedSearchActorsSkeleton = __importStar(requireSearchActorsSkeleton());
    client$1.AppBskyUnspeccedSearchPostsSkeleton = __importStar(requireSearchPostsSkeleton());
    client$1.AppBskyUnspeccedSearchStarterPacksSkeleton = __importStar(requireSearchStarterPacksSkeleton());
    client$1.AppBskyVideoDefs = __importStar(requireDefs$8());
    client$1.AppBskyVideoGetJobStatus = __importStar(requireGetJobStatus());
    client$1.AppBskyVideoGetUploadLimits = __importStar(requireGetUploadLimits());
    client$1.AppBskyVideoUploadVideo = __importStar(requireUploadVideo());
    client$1.ChatBskyActorDeclaration = __importStar(requireDeclaration());
    client$1.ChatBskyActorDefs = __importStar(requireDefs$7());
    client$1.ChatBskyActorDeleteAccount = __importStar(requireDeleteAccount());
    client$1.ChatBskyActorExportAccountData = __importStar(requireExportAccountData());
    client$1.ChatBskyConvoDefs = __importStar(requireDefs$6());
    client$1.ChatBskyConvoDeleteMessageForSelf = __importStar(requireDeleteMessageForSelf());
    client$1.ChatBskyConvoGetConvo = __importStar(requireGetConvo());
    client$1.ChatBskyConvoGetConvoForMembers = __importStar(requireGetConvoForMembers());
    client$1.ChatBskyConvoGetLog = __importStar(requireGetLog());
    client$1.ChatBskyConvoGetMessages = __importStar(requireGetMessages());
    client$1.ChatBskyConvoLeaveConvo = __importStar(requireLeaveConvo());
    client$1.ChatBskyConvoListConvos = __importStar(requireListConvos());
    client$1.ChatBskyConvoMuteConvo = __importStar(requireMuteConvo());
    client$1.ChatBskyConvoSendMessage = __importStar(requireSendMessage());
    client$1.ChatBskyConvoSendMessageBatch = __importStar(requireSendMessageBatch());
    client$1.ChatBskyConvoUnmuteConvo = __importStar(requireUnmuteConvo());
    client$1.ChatBskyConvoUpdateRead = __importStar(requireUpdateRead());
    client$1.ChatBskyModerationGetActorMetadata = __importStar(requireGetActorMetadata());
    client$1.ChatBskyModerationGetMessageContext = __importStar(requireGetMessageContext());
    client$1.ChatBskyModerationUpdateActorAccess = __importStar(requireUpdateActorAccess());
    client$1.ToolsOzoneCommunicationCreateTemplate = __importStar(requireCreateTemplate());
    client$1.ToolsOzoneCommunicationDefs = __importStar(requireDefs$5());
    client$1.ToolsOzoneCommunicationDeleteTemplate = __importStar(requireDeleteTemplate());
    client$1.ToolsOzoneCommunicationListTemplates = __importStar(requireListTemplates());
    client$1.ToolsOzoneCommunicationUpdateTemplate = __importStar(requireUpdateTemplate());
    client$1.ToolsOzoneModerationDefs = __importStar(requireDefs$4());
    client$1.ToolsOzoneModerationEmitEvent = __importStar(requireEmitEvent());
    client$1.ToolsOzoneModerationGetEvent = __importStar(requireGetEvent());
    client$1.ToolsOzoneModerationGetRecord = __importStar(requireGetRecord());
    client$1.ToolsOzoneModerationGetRecords = __importStar(requireGetRecords());
    client$1.ToolsOzoneModerationGetRepo = __importStar(requireGetRepo());
    client$1.ToolsOzoneModerationGetRepos = __importStar(requireGetRepos());
    client$1.ToolsOzoneModerationQueryEvents = __importStar(requireQueryEvents());
    client$1.ToolsOzoneModerationQueryStatuses = __importStar(requireQueryStatuses());
    client$1.ToolsOzoneModerationSearchRepos = __importStar(requireSearchRepos());
    client$1.ToolsOzoneServerGetConfig = __importStar(requireGetConfig());
    client$1.ToolsOzoneSetAddValues = __importStar(requireAddValues());
    client$1.ToolsOzoneSetDefs = __importStar(requireDefs$3());
    client$1.ToolsOzoneSetDeleteSet = __importStar(requireDeleteSet());
    client$1.ToolsOzoneSetDeleteValues = __importStar(requireDeleteValues());
    client$1.ToolsOzoneSetGetValues = __importStar(requireGetValues());
    client$1.ToolsOzoneSetQuerySets = __importStar(requireQuerySets());
    client$1.ToolsOzoneSetUpsertSet = __importStar(requireUpsertSet());
    client$1.ToolsOzoneSettingDefs = __importStar(requireDefs$2());
    client$1.ToolsOzoneSettingListOptions = __importStar(requireListOptions());
    client$1.ToolsOzoneSettingRemoveOptions = __importStar(requireRemoveOptions());
    client$1.ToolsOzoneSettingUpsertOption = __importStar(requireUpsertOption());
    client$1.ToolsOzoneSignatureDefs = __importStar(requireDefs$1());
    client$1.ToolsOzoneSignatureFindCorrelation = __importStar(requireFindCorrelation());
    client$1.ToolsOzoneSignatureFindRelatedAccounts = __importStar(requireFindRelatedAccounts());
    client$1.ToolsOzoneSignatureSearchAccounts = __importStar(requireSearchAccounts());
    client$1.ToolsOzoneTeamAddMember = __importStar(requireAddMember());
    client$1.ToolsOzoneTeamDefs = __importStar(requireDefs());
    client$1.ToolsOzoneTeamDeleteMember = __importStar(requireDeleteMember());
    client$1.ToolsOzoneTeamListMembers = __importStar(requireListMembers());
    client$1.ToolsOzoneTeamUpdateMember = __importStar(requireUpdateMember());
    client$1.COM_ATPROTO_MODERATION = {
      DefsReasonSpam: "com.atproto.moderation.defs#reasonSpam",
      DefsReasonViolation: "com.atproto.moderation.defs#reasonViolation",
      DefsReasonMisleading: "com.atproto.moderation.defs#reasonMisleading",
      DefsReasonSexual: "com.atproto.moderation.defs#reasonSexual",
      DefsReasonRude: "com.atproto.moderation.defs#reasonRude",
      DefsReasonOther: "com.atproto.moderation.defs#reasonOther",
      DefsReasonAppeal: "com.atproto.moderation.defs#reasonAppeal"
    };
    client$1.APP_BSKY_FEED = {
      DefsRequestLess: "app.bsky.feed.defs#requestLess",
      DefsRequestMore: "app.bsky.feed.defs#requestMore",
      DefsClickthroughItem: "app.bsky.feed.defs#clickthroughItem",
      DefsClickthroughAuthor: "app.bsky.feed.defs#clickthroughAuthor",
      DefsClickthroughReposter: "app.bsky.feed.defs#clickthroughReposter",
      DefsClickthroughEmbed: "app.bsky.feed.defs#clickthroughEmbed",
      DefsContentModeUnspecified: "app.bsky.feed.defs#contentModeUnspecified",
      DefsContentModeVideo: "app.bsky.feed.defs#contentModeVideo",
      DefsInteractionSeen: "app.bsky.feed.defs#interactionSeen",
      DefsInteractionLike: "app.bsky.feed.defs#interactionLike",
      DefsInteractionRepost: "app.bsky.feed.defs#interactionRepost",
      DefsInteractionReply: "app.bsky.feed.defs#interactionReply",
      DefsInteractionQuote: "app.bsky.feed.defs#interactionQuote",
      DefsInteractionShare: "app.bsky.feed.defs#interactionShare"
    };
    client$1.APP_BSKY_GRAPH = {
      DefsModlist: "app.bsky.graph.defs#modlist",
      DefsCuratelist: "app.bsky.graph.defs#curatelist",
      DefsReferencelist: "app.bsky.graph.defs#referencelist"
    };
    client$1.TOOLS_OZONE_MODERATION = {
      DefsReviewOpen: "tools.ozone.moderation.defs#reviewOpen",
      DefsReviewEscalated: "tools.ozone.moderation.defs#reviewEscalated",
      DefsReviewClosed: "tools.ozone.moderation.defs#reviewClosed",
      DefsReviewNone: "tools.ozone.moderation.defs#reviewNone"
    };
    client$1.TOOLS_OZONE_TEAM = {
      DefsRoleAdmin: "tools.ozone.team.defs#roleAdmin",
      DefsRoleModerator: "tools.ozone.team.defs#roleModerator",
      DefsRoleTriage: "tools.ozone.team.defs#roleTriage"
    };
    class AtpBaseClient extends xrpc_1.XrpcClient {
      constructor(options) {
        super(options, lexicons_js_1.schemas);
        Object.defineProperty(this, "com", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "app", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "chat", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "tools", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.com = new ComNS(this);
        this.app = new AppNS(this);
        this.chat = new ChatNS(this);
        this.tools = new ToolsNS(this);
      }
      /** @deprecated use `this` instead */
      get xrpc() {
        return this;
      }
    }
    client$1.AtpBaseClient = AtpBaseClient;
    class ComNS {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "atproto", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
        this.atproto = new ComAtprotoNS(client2);
      }
    }
    client$1.ComNS = ComNS;
    class ComAtprotoNS {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "admin", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "identity", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "label", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "lexicon", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "moderation", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "repo", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "server", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "sync", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "temp", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
        this.admin = new ComAtprotoAdminNS(client2);
        this.identity = new ComAtprotoIdentityNS(client2);
        this.label = new ComAtprotoLabelNS(client2);
        this.lexicon = new ComAtprotoLexiconNS(client2);
        this.moderation = new ComAtprotoModerationNS(client2);
        this.repo = new ComAtprotoRepoNS(client2);
        this.server = new ComAtprotoServerNS(client2);
        this.sync = new ComAtprotoSyncNS(client2);
        this.temp = new ComAtprotoTempNS(client2);
      }
    }
    client$1.ComAtprotoNS = ComAtprotoNS;
    class ComAtprotoAdminNS {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
      }
      deleteAccount(data, opts) {
        return this._client.call("com.atproto.admin.deleteAccount", opts?.qp, data, opts);
      }
      disableAccountInvites(data, opts) {
        return this._client.call("com.atproto.admin.disableAccountInvites", opts?.qp, data, opts);
      }
      disableInviteCodes(data, opts) {
        return this._client.call("com.atproto.admin.disableInviteCodes", opts?.qp, data, opts);
      }
      enableAccountInvites(data, opts) {
        return this._client.call("com.atproto.admin.enableAccountInvites", opts?.qp, data, opts);
      }
      getAccountInfo(params, opts) {
        return this._client.call("com.atproto.admin.getAccountInfo", params, void 0, opts);
      }
      getAccountInfos(params, opts) {
        return this._client.call("com.atproto.admin.getAccountInfos", params, void 0, opts);
      }
      getInviteCodes(params, opts) {
        return this._client.call("com.atproto.admin.getInviteCodes", params, void 0, opts);
      }
      getSubjectStatus(params, opts) {
        return this._client.call("com.atproto.admin.getSubjectStatus", params, void 0, opts);
      }
      searchAccounts(params, opts) {
        return this._client.call("com.atproto.admin.searchAccounts", params, void 0, opts);
      }
      sendEmail(data, opts) {
        return this._client.call("com.atproto.admin.sendEmail", opts?.qp, data, opts);
      }
      updateAccountEmail(data, opts) {
        return this._client.call("com.atproto.admin.updateAccountEmail", opts?.qp, data, opts);
      }
      updateAccountHandle(data, opts) {
        return this._client.call("com.atproto.admin.updateAccountHandle", opts?.qp, data, opts);
      }
      updateAccountPassword(data, opts) {
        return this._client.call("com.atproto.admin.updateAccountPassword", opts?.qp, data, opts);
      }
      updateSubjectStatus(data, opts) {
        return this._client.call("com.atproto.admin.updateSubjectStatus", opts?.qp, data, opts);
      }
    }
    client$1.ComAtprotoAdminNS = ComAtprotoAdminNS;
    class ComAtprotoIdentityNS {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
      }
      getRecommendedDidCredentials(params, opts) {
        return this._client.call("com.atproto.identity.getRecommendedDidCredentials", params, void 0, opts);
      }
      requestPlcOperationSignature(data, opts) {
        return this._client.call("com.atproto.identity.requestPlcOperationSignature", opts?.qp, data, opts);
      }
      resolveHandle(params, opts) {
        return this._client.call("com.atproto.identity.resolveHandle", params, void 0, opts);
      }
      signPlcOperation(data, opts) {
        return this._client.call("com.atproto.identity.signPlcOperation", opts?.qp, data, opts);
      }
      submitPlcOperation(data, opts) {
        return this._client.call("com.atproto.identity.submitPlcOperation", opts?.qp, data, opts);
      }
      updateHandle(data, opts) {
        return this._client.call("com.atproto.identity.updateHandle", opts?.qp, data, opts);
      }
    }
    client$1.ComAtprotoIdentityNS = ComAtprotoIdentityNS;
    class ComAtprotoLabelNS {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
      }
      queryLabels(params, opts) {
        return this._client.call("com.atproto.label.queryLabels", params, void 0, opts);
      }
    }
    client$1.ComAtprotoLabelNS = ComAtprotoLabelNS;
    class ComAtprotoLexiconNS {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "schema", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
        this.schema = new SchemaRecord(client2);
      }
    }
    client$1.ComAtprotoLexiconNS = ComAtprotoLexiconNS;
    class SchemaRecord {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
      }
      async list(params) {
        const res = await this._client.call("com.atproto.repo.listRecords", {
          collection: "com.atproto.lexicon.schema",
          ...params
        });
        return res.data;
      }
      async get(params) {
        const res = await this._client.call("com.atproto.repo.getRecord", {
          collection: "com.atproto.lexicon.schema",
          ...params
        });
        return res.data;
      }
      async create(params, record2, headers) {
        const collection = "com.atproto.lexicon.schema";
        const res = await this._client.call("com.atproto.repo.createRecord", void 0, { collection, ...params, record: { ...record2, $type: collection } }, { encoding: "application/json", headers });
        return res.data;
      }
      async delete(params, headers) {
        await this._client.call("com.atproto.repo.deleteRecord", void 0, { collection: "com.atproto.lexicon.schema", ...params }, { headers });
      }
    }
    client$1.SchemaRecord = SchemaRecord;
    class ComAtprotoModerationNS {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
      }
      createReport(data, opts) {
        return this._client.call("com.atproto.moderation.createReport", opts?.qp, data, opts);
      }
    }
    client$1.ComAtprotoModerationNS = ComAtprotoModerationNS;
    class ComAtprotoRepoNS {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
      }
      applyWrites(data, opts) {
        return this._client.call("com.atproto.repo.applyWrites", opts?.qp, data, opts).catch((e) => {
          throw ComAtprotoRepoApplyWrites.toKnownErr(e);
        });
      }
      createRecord(data, opts) {
        return this._client.call("com.atproto.repo.createRecord", opts?.qp, data, opts).catch((e) => {
          throw ComAtprotoRepoCreateRecord.toKnownErr(e);
        });
      }
      deleteRecord(data, opts) {
        return this._client.call("com.atproto.repo.deleteRecord", opts?.qp, data, opts).catch((e) => {
          throw ComAtprotoRepoDeleteRecord.toKnownErr(e);
        });
      }
      describeRepo(params, opts) {
        return this._client.call("com.atproto.repo.describeRepo", params, void 0, opts);
      }
      getRecord(params, opts) {
        return this._client.call("com.atproto.repo.getRecord", params, void 0, opts).catch((e) => {
          throw ComAtprotoRepoGetRecord.toKnownErr(e);
        });
      }
      importRepo(data, opts) {
        return this._client.call("com.atproto.repo.importRepo", opts?.qp, data, opts);
      }
      listMissingBlobs(params, opts) {
        return this._client.call("com.atproto.repo.listMissingBlobs", params, void 0, opts);
      }
      listRecords(params, opts) {
        return this._client.call("com.atproto.repo.listRecords", params, void 0, opts);
      }
      putRecord(data, opts) {
        return this._client.call("com.atproto.repo.putRecord", opts?.qp, data, opts).catch((e) => {
          throw ComAtprotoRepoPutRecord.toKnownErr(e);
        });
      }
      uploadBlob(data, opts) {
        return this._client.call("com.atproto.repo.uploadBlob", opts?.qp, data, opts);
      }
    }
    client$1.ComAtprotoRepoNS = ComAtprotoRepoNS;
    class ComAtprotoServerNS {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
      }
      activateAccount(data, opts) {
        return this._client.call("com.atproto.server.activateAccount", opts?.qp, data, opts);
      }
      checkAccountStatus(params, opts) {
        return this._client.call("com.atproto.server.checkAccountStatus", params, void 0, opts);
      }
      confirmEmail(data, opts) {
        return this._client.call("com.atproto.server.confirmEmail", opts?.qp, data, opts).catch((e) => {
          throw ComAtprotoServerConfirmEmail.toKnownErr(e);
        });
      }
      createAccount(data, opts) {
        return this._client.call("com.atproto.server.createAccount", opts?.qp, data, opts).catch((e) => {
          throw ComAtprotoServerCreateAccount.toKnownErr(e);
        });
      }
      createAppPassword(data, opts) {
        return this._client.call("com.atproto.server.createAppPassword", opts?.qp, data, opts).catch((e) => {
          throw ComAtprotoServerCreateAppPassword.toKnownErr(e);
        });
      }
      createInviteCode(data, opts) {
        return this._client.call("com.atproto.server.createInviteCode", opts?.qp, data, opts);
      }
      createInviteCodes(data, opts) {
        return this._client.call("com.atproto.server.createInviteCodes", opts?.qp, data, opts);
      }
      createSession(data, opts) {
        return this._client.call("com.atproto.server.createSession", opts?.qp, data, opts).catch((e) => {
          throw ComAtprotoServerCreateSession.toKnownErr(e);
        });
      }
      deactivateAccount(data, opts) {
        return this._client.call("com.atproto.server.deactivateAccount", opts?.qp, data, opts);
      }
      deleteAccount(data, opts) {
        return this._client.call("com.atproto.server.deleteAccount", opts?.qp, data, opts).catch((e) => {
          throw ComAtprotoServerDeleteAccount.toKnownErr(e);
        });
      }
      deleteSession(data, opts) {
        return this._client.call("com.atproto.server.deleteSession", opts?.qp, data, opts);
      }
      describeServer(params, opts) {
        return this._client.call("com.atproto.server.describeServer", params, void 0, opts);
      }
      getAccountInviteCodes(params, opts) {
        return this._client.call("com.atproto.server.getAccountInviteCodes", params, void 0, opts).catch((e) => {
          throw ComAtprotoServerGetAccountInviteCodes.toKnownErr(e);
        });
      }
      getServiceAuth(params, opts) {
        return this._client.call("com.atproto.server.getServiceAuth", params, void 0, opts).catch((e) => {
          throw ComAtprotoServerGetServiceAuth.toKnownErr(e);
        });
      }
      getSession(params, opts) {
        return this._client.call("com.atproto.server.getSession", params, void 0, opts);
      }
      listAppPasswords(params, opts) {
        return this._client.call("com.atproto.server.listAppPasswords", params, void 0, opts).catch((e) => {
          throw ComAtprotoServerListAppPasswords.toKnownErr(e);
        });
      }
      refreshSession(data, opts) {
        return this._client.call("com.atproto.server.refreshSession", opts?.qp, data, opts).catch((e) => {
          throw ComAtprotoServerRefreshSession.toKnownErr(e);
        });
      }
      requestAccountDelete(data, opts) {
        return this._client.call("com.atproto.server.requestAccountDelete", opts?.qp, data, opts);
      }
      requestEmailConfirmation(data, opts) {
        return this._client.call("com.atproto.server.requestEmailConfirmation", opts?.qp, data, opts);
      }
      requestEmailUpdate(data, opts) {
        return this._client.call("com.atproto.server.requestEmailUpdate", opts?.qp, data, opts);
      }
      requestPasswordReset(data, opts) {
        return this._client.call("com.atproto.server.requestPasswordReset", opts?.qp, data, opts);
      }
      reserveSigningKey(data, opts) {
        return this._client.call("com.atproto.server.reserveSigningKey", opts?.qp, data, opts);
      }
      resetPassword(data, opts) {
        return this._client.call("com.atproto.server.resetPassword", opts?.qp, data, opts).catch((e) => {
          throw ComAtprotoServerResetPassword.toKnownErr(e);
        });
      }
      revokeAppPassword(data, opts) {
        return this._client.call("com.atproto.server.revokeAppPassword", opts?.qp, data, opts);
      }
      updateEmail(data, opts) {
        return this._client.call("com.atproto.server.updateEmail", opts?.qp, data, opts).catch((e) => {
          throw ComAtprotoServerUpdateEmail.toKnownErr(e);
        });
      }
    }
    client$1.ComAtprotoServerNS = ComAtprotoServerNS;
    class ComAtprotoSyncNS {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
      }
      getBlob(params, opts) {
        return this._client.call("com.atproto.sync.getBlob", params, void 0, opts).catch((e) => {
          throw ComAtprotoSyncGetBlob.toKnownErr(e);
        });
      }
      getBlocks(params, opts) {
        return this._client.call("com.atproto.sync.getBlocks", params, void 0, opts).catch((e) => {
          throw ComAtprotoSyncGetBlocks.toKnownErr(e);
        });
      }
      getCheckout(params, opts) {
        return this._client.call("com.atproto.sync.getCheckout", params, void 0, opts);
      }
      getHead(params, opts) {
        return this._client.call("com.atproto.sync.getHead", params, void 0, opts).catch((e) => {
          throw ComAtprotoSyncGetHead.toKnownErr(e);
        });
      }
      getLatestCommit(params, opts) {
        return this._client.call("com.atproto.sync.getLatestCommit", params, void 0, opts).catch((e) => {
          throw ComAtprotoSyncGetLatestCommit.toKnownErr(e);
        });
      }
      getRecord(params, opts) {
        return this._client.call("com.atproto.sync.getRecord", params, void 0, opts).catch((e) => {
          throw ComAtprotoSyncGetRecord.toKnownErr(e);
        });
      }
      getRepo(params, opts) {
        return this._client.call("com.atproto.sync.getRepo", params, void 0, opts).catch((e) => {
          throw ComAtprotoSyncGetRepo.toKnownErr(e);
        });
      }
      getRepoStatus(params, opts) {
        return this._client.call("com.atproto.sync.getRepoStatus", params, void 0, opts).catch((e) => {
          throw ComAtprotoSyncGetRepoStatus.toKnownErr(e);
        });
      }
      listBlobs(params, opts) {
        return this._client.call("com.atproto.sync.listBlobs", params, void 0, opts).catch((e) => {
          throw ComAtprotoSyncListBlobs.toKnownErr(e);
        });
      }
      listRepos(params, opts) {
        return this._client.call("com.atproto.sync.listRepos", params, void 0, opts);
      }
      notifyOfUpdate(data, opts) {
        return this._client.call("com.atproto.sync.notifyOfUpdate", opts?.qp, data, opts);
      }
      requestCrawl(data, opts) {
        return this._client.call("com.atproto.sync.requestCrawl", opts?.qp, data, opts);
      }
    }
    client$1.ComAtprotoSyncNS = ComAtprotoSyncNS;
    class ComAtprotoTempNS {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
      }
      addReservedHandle(data, opts) {
        return this._client.call("com.atproto.temp.addReservedHandle", opts?.qp, data, opts);
      }
      checkSignupQueue(params, opts) {
        return this._client.call("com.atproto.temp.checkSignupQueue", params, void 0, opts);
      }
      fetchLabels(params, opts) {
        return this._client.call("com.atproto.temp.fetchLabels", params, void 0, opts);
      }
      requestPhoneVerification(data, opts) {
        return this._client.call("com.atproto.temp.requestPhoneVerification", opts?.qp, data, opts);
      }
    }
    client$1.ComAtprotoTempNS = ComAtprotoTempNS;
    class AppNS {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "bsky", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
        this.bsky = new AppBskyNS(client2);
      }
    }
    client$1.AppNS = AppNS;
    class AppBskyNS {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "actor", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "embed", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "feed", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "graph", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "labeler", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "notification", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "richtext", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "unspecced", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "video", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
        this.actor = new AppBskyActorNS(client2);
        this.embed = new AppBskyEmbedNS(client2);
        this.feed = new AppBskyFeedNS(client2);
        this.graph = new AppBskyGraphNS(client2);
        this.labeler = new AppBskyLabelerNS(client2);
        this.notification = new AppBskyNotificationNS(client2);
        this.richtext = new AppBskyRichtextNS(client2);
        this.unspecced = new AppBskyUnspeccedNS(client2);
        this.video = new AppBskyVideoNS(client2);
      }
    }
    client$1.AppBskyNS = AppBskyNS;
    class AppBskyActorNS {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "profile", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
        this.profile = new ProfileRecord(client2);
      }
      getPreferences(params, opts) {
        return this._client.call("app.bsky.actor.getPreferences", params, void 0, opts);
      }
      getProfile(params, opts) {
        return this._client.call("app.bsky.actor.getProfile", params, void 0, opts);
      }
      getProfiles(params, opts) {
        return this._client.call("app.bsky.actor.getProfiles", params, void 0, opts);
      }
      getSuggestions(params, opts) {
        return this._client.call("app.bsky.actor.getSuggestions", params, void 0, opts);
      }
      putPreferences(data, opts) {
        return this._client.call("app.bsky.actor.putPreferences", opts?.qp, data, opts);
      }
      searchActors(params, opts) {
        return this._client.call("app.bsky.actor.searchActors", params, void 0, opts);
      }
      searchActorsTypeahead(params, opts) {
        return this._client.call("app.bsky.actor.searchActorsTypeahead", params, void 0, opts);
      }
    }
    client$1.AppBskyActorNS = AppBskyActorNS;
    class ProfileRecord {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
      }
      async list(params) {
        const res = await this._client.call("com.atproto.repo.listRecords", {
          collection: "app.bsky.actor.profile",
          ...params
        });
        return res.data;
      }
      async get(params) {
        const res = await this._client.call("com.atproto.repo.getRecord", {
          collection: "app.bsky.actor.profile",
          ...params
        });
        return res.data;
      }
      async create(params, record2, headers) {
        const collection = "app.bsky.actor.profile";
        const res = await this._client.call("com.atproto.repo.createRecord", void 0, {
          collection,
          rkey: "self",
          ...params,
          record: { ...record2, $type: collection }
        }, { encoding: "application/json", headers });
        return res.data;
      }
      async delete(params, headers) {
        await this._client.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.actor.profile", ...params }, { headers });
      }
    }
    client$1.ProfileRecord = ProfileRecord;
    class AppBskyEmbedNS {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
      }
    }
    client$1.AppBskyEmbedNS = AppBskyEmbedNS;
    class AppBskyFeedNS {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "generator", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "like", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "post", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "postgate", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "repost", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "threadgate", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
        this.generator = new GeneratorRecord(client2);
        this.like = new LikeRecord(client2);
        this.post = new PostRecord(client2);
        this.postgate = new PostgateRecord(client2);
        this.repost = new RepostRecord(client2);
        this.threadgate = new ThreadgateRecord(client2);
      }
      describeFeedGenerator(params, opts) {
        return this._client.call("app.bsky.feed.describeFeedGenerator", params, void 0, opts);
      }
      getActorFeeds(params, opts) {
        return this._client.call("app.bsky.feed.getActorFeeds", params, void 0, opts);
      }
      getActorLikes(params, opts) {
        return this._client.call("app.bsky.feed.getActorLikes", params, void 0, opts).catch((e) => {
          throw AppBskyFeedGetActorLikes.toKnownErr(e);
        });
      }
      getAuthorFeed(params, opts) {
        return this._client.call("app.bsky.feed.getAuthorFeed", params, void 0, opts).catch((e) => {
          throw AppBskyFeedGetAuthorFeed.toKnownErr(e);
        });
      }
      getFeed(params, opts) {
        return this._client.call("app.bsky.feed.getFeed", params, void 0, opts).catch((e) => {
          throw AppBskyFeedGetFeed.toKnownErr(e);
        });
      }
      getFeedGenerator(params, opts) {
        return this._client.call("app.bsky.feed.getFeedGenerator", params, void 0, opts);
      }
      getFeedGenerators(params, opts) {
        return this._client.call("app.bsky.feed.getFeedGenerators", params, void 0, opts);
      }
      getFeedSkeleton(params, opts) {
        return this._client.call("app.bsky.feed.getFeedSkeleton", params, void 0, opts).catch((e) => {
          throw AppBskyFeedGetFeedSkeleton.toKnownErr(e);
        });
      }
      getLikes(params, opts) {
        return this._client.call("app.bsky.feed.getLikes", params, void 0, opts);
      }
      getListFeed(params, opts) {
        return this._client.call("app.bsky.feed.getListFeed", params, void 0, opts).catch((e) => {
          throw AppBskyFeedGetListFeed.toKnownErr(e);
        });
      }
      getPostThread(params, opts) {
        return this._client.call("app.bsky.feed.getPostThread", params, void 0, opts).catch((e) => {
          throw AppBskyFeedGetPostThread.toKnownErr(e);
        });
      }
      getPosts(params, opts) {
        return this._client.call("app.bsky.feed.getPosts", params, void 0, opts);
      }
      getQuotes(params, opts) {
        return this._client.call("app.bsky.feed.getQuotes", params, void 0, opts);
      }
      getRepostedBy(params, opts) {
        return this._client.call("app.bsky.feed.getRepostedBy", params, void 0, opts);
      }
      getSuggestedFeeds(params, opts) {
        return this._client.call("app.bsky.feed.getSuggestedFeeds", params, void 0, opts);
      }
      getTimeline(params, opts) {
        return this._client.call("app.bsky.feed.getTimeline", params, void 0, opts);
      }
      searchPosts(params, opts) {
        return this._client.call("app.bsky.feed.searchPosts", params, void 0, opts).catch((e) => {
          throw AppBskyFeedSearchPosts.toKnownErr(e);
        });
      }
      sendInteractions(data, opts) {
        return this._client.call("app.bsky.feed.sendInteractions", opts?.qp, data, opts);
      }
    }
    client$1.AppBskyFeedNS = AppBskyFeedNS;
    class GeneratorRecord {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
      }
      async list(params) {
        const res = await this._client.call("com.atproto.repo.listRecords", {
          collection: "app.bsky.feed.generator",
          ...params
        });
        return res.data;
      }
      async get(params) {
        const res = await this._client.call("com.atproto.repo.getRecord", {
          collection: "app.bsky.feed.generator",
          ...params
        });
        return res.data;
      }
      async create(params, record2, headers) {
        const collection = "app.bsky.feed.generator";
        const res = await this._client.call("com.atproto.repo.createRecord", void 0, { collection, ...params, record: { ...record2, $type: collection } }, { encoding: "application/json", headers });
        return res.data;
      }
      async delete(params, headers) {
        await this._client.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.feed.generator", ...params }, { headers });
      }
    }
    client$1.GeneratorRecord = GeneratorRecord;
    class LikeRecord {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
      }
      async list(params) {
        const res = await this._client.call("com.atproto.repo.listRecords", {
          collection: "app.bsky.feed.like",
          ...params
        });
        return res.data;
      }
      async get(params) {
        const res = await this._client.call("com.atproto.repo.getRecord", {
          collection: "app.bsky.feed.like",
          ...params
        });
        return res.data;
      }
      async create(params, record2, headers) {
        const collection = "app.bsky.feed.like";
        const res = await this._client.call("com.atproto.repo.createRecord", void 0, { collection, ...params, record: { ...record2, $type: collection } }, { encoding: "application/json", headers });
        return res.data;
      }
      async delete(params, headers) {
        await this._client.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.feed.like", ...params }, { headers });
      }
    }
    client$1.LikeRecord = LikeRecord;
    class PostRecord {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
      }
      async list(params) {
        const res = await this._client.call("com.atproto.repo.listRecords", {
          collection: "app.bsky.feed.post",
          ...params
        });
        return res.data;
      }
      async get(params) {
        const res = await this._client.call("com.atproto.repo.getRecord", {
          collection: "app.bsky.feed.post",
          ...params
        });
        return res.data;
      }
      async create(params, record2, headers) {
        const collection = "app.bsky.feed.post";
        const res = await this._client.call("com.atproto.repo.createRecord", void 0, { collection, ...params, record: { ...record2, $type: collection } }, { encoding: "application/json", headers });
        return res.data;
      }
      async delete(params, headers) {
        await this._client.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.feed.post", ...params }, { headers });
      }
    }
    client$1.PostRecord = PostRecord;
    class PostgateRecord {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
      }
      async list(params) {
        const res = await this._client.call("com.atproto.repo.listRecords", {
          collection: "app.bsky.feed.postgate",
          ...params
        });
        return res.data;
      }
      async get(params) {
        const res = await this._client.call("com.atproto.repo.getRecord", {
          collection: "app.bsky.feed.postgate",
          ...params
        });
        return res.data;
      }
      async create(params, record2, headers) {
        const collection = "app.bsky.feed.postgate";
        const res = await this._client.call("com.atproto.repo.createRecord", void 0, { collection, ...params, record: { ...record2, $type: collection } }, { encoding: "application/json", headers });
        return res.data;
      }
      async delete(params, headers) {
        await this._client.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.feed.postgate", ...params }, { headers });
      }
    }
    client$1.PostgateRecord = PostgateRecord;
    class RepostRecord {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
      }
      async list(params) {
        const res = await this._client.call("com.atproto.repo.listRecords", {
          collection: "app.bsky.feed.repost",
          ...params
        });
        return res.data;
      }
      async get(params) {
        const res = await this._client.call("com.atproto.repo.getRecord", {
          collection: "app.bsky.feed.repost",
          ...params
        });
        return res.data;
      }
      async create(params, record2, headers) {
        const collection = "app.bsky.feed.repost";
        const res = await this._client.call("com.atproto.repo.createRecord", void 0, { collection, ...params, record: { ...record2, $type: collection } }, { encoding: "application/json", headers });
        return res.data;
      }
      async delete(params, headers) {
        await this._client.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.feed.repost", ...params }, { headers });
      }
    }
    client$1.RepostRecord = RepostRecord;
    class ThreadgateRecord {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
      }
      async list(params) {
        const res = await this._client.call("com.atproto.repo.listRecords", {
          collection: "app.bsky.feed.threadgate",
          ...params
        });
        return res.data;
      }
      async get(params) {
        const res = await this._client.call("com.atproto.repo.getRecord", {
          collection: "app.bsky.feed.threadgate",
          ...params
        });
        return res.data;
      }
      async create(params, record2, headers) {
        const collection = "app.bsky.feed.threadgate";
        const res = await this._client.call("com.atproto.repo.createRecord", void 0, { collection, ...params, record: { ...record2, $type: collection } }, { encoding: "application/json", headers });
        return res.data;
      }
      async delete(params, headers) {
        await this._client.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.feed.threadgate", ...params }, { headers });
      }
    }
    client$1.ThreadgateRecord = ThreadgateRecord;
    class AppBskyGraphNS {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "block", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "follow", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "list", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "listblock", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "listitem", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "starterpack", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
        this.block = new BlockRecord(client2);
        this.follow = new FollowRecord(client2);
        this.list = new ListRecord(client2);
        this.listblock = new ListblockRecord(client2);
        this.listitem = new ListitemRecord(client2);
        this.starterpack = new StarterpackRecord(client2);
      }
      getActorStarterPacks(params, opts) {
        return this._client.call("app.bsky.graph.getActorStarterPacks", params, void 0, opts);
      }
      getBlocks(params, opts) {
        return this._client.call("app.bsky.graph.getBlocks", params, void 0, opts);
      }
      getFollowers(params, opts) {
        return this._client.call("app.bsky.graph.getFollowers", params, void 0, opts);
      }
      getFollows(params, opts) {
        return this._client.call("app.bsky.graph.getFollows", params, void 0, opts);
      }
      getKnownFollowers(params, opts) {
        return this._client.call("app.bsky.graph.getKnownFollowers", params, void 0, opts);
      }
      getList(params, opts) {
        return this._client.call("app.bsky.graph.getList", params, void 0, opts);
      }
      getListBlocks(params, opts) {
        return this._client.call("app.bsky.graph.getListBlocks", params, void 0, opts);
      }
      getListMutes(params, opts) {
        return this._client.call("app.bsky.graph.getListMutes", params, void 0, opts);
      }
      getLists(params, opts) {
        return this._client.call("app.bsky.graph.getLists", params, void 0, opts);
      }
      getMutes(params, opts) {
        return this._client.call("app.bsky.graph.getMutes", params, void 0, opts);
      }
      getRelationships(params, opts) {
        return this._client.call("app.bsky.graph.getRelationships", params, void 0, opts).catch((e) => {
          throw AppBskyGraphGetRelationships.toKnownErr(e);
        });
      }
      getStarterPack(params, opts) {
        return this._client.call("app.bsky.graph.getStarterPack", params, void 0, opts);
      }
      getStarterPacks(params, opts) {
        return this._client.call("app.bsky.graph.getStarterPacks", params, void 0, opts);
      }
      getSuggestedFollowsByActor(params, opts) {
        return this._client.call("app.bsky.graph.getSuggestedFollowsByActor", params, void 0, opts);
      }
      muteActor(data, opts) {
        return this._client.call("app.bsky.graph.muteActor", opts?.qp, data, opts);
      }
      muteActorList(data, opts) {
        return this._client.call("app.bsky.graph.muteActorList", opts?.qp, data, opts);
      }
      muteThread(data, opts) {
        return this._client.call("app.bsky.graph.muteThread", opts?.qp, data, opts);
      }
      searchStarterPacks(params, opts) {
        return this._client.call("app.bsky.graph.searchStarterPacks", params, void 0, opts);
      }
      unmuteActor(data, opts) {
        return this._client.call("app.bsky.graph.unmuteActor", opts?.qp, data, opts);
      }
      unmuteActorList(data, opts) {
        return this._client.call("app.bsky.graph.unmuteActorList", opts?.qp, data, opts);
      }
      unmuteThread(data, opts) {
        return this._client.call("app.bsky.graph.unmuteThread", opts?.qp, data, opts);
      }
    }
    client$1.AppBskyGraphNS = AppBskyGraphNS;
    class BlockRecord {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
      }
      async list(params) {
        const res = await this._client.call("com.atproto.repo.listRecords", {
          collection: "app.bsky.graph.block",
          ...params
        });
        return res.data;
      }
      async get(params) {
        const res = await this._client.call("com.atproto.repo.getRecord", {
          collection: "app.bsky.graph.block",
          ...params
        });
        return res.data;
      }
      async create(params, record2, headers) {
        const collection = "app.bsky.graph.block";
        const res = await this._client.call("com.atproto.repo.createRecord", void 0, { collection, ...params, record: { ...record2, $type: collection } }, { encoding: "application/json", headers });
        return res.data;
      }
      async delete(params, headers) {
        await this._client.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.graph.block", ...params }, { headers });
      }
    }
    client$1.BlockRecord = BlockRecord;
    class FollowRecord {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
      }
      async list(params) {
        const res = await this._client.call("com.atproto.repo.listRecords", {
          collection: "app.bsky.graph.follow",
          ...params
        });
        return res.data;
      }
      async get(params) {
        const res = await this._client.call("com.atproto.repo.getRecord", {
          collection: "app.bsky.graph.follow",
          ...params
        });
        return res.data;
      }
      async create(params, record2, headers) {
        const collection = "app.bsky.graph.follow";
        const res = await this._client.call("com.atproto.repo.createRecord", void 0, { collection, ...params, record: { ...record2, $type: collection } }, { encoding: "application/json", headers });
        return res.data;
      }
      async delete(params, headers) {
        await this._client.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.graph.follow", ...params }, { headers });
      }
    }
    client$1.FollowRecord = FollowRecord;
    class ListRecord {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
      }
      async list(params) {
        const res = await this._client.call("com.atproto.repo.listRecords", {
          collection: "app.bsky.graph.list",
          ...params
        });
        return res.data;
      }
      async get(params) {
        const res = await this._client.call("com.atproto.repo.getRecord", {
          collection: "app.bsky.graph.list",
          ...params
        });
        return res.data;
      }
      async create(params, record2, headers) {
        const collection = "app.bsky.graph.list";
        const res = await this._client.call("com.atproto.repo.createRecord", void 0, { collection, ...params, record: { ...record2, $type: collection } }, { encoding: "application/json", headers });
        return res.data;
      }
      async delete(params, headers) {
        await this._client.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.graph.list", ...params }, { headers });
      }
    }
    client$1.ListRecord = ListRecord;
    class ListblockRecord {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
      }
      async list(params) {
        const res = await this._client.call("com.atproto.repo.listRecords", {
          collection: "app.bsky.graph.listblock",
          ...params
        });
        return res.data;
      }
      async get(params) {
        const res = await this._client.call("com.atproto.repo.getRecord", {
          collection: "app.bsky.graph.listblock",
          ...params
        });
        return res.data;
      }
      async create(params, record2, headers) {
        const collection = "app.bsky.graph.listblock";
        const res = await this._client.call("com.atproto.repo.createRecord", void 0, { collection, ...params, record: { ...record2, $type: collection } }, { encoding: "application/json", headers });
        return res.data;
      }
      async delete(params, headers) {
        await this._client.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.graph.listblock", ...params }, { headers });
      }
    }
    client$1.ListblockRecord = ListblockRecord;
    class ListitemRecord {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
      }
      async list(params) {
        const res = await this._client.call("com.atproto.repo.listRecords", {
          collection: "app.bsky.graph.listitem",
          ...params
        });
        return res.data;
      }
      async get(params) {
        const res = await this._client.call("com.atproto.repo.getRecord", {
          collection: "app.bsky.graph.listitem",
          ...params
        });
        return res.data;
      }
      async create(params, record2, headers) {
        const collection = "app.bsky.graph.listitem";
        const res = await this._client.call("com.atproto.repo.createRecord", void 0, { collection, ...params, record: { ...record2, $type: collection } }, { encoding: "application/json", headers });
        return res.data;
      }
      async delete(params, headers) {
        await this._client.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.graph.listitem", ...params }, { headers });
      }
    }
    client$1.ListitemRecord = ListitemRecord;
    class StarterpackRecord {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
      }
      async list(params) {
        const res = await this._client.call("com.atproto.repo.listRecords", {
          collection: "app.bsky.graph.starterpack",
          ...params
        });
        return res.data;
      }
      async get(params) {
        const res = await this._client.call("com.atproto.repo.getRecord", {
          collection: "app.bsky.graph.starterpack",
          ...params
        });
        return res.data;
      }
      async create(params, record2, headers) {
        const collection = "app.bsky.graph.starterpack";
        const res = await this._client.call("com.atproto.repo.createRecord", void 0, { collection, ...params, record: { ...record2, $type: collection } }, { encoding: "application/json", headers });
        return res.data;
      }
      async delete(params, headers) {
        await this._client.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.graph.starterpack", ...params }, { headers });
      }
    }
    client$1.StarterpackRecord = StarterpackRecord;
    class AppBskyLabelerNS {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "service", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
        this.service = new ServiceRecord(client2);
      }
      getServices(params, opts) {
        return this._client.call("app.bsky.labeler.getServices", params, void 0, opts);
      }
    }
    client$1.AppBskyLabelerNS = AppBskyLabelerNS;
    class ServiceRecord {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
      }
      async list(params) {
        const res = await this._client.call("com.atproto.repo.listRecords", {
          collection: "app.bsky.labeler.service",
          ...params
        });
        return res.data;
      }
      async get(params) {
        const res = await this._client.call("com.atproto.repo.getRecord", {
          collection: "app.bsky.labeler.service",
          ...params
        });
        return res.data;
      }
      async create(params, record2, headers) {
        const collection = "app.bsky.labeler.service";
        const res = await this._client.call("com.atproto.repo.createRecord", void 0, {
          collection,
          rkey: "self",
          ...params,
          record: { ...record2, $type: collection }
        }, { encoding: "application/json", headers });
        return res.data;
      }
      async delete(params, headers) {
        await this._client.call("com.atproto.repo.deleteRecord", void 0, { collection: "app.bsky.labeler.service", ...params }, { headers });
      }
    }
    client$1.ServiceRecord = ServiceRecord;
    class AppBskyNotificationNS {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
      }
      getUnreadCount(params, opts) {
        return this._client.call("app.bsky.notification.getUnreadCount", params, void 0, opts);
      }
      listNotifications(params, opts) {
        return this._client.call("app.bsky.notification.listNotifications", params, void 0, opts);
      }
      putPreferences(data, opts) {
        return this._client.call("app.bsky.notification.putPreferences", opts?.qp, data, opts);
      }
      registerPush(data, opts) {
        return this._client.call("app.bsky.notification.registerPush", opts?.qp, data, opts);
      }
      updateSeen(data, opts) {
        return this._client.call("app.bsky.notification.updateSeen", opts?.qp, data, opts);
      }
    }
    client$1.AppBskyNotificationNS = AppBskyNotificationNS;
    class AppBskyRichtextNS {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
      }
    }
    client$1.AppBskyRichtextNS = AppBskyRichtextNS;
    class AppBskyUnspeccedNS {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
      }
      getConfig(params, opts) {
        return this._client.call("app.bsky.unspecced.getConfig", params, void 0, opts);
      }
      getPopularFeedGenerators(params, opts) {
        return this._client.call("app.bsky.unspecced.getPopularFeedGenerators", params, void 0, opts);
      }
      getSuggestionsSkeleton(params, opts) {
        return this._client.call("app.bsky.unspecced.getSuggestionsSkeleton", params, void 0, opts);
      }
      getTaggedSuggestions(params, opts) {
        return this._client.call("app.bsky.unspecced.getTaggedSuggestions", params, void 0, opts);
      }
      getTrendingTopics(params, opts) {
        return this._client.call("app.bsky.unspecced.getTrendingTopics", params, void 0, opts);
      }
      searchActorsSkeleton(params, opts) {
        return this._client.call("app.bsky.unspecced.searchActorsSkeleton", params, void 0, opts).catch((e) => {
          throw AppBskyUnspeccedSearchActorsSkeleton.toKnownErr(e);
        });
      }
      searchPostsSkeleton(params, opts) {
        return this._client.call("app.bsky.unspecced.searchPostsSkeleton", params, void 0, opts).catch((e) => {
          throw AppBskyUnspeccedSearchPostsSkeleton.toKnownErr(e);
        });
      }
      searchStarterPacksSkeleton(params, opts) {
        return this._client.call("app.bsky.unspecced.searchStarterPacksSkeleton", params, void 0, opts).catch((e) => {
          throw AppBskyUnspeccedSearchStarterPacksSkeleton.toKnownErr(e);
        });
      }
    }
    client$1.AppBskyUnspeccedNS = AppBskyUnspeccedNS;
    class AppBskyVideoNS {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
      }
      getJobStatus(params, opts) {
        return this._client.call("app.bsky.video.getJobStatus", params, void 0, opts);
      }
      getUploadLimits(params, opts) {
        return this._client.call("app.bsky.video.getUploadLimits", params, void 0, opts);
      }
      uploadVideo(data, opts) {
        return this._client.call("app.bsky.video.uploadVideo", opts?.qp, data, opts);
      }
    }
    client$1.AppBskyVideoNS = AppBskyVideoNS;
    class ChatNS {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "bsky", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
        this.bsky = new ChatBskyNS(client2);
      }
    }
    client$1.ChatNS = ChatNS;
    class ChatBskyNS {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "actor", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "convo", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "moderation", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
        this.actor = new ChatBskyActorNS(client2);
        this.convo = new ChatBskyConvoNS(client2);
        this.moderation = new ChatBskyModerationNS(client2);
      }
    }
    client$1.ChatBskyNS = ChatBskyNS;
    class ChatBskyActorNS {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "declaration", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
        this.declaration = new DeclarationRecord(client2);
      }
      deleteAccount(data, opts) {
        return this._client.call("chat.bsky.actor.deleteAccount", opts?.qp, data, opts);
      }
      exportAccountData(params, opts) {
        return this._client.call("chat.bsky.actor.exportAccountData", params, void 0, opts);
      }
    }
    client$1.ChatBskyActorNS = ChatBskyActorNS;
    class DeclarationRecord {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
      }
      async list(params) {
        const res = await this._client.call("com.atproto.repo.listRecords", {
          collection: "chat.bsky.actor.declaration",
          ...params
        });
        return res.data;
      }
      async get(params) {
        const res = await this._client.call("com.atproto.repo.getRecord", {
          collection: "chat.bsky.actor.declaration",
          ...params
        });
        return res.data;
      }
      async create(params, record2, headers) {
        const collection = "chat.bsky.actor.declaration";
        const res = await this._client.call("com.atproto.repo.createRecord", void 0, {
          collection,
          rkey: "self",
          ...params,
          record: { ...record2, $type: collection }
        }, { encoding: "application/json", headers });
        return res.data;
      }
      async delete(params, headers) {
        await this._client.call("com.atproto.repo.deleteRecord", void 0, { collection: "chat.bsky.actor.declaration", ...params }, { headers });
      }
    }
    client$1.DeclarationRecord = DeclarationRecord;
    class ChatBskyConvoNS {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
      }
      deleteMessageForSelf(data, opts) {
        return this._client.call("chat.bsky.convo.deleteMessageForSelf", opts?.qp, data, opts);
      }
      getConvo(params, opts) {
        return this._client.call("chat.bsky.convo.getConvo", params, void 0, opts);
      }
      getConvoForMembers(params, opts) {
        return this._client.call("chat.bsky.convo.getConvoForMembers", params, void 0, opts);
      }
      getLog(params, opts) {
        return this._client.call("chat.bsky.convo.getLog", params, void 0, opts);
      }
      getMessages(params, opts) {
        return this._client.call("chat.bsky.convo.getMessages", params, void 0, opts);
      }
      leaveConvo(data, opts) {
        return this._client.call("chat.bsky.convo.leaveConvo", opts?.qp, data, opts);
      }
      listConvos(params, opts) {
        return this._client.call("chat.bsky.convo.listConvos", params, void 0, opts);
      }
      muteConvo(data, opts) {
        return this._client.call("chat.bsky.convo.muteConvo", opts?.qp, data, opts);
      }
      sendMessage(data, opts) {
        return this._client.call("chat.bsky.convo.sendMessage", opts?.qp, data, opts);
      }
      sendMessageBatch(data, opts) {
        return this._client.call("chat.bsky.convo.sendMessageBatch", opts?.qp, data, opts);
      }
      unmuteConvo(data, opts) {
        return this._client.call("chat.bsky.convo.unmuteConvo", opts?.qp, data, opts);
      }
      updateRead(data, opts) {
        return this._client.call("chat.bsky.convo.updateRead", opts?.qp, data, opts);
      }
    }
    client$1.ChatBskyConvoNS = ChatBskyConvoNS;
    class ChatBskyModerationNS {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
      }
      getActorMetadata(params, opts) {
        return this._client.call("chat.bsky.moderation.getActorMetadata", params, void 0, opts);
      }
      getMessageContext(params, opts) {
        return this._client.call("chat.bsky.moderation.getMessageContext", params, void 0, opts);
      }
      updateActorAccess(data, opts) {
        return this._client.call("chat.bsky.moderation.updateActorAccess", opts?.qp, data, opts);
      }
    }
    client$1.ChatBskyModerationNS = ChatBskyModerationNS;
    class ToolsNS {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "ozone", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
        this.ozone = new ToolsOzoneNS(client2);
      }
    }
    client$1.ToolsNS = ToolsNS;
    class ToolsOzoneNS {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "communication", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "moderation", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "server", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "set", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "setting", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "signature", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "team", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
        this.communication = new ToolsOzoneCommunicationNS(client2);
        this.moderation = new ToolsOzoneModerationNS(client2);
        this.server = new ToolsOzoneServerNS(client2);
        this.set = new ToolsOzoneSetNS(client2);
        this.setting = new ToolsOzoneSettingNS(client2);
        this.signature = new ToolsOzoneSignatureNS(client2);
        this.team = new ToolsOzoneTeamNS(client2);
      }
    }
    client$1.ToolsOzoneNS = ToolsOzoneNS;
    class ToolsOzoneCommunicationNS {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
      }
      createTemplate(data, opts) {
        return this._client.call("tools.ozone.communication.createTemplate", opts?.qp, data, opts).catch((e) => {
          throw ToolsOzoneCommunicationCreateTemplate.toKnownErr(e);
        });
      }
      deleteTemplate(data, opts) {
        return this._client.call("tools.ozone.communication.deleteTemplate", opts?.qp, data, opts);
      }
      listTemplates(params, opts) {
        return this._client.call("tools.ozone.communication.listTemplates", params, void 0, opts);
      }
      updateTemplate(data, opts) {
        return this._client.call("tools.ozone.communication.updateTemplate", opts?.qp, data, opts).catch((e) => {
          throw ToolsOzoneCommunicationUpdateTemplate.toKnownErr(e);
        });
      }
    }
    client$1.ToolsOzoneCommunicationNS = ToolsOzoneCommunicationNS;
    class ToolsOzoneModerationNS {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
      }
      emitEvent(data, opts) {
        return this._client.call("tools.ozone.moderation.emitEvent", opts?.qp, data, opts).catch((e) => {
          throw ToolsOzoneModerationEmitEvent.toKnownErr(e);
        });
      }
      getEvent(params, opts) {
        return this._client.call("tools.ozone.moderation.getEvent", params, void 0, opts);
      }
      getRecord(params, opts) {
        return this._client.call("tools.ozone.moderation.getRecord", params, void 0, opts).catch((e) => {
          throw ToolsOzoneModerationGetRecord.toKnownErr(e);
        });
      }
      getRecords(params, opts) {
        return this._client.call("tools.ozone.moderation.getRecords", params, void 0, opts);
      }
      getRepo(params, opts) {
        return this._client.call("tools.ozone.moderation.getRepo", params, void 0, opts).catch((e) => {
          throw ToolsOzoneModerationGetRepo.toKnownErr(e);
        });
      }
      getRepos(params, opts) {
        return this._client.call("tools.ozone.moderation.getRepos", params, void 0, opts);
      }
      queryEvents(params, opts) {
        return this._client.call("tools.ozone.moderation.queryEvents", params, void 0, opts);
      }
      queryStatuses(params, opts) {
        return this._client.call("tools.ozone.moderation.queryStatuses", params, void 0, opts);
      }
      searchRepos(params, opts) {
        return this._client.call("tools.ozone.moderation.searchRepos", params, void 0, opts);
      }
    }
    client$1.ToolsOzoneModerationNS = ToolsOzoneModerationNS;
    class ToolsOzoneServerNS {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
      }
      getConfig(params, opts) {
        return this._client.call("tools.ozone.server.getConfig", params, void 0, opts);
      }
    }
    client$1.ToolsOzoneServerNS = ToolsOzoneServerNS;
    class ToolsOzoneSetNS {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
      }
      addValues(data, opts) {
        return this._client.call("tools.ozone.set.addValues", opts?.qp, data, opts);
      }
      deleteSet(data, opts) {
        return this._client.call("tools.ozone.set.deleteSet", opts?.qp, data, opts).catch((e) => {
          throw ToolsOzoneSetDeleteSet.toKnownErr(e);
        });
      }
      deleteValues(data, opts) {
        return this._client.call("tools.ozone.set.deleteValues", opts?.qp, data, opts).catch((e) => {
          throw ToolsOzoneSetDeleteValues.toKnownErr(e);
        });
      }
      getValues(params, opts) {
        return this._client.call("tools.ozone.set.getValues", params, void 0, opts).catch((e) => {
          throw ToolsOzoneSetGetValues.toKnownErr(e);
        });
      }
      querySets(params, opts) {
        return this._client.call("tools.ozone.set.querySets", params, void 0, opts);
      }
      upsertSet(data, opts) {
        return this._client.call("tools.ozone.set.upsertSet", opts?.qp, data, opts);
      }
    }
    client$1.ToolsOzoneSetNS = ToolsOzoneSetNS;
    class ToolsOzoneSettingNS {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
      }
      listOptions(params, opts) {
        return this._client.call("tools.ozone.setting.listOptions", params, void 0, opts);
      }
      removeOptions(data, opts) {
        return this._client.call("tools.ozone.setting.removeOptions", opts?.qp, data, opts);
      }
      upsertOption(data, opts) {
        return this._client.call("tools.ozone.setting.upsertOption", opts?.qp, data, opts);
      }
    }
    client$1.ToolsOzoneSettingNS = ToolsOzoneSettingNS;
    class ToolsOzoneSignatureNS {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
      }
      findCorrelation(params, opts) {
        return this._client.call("tools.ozone.signature.findCorrelation", params, void 0, opts);
      }
      findRelatedAccounts(params, opts) {
        return this._client.call("tools.ozone.signature.findRelatedAccounts", params, void 0, opts);
      }
      searchAccounts(params, opts) {
        return this._client.call("tools.ozone.signature.searchAccounts", params, void 0, opts);
      }
    }
    client$1.ToolsOzoneSignatureNS = ToolsOzoneSignatureNS;
    class ToolsOzoneTeamNS {
      constructor(client2) {
        Object.defineProperty(this, "_client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this._client = client2;
      }
      addMember(data, opts) {
        return this._client.call("tools.ozone.team.addMember", opts?.qp, data, opts).catch((e) => {
          throw ToolsOzoneTeamAddMember.toKnownErr(e);
        });
      }
      deleteMember(data, opts) {
        return this._client.call("tools.ozone.team.deleteMember", opts?.qp, data, opts).catch((e) => {
          throw ToolsOzoneTeamDeleteMember.toKnownErr(e);
        });
      }
      listMembers(params, opts) {
        return this._client.call("tools.ozone.team.listMembers", params, void 0, opts);
      }
      updateMember(data, opts) {
        return this._client.call("tools.ozone.team.updateMember", opts?.qp, data, opts).catch((e) => {
          throw ToolsOzoneTeamUpdateMember.toKnownErr(e);
        });
      }
    }
    client$1.ToolsOzoneTeamNS = ToolsOzoneTeamNS;
    return client$1;
  }
  var richText = {};
  var detection = {};
  const require$$0 = /* @__PURE__ */ JSON.parse('["aaa","aarp","abb","abbott","abbvie","abc","able","abogado","abudhabi","ac","academy","accenture","accountant","accountants","aco","actor","ad","ads","adult","ae","aeg","aero","aetna","af","afl","africa","ag","agakhan","agency","ai","aig","airbus","airforce","airtel","akdn","al","alibaba","alipay","allfinanz","allstate","ally","alsace","alstom","am","amazon","americanexpress","americanfamily","amex","amfam","amica","amsterdam","analytics","android","anquan","anz","ao","aol","apartments","app","apple","aq","aquarelle","ar","arab","aramco","archi","army","arpa","art","arte","as","asda","asia","associates","at","athleta","attorney","au","auction","audi","audible","audio","auspost","author","auto","autos","aw","aws","ax","axa","az","azure","ba","baby","baidu","banamex","band","bank","bar","barcelona","barclaycard","barclays","barefoot","bargains","baseball","basketball","bauhaus","bayern","bb","bbc","bbt","bbva","bcg","bcn","bd","be","beats","beauty","beer","bentley","berlin","best","bestbuy","bet","bf","bg","bh","bharti","bi","bible","bid","bike","bing","bingo","bio","biz","bj","black","blackfriday","blockbuster","blog","bloomberg","blue","bm","bms","bmw","bn","bnpparibas","bo","boats","boehringer","bofa","bom","bond","boo","book","booking","bosch","bostik","boston","bot","boutique","box","br","bradesco","bridgestone","broadway","broker","brother","brussels","bs","bt","build","builders","business","buy","buzz","bv","bw","by","bz","bzh","ca","cab","cafe","cal","call","calvinklein","cam","camera","camp","canon","capetown","capital","capitalone","car","caravan","cards","care","career","careers","cars","casa","case","cash","casino","cat","catering","catholic","cba","cbn","cbre","cc","cd","center","ceo","cern","cf","cfa","cfd","cg","ch","chanel","channel","charity","chase","chat","cheap","chintai","christmas","chrome","church","ci","cipriani","circle","cisco","citadel","citi","citic","city","ck","cl","claims","cleaning","click","clinic","clinique","clothing","cloud","club","clubmed","cm","cn","co","coach","codes","coffee","college","cologne","com","commbank","community","company","compare","computer","comsec","condos","construction","consulting","contact","contractors","cooking","cool","coop","corsica","country","coupon","coupons","courses","cpa","cr","credit","creditcard","creditunion","cricket","crown","crs","cruise","cruises","cu","cuisinella","cv","cw","cx","cy","cymru","cyou","cz","dad","dance","data","date","dating","datsun","day","dclk","dds","de","deal","dealer","deals","degree","delivery","dell","deloitte","delta","democrat","dental","dentist","desi","design","dev","dhl","diamonds","diet","digital","direct","directory","discount","discover","dish","diy","dj","dk","dm","dnp","do","docs","doctor","dog","domains","dot","download","drive","dtv","dubai","dunlop","dupont","durban","dvag","dvr","dz","earth","eat","ec","eco","edeka","edu","education","ee","eg","email","emerck","energy","engineer","engineering","enterprises","epson","equipment","er","ericsson","erni","es","esq","estate","et","eu","eurovision","eus","events","exchange","expert","exposed","express","extraspace","fage","fail","fairwinds","faith","family","fan","fans","farm","farmers","fashion","fast","fedex","feedback","ferrari","ferrero","fi","fidelity","fido","film","final","finance","financial","fire","firestone","firmdale","fish","fishing","fit","fitness","fj","fk","flickr","flights","flir","florist","flowers","fly","fm","fo","foo","food","football","ford","forex","forsale","forum","foundation","fox","fr","free","fresenius","frl","frogans","frontier","ftr","fujitsu","fun","fund","furniture","futbol","fyi","ga","gal","gallery","gallo","gallup","game","games","gap","garden","gay","gb","gbiz","gd","gdn","ge","gea","gent","genting","george","gf","gg","ggee","gh","gi","gift","gifts","gives","giving","gl","glass","gle","global","globo","gm","gmail","gmbh","gmo","gmx","gn","godaddy","gold","goldpoint","golf","goo","goodyear","goog","google","gop","got","gov","gp","gq","gr","grainger","graphics","gratis","green","gripe","grocery","group","gs","gt","gu","gucci","guge","guide","guitars","guru","gw","gy","hair","hamburg","hangout","haus","hbo","hdfc","hdfcbank","health","healthcare","help","helsinki","here","hermes","hiphop","hisamitsu","hitachi","hiv","hk","hkt","hm","hn","hockey","holdings","holiday","homedepot","homegoods","homes","homesense","honda","horse","hospital","host","hosting","hot","hotels","hotmail","house","how","hr","hsbc","ht","hu","hughes","hyatt","hyundai","ibm","icbc","ice","icu","id","ie","ieee","ifm","ikano","il","im","imamat","imdb","immo","immobilien","in","inc","industries","infiniti","info","ing","ink","institute","insurance","insure","int","international","intuit","investments","io","ipiranga","iq","ir","irish","is","ismaili","ist","istanbul","it","itau","itv","jaguar","java","jcb","je","jeep","jetzt","jewelry","jio","jll","jm","jmp","jnj","jo","jobs","joburg","jot","joy","jp","jpmorgan","jprs","juegos","juniper","kaufen","kddi","ke","kerryhotels","kerrylogistics","kerryproperties","kfh","kg","kh","ki","kia","kids","kim","kindle","kitchen","kiwi","km","kn","koeln","komatsu","kosher","kp","kpmg","kpn","kr","krd","kred","kuokgroup","kw","ky","kyoto","kz","la","lacaixa","lamborghini","lamer","lancaster","land","landrover","lanxess","lasalle","lat","latino","latrobe","law","lawyer","lb","lc","lds","lease","leclerc","lefrak","legal","lego","lexus","lgbt","li","lidl","life","lifeinsurance","lifestyle","lighting","like","lilly","limited","limo","lincoln","link","lipsy","live","living","lk","llc","llp","loan","loans","locker","locus","lol","london","lotte","lotto","love","lpl","lplfinancial","lr","ls","lt","ltd","ltda","lu","lundbeck","luxe","luxury","lv","ly","ma","madrid","maif","maison","makeup","man","management","mango","map","market","marketing","markets","marriott","marshalls","mattel","mba","mc","mckinsey","md","me","med","media","meet","melbourne","meme","memorial","men","menu","merckmsd","mg","mh","miami","microsoft","mil","mini","mint","mit","mitsubishi","mk","ml","mlb","mls","mm","mma","mn","mo","mobi","mobile","moda","moe","moi","mom","monash","money","monster","mormon","mortgage","moscow","moto","motorcycles","mov","movie","mp","mq","mr","ms","msd","mt","mtn","mtr","mu","museum","music","mv","mw","mx","my","mz","na","nab","nagoya","name","navy","nba","nc","ne","nec","net","netbank","netflix","network","neustar","new","news","next","nextdirect","nexus","nf","nfl","ng","ngo","nhk","ni","nico","nike","nikon","ninja","nissan","nissay","nl","no","nokia","norton","now","nowruz","nowtv","np","nr","nra","nrw","ntt","nu","nyc","nz","obi","observer","office","okinawa","olayan","olayangroup","ollo","om","omega","one","ong","onl","online","ooo","open","oracle","orange","org","organic","origins","osaka","otsuka","ott","ovh","pa","page","panasonic","paris","pars","partners","parts","party","pay","pccw","pe","pet","pf","pfizer","pg","ph","pharmacy","phd","philips","phone","photo","photography","photos","physio","pics","pictet","pictures","pid","pin","ping","pink","pioneer","pizza","pk","pl","place","play","playstation","plumbing","plus","pm","pn","pnc","pohl","poker","politie","porn","post","pr","pramerica","praxi","press","prime","pro","prod","productions","prof","progressive","promo","properties","property","protection","pru","prudential","ps","pt","pub","pw","pwc","py","qa","qpon","quebec","quest","racing","radio","re","read","realestate","realtor","realty","recipes","red","redstone","redumbrella","rehab","reise","reisen","reit","reliance","ren","rent","rentals","repair","report","republican","rest","restaurant","review","reviews","rexroth","rich","richardli","ricoh","ril","rio","rip","ro","rocks","rodeo","rogers","room","rs","rsvp","ru","rugby","ruhr","run","rw","rwe","ryukyu","sa","saarland","safe","safety","sakura","sale","salon","samsclub","samsung","sandvik","sandvikcoromant","sanofi","sap","sarl","sas","save","saxo","sb","sbi","sbs","sc","scb","schaeffler","schmidt","scholarships","school","schule","schwarz","science","scot","sd","se","search","seat","secure","security","seek","select","sener","services","seven","sew","sex","sexy","sfr","sg","sh","shangrila","sharp","shell","shia","shiksha","shoes","shop","shopping","shouji","show","si","silk","sina","singles","site","sj","sk","ski","skin","sky","skype","sl","sling","sm","smart","smile","sn","sncf","so","soccer","social","softbank","software","sohu","solar","solutions","song","sony","soy","spa","space","sport","spot","sr","srl","ss","st","stada","staples","star","statebank","statefarm","stc","stcgroup","stockholm","storage","store","stream","studio","study","style","su","sucks","supplies","supply","support","surf","surgery","suzuki","sv","swatch","swiss","sx","sy","sydney","systems","sz","tab","taipei","talk","taobao","target","tatamotors","tatar","tattoo","tax","taxi","tc","tci","td","tdk","team","tech","technology","tel","temasek","tennis","teva","tf","tg","th","thd","theater","theatre","tiaa","tickets","tienda","tips","tires","tirol","tj","tjmaxx","tjx","tk","tkmaxx","tl","tm","tmall","tn","to","today","tokyo","tools","top","toray","toshiba","total","tours","town","toyota","toys","tr","trade","trading","training","travel","travelers","travelersinsurance","trust","trv","tt","tube","tui","tunes","tushu","tv","tvs","tw","tz","ua","ubank","ubs","ug","uk","unicom","university","uno","uol","ups","us","uy","uz","va","vacations","vana","vanguard","vc","ve","vegas","ventures","verisign","verm\xF6gensberater","verm\xF6gensberatung","versicherung","vet","vg","vi","viajes","video","vig","viking","villas","vin","vip","virgin","visa","vision","viva","vivo","vlaanderen","vn","vodka","volvo","vote","voting","voto","voyage","vu","wales","walmart","walter","wang","wanggou","watch","watches","weather","weatherchannel","webcam","weber","website","wed","wedding","weibo","weir","wf","whoswho","wien","wiki","williamhill","win","windows","wine","winners","wme","wolterskluwer","woodside","work","works","world","wow","ws","wtc","wtf","xbox","xerox","xihuan","xin","xxx","xyz","yachts","yahoo","yamaxun","yandex","ye","yodobashi","yoga","yokohama","you","youtube","yt","yun","za","zappos","zara","zero","zip","zm","zone","zuerich","zw","\u03B5\u03BB","\u03B5\u03C5","\u0431\u0433","\u0431\u0435\u043B","\u0434\u0435\u0442\u0438","\u0435\u044E","\u043A\u0430\u0442\u043E\u043B\u0438\u043A","\u043A\u043E\u043C","\u043C\u043A\u0434","\u043C\u043E\u043D","\u043C\u043E\u0441\u043A\u0432\u0430","\u043E\u043D\u043B\u0430\u0439\u043D","\u043E\u0440\u0433","\u0440\u0443\u0441","\u0440\u0444","\u0441\u0430\u0439\u0442","\u0441\u0440\u0431","\u0443\u043A\u0440","\u049B\u0430\u0437","\u0570\u0561\u0575","\u05D9\u05E9\u05E8\u05D0\u05DC","\u05E7\u05D5\u05DD","\u0627\u0628\u0648\u0638\u0628\u064A","\u0627\u0631\u0627\u0645\u0643\u0648","\u0627\u0644\u0627\u0631\u062F\u0646","\u0627\u0644\u0628\u062D\u0631\u064A\u0646","\u0627\u0644\u062C\u0632\u0627\u0626\u0631","\u0627\u0644\u0633\u0639\u0648\u062F\u064A\u0629","\u0627\u0644\u0639\u0644\u064A\u0627\u0646","\u0627\u0644\u0645\u063A\u0631\u0628","\u0627\u0645\u0627\u0631\u0627\u062A","\u0627\u06CC\u0631\u0627\u0646","\u0628\u0627\u0631\u062A","\u0628\u0627\u0632\u0627\u0631","\u0628\u064A\u062A\u0643","\u0628\u06BE\u0627\u0631\u062A","\u062A\u0648\u0646\u0633","\u0633\u0648\u062F\u0627\u0646","\u0633\u0648\u0631\u064A\u0629","\u0634\u0628\u0643\u0629","\u0639\u0631\u0627\u0642","\u0639\u0631\u0628","\u0639\u0645\u0627\u0646","\u0641\u0644\u0633\u0637\u064A\u0646","\u0642\u0637\u0631","\u0643\u0627\u062B\u0648\u0644\u064A\u0643","\u0643\u0648\u0645","\u0645\u0635\u0631","\u0645\u0644\u064A\u0633\u064A\u0627","\u0645\u0648\u0631\u064A\u062A\u0627\u0646\u064A\u0627","\u0645\u0648\u0642\u0639","\u0647\u0645\u0631\u0627\u0647","\u067E\u0627\u06A9\u0633\u062A\u0627\u0646","\u0680\u0627\u0631\u062A","\u0915\u0949\u092E","\u0928\u0947\u091F","\u092D\u093E\u0930\u0924","\u092D\u093E\u0930\u0924\u092E\u094D","\u092D\u093E\u0930\u094B\u0924","\u0938\u0902\u0917\u0920\u0928","\u09AC\u09BE\u0982\u09B2\u09BE","\u09AD\u09BE\u09B0\u09A4","\u09AD\u09BE\u09F0\u09A4","\u0A2D\u0A3E\u0A30\u0A24","\u0AAD\u0ABE\u0AB0\u0AA4","\u0B2D\u0B3E\u0B30\u0B24","\u0B87\u0BA8\u0BCD\u0BA4\u0BBF\u0BAF\u0BBE","\u0B87\u0BB2\u0B99\u0BCD\u0B95\u0BC8","\u0B9A\u0BBF\u0B99\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0BC2\u0BB0\u0BCD","\u0C2D\u0C3E\u0C30\u0C24\u0C4D","\u0CAD\u0CBE\u0CB0\u0CA4","\u0D2D\u0D3E\u0D30\u0D24\u0D02","\u0DBD\u0D82\u0D9A\u0DCF","\u0E04\u0E2D\u0E21","\u0E44\u0E17\u0E22","\u0EA5\u0EB2\u0EA7","\u10D2\u10D4","\u307F\u3093\u306A","\u30A2\u30DE\u30BE\u30F3","\u30AF\u30E9\u30A6\u30C9","\u30B0\u30FC\u30B0\u30EB","\u30B3\u30E0","\u30B9\u30C8\u30A2","\u30BB\u30FC\u30EB","\u30D5\u30A1\u30C3\u30B7\u30E7\u30F3","\u30DD\u30A4\u30F3\u30C8","\u4E16\u754C","\u4E2D\u4FE1","\u4E2D\u56FD","\u4E2D\u570B","\u4E2D\u6587\u7F51","\u4E9A\u9A6C\u900A","\u4F01\u4E1A","\u4F5B\u5C71","\u4FE1\u606F","\u5065\u5EB7","\u516B\u5366","\u516C\u53F8","\u516C\u76CA","\u53F0\u6E7E","\u53F0\u7063","\u5546\u57CE","\u5546\u5E97","\u5546\u6807","\u5609\u91CC","\u5609\u91CC\u5927\u9152\u5E97","\u5728\u7EBF","\u5927\u62FF","\u5929\u4E3B\u6559","\u5A31\u4E50","\u5BB6\u96FB","\u5E7F\u4E1C","\u5FAE\u535A","\u6148\u5584","\u6211\u7231\u4F60","\u624B\u673A","\u62DB\u8058","\u653F\u52A1","\u653F\u5E9C","\u65B0\u52A0\u5761","\u65B0\u95FB","\u65F6\u5C1A","\u66F8\u7C4D","\u673A\u6784","\u6DE1\u9A6C\u9521","\u6E38\u620F","\u6FB3\u9580","\u70B9\u770B","\u79FB\u52A8","\u7EC4\u7EC7\u673A\u6784","\u7F51\u5740","\u7F51\u5E97","\u7F51\u7AD9","\u7F51\u7EDC","\u8054\u901A","\u8C37\u6B4C","\u8D2D\u7269","\u901A\u8CA9","\u96C6\u56E2","\u96FB\u8A0A\u76C8\u79D1","\u98DE\u5229\u6D66","\u98DF\u54C1","\u9910\u5385","\u9999\u683C\u91CC\u62C9","\u9999\u6E2F","\uB2F7\uB137","\uB2F7\uCEF4","\uC0BC\uC131","\uD55C\uAD6D"]');
  var util$2 = {};
  var hasRequiredUtil$2;
  function requireUtil$2() {
    if (hasRequiredUtil$2) return util$2;
    hasRequiredUtil$2 = 1;
    Object.defineProperty(util$2, "__esModule", { value: true });
    util$2.TAG_REGEX = util$2.TRAILING_PUNCTUATION_REGEX = util$2.URL_REGEX = util$2.MENTION_REGEX = void 0;
    util$2.MENTION_REGEX = /(^|\s|\()(@)([a-zA-Z0-9.-]+)(\b)/g;
    util$2.URL_REGEX = /(^|\s|\()((https?:\/\/[\S]+)|((?<domain>[a-z][a-z0-9]*(\.[a-z0-9]+)+)[\S]*))/gim;
    util$2.TRAILING_PUNCTUATION_REGEX = /\p{P}+$/gu;
    util$2.TAG_REGEX = // eslint-disable-next-line no-misleading-character-class
    /(^|\s)[#]((?!\ufe0f)[^\s\u00AD\u2060\u200A\u200B\u200C\u200D\u20e2]*[^\d\s\p{P}\u00AD\u2060\u200A\u200B\u200C\u200D\u20e2]+[^\s\u00AD\u2060\u200A\u200B\u200C\u200D\u20e2]*)?/gu;
    return util$2;
  }
  var hasRequiredDetection;
  function requireDetection() {
    if (hasRequiredDetection) return detection;
    hasRequiredDetection = 1;
    var __importDefault = detection && detection.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(detection, "__esModule", { value: true });
    detection.detectFacets = detectFacets;
    const tlds_1 = __importDefault(require$$0);
    const util_1 = requireUtil$2();
    function detectFacets(text) {
      let match2;
      const facets = [];
      {
        const re = util_1.MENTION_REGEX;
        while (match2 = re.exec(text.utf16)) {
          if (!isValidDomain(match2[3]) && !match2[3].endsWith(".test")) {
            continue;
          }
          const start = text.utf16.indexOf(match2[3], match2.index) - 1;
          facets.push({
            $type: "app.bsky.richtext.facet",
            index: {
              byteStart: text.utf16IndexToUtf8Index(start),
              byteEnd: text.utf16IndexToUtf8Index(start + match2[3].length + 1)
            },
            features: [
              {
                $type: "app.bsky.richtext.facet#mention",
                did: match2[3]
                // must be resolved afterwards
              }
            ]
          });
        }
      }
      {
        const re = util_1.URL_REGEX;
        while (match2 = re.exec(text.utf16)) {
          let uri = match2[2];
          if (!uri.startsWith("http")) {
            const domain = match2.groups?.domain;
            if (!domain || !isValidDomain(domain)) {
              continue;
            }
            uri = `https://${uri}`;
          }
          const start = text.utf16.indexOf(match2[2], match2.index);
          const index = { start, end: start + match2[2].length };
          if (/[.,;:!?]$/.test(uri)) {
            uri = uri.slice(0, -1);
            index.end--;
          }
          if (/[)]$/.test(uri) && !uri.includes("(")) {
            uri = uri.slice(0, -1);
            index.end--;
          }
          facets.push({
            index: {
              byteStart: text.utf16IndexToUtf8Index(index.start),
              byteEnd: text.utf16IndexToUtf8Index(index.end)
            },
            features: [
              {
                $type: "app.bsky.richtext.facet#link",
                uri
              }
            ]
          });
        }
      }
      {
        const re = util_1.TAG_REGEX;
        while (match2 = re.exec(text.utf16)) {
          const leading = match2[1];
          let tag = match2[2];
          if (!tag)
            continue;
          tag = tag.trim().replace(util_1.TRAILING_PUNCTUATION_REGEX, "");
          if (tag.length === 0 || tag.length > 64)
            continue;
          const index = match2.index + leading.length;
          facets.push({
            index: {
              byteStart: text.utf16IndexToUtf8Index(index),
              byteEnd: text.utf16IndexToUtf8Index(index + 1 + tag.length)
            },
            features: [
              {
                $type: "app.bsky.richtext.facet#tag",
                tag
              }
            ]
          });
        }
      }
      return facets.length > 0 ? facets : void 0;
    }
    function isValidDomain(str) {
      return !!tlds_1.default.find((tld) => {
        const i = str.lastIndexOf(tld);
        if (i === -1) {
          return false;
        }
        return str.charAt(i - 1) === "." && i === str.length - tld.length;
      });
    }
    return detection;
  }
  var sanitization = {};
  var unicode = {};
  var hasRequiredUnicode;
  function requireUnicode() {
    if (hasRequiredUnicode) return unicode;
    hasRequiredUnicode = 1;
    Object.defineProperty(unicode, "__esModule", { value: true });
    unicode.UnicodeString = void 0;
    const common_web_1 = requireDist$4();
    const encoder = new TextEncoder();
    const decoder = new TextDecoder();
    class UnicodeString {
      constructor(utf16) {
        Object.defineProperty(this, "utf16", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "utf8", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "_graphemeLen", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.utf16 = utf16;
        this.utf8 = encoder.encode(utf16);
      }
      get length() {
        return this.utf8.byteLength;
      }
      get graphemeLength() {
        if (!this._graphemeLen) {
          this._graphemeLen = (0, common_web_1.graphemeLen)(this.utf16);
        }
        return this._graphemeLen;
      }
      slice(start, end) {
        return decoder.decode(this.utf8.slice(start, end));
      }
      utf16IndexToUtf8Index(i) {
        return encoder.encode(this.utf16.slice(0, i)).byteLength;
      }
      toString() {
        return this.utf16;
      }
    }
    unicode.UnicodeString = UnicodeString;
    return unicode;
  }
  var hasRequiredSanitization;
  function requireSanitization() {
    if (hasRequiredSanitization) return sanitization;
    hasRequiredSanitization = 1;
    Object.defineProperty(sanitization, "__esModule", { value: true });
    sanitization.sanitizeRichText = sanitizeRichText;
    const unicode_1 = requireUnicode();
    const EXCESS_SPACE_RE = /[\r\n]([\u00AD\u2060\u200D\u200C\u200B\s]*[\r\n]){2,}/;
    const REPLACEMENT_STR = "\n\n";
    function sanitizeRichText(richText2, opts) {
      if (opts.cleanNewlines) {
        richText2 = clean(richText2, EXCESS_SPACE_RE, REPLACEMENT_STR);
      }
      return richText2;
    }
    function clean(richText2, targetRegexp, replacementString) {
      richText2 = richText2.clone();
      let match2 = richText2.unicodeText.utf16.match(targetRegexp);
      while (match2 && typeof match2.index !== "undefined") {
        const oldText = richText2.unicodeText;
        const removeStartIndex = richText2.unicodeText.utf16IndexToUtf8Index(match2.index);
        const removeEndIndex = removeStartIndex + new unicode_1.UnicodeString(match2[0]).length;
        richText2.delete(removeStartIndex, removeEndIndex);
        if (richText2.unicodeText.utf16 === oldText.utf16) {
          break;
        }
        richText2.insert(removeStartIndex, replacementString);
        match2 = richText2.unicodeText.utf16.match(targetRegexp);
      }
      return richText2;
    }
    return sanitization;
  }
  var hasRequiredRichText;
  function requireRichText() {
    if (hasRequiredRichText) return richText;
    hasRequiredRichText = 1;
    Object.defineProperty(richText, "__esModule", { value: true });
    richText.RichText = richText.RichTextSegment = void 0;
    const client_1 = requireClient();
    const detection_1 = requireDetection();
    const sanitization_1 = requireSanitization();
    const unicode_1 = requireUnicode();
    class RichTextSegment {
      constructor(text, facet2) {
        Object.defineProperty(this, "text", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: text
        });
        Object.defineProperty(this, "facet", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: facet2
        });
      }
      get link() {
        return this.facet?.features.find(client_1.AppBskyRichtextFacet.isLink);
      }
      isLink() {
        return !!this.link;
      }
      get mention() {
        return this.facet?.features.find(client_1.AppBskyRichtextFacet.isMention);
      }
      isMention() {
        return !!this.mention;
      }
      get tag() {
        return this.facet?.features.find(client_1.AppBskyRichtextFacet.isTag);
      }
      isTag() {
        return !!this.tag;
      }
    }
    richText.RichTextSegment = RichTextSegment;
    class RichText {
      constructor(props, opts) {
        Object.defineProperty(this, "unicodeText", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "facets", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.unicodeText = new unicode_1.UnicodeString(props.text);
        this.facets = props.facets;
        if (!this.facets?.length && props.entities?.length) {
          this.facets = entitiesToFacets(this.unicodeText, props.entities);
        }
        if (this.facets) {
          this.facets = this.facets.filter(facetFilter).sort(facetSort);
        }
        if (opts?.cleanNewlines) {
          (0, sanitization_1.sanitizeRichText)(this, { cleanNewlines: true }).copyInto(this);
        }
      }
      get text() {
        return this.unicodeText.toString();
      }
      get length() {
        return this.unicodeText.length;
      }
      get graphemeLength() {
        return this.unicodeText.graphemeLength;
      }
      clone() {
        return new RichText({
          text: this.unicodeText.utf16,
          facets: cloneDeep(this.facets)
        });
      }
      copyInto(target2) {
        target2.unicodeText = this.unicodeText;
        target2.facets = cloneDeep(this.facets);
      }
      *segments() {
        const facets = this.facets || [];
        if (!facets.length) {
          yield new RichTextSegment(this.unicodeText.utf16);
          return;
        }
        let textCursor = 0;
        let facetCursor = 0;
        do {
          const currFacet = facets[facetCursor];
          if (textCursor < currFacet.index.byteStart) {
            yield new RichTextSegment(this.unicodeText.slice(textCursor, currFacet.index.byteStart));
          } else if (textCursor > currFacet.index.byteStart) {
            facetCursor++;
            continue;
          }
          if (currFacet.index.byteStart < currFacet.index.byteEnd) {
            const subtext = this.unicodeText.slice(currFacet.index.byteStart, currFacet.index.byteEnd);
            if (!subtext.trim()) {
              yield new RichTextSegment(subtext);
            } else {
              yield new RichTextSegment(subtext, currFacet);
            }
          }
          textCursor = currFacet.index.byteEnd;
          facetCursor++;
        } while (facetCursor < facets.length);
        if (textCursor < this.unicodeText.length) {
          yield new RichTextSegment(this.unicodeText.slice(textCursor, this.unicodeText.length));
        }
      }
      insert(insertIndex, insertText) {
        this.unicodeText = new unicode_1.UnicodeString(this.unicodeText.slice(0, insertIndex) + insertText + this.unicodeText.slice(insertIndex));
        if (!this.facets?.length) {
          return this;
        }
        const numCharsAdded = insertText.length;
        for (const ent of this.facets) {
          if (insertIndex <= ent.index.byteStart) {
            ent.index.byteStart += numCharsAdded;
            ent.index.byteEnd += numCharsAdded;
          } else if (insertIndex >= ent.index.byteStart && insertIndex < ent.index.byteEnd) {
            ent.index.byteEnd += numCharsAdded;
          }
        }
        return this;
      }
      delete(removeStartIndex, removeEndIndex) {
        this.unicodeText = new unicode_1.UnicodeString(this.unicodeText.slice(0, removeStartIndex) + this.unicodeText.slice(removeEndIndex));
        if (!this.facets?.length) {
          return this;
        }
        const numCharsRemoved = removeEndIndex - removeStartIndex;
        for (const ent of this.facets) {
          if (removeStartIndex <= ent.index.byteStart && removeEndIndex >= ent.index.byteEnd) {
            ent.index.byteStart = 0;
            ent.index.byteEnd = 0;
          } else if (removeStartIndex > ent.index.byteEnd) ;
          else if (removeStartIndex > ent.index.byteStart && removeStartIndex <= ent.index.byteEnd && removeEndIndex > ent.index.byteEnd) {
            ent.index.byteEnd = removeStartIndex;
          } else if (removeStartIndex >= ent.index.byteStart && removeEndIndex <= ent.index.byteEnd) {
            ent.index.byteEnd -= numCharsRemoved;
          } else if (removeStartIndex < ent.index.byteStart && removeEndIndex >= ent.index.byteStart && removeEndIndex <= ent.index.byteEnd) {
            ent.index.byteStart = removeStartIndex;
            ent.index.byteEnd -= numCharsRemoved;
          } else if (removeEndIndex < ent.index.byteStart) {
            ent.index.byteStart -= numCharsRemoved;
            ent.index.byteEnd -= numCharsRemoved;
          }
        }
        this.facets = this.facets.filter((ent) => ent.index.byteStart < ent.index.byteEnd);
        return this;
      }
      /**
       * Detects facets such as links and mentions
       * Note: Overwrites the existing facets with auto-detected facets
       */
      async detectFacets(agent2) {
        this.facets = (0, detection_1.detectFacets)(this.unicodeText);
        if (this.facets) {
          const promises = [];
          for (const facet2 of this.facets) {
            for (const feature of facet2.features) {
              if (client_1.AppBskyRichtextFacet.isMention(feature)) {
                promises.push(agent2.com.atproto.identity.resolveHandle({ handle: feature.did }).then((res) => res?.data.did).catch((_) => void 0).then((did2) => {
                  feature.did = did2 || "";
                }));
              }
            }
          }
          await Promise.allSettled(promises);
          this.facets.sort(facetSort);
        }
      }
      /**
       * Detects facets such as links and mentions but does not resolve them
       * Will produce invalid facets! For instance, mentions will not have their DIDs set.
       * Note: Overwrites the existing facets with auto-detected facets
       */
      detectFacetsWithoutResolution() {
        this.facets = (0, detection_1.detectFacets)(this.unicodeText);
        if (this.facets) {
          this.facets.sort(facetSort);
        }
      }
    }
    richText.RichText = RichText;
    const facetSort = (a, b) => a.index.byteStart - b.index.byteStart;
    const facetFilter = (facet2) => (
      // discard negative-length facets. zero-length facets are valid
      facet2.index.byteStart <= facet2.index.byteEnd
    );
    function entitiesToFacets(text, entities) {
      const facets = [];
      for (const ent of entities) {
        if (ent.type === "link") {
          facets.push({
            $type: "app.bsky.richtext.facet",
            index: {
              byteStart: text.utf16IndexToUtf8Index(ent.index.start),
              byteEnd: text.utf16IndexToUtf8Index(ent.index.end)
            },
            features: [{ $type: "app.bsky.richtext.facet#link", uri: ent.value }]
          });
        } else if (ent.type === "mention") {
          facets.push({
            $type: "app.bsky.richtext.facet",
            index: {
              byteStart: text.utf16IndexToUtf8Index(ent.index.start),
              byteEnd: text.utf16IndexToUtf8Index(ent.index.end)
            },
            features: [
              { $type: "app.bsky.richtext.facet#mention", did: ent.value }
            ]
          });
        }
      }
      return facets;
    }
    function cloneDeep(v) {
      if (typeof v === "undefined") {
        return v;
      }
      return JSON.parse(JSON.stringify(v));
    }
    return richText;
  }
  var moderation = {};
  var decision = {};
  var labels = {};
  var hasRequiredLabels;
  function requireLabels() {
    if (hasRequiredLabels) return labels;
    hasRequiredLabels = 1;
    Object.defineProperty(labels, "__esModule", { value: true });
    labels.LABELS = labels.DEFAULT_LABEL_SETTINGS = void 0;
    labels.DEFAULT_LABEL_SETTINGS = {
      porn: "hide",
      sexual: "warn",
      nudity: "ignore",
      "graphic-media": "warn"
    };
    labels.LABELS = {
      "!hide": {
        identifier: "!hide",
        configurable: false,
        defaultSetting: "hide",
        flags: ["no-override", "no-self"],
        severity: "alert",
        blurs: "content",
        behaviors: {
          account: {
            profileList: "blur",
            profileView: "blur",
            avatar: "blur",
            banner: "blur",
            displayName: "blur",
            contentList: "blur",
            contentView: "blur"
          },
          profile: {
            avatar: "blur",
            banner: "blur",
            displayName: "blur"
          },
          content: {
            contentList: "blur",
            contentView: "blur"
          }
        },
        locales: []
      },
      "!warn": {
        identifier: "!warn",
        configurable: false,
        defaultSetting: "warn",
        flags: ["no-self"],
        severity: "none",
        blurs: "content",
        behaviors: {
          account: {
            profileList: "blur",
            profileView: "blur",
            avatar: "blur",
            banner: "blur",
            contentList: "blur",
            contentView: "blur"
          },
          profile: {
            avatar: "blur",
            banner: "blur",
            displayName: "blur"
          },
          content: {
            contentList: "blur",
            contentView: "blur"
          }
        },
        locales: []
      },
      "!no-unauthenticated": {
        identifier: "!no-unauthenticated",
        configurable: false,
        defaultSetting: "hide",
        flags: ["no-override", "unauthed"],
        severity: "none",
        blurs: "content",
        behaviors: {
          account: {
            profileList: "blur",
            profileView: "blur",
            avatar: "blur",
            banner: "blur",
            displayName: "blur",
            contentList: "blur",
            contentView: "blur"
          },
          profile: {
            avatar: "blur",
            banner: "blur",
            displayName: "blur"
          },
          content: {
            contentList: "blur",
            contentView: "blur"
          }
        },
        locales: []
      },
      porn: {
        identifier: "porn",
        configurable: true,
        defaultSetting: "hide",
        flags: ["adult"],
        severity: "none",
        blurs: "media",
        behaviors: {
          account: {
            avatar: "blur",
            banner: "blur"
          },
          profile: {
            avatar: "blur",
            banner: "blur"
          },
          content: {
            contentMedia: "blur"
          }
        },
        locales: []
      },
      sexual: {
        identifier: "sexual",
        configurable: true,
        defaultSetting: "warn",
        flags: ["adult"],
        severity: "none",
        blurs: "media",
        behaviors: {
          account: {
            avatar: "blur",
            banner: "blur"
          },
          profile: {
            avatar: "blur",
            banner: "blur"
          },
          content: {
            contentMedia: "blur"
          }
        },
        locales: []
      },
      nudity: {
        identifier: "nudity",
        configurable: true,
        defaultSetting: "ignore",
        flags: [],
        severity: "none",
        blurs: "media",
        behaviors: {
          account: {
            avatar: "blur",
            banner: "blur"
          },
          profile: {
            avatar: "blur",
            banner: "blur"
          },
          content: {
            contentMedia: "blur"
          }
        },
        locales: []
      },
      "graphic-media": {
        identifier: "graphic-media",
        flags: ["adult"],
        configurable: true,
        defaultSetting: "warn",
        severity: "none",
        blurs: "media",
        behaviors: {
          account: {
            avatar: "blur",
            banner: "blur"
          },
          profile: {
            avatar: "blur",
            banner: "blur"
          },
          content: {
            contentMedia: "blur"
          }
        },
        locales: []
      },
      /** @deprecated alias for `graphic-media` */
      gore: {
        identifier: "gore",
        flags: ["adult"],
        configurable: true,
        defaultSetting: "warn",
        severity: "none",
        blurs: "media",
        behaviors: {
          account: {
            avatar: "blur",
            banner: "blur"
          },
          profile: {
            avatar: "blur",
            banner: "blur"
          },
          content: {
            contentMedia: "blur"
          }
        },
        locales: []
      }
    };
    return labels;
  }
  var types = {};
  var hasRequiredTypes;
  function requireTypes() {
    if (hasRequiredTypes) return types;
    hasRequiredTypes = 1;
    Object.defineProperty(types, "__esModule", { value: true });
    types.NOOP_BEHAVIOR = types.HIDE_BEHAVIOR = types.MUTEWORD_BEHAVIOR = types.MUTE_BEHAVIOR = types.BLOCK_BEHAVIOR = types.CUSTOM_LABEL_VALUE_RE = void 0;
    types.CUSTOM_LABEL_VALUE_RE = /^[a-z-]+$/;
    types.BLOCK_BEHAVIOR = {
      profileList: "blur",
      profileView: "alert",
      avatar: "blur",
      banner: "blur",
      contentList: "blur",
      contentView: "blur"
    };
    types.MUTE_BEHAVIOR = {
      profileList: "inform",
      profileView: "alert",
      contentList: "blur",
      contentView: "inform"
    };
    types.MUTEWORD_BEHAVIOR = {
      contentList: "blur",
      contentView: "blur"
    };
    types.HIDE_BEHAVIOR = {
      contentList: "blur",
      contentView: "blur"
    };
    types.NOOP_BEHAVIOR = {};
    return types;
  }
  var ui = {};
  var hasRequiredUi;
  function requireUi() {
    if (hasRequiredUi) return ui;
    hasRequiredUi = 1;
    Object.defineProperty(ui, "__esModule", { value: true });
    ui.ModerationUI = void 0;
    class ModerationUI {
      constructor() {
        Object.defineProperty(this, "noOverride", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: false
        });
        Object.defineProperty(this, "filters", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: []
        });
        Object.defineProperty(this, "blurs", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: []
        });
        Object.defineProperty(this, "alerts", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: []
        });
        Object.defineProperty(this, "informs", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: []
        });
      }
      get filter() {
        return this.filters.length !== 0;
      }
      get blur() {
        return this.blurs.length !== 0;
      }
      get alert() {
        return this.alerts.length !== 0;
      }
      get inform() {
        return this.informs.length !== 0;
      }
    }
    ui.ModerationUI = ModerationUI;
    return ui;
  }
  var hasRequiredDecision;
  function requireDecision() {
    if (hasRequiredDecision) return decision;
    hasRequiredDecision = 1;
    Object.defineProperty(decision, "__esModule", { value: true });
    decision.ModerationDecision = void 0;
    const labels_1 = requireLabels();
    const types_1 = requireTypes();
    const ui_1 = requireUi();
    var ModerationBehaviorSeverity;
    (function(ModerationBehaviorSeverity2) {
      ModerationBehaviorSeverity2[ModerationBehaviorSeverity2["High"] = 0] = "High";
      ModerationBehaviorSeverity2[ModerationBehaviorSeverity2["Medium"] = 1] = "Medium";
      ModerationBehaviorSeverity2[ModerationBehaviorSeverity2["Low"] = 2] = "Low";
    })(ModerationBehaviorSeverity || (ModerationBehaviorSeverity = {}));
    class ModerationDecision {
      constructor() {
        Object.defineProperty(this, "did", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: ""
        });
        Object.defineProperty(this, "isMe", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: false
        });
        Object.defineProperty(this, "causes", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: []
        });
      }
      static merge(...decisions) {
        const decisionsFiltered = decisions.filter((v) => v != null);
        const decision2 = new ModerationDecision();
        if (decisionsFiltered[0]) {
          decision2.did = decisionsFiltered[0].did;
          decision2.isMe = decisionsFiltered[0].isMe;
        }
        decision2.causes = decisionsFiltered.flatMap((d) => d.causes);
        return decision2;
      }
      downgrade() {
        for (const cause of this.causes) {
          cause.downgraded = true;
        }
        return this;
      }
      get blocked() {
        return !!this.blockCause;
      }
      get muted() {
        return !!this.muteCause;
      }
      get blockCause() {
        return this.causes.find((cause) => cause.type === "blocking" || cause.type === "blocked-by" || cause.type === "block-other");
      }
      get muteCause() {
        return this.causes.find((cause) => cause.type === "muted");
      }
      get labelCauses() {
        return this.causes.filter((cause) => cause.type === "label");
      }
      ui(context) {
        const ui2 = new ui_1.ModerationUI();
        for (const cause of this.causes) {
          if (cause.type === "blocking" || cause.type === "blocked-by" || cause.type === "block-other") {
            if (this.isMe) {
              continue;
            }
            if (context === "profileList" || context === "contentList") {
              ui2.filters.push(cause);
            }
            if (!cause.downgraded) {
              if (types_1.BLOCK_BEHAVIOR[context] === "blur") {
                ui2.noOverride = true;
                ui2.blurs.push(cause);
              } else if (types_1.BLOCK_BEHAVIOR[context] === "alert") {
                ui2.alerts.push(cause);
              } else if (types_1.BLOCK_BEHAVIOR[context] === "inform") {
                ui2.informs.push(cause);
              }
            }
          } else if (cause.type === "muted") {
            if (this.isMe) {
              continue;
            }
            if (context === "profileList" || context === "contentList") {
              ui2.filters.push(cause);
            }
            if (!cause.downgraded) {
              if (types_1.MUTE_BEHAVIOR[context] === "blur") {
                ui2.blurs.push(cause);
              } else if (types_1.MUTE_BEHAVIOR[context] === "alert") {
                ui2.alerts.push(cause);
              } else if (types_1.MUTE_BEHAVIOR[context] === "inform") {
                ui2.informs.push(cause);
              }
            }
          } else if (cause.type === "mute-word") {
            if (this.isMe) {
              continue;
            }
            if (context === "contentList") {
              ui2.filters.push(cause);
            }
            if (!cause.downgraded) {
              if (types_1.MUTEWORD_BEHAVIOR[context] === "blur") {
                ui2.blurs.push(cause);
              } else if (types_1.MUTEWORD_BEHAVIOR[context] === "alert") {
                ui2.alerts.push(cause);
              } else if (types_1.MUTEWORD_BEHAVIOR[context] === "inform") {
                ui2.informs.push(cause);
              }
            }
          } else if (cause.type === "hidden") {
            if (context === "profileList" || context === "contentList") {
              ui2.filters.push(cause);
            }
            if (!cause.downgraded) {
              if (types_1.HIDE_BEHAVIOR[context] === "blur") {
                ui2.blurs.push(cause);
              } else if (types_1.HIDE_BEHAVIOR[context] === "alert") {
                ui2.alerts.push(cause);
              } else if (types_1.HIDE_BEHAVIOR[context] === "inform") {
                ui2.informs.push(cause);
              }
            }
          } else if (cause.type === "label") {
            if (context === "profileList" && cause.target === "account") {
              if (cause.setting === "hide" && !this.isMe) {
                ui2.filters.push(cause);
              }
            } else if (context === "contentList" && (cause.target === "account" || cause.target === "content")) {
              if (cause.setting === "hide" && !this.isMe) {
                ui2.filters.push(cause);
              }
            }
            if (!cause.downgraded) {
              if (cause.behavior[context] === "blur") {
                ui2.blurs.push(cause);
                if (cause.noOverride && !this.isMe) {
                  ui2.noOverride = true;
                }
              } else if (cause.behavior[context] === "alert") {
                ui2.alerts.push(cause);
              } else if (cause.behavior[context] === "inform") {
                ui2.informs.push(cause);
              }
            }
          }
        }
        ui2.filters.sort(sortByPriority);
        ui2.blurs.sort(sortByPriority);
        return ui2;
      }
      setDid(did2) {
        this.did = did2;
      }
      setIsMe(isMe) {
        this.isMe = isMe;
      }
      addHidden(hidden2) {
        if (hidden2) {
          this.causes.push({
            type: "hidden",
            source: { type: "user" },
            priority: 6
          });
        }
      }
      addMutedWord(mutedWord) {
        if (mutedWord) {
          this.causes.push({
            type: "mute-word",
            source: { type: "user" },
            priority: 6
          });
        }
      }
      addBlocking(blocking) {
        if (blocking) {
          this.causes.push({
            type: "blocking",
            source: { type: "user" },
            priority: 3
          });
        }
      }
      addBlockingByList(blockingByList) {
        if (blockingByList) {
          this.causes.push({
            type: "blocking",
            source: { type: "list", list: blockingByList },
            priority: 3
          });
        }
      }
      addBlockedBy(blockedBy) {
        if (blockedBy) {
          this.causes.push({
            type: "blocked-by",
            source: { type: "user" },
            priority: 4
          });
        }
      }
      addBlockOther(blockOther) {
        if (blockOther) {
          this.causes.push({
            type: "block-other",
            source: { type: "user" },
            priority: 4
          });
        }
      }
      addLabel(target2, label, opts) {
        const labelDef = types_1.CUSTOM_LABEL_VALUE_RE.test(label.val) ? opts.labelDefs?.[label.src]?.find((def) => def.identifier === label.val) || labels_1.LABELS[label.val] : labels_1.LABELS[label.val];
        if (!labelDef) {
          return;
        }
        const isSelf = label.src === this.did;
        const labeler = isSelf ? void 0 : opts.prefs.labelers.find((s) => s.did === label.src);
        if (!isSelf && !labeler) {
          return;
        }
        if (isSelf && labelDef.flags.includes("no-self")) {
          return;
        }
        let labelPref = labelDef.defaultSetting || "ignore";
        if (!labelDef.configurable) {
          labelPref = labelDef.defaultSetting || "hide";
        } else if (labelDef.flags.includes("adult") && !opts.prefs.adultContentEnabled) {
          labelPref = "hide";
        } else if (labeler?.labels[labelDef.identifier]) {
          labelPref = labeler?.labels[labelDef.identifier];
        } else if (opts.prefs.labels[labelDef.identifier]) {
          labelPref = opts.prefs.labels[labelDef.identifier];
        }
        if (labelPref === "ignore") {
          return;
        }
        if (labelDef.flags.includes("unauthed") && !!opts.userDid) {
          return;
        }
        let priority;
        const severity = measureModerationBehaviorSeverity(labelDef.behaviors[target2]);
        if (labelDef.flags.includes("no-override") || labelDef.flags.includes("adult") && !opts.prefs.adultContentEnabled) {
          priority = 1;
        } else if (labelPref === "hide") {
          priority = 2;
        } else if (severity === ModerationBehaviorSeverity.High) {
          priority = 5;
        } else if (severity === ModerationBehaviorSeverity.Medium) {
          priority = 7;
        } else {
          priority = 8;
        }
        let noOverride = false;
        if (labelDef.flags.includes("no-override")) {
          noOverride = true;
        } else if (labelDef.flags.includes("adult") && !opts.prefs.adultContentEnabled) {
          noOverride = true;
        }
        this.causes.push({
          type: "label",
          source: isSelf || !labeler ? { type: "user" } : { type: "labeler", did: labeler.did },
          label,
          labelDef,
          target: target2,
          setting: labelPref,
          behavior: labelDef.behaviors[target2] || types_1.NOOP_BEHAVIOR,
          noOverride,
          priority
        });
      }
      addMuted(muted) {
        if (muted) {
          this.causes.push({
            type: "muted",
            source: { type: "user" },
            priority: 6
          });
        }
      }
      addMutedByList(mutedByList) {
        if (mutedByList) {
          this.causes.push({
            type: "muted",
            source: { type: "list", list: mutedByList },
            priority: 6
          });
        }
      }
    }
    decision.ModerationDecision = ModerationDecision;
    function measureModerationBehaviorSeverity(beh) {
      if (!beh) {
        return ModerationBehaviorSeverity.Low;
      }
      if (beh.profileView === "blur" || beh.contentView === "blur") {
        return ModerationBehaviorSeverity.High;
      }
      if (beh.contentList === "blur" || beh.contentMedia === "blur") {
        return ModerationBehaviorSeverity.Medium;
      }
      return ModerationBehaviorSeverity.Low;
    }
    function sortByPriority(a, b) {
      return a.priority - b.priority;
    }
    return decision;
  }
  var account = {};
  var hasRequiredAccount;
  function requireAccount() {
    if (hasRequiredAccount) return account;
    hasRequiredAccount = 1;
    Object.defineProperty(account, "__esModule", { value: true });
    account.decideAccount = decideAccount;
    account.filterAccountLabels = filterAccountLabels;
    const decision_1 = requireDecision();
    function decideAccount(subject, opts) {
      const acc = new decision_1.ModerationDecision();
      acc.setDid(subject.did);
      acc.setIsMe(subject.did === opts.userDid);
      if (subject.viewer?.muted) {
        if (subject.viewer?.mutedByList) {
          acc.addMutedByList(subject.viewer?.mutedByList);
        } else {
          acc.addMuted(subject.viewer?.muted);
        }
      }
      if (subject.viewer?.blocking) {
        if (subject.viewer?.blockingByList) {
          acc.addBlockingByList(subject.viewer?.blockingByList);
        } else {
          acc.addBlocking(subject.viewer?.blocking);
        }
      }
      acc.addBlockedBy(subject.viewer?.blockedBy);
      for (const label of filterAccountLabels(subject.labels)) {
        acc.addLabel("account", label, opts);
      }
      return acc;
    }
    function filterAccountLabels(labels2) {
      if (!labels2) {
        return [];
      }
      return labels2.filter((label) => !label.uri.endsWith("/app.bsky.actor.profile/self") || label.val === "!no-unauthenticated");
    }
    return account;
  }
  var feedGenerator = {};
  var profile = {};
  var hasRequiredProfile;
  function requireProfile() {
    if (hasRequiredProfile) return profile;
    hasRequiredProfile = 1;
    Object.defineProperty(profile, "__esModule", { value: true });
    profile.decideProfile = decideProfile;
    profile.filterProfileLabels = filterProfileLabels;
    const decision_1 = requireDecision();
    function decideProfile(subject, opts) {
      const acc = new decision_1.ModerationDecision();
      acc.setDid(subject.did);
      acc.setIsMe(subject.did === opts.userDid);
      for (const label of filterProfileLabels(subject.labels)) {
        acc.addLabel("profile", label, opts);
      }
      return acc;
    }
    function filterProfileLabels(labels2) {
      if (!labels2) {
        return [];
      }
      return labels2.filter((label) => label.uri.endsWith("/app.bsky.actor.profile/self"));
    }
    return profile;
  }
  var hasRequiredFeedGenerator;
  function requireFeedGenerator() {
    if (hasRequiredFeedGenerator) return feedGenerator;
    hasRequiredFeedGenerator = 1;
    Object.defineProperty(feedGenerator, "__esModule", { value: true });
    feedGenerator.decideFeedGenerator = decideFeedGenerator;
    const decision_1 = requireDecision();
    const account_1 = requireAccount();
    const profile_1 = requireProfile();
    function decideFeedGenerator(subject, opts) {
      const acc = new decision_1.ModerationDecision();
      acc.setDid(subject.creator.did);
      acc.setIsMe(subject.creator.did === opts.userDid);
      if (subject.labels?.length) {
        for (const label of subject.labels) {
          acc.addLabel("content", label, opts);
        }
      }
      return decision_1.ModerationDecision.merge(acc, (0, account_1.decideAccount)(subject.creator, opts), (0, profile_1.decideProfile)(subject.creator, opts));
    }
    return feedGenerator;
  }
  var notification = {};
  var hasRequiredNotification;
  function requireNotification() {
    if (hasRequiredNotification) return notification;
    hasRequiredNotification = 1;
    Object.defineProperty(notification, "__esModule", { value: true });
    notification.decideNotification = decideNotification;
    const decision_1 = requireDecision();
    const account_1 = requireAccount();
    const profile_1 = requireProfile();
    function decideNotification(subject, opts) {
      const acc = new decision_1.ModerationDecision();
      acc.setDid(subject.author.did);
      acc.setIsMe(subject.author.did === opts.userDid);
      if (subject.labels?.length) {
        for (const label of subject.labels) {
          acc.addLabel("content", label, opts);
        }
      }
      return decision_1.ModerationDecision.merge(acc, (0, account_1.decideAccount)(subject.author, opts), (0, profile_1.decideProfile)(subject.author, opts));
    }
    return notification;
  }
  var post = {};
  var mutewords = {};
  var hasRequiredMutewords;
  function requireMutewords() {
    if (hasRequiredMutewords) return mutewords;
    hasRequiredMutewords = 1;
    Object.defineProperty(mutewords, "__esModule", { value: true });
    mutewords.hasMutedWord = hasMutedWord;
    const client_1 = requireClient();
    const REGEX = {
      LEADING_TRAILING_PUNCTUATION: /(?:^\p{P}+|\p{P}+$)/gu,
      WORD_BOUNDARY: /[\s\n\t\r\f\v]+?/g
    };
    const LANGUAGE_EXCEPTIONS = [
      "ja",
      // Japanese
      "zh",
      // Chinese
      "ko",
      // Korean
      "th",
      // Thai
      "vi"
      // Vietnamese
    ];
    function hasMutedWord({ mutedWords, text, facets, outlineTags, languages, actor }) {
      const exception2 = LANGUAGE_EXCEPTIONS.includes(languages?.[0] || "");
      const tags = [].concat(outlineTags || []).concat((facets || []).flatMap((facet2) => facet2.features.filter(client_1.AppBskyRichtextFacet.isTag).map((tag) => tag.tag))).map((t) => t.toLowerCase());
      for (const mute of mutedWords) {
        const mutedWord = mute.value.toLowerCase();
        const postText = text.toLowerCase();
        if (mute.expiresAt && mute.expiresAt < (/* @__PURE__ */ new Date()).toISOString())
          continue;
        if (mute.actorTarget === "exclude-following" && Boolean(actor?.viewer?.following))
          continue;
        if (tags.includes(mutedWord))
          return true;
        if (!mute.targets.includes("content"))
          continue;
        if ((mutedWord.length === 1 || exception2) && postText.includes(mutedWord))
          return true;
        if (mutedWord.length > postText.length)
          continue;
        if (mutedWord === postText)
          return true;
        if (/(?:\s|\p{P})+?/u.test(mutedWord) && postText.includes(mutedWord))
          return true;
        const words = postText.split(REGEX.WORD_BOUNDARY);
        for (const word of words) {
          if (word === mutedWord)
            return true;
          const wordTrimmedPunctuation = word.replace(REGEX.LEADING_TRAILING_PUNCTUATION, "");
          if (mutedWord === wordTrimmedPunctuation)
            return true;
          if (mutedWord.length > wordTrimmedPunctuation.length)
            continue;
          if (/\p{P}+/u.test(wordTrimmedPunctuation)) {
            const spacedWord = wordTrimmedPunctuation.replace(/\p{P}+/gu, " ");
            if (spacedWord === mutedWord)
              return true;
            const contiguousWord = spacedWord.replace(/\s/gu, "");
            if (contiguousWord === mutedWord)
              return true;
            const wordParts = wordTrimmedPunctuation.split(/\p{P}+/u);
            for (const wordPart of wordParts) {
              if (wordPart === mutedWord)
                return true;
            }
          }
        }
      }
      return false;
    }
    return mutewords;
  }
  var hasRequiredPost;
  function requirePost() {
    if (hasRequiredPost) return post;
    hasRequiredPost = 1;
    Object.defineProperty(post, "__esModule", { value: true });
    post.decidePost = decidePost;
    const client_1 = requireClient();
    const decision_1 = requireDecision();
    const mutewords_1 = requireMutewords();
    const account_1 = requireAccount();
    const profile_1 = requireProfile();
    function decidePost(subject, opts) {
      return decision_1.ModerationDecision.merge(decideSubject(subject, opts), decideEmbed(subject.embed, opts)?.downgrade(), (0, account_1.decideAccount)(subject.author, opts), (0, profile_1.decideProfile)(subject.author, opts));
    }
    function decideSubject(subject, opts) {
      const acc = new decision_1.ModerationDecision();
      acc.setDid(subject.author.did);
      acc.setIsMe(subject.author.did === opts.userDid);
      if (subject.labels?.length) {
        for (const label of subject.labels) {
          acc.addLabel("content", label, opts);
        }
      }
      acc.addHidden(checkHiddenPost(subject, opts.prefs.hiddenPosts));
      if (!acc.isMe) {
        acc.addMutedWord(checkMutedWords(subject, opts.prefs.mutedWords));
      }
      return acc;
    }
    function decideEmbed(embed2, opts) {
      if (embed2) {
        if ((client_1.AppBskyEmbedRecord.isView(embed2) || client_1.AppBskyEmbedRecordWithMedia.isView(embed2)) && client_1.AppBskyEmbedRecord.isViewRecord(embed2.record)) {
          return decideQuotedPost(embed2.record, opts);
        } else if (client_1.AppBskyEmbedRecordWithMedia.isView(embed2) && client_1.AppBskyEmbedRecord.isViewRecord(embed2.record.record)) {
          return decideQuotedPost(embed2.record.record, opts);
        } else if ((client_1.AppBskyEmbedRecord.isView(embed2) || client_1.AppBskyEmbedRecordWithMedia.isView(embed2)) && client_1.AppBskyEmbedRecord.isViewBlocked(embed2.record)) {
          return decideBlockedQuotedPost(embed2.record, opts);
        } else if (client_1.AppBskyEmbedRecordWithMedia.isView(embed2) && client_1.AppBskyEmbedRecord.isViewBlocked(embed2.record.record)) {
          return decideBlockedQuotedPost(embed2.record.record, opts);
        }
      }
      return void 0;
    }
    function decideQuotedPost(subject, opts) {
      const acc = new decision_1.ModerationDecision();
      acc.setDid(subject.author.did);
      acc.setIsMe(subject.author.did === opts.userDid);
      if (subject.labels?.length) {
        for (const label of subject.labels) {
          acc.addLabel("content", label, opts);
        }
      }
      return decision_1.ModerationDecision.merge(acc, (0, account_1.decideAccount)(subject.author, opts), (0, profile_1.decideProfile)(subject.author, opts));
    }
    function decideBlockedQuotedPost(subject, opts) {
      const acc = new decision_1.ModerationDecision();
      acc.setDid(subject.author.did);
      acc.setIsMe(subject.author.did === opts.userDid);
      if (subject.author.viewer?.muted) {
        if (subject.author.viewer?.mutedByList) {
          acc.addMutedByList(subject.author.viewer?.mutedByList);
        } else {
          acc.addMuted(subject.author.viewer?.muted);
        }
      }
      if (subject.author.viewer?.blocking) {
        if (subject.author.viewer?.blockingByList) {
          acc.addBlockingByList(subject.author.viewer?.blockingByList);
        } else {
          acc.addBlocking(subject.author.viewer?.blocking);
        }
      }
      acc.addBlockedBy(subject.author.viewer?.blockedBy);
      return acc;
    }
    function checkHiddenPost(subject, hiddenPosts) {
      if (!hiddenPosts?.length) {
        return false;
      }
      if (hiddenPosts.includes(subject.uri)) {
        return true;
      }
      if (subject.embed) {
        if (client_1.AppBskyEmbedRecord.isView(subject.embed) && client_1.AppBskyEmbedRecord.isViewRecord(subject.embed.record) && hiddenPosts.includes(subject.embed.record.uri)) {
          return true;
        }
        if (client_1.AppBskyEmbedRecordWithMedia.isView(subject.embed) && client_1.AppBskyEmbedRecord.isViewRecord(subject.embed.record.record) && hiddenPosts.includes(subject.embed.record.record.uri)) {
          return true;
        }
      }
      return false;
    }
    function checkMutedWords(subject, mutedWords) {
      if (!mutedWords?.length) {
        return false;
      }
      const postAuthor = subject.author;
      if (client_1.AppBskyFeedPost.isRecord(subject.record)) {
        const post2 = subject.record;
        if ((0, mutewords_1.hasMutedWord)({
          mutedWords,
          text: post2.text,
          facets: post2.facets,
          outlineTags: post2.tags,
          languages: post2.langs,
          actor: postAuthor
        })) {
          return true;
        }
        if (post2.embed && client_1.AppBskyEmbedImages.isMain(post2.embed)) {
          for (const image of post2.embed.images) {
            if ((0, mutewords_1.hasMutedWord)({
              mutedWords,
              text: image.alt,
              languages: post2.langs,
              actor: postAuthor
            })) {
              return true;
            }
          }
        }
      }
      const { embed: embed2 } = subject;
      if (embed2) {
        if ((client_1.AppBskyEmbedRecord.isView(embed2) || client_1.AppBskyEmbedRecordWithMedia.isView(embed2)) && client_1.AppBskyEmbedRecord.isViewRecord(embed2.record)) {
          if (client_1.AppBskyFeedPost.isRecord(embed2.record.value)) {
            const embeddedPost = embed2.record.value;
            const embedAuthor = embed2.record.author;
            if ((0, mutewords_1.hasMutedWord)({
              mutedWords,
              text: embeddedPost.text,
              facets: embeddedPost.facets,
              outlineTags: embeddedPost.tags,
              languages: embeddedPost.langs,
              actor: embedAuthor
            })) {
              return true;
            }
            if (client_1.AppBskyEmbedImages.isMain(embeddedPost.embed)) {
              for (const image of embeddedPost.embed.images) {
                if ((0, mutewords_1.hasMutedWord)({
                  mutedWords,
                  text: image.alt,
                  languages: embeddedPost.langs,
                  actor: embedAuthor
                })) {
                  return true;
                }
              }
            }
            if (client_1.AppBskyEmbedExternal.isMain(embeddedPost.embed)) {
              const { external: external2 } = embeddedPost.embed;
              if ((0, mutewords_1.hasMutedWord)({
                mutedWords,
                text: external2.title + " " + external2.description,
                languages: [],
                actor: embedAuthor
              })) {
                return true;
              }
            }
            if (client_1.AppBskyEmbedRecordWithMedia.isMain(embeddedPost.embed)) {
              if (client_1.AppBskyEmbedExternal.isMain(embeddedPost.embed.media)) {
                const { external: external2 } = embeddedPost.embed.media;
                if ((0, mutewords_1.hasMutedWord)({
                  mutedWords,
                  text: external2.title + " " + external2.description,
                  languages: [],
                  actor: embedAuthor
                })) {
                  return true;
                }
              }
              if (client_1.AppBskyEmbedImages.isMain(embeddedPost.embed.media)) {
                for (const image of embeddedPost.embed.media.images) {
                  if ((0, mutewords_1.hasMutedWord)({
                    mutedWords,
                    text: image.alt,
                    languages: client_1.AppBskyFeedPost.isRecord(embeddedPost.record) ? embeddedPost.langs : [],
                    actor: embedAuthor
                  })) {
                    return true;
                  }
                }
              }
            }
          }
        } else if (client_1.AppBskyEmbedExternal.isView(embed2)) {
          const { external: external2 } = embed2;
          if ((0, mutewords_1.hasMutedWord)({
            mutedWords,
            text: external2.title + " " + external2.description,
            languages: [],
            actor: postAuthor
          })) {
            return true;
          }
        } else if (client_1.AppBskyEmbedRecordWithMedia.isView(embed2) && client_1.AppBskyEmbedRecord.isViewRecord(embed2.record.record)) {
          const embedAuthor = embed2.record.record.author;
          if (client_1.AppBskyFeedPost.isRecord(embed2.record.record.value)) {
            const post2 = embed2.record.record.value;
            if ((0, mutewords_1.hasMutedWord)({
              mutedWords,
              text: post2.text,
              facets: post2.facets,
              outlineTags: post2.tags,
              languages: post2.langs,
              actor: embedAuthor
            })) {
              return true;
            }
          }
          if (client_1.AppBskyEmbedImages.isView(embed2.media)) {
            for (const image of embed2.media.images) {
              if ((0, mutewords_1.hasMutedWord)({
                mutedWords,
                text: image.alt,
                languages: client_1.AppBskyFeedPost.isRecord(subject.record) ? subject.record.langs : [],
                actor: embedAuthor
              })) {
                return true;
              }
            }
          }
          if (client_1.AppBskyEmbedExternal.isView(embed2.media)) {
            const { external: external2 } = embed2.media;
            if ((0, mutewords_1.hasMutedWord)({
              mutedWords,
              text: external2.title + " " + external2.description,
              languages: [],
              actor: embedAuthor
            })) {
              return true;
            }
          }
        }
      }
      return false;
    }
    return post;
  }
  var userList = {};
  var hasRequiredUserList;
  function requireUserList() {
    if (hasRequiredUserList) return userList;
    hasRequiredUserList = 1;
    Object.defineProperty(userList, "__esModule", { value: true });
    userList.decideUserList = decideUserList;
    const syntax_1 = requireDist$5();
    const decision_1 = requireDecision();
    const account_1 = requireAccount();
    const profile_1 = requireProfile();
    function decideUserList(subject, opts) {
      const acc = new decision_1.ModerationDecision();
      const creator = (
        // Note: ListViewBasic should not contain a creator field, but let's support it anyway
        "creator" in subject && isProfile(subject.creator) ? subject.creator : void 0
      );
      if (creator) {
        acc.setDid(creator.did);
        acc.setIsMe(creator.did === opts.userDid);
        if (subject.labels?.length) {
          for (const label of subject.labels) {
            acc.addLabel("content", label, opts);
          }
        }
        return decision_1.ModerationDecision.merge(acc, (0, account_1.decideAccount)(creator, opts), (0, profile_1.decideProfile)(creator, opts));
      }
      const creatorDid = new syntax_1.AtUri(subject.uri).hostname;
      acc.setDid(creatorDid);
      acc.setIsMe(creatorDid === opts.userDid);
      if (subject.labels?.length) {
        for (const label of subject.labels) {
          acc.addLabel("content", label, opts);
        }
      }
      return acc;
    }
    function isProfile(v) {
      return v && typeof v === "object" && "did" in v;
    }
    return userList;
  }
  var util$1 = {};
  var hasRequiredUtil$1;
  function requireUtil$1() {
    if (hasRequiredUtil$1) return util$1;
    hasRequiredUtil$1 = 1;
    Object.defineProperty(util$1, "__esModule", { value: true });
    util$1.isQuotedPost = isQuotedPost;
    util$1.isQuotedPostWithMedia = isQuotedPostWithMedia;
    util$1.interpretLabelValueDefinition = interpretLabelValueDefinition;
    util$1.interpretLabelValueDefinitions = interpretLabelValueDefinitions;
    const client_1 = requireClient();
    const util_1 = requireUtil$5();
    function isQuotedPost(embed2) {
      return Boolean(embed2 && client_1.AppBskyEmbedRecord.isView(embed2));
    }
    function isQuotedPostWithMedia(embed2) {
      return Boolean(embed2 && client_1.AppBskyEmbedRecordWithMedia.isView(embed2));
    }
    function interpretLabelValueDefinition(def, definedBy) {
      const behaviors = {
        account: {},
        profile: {},
        content: {}
      };
      const alertOrInform = def.severity === "alert" ? "alert" : def.severity === "inform" ? "inform" : void 0;
      if (def.blurs === "content") {
        behaviors.account.profileList = alertOrInform;
        behaviors.account.profileView = alertOrInform;
        behaviors.account.contentList = "blur";
        behaviors.account.contentView = def.adultOnly ? "blur" : alertOrInform;
        behaviors.profile.profileList = alertOrInform;
        behaviors.profile.profileView = alertOrInform;
        behaviors.content.contentList = "blur";
        behaviors.content.contentView = def.adultOnly ? "blur" : alertOrInform;
      } else if (def.blurs === "media") {
        behaviors.account.profileList = alertOrInform;
        behaviors.account.profileView = alertOrInform;
        behaviors.account.avatar = "blur";
        behaviors.account.banner = "blur";
        behaviors.profile.profileList = alertOrInform;
        behaviors.profile.profileView = alertOrInform;
        behaviors.profile.avatar = "blur";
        behaviors.profile.banner = "blur";
        behaviors.content.contentMedia = "blur";
      } else if (def.blurs === "none") {
        behaviors.account.profileList = alertOrInform;
        behaviors.account.profileView = alertOrInform;
        behaviors.account.contentList = alertOrInform;
        behaviors.account.contentView = alertOrInform;
        behaviors.profile.profileList = alertOrInform;
        behaviors.profile.profileView = alertOrInform;
        behaviors.content.contentList = alertOrInform;
        behaviors.content.contentView = alertOrInform;
      }
      let defaultSetting = "warn";
      if (def.defaultSetting === "hide" || def.defaultSetting === "ignore") {
        defaultSetting = def.defaultSetting;
      }
      const flags = ["no-self"];
      if (def.adultOnly) {
        flags.push("adult");
      }
      return {
        ...def,
        definedBy,
        configurable: true,
        defaultSetting,
        flags,
        behaviors
      };
    }
    function interpretLabelValueDefinitions(labelerView) {
      return (labelerView.policies?.labelValueDefinitions || []).filter((0, util_1.asPredicate)(client_1.ComAtprotoLabelDefs.validateLabelValueDefinition)).map((labelValDef) => interpretLabelValueDefinition(labelValDef, labelerView.creator.did));
    }
    return util$1;
  }
  var hasRequiredModeration;
  function requireModeration() {
    if (hasRequiredModeration) return moderation;
    hasRequiredModeration = 1;
    (function(exports$1) {
      Object.defineProperty(exports$1, "__esModule", { value: true });
      exports$1.interpretLabelValueDefinitions = exports$1.interpretLabelValueDefinition = exports$1.hasMutedWord = exports$1.ModerationDecision = exports$1.ModerationUI = void 0;
      exports$1.moderateProfile = moderateProfile;
      exports$1.moderatePost = moderatePost;
      exports$1.moderateNotification = moderateNotification;
      exports$1.moderateFeedGenerator = moderateFeedGenerator;
      exports$1.moderateUserList = moderateUserList;
      const decision_1 = requireDecision();
      const account_1 = requireAccount();
      const feed_generator_1 = requireFeedGenerator();
      const notification_1 = requireNotification();
      const post_1 = requirePost();
      const profile_1 = requireProfile();
      const user_list_1 = requireUserList();
      var ui_1 = requireUi();
      Object.defineProperty(exports$1, "ModerationUI", { enumerable: true, get: function() {
        return ui_1.ModerationUI;
      } });
      var decision_2 = requireDecision();
      Object.defineProperty(exports$1, "ModerationDecision", { enumerable: true, get: function() {
        return decision_2.ModerationDecision;
      } });
      var mutewords_1 = requireMutewords();
      Object.defineProperty(exports$1, "hasMutedWord", { enumerable: true, get: function() {
        return mutewords_1.hasMutedWord;
      } });
      var util_1 = requireUtil$1();
      Object.defineProperty(exports$1, "interpretLabelValueDefinition", { enumerable: true, get: function() {
        return util_1.interpretLabelValueDefinition;
      } });
      Object.defineProperty(exports$1, "interpretLabelValueDefinitions", { enumerable: true, get: function() {
        return util_1.interpretLabelValueDefinitions;
      } });
      function moderateProfile(subject, opts) {
        return decision_1.ModerationDecision.merge((0, account_1.decideAccount)(subject, opts), (0, profile_1.decideProfile)(subject, opts));
      }
      function moderatePost(subject, opts) {
        return (0, post_1.decidePost)(subject, opts);
      }
      function moderateNotification(subject, opts) {
        return (0, notification_1.decideNotification)(subject, opts);
      }
      function moderateFeedGenerator(subject, opts) {
        return (0, feed_generator_1.decideFeedGenerator)(subject, opts);
      }
      function moderateUserList(subject, opts) {
        return (0, user_list_1.decideUserList)(subject, opts);
      }
    })(moderation);
    return moderation;
  }
  var mocker = {};
  var hasRequiredMocker;
  function requireMocker() {
    if (hasRequiredMocker) return mocker;
    hasRequiredMocker = 1;
    Object.defineProperty(mocker, "__esModule", { value: true });
    mocker.mock = void 0;
    const FAKE_CID = "bafyreiclp443lavogvhj3d2ob2cxbfuscni2k5jk7bebjzg7khl3esabwq";
    mocker.mock = {
      post({ text, facets, reply, embed: embed2 }) {
        return {
          $type: "app.bsky.feed.post",
          text,
          facets,
          reply,
          embed: embed2,
          langs: ["en"],
          createdAt: (/* @__PURE__ */ new Date()).toISOString()
        };
      },
      postView({ record: record2, author, embed: embed2, replyCount, repostCount, likeCount, viewer, labels: labels2 }) {
        return {
          $type: "app.bsky.feed.defs#postView",
          uri: `at://${author.did}/app.bsky.feed.post/fake`,
          cid: FAKE_CID,
          author,
          record: record2,
          embed: embed2,
          replyCount,
          repostCount,
          likeCount,
          indexedAt: (/* @__PURE__ */ new Date()).toISOString(),
          viewer,
          labels: labels2
        };
      },
      embedRecordView({ record: record2, author, labels: labels2 }) {
        return {
          $type: "app.bsky.embed.record#view",
          record: {
            $type: "app.bsky.embed.record#viewRecord",
            uri: `at://${author.did}/app.bsky.feed.post/fake`,
            cid: FAKE_CID,
            author,
            value: record2,
            labels: labels2,
            indexedAt: (/* @__PURE__ */ new Date()).toISOString()
          }
        };
      },
      profileViewBasic({ handle: handle2, displayName, description, viewer, labels: labels2 }) {
        return {
          did: `did:web:${handle2}`,
          handle: handle2,
          displayName,
          // @ts-expect-error technically not in ProfileViewBasic but useful in some cases
          description,
          viewer,
          labels: labels2
        };
      },
      actorViewerState({ muted, mutedByList, blockedBy, blocking, blockingByList, following, followedBy }) {
        return {
          muted,
          mutedByList,
          blockedBy,
          blocking,
          blockingByList,
          following,
          followedBy
        };
      },
      listViewBasic({ name }) {
        return {
          uri: "at://did:plc:fake/app.bsky.graph.list/fake",
          cid: FAKE_CID,
          name,
          purpose: "app.bsky.graph.defs#modlist",
          indexedAt: (/* @__PURE__ */ new Date()).toISOString()
        };
      },
      replyNotification({ author, record: record2, labels: labels2 }) {
        return {
          uri: `at://${author.did}/app.bsky.feed.post/fake`,
          cid: FAKE_CID,
          author,
          reason: "reply",
          reasonSubject: `at://${author.did}/app.bsky.feed.post/fake-parent`,
          record: record2,
          isRead: false,
          indexedAt: (/* @__PURE__ */ new Date()).toISOString(),
          labels: labels2
        };
      },
      followNotification({ author, subjectDid, labels: labels2 }) {
        return {
          uri: `at://${author.did}/app.bsky.graph.follow/fake`,
          cid: FAKE_CID,
          author,
          reason: "follow",
          record: {
            $type: "app.bsky.graph.follow",
            createdAt: (/* @__PURE__ */ new Date()).toISOString(),
            subject: subjectDid
          },
          isRead: false,
          indexedAt: (/* @__PURE__ */ new Date()).toISOString(),
          labels: labels2
        };
      },
      label({ val, uri, src: src2 }) {
        return {
          src: src2 || "did:plc:fake-labeler",
          uri,
          val,
          cts: (/* @__PURE__ */ new Date()).toISOString()
        };
      }
    };
    return mocker;
  }
  var agent = {};
  var AwaitLock = {};
  var hasRequiredAwaitLock;
  function requireAwaitLock() {
    if (hasRequiredAwaitLock) return AwaitLock;
    hasRequiredAwaitLock = 1;
    var __classPrivateFieldGet = AwaitLock && AwaitLock.__classPrivateFieldGet || function(receiver, state2, kind, f) {
      if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
      if (typeof state2 === "function" ? receiver !== state2 || !f : !state2.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state2.get(receiver);
    };
    var __classPrivateFieldSet = AwaitLock && AwaitLock.__classPrivateFieldSet || function(receiver, state2, value, kind, f) {
      if (kind === "m") throw new TypeError("Private method is not writable");
      if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
      if (typeof state2 === "function" ? receiver !== state2 || !f : !state2.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state2.set(receiver, value), value;
    };
    var _AwaitLock_acquired, _AwaitLock_waitingResolvers;
    Object.defineProperty(AwaitLock, "__esModule", { value: true });
    let AwaitLock$1 = class AwaitLock {
      constructor() {
        _AwaitLock_acquired.set(this, false);
        _AwaitLock_waitingResolvers.set(this, /* @__PURE__ */ new Set());
      }
      /**
       * Whether the lock is currently acquired or not. Accessing this property does not affect the
       * status of the lock.
       */
      get acquired() {
        return __classPrivateFieldGet(this, _AwaitLock_acquired, "f");
      }
      /**
       * Acquires the lock, waiting if necessary for it to become free if it is already locked. The
       * returned promise is fulfilled once the lock is acquired.
       *
       * A timeout (in milliseconds) may be optionally provided. If the lock cannot be acquired before
       * the timeout elapses, the returned promise is rejected with an error. The behavior of invalid
       * timeout values depends on how `setTimeout` handles those values.
       *
       * After acquiring the lock, you **must** call `release` when you are done with it.
       */
      acquireAsync({ timeout } = {}) {
        if (!__classPrivateFieldGet(this, _AwaitLock_acquired, "f")) {
          __classPrivateFieldSet(this, _AwaitLock_acquired, true, "f");
          return Promise.resolve();
        }
        if (timeout == null) {
          return new Promise((resolve) => {
            __classPrivateFieldGet(this, _AwaitLock_waitingResolvers, "f").add(resolve);
          });
        }
        let resolver;
        let timer;
        return Promise.race([
          new Promise((resolve) => {
            resolver = () => {
              clearTimeout(timer);
              resolve();
            };
            __classPrivateFieldGet(this, _AwaitLock_waitingResolvers, "f").add(resolver);
          }),
          new Promise((_, reject) => {
            timer = setTimeout(() => {
              __classPrivateFieldGet(this, _AwaitLock_waitingResolvers, "f").delete(resolver);
              reject(new Error(`Timed out waiting for lock`));
            }, timeout);
          })
        ]);
      }
      /**
       * Acquires the lock if it is free and otherwise returns immediately without waiting. Returns
       * `true` if the lock was free and is now acquired, and `false` otherwise.
       *
       * This method differs from calling `acquireAsync` with a zero-millisecond timeout in that it runs
       * synchronously without waiting for the JavaScript task queue.
       */
      tryAcquire() {
        if (!__classPrivateFieldGet(this, _AwaitLock_acquired, "f")) {
          __classPrivateFieldSet(this, _AwaitLock_acquired, true, "f");
          return true;
        }
        return false;
      }
      /**
       * Releases the lock and gives it to the next waiting acquirer, if there is one. Each acquirer
       * must release the lock exactly once.
       */
      release() {
        if (!__classPrivateFieldGet(this, _AwaitLock_acquired, "f")) {
          throw new Error(`Cannot release an unacquired lock`);
        }
        if (__classPrivateFieldGet(this, _AwaitLock_waitingResolvers, "f").size > 0) {
          const [resolve] = __classPrivateFieldGet(this, _AwaitLock_waitingResolvers, "f");
          __classPrivateFieldGet(this, _AwaitLock_waitingResolvers, "f").delete(resolve);
          resolve();
        } else {
          __classPrivateFieldSet(this, _AwaitLock_acquired, false, "f");
        }
      }
    };
    AwaitLock.default = AwaitLock$1;
    _AwaitLock_acquired = /* @__PURE__ */ new WeakMap(), _AwaitLock_waitingResolvers = /* @__PURE__ */ new WeakMap();
    return AwaitLock;
  }
  var predicate = {};
  var hasRequiredPredicate;
  function requirePredicate() {
    if (hasRequiredPredicate) return predicate;
    hasRequiredPredicate = 1;
    Object.defineProperty(predicate, "__esModule", { value: true });
    predicate.isValidThreadViewPref = predicate.isValidSavedFeedsPrefV2 = predicate.isValidSavedFeedsPref = predicate.isValidPostInteractionSettingsPref = predicate.isValidPersonalDetailsPref = predicate.isValidMutedWordsPref = predicate.isValidLabelersPref = predicate.isValidInterestsPref = predicate.isValidHiddenPostsPref = predicate.isValidFeedViewPref = predicate.isValidContentLabelPref = predicate.isValidBskyAppStatePref = predicate.isValidAdultContentPref = predicate.isValidProfile = void 0;
    const index_1 = requireClient();
    const util_1 = requireUtil$5();
    predicate.isValidProfile = (0, util_1.asPredicate)(index_1.AppBskyActorProfile.validateRecord);
    predicate.isValidAdultContentPref = (0, util_1.asPredicate)(index_1.AppBskyActorDefs.validateAdultContentPref);
    predicate.isValidBskyAppStatePref = (0, util_1.asPredicate)(index_1.AppBskyActorDefs.validateBskyAppStatePref);
    predicate.isValidContentLabelPref = (0, util_1.asPredicate)(index_1.AppBskyActorDefs.validateContentLabelPref);
    predicate.isValidFeedViewPref = (0, util_1.asPredicate)(index_1.AppBskyActorDefs.validateFeedViewPref);
    predicate.isValidHiddenPostsPref = (0, util_1.asPredicate)(index_1.AppBskyActorDefs.validateHiddenPostsPref);
    predicate.isValidInterestsPref = (0, util_1.asPredicate)(index_1.AppBskyActorDefs.validateInterestsPref);
    predicate.isValidLabelersPref = (0, util_1.asPredicate)(index_1.AppBskyActorDefs.validateLabelersPref);
    predicate.isValidMutedWordsPref = (0, util_1.asPredicate)(index_1.AppBskyActorDefs.validateMutedWordsPref);
    predicate.isValidPersonalDetailsPref = (0, util_1.asPredicate)(index_1.AppBskyActorDefs.validatePersonalDetailsPref);
    predicate.isValidPostInteractionSettingsPref = (0, util_1.asPredicate)(index_1.AppBskyActorDefs.validatePostInteractionSettingsPref);
    predicate.isValidSavedFeedsPref = (0, util_1.asPredicate)(index_1.AppBskyActorDefs.validateSavedFeedsPref);
    predicate.isValidSavedFeedsPrefV2 = (0, util_1.asPredicate)(index_1.AppBskyActorDefs.validateSavedFeedsPrefV2);
    predicate.isValidThreadViewPref = (0, util_1.asPredicate)(index_1.AppBskyActorDefs.validateThreadViewPref);
    return predicate;
  }
  var hasRequiredAgent;
  function requireAgent() {
    if (hasRequiredAgent) return agent;
    hasRequiredAgent = 1;
    var __createBinding = agent && agent.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = agent && agent.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = agent && agent.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __classPrivateFieldGet = agent && agent.__classPrivateFieldGet || function(receiver, state2, kind, f) {
      if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
      if (typeof state2 === "function" ? receiver !== state2 || !f : !state2.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state2.get(receiver);
    };
    var __importDefault = agent && agent.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var _Agent_prefsLock;
    Object.defineProperty(agent, "__esModule", { value: true });
    agent.Agent = void 0;
    const await_lock_1 = __importDefault(requireAwaitLock());
    const common_web_1 = requireDist$4();
    const syntax_1 = requireDist$5();
    const xrpc_1 = requireDist$1();
    const index_1 = requireClient();
    const lexicons_1 = requireLexicons();
    const const_1 = require_const();
    const moderation_1 = requireModeration();
    const labels_1 = requireLabels();
    const predicate2 = __importStar(requirePredicate());
    const util_1 = requireUtil$4();
    const FEED_VIEW_PREF_DEFAULTS = {
      hideReplies: false,
      hideRepliesByUnfollowed: true,
      hideRepliesByLikeCount: 0,
      hideReposts: false,
      hideQuotePosts: false
    };
    const THREAD_VIEW_PREF_DEFAULTS = {
      sort: "hotness",
      prioritizeFollowedUsers: true
    };
    class Agent extends xrpc_1.XrpcClient {
      /**
       * Configures the Agent (or its sub classes) globally.
       */
      static configure(opts) {
        if (opts.appLabelers) {
          this.appLabelers = opts.appLabelers.map(util_1.asDid);
        }
      }
      /** @deprecated use `this` instead */
      get xrpc() {
        return this;
      }
      constructor(options) {
        const sessionManager = typeof options === "string" || options instanceof URL ? {
          did: void 0,
          fetchHandler: (0, xrpc_1.buildFetchHandler)(options)
        } : options;
        super((url, init) => {
          const headers = new Headers(init?.headers);
          if (this.proxy && !headers.has("atproto-proxy")) {
            headers.set("atproto-proxy", this.proxy);
          }
          headers.set("atproto-accept-labelers", [
            ...this.appLabelers.map((l) => `${l};redact`),
            ...this.labelers,
            headers.get("atproto-accept-labelers")?.trim()
          ].filter(Boolean).join(", "));
          return this.sessionManager.fetchHandler(url, { ...init, headers });
        }, lexicons_1.schemas);
        Object.defineProperty(this, "com", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: new index_1.ComNS(this)
        });
        Object.defineProperty(this, "app", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: new index_1.AppNS(this)
        });
        Object.defineProperty(this, "chat", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: new index_1.ChatNS(this)
        });
        Object.defineProperty(this, "tools", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: new index_1.ToolsNS(this)
        });
        Object.defineProperty(this, "sessionManager", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "labelers", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: []
        });
        Object.defineProperty(this, "proxy", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "uploadBlob", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: (data, opts) => this.com.atproto.repo.uploadBlob(data, opts)
        });
        Object.defineProperty(this, "resolveHandle", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: (params, opts) => this.com.atproto.identity.resolveHandle(params, opts)
        });
        Object.defineProperty(this, "updateHandle", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: (data, opts) => this.com.atproto.identity.updateHandle(data, opts)
        });
        Object.defineProperty(this, "createModerationReport", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: (data, opts) => this.com.atproto.moderation.createReport(data, opts)
        });
        Object.defineProperty(this, "getTimeline", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: (params, opts) => this.app.bsky.feed.getTimeline(params, opts)
        });
        Object.defineProperty(this, "getAuthorFeed", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: (params, opts) => this.app.bsky.feed.getAuthorFeed(params, opts)
        });
        Object.defineProperty(this, "getActorLikes", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: (params, opts) => this.app.bsky.feed.getActorLikes(params, opts)
        });
        Object.defineProperty(this, "getPostThread", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: (params, opts) => this.app.bsky.feed.getPostThread(params, opts)
        });
        Object.defineProperty(this, "getPost", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: (params) => this.app.bsky.feed.post.get(params)
        });
        Object.defineProperty(this, "getPosts", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: (params, opts) => this.app.bsky.feed.getPosts(params, opts)
        });
        Object.defineProperty(this, "getLikes", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: (params, opts) => this.app.bsky.feed.getLikes(params, opts)
        });
        Object.defineProperty(this, "getRepostedBy", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: (params, opts) => this.app.bsky.feed.getRepostedBy(params, opts)
        });
        Object.defineProperty(this, "getFollows", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: (params, opts) => this.app.bsky.graph.getFollows(params, opts)
        });
        Object.defineProperty(this, "getFollowers", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: (params, opts) => this.app.bsky.graph.getFollowers(params, opts)
        });
        Object.defineProperty(this, "getProfile", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: (params, opts) => this.app.bsky.actor.getProfile(params, opts)
        });
        Object.defineProperty(this, "getProfiles", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: (params, opts) => this.app.bsky.actor.getProfiles(params, opts)
        });
        Object.defineProperty(this, "getSuggestions", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: (params, opts) => this.app.bsky.actor.getSuggestions(params, opts)
        });
        Object.defineProperty(this, "searchActors", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: (params, opts) => this.app.bsky.actor.searchActors(params, opts)
        });
        Object.defineProperty(this, "searchActorsTypeahead", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: (params, opts) => this.app.bsky.actor.searchActorsTypeahead(params, opts)
        });
        Object.defineProperty(this, "listNotifications", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: (params, opts) => this.app.bsky.notification.listNotifications(params, opts)
        });
        Object.defineProperty(this, "countUnreadNotifications", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: (params, opts) => this.app.bsky.notification.getUnreadCount(params, opts)
        });
        Object.defineProperty(this, "getLabelers", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: (params, opts) => this.app.bsky.labeler.getServices(params, opts)
        });
        _Agent_prefsLock.set(
          this,
          new await_lock_1.default()
          /**
           * This function updates the preferences of a user and allows for a callback function to be executed
           * before the update.
           * @param cb - cb is a callback function that takes in a single parameter of type
           * AppBskyActorDefs.Preferences and returns either a boolean or void. This callback function is used to
           * update the preferences of the user. The function is called with the current preferences as an
           * argument and if the callback returns false, the preferences are not updated.
           */
        );
        this.sessionManager = sessionManager;
      }
      //#region Cloning utilities
      clone() {
        return this.copyInto(new Agent(this.sessionManager));
      }
      copyInto(inst) {
        inst.configureLabelers(this.labelers);
        inst.configureProxy(this.proxy ?? null);
        inst.clearHeaders();
        for (const [key, value] of this.headers)
          inst.setHeader(key, value);
        return inst;
      }
      withProxy(serviceType, did2) {
        const inst = this.clone();
        inst.configureProxy(`${(0, util_1.asDid)(did2)}#${serviceType}`);
        return inst;
      }
      //#endregion
      //#region ATPROTO labelers configuration utilities
      /**
       * The labelers statically configured on the class of the current instance.
       */
      get appLabelers() {
        return this.constructor.appLabelers;
      }
      configureLabelers(labelerDids) {
        this.labelers = labelerDids.map(util_1.asDid);
      }
      /** @deprecated use {@link configureLabelers} instead */
      configureLabelersHeader(labelerDids) {
        this.configureLabelers(labelerDids.filter(util_1.isDid));
      }
      configureProxy(value) {
        if (value === null)
          this.proxy = void 0;
        else if ((0, util_1.isDid)(value))
          this.proxy = value;
        else
          throw new TypeError("Invalid proxy DID");
      }
      /** @deprecated use {@link configureProxy} instead */
      configureProxyHeader(serviceType, did2) {
        if ((0, util_1.isDid)(did2))
          this.configureProxy(`${did2}#${serviceType}`);
      }
      //#endregion
      //#region Session management
      /**
       * Get the authenticated user's DID, if any.
       */
      get did() {
        return this.sessionManager.did;
      }
      /** @deprecated Use {@link Agent.assertDid} instead */
      get accountDid() {
        return this.assertDid;
      }
      /**
       * Get the authenticated user's DID, or throw an error if not authenticated.
       */
      get assertDid() {
        this.assertAuthenticated();
        return this.did;
      }
      /**
       * Assert that the user is authenticated.
       */
      assertAuthenticated() {
        if (!this.did)
          throw new Error("Not logged in");
      }
      //#endregion
      /** @deprecated use "this" instead */
      get api() {
        return this;
      }
      async getLabelDefinitions(prefs) {
        const dids = [...this.appLabelers];
        if (isBskyPrefs(prefs)) {
          dids.push(...prefs.moderationPrefs.labelers.map((l) => l.did));
        } else if (isModPrefs(prefs)) {
          dids.push(...prefs.labelers.map((l) => l.did));
        } else {
          dids.push(...prefs);
        }
        const labelers = await this.getLabelers({
          dids,
          detailed: true
        });
        const labelDefs = {};
        if (labelers.data) {
          for (const labeler of labelers.data.views) {
            labelDefs[labeler.creator.did] = (0, moderation_1.interpretLabelValueDefinitions)(labeler);
          }
        }
        return labelDefs;
      }
      async post(record2) {
        record2.createdAt || (record2.createdAt = (/* @__PURE__ */ new Date()).toISOString());
        return this.app.bsky.feed.post.create({ repo: this.accountDid }, record2);
      }
      async deletePost(postUri) {
        this.assertAuthenticated();
        const postUrip = new syntax_1.AtUri(postUri);
        return this.app.bsky.feed.post.delete({
          repo: postUrip.hostname,
          rkey: postUrip.rkey
        });
      }
      async like(uri, cid2) {
        return this.app.bsky.feed.like.create({ repo: this.accountDid }, {
          subject: { uri, cid: cid2 },
          createdAt: (/* @__PURE__ */ new Date()).toISOString()
        });
      }
      async deleteLike(likeUri) {
        this.assertAuthenticated();
        const likeUrip = new syntax_1.AtUri(likeUri);
        return this.app.bsky.feed.like.delete({
          repo: likeUrip.hostname,
          rkey: likeUrip.rkey
        });
      }
      async repost(uri, cid2) {
        return this.app.bsky.feed.repost.create({ repo: this.accountDid }, {
          subject: { uri, cid: cid2 },
          createdAt: (/* @__PURE__ */ new Date()).toISOString()
        });
      }
      async deleteRepost(repostUri) {
        this.assertAuthenticated();
        const repostUrip = new syntax_1.AtUri(repostUri);
        return this.app.bsky.feed.repost.delete({
          repo: repostUrip.hostname,
          rkey: repostUrip.rkey
        });
      }
      async follow(subjectDid) {
        return this.app.bsky.graph.follow.create({ repo: this.accountDid }, {
          subject: subjectDid,
          createdAt: (/* @__PURE__ */ new Date()).toISOString()
        });
      }
      async deleteFollow(followUri) {
        this.assertAuthenticated();
        const followUrip = new syntax_1.AtUri(followUri);
        return this.app.bsky.graph.follow.delete({
          repo: followUrip.hostname,
          rkey: followUrip.rkey
        });
      }
      /**
       * @note: Using this method will reset the whole profile record if it
       * previously contained invalid values (wrt to the profile lexicon).
       */
      async upsertProfile(updateFn) {
        const upsert = async () => {
          const repo = this.assertDid;
          const collection = "app.bsky.actor.profile";
          const existing = await this.com.atproto.repo.getRecord({ repo, collection, rkey: "self" }).catch((_) => void 0);
          const existingRecord = existing && predicate2.isValidProfile(existing.data.value) ? existing.data.value : void 0;
          const updated = await updateFn(existingRecord);
          const validation2 = index_1.AppBskyActorProfile.validateRecord({
            $type: collection,
            ...updated
          });
          if (!validation2.success) {
            throw validation2.error;
          }
          await this.com.atproto.repo.putRecord({
            repo,
            collection,
            rkey: "self",
            record: validation2.value,
            swapRecord: existing?.data.cid || null
          });
        };
        return (0, common_web_1.retry)(upsert, {
          maxRetries: 5,
          retryable: (e) => e instanceof index_1.ComAtprotoRepoPutRecord.InvalidSwapError
        });
      }
      async mute(actor) {
        return this.app.bsky.graph.muteActor({ actor });
      }
      async unmute(actor) {
        return this.app.bsky.graph.unmuteActor({ actor });
      }
      async muteModList(uri) {
        return this.app.bsky.graph.muteActorList({ list: uri });
      }
      async unmuteModList(uri) {
        return this.app.bsky.graph.unmuteActorList({ list: uri });
      }
      async blockModList(uri) {
        return this.app.bsky.graph.listblock.create({ repo: this.accountDid }, {
          subject: uri,
          createdAt: (/* @__PURE__ */ new Date()).toISOString()
        });
      }
      async unblockModList(uri) {
        const repo = this.accountDid;
        const listInfo = await this.app.bsky.graph.getList({
          list: uri,
          limit: 1
        });
        const blocked = listInfo.data.list.viewer?.blocked;
        if (blocked) {
          const { rkey } = new syntax_1.AtUri(blocked);
          return this.app.bsky.graph.listblock.delete({
            repo,
            rkey
          });
        }
      }
      async updateSeenNotifications(seenAt = (/* @__PURE__ */ new Date()).toISOString()) {
        return this.app.bsky.notification.updateSeen({ seenAt });
      }
      async getPreferences() {
        const prefs = {
          feeds: {
            saved: void 0,
            pinned: void 0
          },
          // @ts-ignore populating below
          savedFeeds: void 0,
          feedViewPrefs: {
            home: {
              ...FEED_VIEW_PREF_DEFAULTS
            }
          },
          threadViewPrefs: { ...THREAD_VIEW_PREF_DEFAULTS },
          moderationPrefs: {
            adultContentEnabled: false,
            labels: { ...labels_1.DEFAULT_LABEL_SETTINGS },
            labelers: this.appLabelers.map((did2) => ({
              did: did2,
              labels: {}
            })),
            mutedWords: [],
            hiddenPosts: []
          },
          birthDate: void 0,
          interests: {
            tags: []
          },
          bskyAppState: {
            queuedNudges: [],
            activeProgressGuide: void 0,
            nuxs: []
          },
          postInteractionSettings: {
            threadgateAllowRules: void 0,
            postgateEmbeddingRules: void 0
          }
        };
        const res = await this.app.bsky.actor.getPreferences({});
        const labelPrefs = [];
        for (const pref of res.data.preferences) {
          if (predicate2.isValidAdultContentPref(pref)) {
            prefs.moderationPrefs.adultContentEnabled = pref.enabled;
          } else if (predicate2.isValidContentLabelPref(pref)) {
            const adjustedPref = adjustLegacyContentLabelPref(pref);
            labelPrefs.push(adjustedPref);
          } else if (predicate2.isValidLabelersPref(pref)) {
            prefs.moderationPrefs.labelers = this.appLabelers.map((did2) => ({ did: did2, labels: {} })).concat(pref.labelers.map((labeler) => ({
              ...labeler,
              labels: {}
            })));
          } else if (predicate2.isValidSavedFeedsPrefV2(pref)) {
            prefs.savedFeeds = pref.items;
          } else if (predicate2.isValidSavedFeedsPref(pref)) {
            prefs.feeds.saved = pref.saved;
            prefs.feeds.pinned = pref.pinned;
          } else if (predicate2.isValidPersonalDetailsPref(pref)) {
            if (pref.birthDate) {
              prefs.birthDate = new Date(pref.birthDate);
            }
          } else if (predicate2.isValidFeedViewPref(pref)) {
            const { $type: _, feed, ...v } = pref;
            prefs.feedViewPrefs[feed] = { ...FEED_VIEW_PREF_DEFAULTS, ...v };
          } else if (predicate2.isValidThreadViewPref(pref)) {
            const { $type: _, ...v } = pref;
            prefs.threadViewPrefs = { ...prefs.threadViewPrefs, ...v };
          } else if (predicate2.isValidInterestsPref(pref)) {
            const { $type: _, ...v } = pref;
            prefs.interests = { ...prefs.interests, ...v };
          } else if (predicate2.isValidMutedWordsPref(pref)) {
            prefs.moderationPrefs.mutedWords = pref.items;
            if (prefs.moderationPrefs.mutedWords.length) {
              prefs.moderationPrefs.mutedWords = prefs.moderationPrefs.mutedWords.map((word) => {
                word.actorTarget = word.actorTarget || "all";
                return word;
              });
            }
          } else if (predicate2.isValidHiddenPostsPref(pref)) {
            prefs.moderationPrefs.hiddenPosts = pref.items;
          } else if (predicate2.isValidBskyAppStatePref(pref)) {
            prefs.bskyAppState.queuedNudges = pref.queuedNudges || [];
            prefs.bskyAppState.activeProgressGuide = pref.activeProgressGuide;
            prefs.bskyAppState.nuxs = pref.nuxs || [];
          } else if (predicate2.isValidPostInteractionSettingsPref(pref)) {
            prefs.postInteractionSettings.threadgateAllowRules = pref.threadgateAllowRules;
            prefs.postInteractionSettings.postgateEmbeddingRules = pref.postgateEmbeddingRules;
          }
        }
        if (prefs.savedFeeds == null) {
          const { saved, pinned } = prefs.feeds;
          if (saved && pinned) {
            const uniqueMigratedSavedFeeds = /* @__PURE__ */ new Map();
            uniqueMigratedSavedFeeds.set("timeline", {
              id: common_web_1.TID.nextStr(),
              type: "timeline",
              value: "following",
              pinned: true
            });
            for (const uri of pinned) {
              const type = (0, util_1.getSavedFeedType)(uri);
              if (type === "unknown")
                continue;
              uniqueMigratedSavedFeeds.set(uri, {
                id: common_web_1.TID.nextStr(),
                type,
                value: uri,
                pinned: true
              });
            }
            for (const uri of saved) {
              if (!uniqueMigratedSavedFeeds.has(uri)) {
                const type = (0, util_1.getSavedFeedType)(uri);
                if (type === "unknown")
                  continue;
                uniqueMigratedSavedFeeds.set(uri, {
                  id: common_web_1.TID.nextStr(),
                  type,
                  value: uri,
                  pinned: false
                });
              }
            }
            prefs.savedFeeds = Array.from(uniqueMigratedSavedFeeds.values());
          } else {
            prefs.savedFeeds = [
              {
                id: common_web_1.TID.nextStr(),
                type: "timeline",
                value: "following",
                pinned: true
              }
            ];
          }
          await this.overwriteSavedFeeds(prefs.savedFeeds);
        }
        for (const pref of labelPrefs) {
          if (pref.labelerDid) {
            const labeler = prefs.moderationPrefs.labelers.find((labeler2) => labeler2.did === pref.labelerDid);
            if (!labeler)
              continue;
            labeler.labels[pref.label] = pref.visibility;
          } else {
            prefs.moderationPrefs.labels[pref.label] = pref.visibility;
          }
        }
        prefs.moderationPrefs.labels = remapLegacyLabels(prefs.moderationPrefs.labels);
        this.configureLabelers(prefsArrayToLabelerDids(res.data.preferences));
        return prefs;
      }
      async overwriteSavedFeeds(savedFeeds) {
        savedFeeds.forEach(util_1.validateSavedFeed);
        const uniqueSavedFeeds = /* @__PURE__ */ new Map();
        savedFeeds.forEach((feed) => {
          if (uniqueSavedFeeds.has(feed.id)) {
            uniqueSavedFeeds.delete(feed.id);
          }
          uniqueSavedFeeds.set(feed.id, feed);
        });
        return this.updateSavedFeedsV2Preferences(() => Array.from(uniqueSavedFeeds.values()));
      }
      async updateSavedFeeds(savedFeedsToUpdate) {
        savedFeedsToUpdate.map(util_1.validateSavedFeed);
        return this.updateSavedFeedsV2Preferences((savedFeeds) => {
          return savedFeeds.map((savedFeed) => {
            const updatedVersion = savedFeedsToUpdate.find((updated) => savedFeed.id === updated.id);
            if (updatedVersion) {
              return {
                ...savedFeed,
                // only update pinned
                pinned: updatedVersion.pinned
              };
            }
            return savedFeed;
          });
        });
      }
      async addSavedFeeds(savedFeeds) {
        const toSave = savedFeeds.map((f) => ({
          ...f,
          id: common_web_1.TID.nextStr()
        }));
        toSave.forEach(util_1.validateSavedFeed);
        return this.updateSavedFeedsV2Preferences((savedFeeds2) => [
          ...savedFeeds2,
          ...toSave
        ]);
      }
      async removeSavedFeeds(ids) {
        return this.updateSavedFeedsV2Preferences((savedFeeds) => [
          ...savedFeeds.filter((feed) => !ids.find((id) => feed.id === id))
        ]);
      }
      /**
       * @deprecated use `overwriteSavedFeeds`
       */
      async setSavedFeeds(saved, pinned) {
        return this.updateFeedPreferences(() => ({
          saved,
          pinned
        }));
      }
      /**
       * @deprecated use `addSavedFeeds`
       */
      async addSavedFeed(v) {
        return this.updateFeedPreferences((saved, pinned) => ({
          saved: [...saved.filter((uri) => uri !== v), v],
          pinned
        }));
      }
      /**
       * @deprecated use `removeSavedFeeds`
       */
      async removeSavedFeed(v) {
        return this.updateFeedPreferences((saved, pinned) => ({
          saved: saved.filter((uri) => uri !== v),
          pinned: pinned.filter((uri) => uri !== v)
        }));
      }
      /**
       * @deprecated use `addSavedFeeds` or `updateSavedFeeds`
       */
      async addPinnedFeed(v) {
        return this.updateFeedPreferences((saved, pinned) => ({
          saved: [...saved.filter((uri) => uri !== v), v],
          pinned: [...pinned.filter((uri) => uri !== v), v]
        }));
      }
      /**
       * @deprecated use `updateSavedFeeds` or `removeSavedFeeds`
       */
      async removePinnedFeed(v) {
        return this.updateFeedPreferences((saved, pinned) => ({
          saved,
          pinned: pinned.filter((uri) => uri !== v)
        }));
      }
      async setAdultContentEnabled(v) {
        await this.updatePreferences((prefs) => {
          const adultContentPref = prefs.findLast(predicate2.isValidAdultContentPref) || {
            $type: "app.bsky.actor.defs#adultContentPref",
            enabled: v
          };
          adultContentPref.enabled = v;
          return prefs.filter((pref) => !index_1.AppBskyActorDefs.isAdultContentPref(pref)).concat(adultContentPref);
        });
      }
      async setContentLabelPref(key, value, labelerDid) {
        if (labelerDid) {
          (0, syntax_1.ensureValidDid)(labelerDid);
        }
        await this.updatePreferences((prefs) => {
          const labelPref = prefs.filter(predicate2.isValidContentLabelPref).findLast((pref) => pref.label === key && pref.labelerDid === labelerDid) || {
            $type: "app.bsky.actor.defs#contentLabelPref",
            label: key,
            labelerDid,
            visibility: value
          };
          labelPref.visibility = value;
          let legacyLabelPref;
          if (index_1.AppBskyActorDefs.isContentLabelPref(labelPref)) {
            if (!labelPref.labelerDid) {
              const legacyLabelValue = {
                "graphic-media": "gore",
                porn: "nsfw",
                sexual: "suggestive",
                // Protect against using toString, hasOwnProperty, etc. as a label:
                __proto__: null
              }[labelPref.label];
              if (legacyLabelValue) {
                legacyLabelPref = prefs.filter(predicate2.isValidContentLabelPref).findLast((pref) => pref.label === legacyLabelValue && pref.labelerDid === void 0) || {
                  $type: "app.bsky.actor.defs#contentLabelPref",
                  label: legacyLabelValue,
                  labelerDid: void 0,
                  visibility: value
                };
                legacyLabelPref.visibility = value;
              }
            }
          }
          return prefs.filter((pref) => !index_1.AppBskyActorDefs.isContentLabelPref(pref) || !(pref.label === key && pref.labelerDid === labelerDid)).concat(labelPref).filter((pref) => {
            if (!legacyLabelPref)
              return true;
            return !index_1.AppBskyActorDefs.isContentLabelPref(pref) || !(pref.label === legacyLabelPref.label && pref.labelerDid === void 0);
          }).concat(legacyLabelPref ? [legacyLabelPref] : []);
        });
      }
      async addLabeler(did2) {
        const prefs = await this.updatePreferences((prefs2) => {
          const labelersPref = prefs2.findLast(predicate2.isValidLabelersPref) || {
            $type: "app.bsky.actor.defs#labelersPref",
            labelers: []
          };
          if (!labelersPref.labelers.some((labeler) => labeler.did === did2)) {
            labelersPref.labelers.push({ did: did2 });
          }
          return prefs2.filter((pref) => !index_1.AppBskyActorDefs.isLabelersPref(pref)).concat(labelersPref);
        });
        this.configureLabelers(prefsArrayToLabelerDids(prefs));
      }
      async removeLabeler(did2) {
        const prefs = await this.updatePreferences((prefs2) => {
          const labelersPref = prefs2.findLast(predicate2.isValidLabelersPref) || {
            $type: "app.bsky.actor.defs#labelersPref",
            labelers: []
          };
          labelersPref.labelers = labelersPref.labelers.filter((l) => l.did !== did2);
          return prefs2.filter((pref) => !index_1.AppBskyActorDefs.isLabelersPref(pref)).concat(labelersPref);
        });
        this.configureLabelers(prefsArrayToLabelerDids(prefs));
      }
      async setPersonalDetails({ birthDate }) {
        await this.updatePreferences((prefs) => {
          const personalDetailsPref = prefs.findLast(predicate2.isValidPersonalDetailsPref) || {
            $type: "app.bsky.actor.defs#personalDetailsPref"
          };
          personalDetailsPref.birthDate = birthDate instanceof Date ? birthDate.toISOString() : birthDate;
          return prefs.filter((pref) => !index_1.AppBskyActorDefs.isPersonalDetailsPref(pref)).concat(personalDetailsPref);
        });
      }
      async setFeedViewPrefs(feed, pref) {
        await this.updatePreferences((prefs) => {
          const existing = prefs.filter(predicate2.isValidFeedViewPref).findLast((pref2) => pref2.feed === feed);
          return prefs.filter((p) => !index_1.AppBskyActorDefs.isFeedViewPref(p) || p.feed !== feed).concat({
            ...existing,
            ...pref,
            $type: "app.bsky.actor.defs#feedViewPref",
            feed
          });
        });
      }
      async setThreadViewPrefs(pref) {
        await this.updatePreferences((prefs) => {
          const existing = prefs.findLast(predicate2.isValidThreadViewPref);
          return prefs.filter((p) => !index_1.AppBskyActorDefs.isThreadViewPref(p)).concat({
            ...existing,
            ...pref,
            $type: "app.bsky.actor.defs#threadViewPref"
          });
        });
      }
      async setInterestsPref(pref) {
        await this.updatePreferences((prefs) => {
          const existing = prefs.findLast(predicate2.isValidInterestsPref);
          return prefs.filter((p) => !index_1.AppBskyActorDefs.isInterestsPref(p)).concat({
            ...existing,
            ...pref,
            $type: "app.bsky.actor.defs#interestsPref"
          });
        });
      }
      /**
       * Add a muted word to user preferences.
       */
      async addMutedWord(mutedWord) {
        const sanitizedValue = (0, util_1.sanitizeMutedWordValue)(mutedWord.value);
        if (!sanitizedValue)
          return;
        await this.updatePreferences((prefs) => {
          let mutedWordsPref = prefs.findLast(predicate2.isValidMutedWordsPref);
          const newMutedWord = {
            id: common_web_1.TID.nextStr(),
            value: sanitizedValue,
            targets: mutedWord.targets || [],
            actorTarget: mutedWord.actorTarget || "all",
            expiresAt: mutedWord.expiresAt || void 0
          };
          if (mutedWordsPref) {
            mutedWordsPref.items.push(newMutedWord);
            mutedWordsPref.items = migrateLegacyMutedWordsItems(mutedWordsPref.items);
          } else {
            mutedWordsPref = {
              $type: "app.bsky.actor.defs#mutedWordsPref",
              items: [newMutedWord]
            };
          }
          return prefs.filter((p) => !index_1.AppBskyActorDefs.isMutedWordsPref(p)).concat(mutedWordsPref);
        });
      }
      /**
       * Convenience method to add muted words to user preferences
       */
      async addMutedWords(newMutedWords) {
        await Promise.all(newMutedWords.map((word) => this.addMutedWord(word)));
      }
      /**
       * @deprecated use `addMutedWords` or `addMutedWord` instead
       */
      async upsertMutedWords(mutedWords) {
        await this.addMutedWords(mutedWords);
      }
      /**
       * Update a muted word in user preferences.
       */
      async updateMutedWord(mutedWord) {
        await this.updatePreferences((prefs) => {
          const mutedWordsPref = prefs.findLast(predicate2.isValidMutedWordsPref);
          if (mutedWordsPref) {
            mutedWordsPref.items = mutedWordsPref.items.map((existingItem) => {
              const match2 = matchMutedWord(existingItem, mutedWord);
              if (match2) {
                const updated = {
                  ...existingItem,
                  ...mutedWord
                };
                return {
                  id: existingItem.id || common_web_1.TID.nextStr(),
                  value: (0, util_1.sanitizeMutedWordValue)(updated.value) || existingItem.value,
                  targets: updated.targets || [],
                  actorTarget: updated.actorTarget || "all",
                  expiresAt: updated.expiresAt || void 0
                };
              } else {
                return existingItem;
              }
            });
            mutedWordsPref.items = migrateLegacyMutedWordsItems(mutedWordsPref.items);
            return prefs.filter((p) => !index_1.AppBskyActorDefs.isMutedWordsPref(p)).concat(mutedWordsPref);
          }
          return prefs;
        });
      }
      /**
       * Remove a muted word from user preferences.
       */
      async removeMutedWord(mutedWord) {
        await this.updatePreferences((prefs) => {
          const mutedWordsPref = prefs.findLast(predicate2.isValidMutedWordsPref);
          if (mutedWordsPref) {
            for (let i = 0; i < mutedWordsPref.items.length; i++) {
              const match2 = matchMutedWord(mutedWordsPref.items[i], mutedWord);
              if (match2) {
                mutedWordsPref.items.splice(i, 1);
                break;
              }
            }
            mutedWordsPref.items = migrateLegacyMutedWordsItems(mutedWordsPref.items);
            return prefs.filter((p) => !index_1.AppBskyActorDefs.isMutedWordsPref(p)).concat(mutedWordsPref);
          }
          return prefs;
        });
      }
      /**
       * Convenience method to remove muted words from user preferences
       */
      async removeMutedWords(mutedWords) {
        await Promise.all(mutedWords.map((word) => this.removeMutedWord(word)));
      }
      async hidePost(postUri) {
        await this.updateHiddenPost(postUri, "hide");
      }
      async unhidePost(postUri) {
        await this.updateHiddenPost(postUri, "unhide");
      }
      async bskyAppQueueNudges(nudges) {
        await this.updatePreferences((prefs) => {
          const pref = prefs.findLast(predicate2.isValidBskyAppStatePref) || {
            $type: "app.bsky.actor.defs#bskyAppStatePref"
          };
          pref.queuedNudges = (pref.queuedNudges || []).concat(nudges);
          return prefs.filter((p) => !index_1.AppBskyActorDefs.isBskyAppStatePref(p)).concat(pref);
        });
      }
      async bskyAppDismissNudges(nudges) {
        await this.updatePreferences((prefs) => {
          const pref = prefs.findLast(predicate2.isValidBskyAppStatePref) || {
            $type: "app.bsky.actor.defs#bskyAppStatePref"
          };
          nudges = Array.isArray(nudges) ? nudges : [nudges];
          pref.queuedNudges = (pref.queuedNudges || []).filter((nudge) => !nudges.includes(nudge));
          return prefs.filter((p) => !index_1.AppBskyActorDefs.isBskyAppStatePref(p)).concat(pref);
        });
      }
      async bskyAppSetActiveProgressGuide(guide) {
        if (guide) {
          const result = index_1.AppBskyActorDefs.validateBskyAppProgressGuide(guide);
          if (!result.success)
            throw result.error;
        }
        await this.updatePreferences((prefs) => {
          const pref = prefs.findLast(predicate2.isValidBskyAppStatePref) || {
            $type: "app.bsky.actor.defs#bskyAppStatePref"
          };
          pref.activeProgressGuide = guide;
          return prefs.filter((p) => !index_1.AppBskyActorDefs.isBskyAppStatePref(p)).concat(pref);
        });
      }
      /**
       * Insert or update a NUX in user prefs
       */
      async bskyAppUpsertNux(nux) {
        (0, util_1.validateNux)(nux);
        await this.updatePreferences((prefs) => {
          const pref = prefs.findLast(predicate2.isValidBskyAppStatePref) || {
            $type: "app.bsky.actor.defs#bskyAppStatePref"
          };
          pref.nuxs = pref.nuxs || [];
          const existing = pref.nuxs?.find((n) => {
            return n.id === nux.id;
          });
          let next;
          if (existing) {
            next = {
              id: existing.id,
              completed: nux.completed,
              data: nux.data,
              expiresAt: nux.expiresAt
            };
          } else {
            next = nux;
          }
          pref.nuxs = pref.nuxs.filter((n) => n.id !== nux.id).concat(next);
          return prefs.filter((p) => !index_1.AppBskyActorDefs.isBskyAppStatePref(p)).concat(pref);
        });
      }
      /**
       * Removes NUXs from user preferences.
       */
      async bskyAppRemoveNuxs(ids) {
        await this.updatePreferences((prefs) => {
          const pref = prefs.findLast(predicate2.isValidBskyAppStatePref) || {
            $type: "app.bsky.actor.defs#bskyAppStatePref"
          };
          pref.nuxs = (pref.nuxs || []).filter((nux) => !ids.includes(nux.id));
          return prefs.filter((p) => !index_1.AppBskyActorDefs.isBskyAppStatePref(p)).concat(pref);
        });
      }
      async setPostInteractionSettings(settings) {
        const result = index_1.AppBskyActorDefs.validatePostInteractionSettingsPref(settings);
        if (!result.success)
          throw result.error;
        await this.updatePreferences((prefs) => {
          const pref = prefs.findLast(predicate2.isValidPostInteractionSettingsPref) || {
            $type: "app.bsky.actor.defs#postInteractionSettingsPref"
          };
          pref.threadgateAllowRules = settings.threadgateAllowRules;
          pref.postgateEmbeddingRules = settings.postgateEmbeddingRules;
          return prefs.filter((p) => !index_1.AppBskyActorDefs.isPostInteractionSettingsPref(p)).concat(pref);
        });
      }
      /**
       * This function updates the preferences of a user and allows for a callback function to be executed
       * before the update.
       * @param cb - cb is a callback function that takes in a single parameter of type
       * AppBskyActorDefs.Preferences and returns either a boolean or void. This callback function is used to
       * update the preferences of the user. The function is called with the current preferences as an
       * argument and if the callback returns false, the preferences are not updated.
       */
      async updatePreferences(cb) {
        try {
          await __classPrivateFieldGet(this, _Agent_prefsLock, "f").acquireAsync();
          const res = await this.app.bsky.actor.getPreferences({});
          const newPrefs = cb(res.data.preferences);
          if (newPrefs === false) {
            return res.data.preferences;
          }
          await this.app.bsky.actor.putPreferences({
            preferences: newPrefs
          });
          return newPrefs;
        } finally {
          __classPrivateFieldGet(this, _Agent_prefsLock, "f").release();
        }
      }
      async updateHiddenPost(postUri, action) {
        await this.updatePreferences((prefs) => {
          const pref = prefs.findLast(predicate2.isValidHiddenPostsPref) || {
            $type: "app.bsky.actor.defs#hiddenPostsPref",
            items: []
          };
          const hiddenItems = new Set(pref.items);
          if (action === "hide")
            hiddenItems.add(postUri);
          else
            hiddenItems.delete(postUri);
          pref.items = [...hiddenItems];
          return prefs.filter((p) => !index_1.AppBskyActorDefs.isHiddenPostsPref(p)).concat(pref);
        });
      }
      /**
       * A helper specifically for updating feed preferences
       */
      async updateFeedPreferences(cb) {
        let res;
        await this.updatePreferences((prefs) => {
          const feedsPref = prefs.findLast(predicate2.isValidSavedFeedsPref) || {
            $type: "app.bsky.actor.defs#savedFeedsPref",
            saved: [],
            pinned: []
          };
          res = cb(feedsPref.saved, feedsPref.pinned);
          feedsPref.saved = res.saved;
          feedsPref.pinned = res.pinned;
          return prefs.filter((pref) => !index_1.AppBskyActorDefs.isSavedFeedsPref(pref)).concat(feedsPref);
        });
        return res;
      }
      async updateSavedFeedsV2Preferences(cb) {
        let maybeMutatedSavedFeeds = [];
        await this.updatePreferences((prefs) => {
          const existingV2Pref = prefs.findLast(predicate2.isValidSavedFeedsPrefV2) || {
            $type: "app.bsky.actor.defs#savedFeedsPrefV2",
            items: []
          };
          const newSavedFeeds = cb(existingV2Pref.items);
          existingV2Pref.items = [...newSavedFeeds].sort((a, b) => (
            // @NOTE: preserve order of items with the same pinned status
            a.pinned === b.pinned ? 0 : a.pinned ? -1 : 1
          ));
          maybeMutatedSavedFeeds = newSavedFeeds;
          let updatedPrefs = prefs.filter((pref) => !index_1.AppBskyActorDefs.isSavedFeedsPrefV2(pref)).concat(existingV2Pref);
          let existingV1Pref = prefs.findLast(predicate2.isValidSavedFeedsPref);
          if (existingV1Pref) {
            const { saved, pinned } = existingV1Pref;
            const v2Compat = (0, util_1.savedFeedsToUriArrays)(
              // v1 only supports feeds and lists
              existingV2Pref.items.filter((i) => ["feed", "list"].includes(i.type))
            );
            existingV1Pref = {
              ...existingV1Pref,
              saved: Array.from(/* @__PURE__ */ new Set([...saved, ...v2Compat.saved])),
              pinned: Array.from(/* @__PURE__ */ new Set([...pinned, ...v2Compat.pinned]))
            };
            updatedPrefs = updatedPrefs.filter((pref) => !index_1.AppBskyActorDefs.isSavedFeedsPref(pref)).concat(existingV1Pref);
          }
          return updatedPrefs;
        });
        return maybeMutatedSavedFeeds;
      }
    }
    agent.Agent = Agent;
    _Agent_prefsLock = /* @__PURE__ */ new WeakMap();
    Object.defineProperty(Agent, "appLabelers", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: [const_1.BSKY_LABELER_DID]
    });
    function adjustLegacyContentLabelPref(pref) {
      let visibility = pref.visibility;
      if (visibility === "show") {
        visibility = "ignore";
      }
      return { ...pref, visibility };
    }
    function remapLegacyLabels(labels2) {
      const _labels = { ...labels2 };
      const legacyToNewMap = {
        gore: "graphic-media",
        nsfw: "porn",
        suggestive: "sexual"
      };
      for (const labelName in _labels) {
        const newLabelName = legacyToNewMap[labelName];
        if (newLabelName) {
          _labels[newLabelName] = _labels[labelName];
        }
      }
      return _labels;
    }
    function prefsArrayToLabelerDids(prefs) {
      const labelersPref = prefs.findLast(predicate2.isValidLabelersPref);
      let dids = [];
      if (labelersPref) {
        dids = labelersPref.labelers.map((labeler) => labeler.did);
      }
      return dids;
    }
    function isBskyPrefs(v) {
      return v && typeof v === "object" && "moderationPrefs" in v && isModPrefs(v.moderationPrefs);
    }
    function isModPrefs(v) {
      return v && typeof v === "object" && "labelers" in v;
    }
    function migrateLegacyMutedWordsItems(items) {
      return items.map((item) => ({
        ...item,
        id: item.id || common_web_1.TID.nextStr()
      }));
    }
    function matchMutedWord(existingWord, newWord) {
      const existingId = existingWord.id;
      const matchById = existingId && existingId === newWord.id;
      const legacyMatchByValue = !existingId && existingWord.value === newWord.value;
      return matchById || legacyMatchByValue;
    }
    return agent;
  }
  var atpAgent = {};
  var hasRequiredAtpAgent;
  function requireAtpAgent() {
    if (hasRequiredAtpAgent) return atpAgent;
    hasRequiredAtpAgent = 1;
    Object.defineProperty(atpAgent, "__esModule", { value: true });
    atpAgent.CredentialSession = atpAgent.AtpAgent = void 0;
    const common_web_1 = requireDist$4();
    const xrpc_1 = requireDist$1();
    const agent_1 = requireAgent();
    const client_1 = requireClient();
    const lexicons_1 = requireLexicons();
    const ReadableStream = globalThis.ReadableStream;
    class AtpAgent extends agent_1.Agent {
      constructor(options) {
        const sessionManager = options instanceof CredentialSession ? options : new CredentialSession(new URL(options.service), options.fetch, options.persistSession);
        super(sessionManager);
        Object.defineProperty(this, "sessionManager", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.sessionManager = sessionManager;
        if (!(options instanceof CredentialSession) && options.headers) {
          for (const [key, value] of options.headers) {
            this.setHeader(key, value);
          }
        }
      }
      clone() {
        return this.copyInto(new AtpAgent(this.sessionManager));
      }
      get session() {
        return this.sessionManager.session;
      }
      get hasSession() {
        return this.sessionManager.hasSession;
      }
      get did() {
        return this.sessionManager.did;
      }
      get serviceUrl() {
        return this.sessionManager.serviceUrl;
      }
      get pdsUrl() {
        return this.sessionManager.pdsUrl;
      }
      get dispatchUrl() {
        return this.sessionManager.dispatchUrl;
      }
      /** @deprecated use {@link serviceUrl} instead */
      get service() {
        return this.serviceUrl;
      }
      get persistSession() {
        throw new Error('Cannot set persistSession directly. "persistSession" is defined through the constructor and will be invoked automatically when session data changes.');
      }
      set persistSession(v) {
        throw new Error('Cannot set persistSession directly. "persistSession" must be defined in the constructor and can no longer be changed.');
      }
      /** @deprecated use {@link AtpAgent.serviceUrl} instead */
      getServiceUrl() {
        return this.serviceUrl;
      }
      async resumeSession(session) {
        return this.sessionManager.resumeSession(session);
      }
      async createAccount(data, opts) {
        return this.sessionManager.createAccount(data, opts);
      }
      async login(opts) {
        return this.sessionManager.login(opts);
      }
      async logout() {
        return this.sessionManager.logout();
      }
    }
    atpAgent.AtpAgent = AtpAgent;
    class CredentialSession {
      constructor(serviceUrl, fetch2 = globalThis.fetch, persistSession) {
        Object.defineProperty(this, "serviceUrl", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: serviceUrl
        });
        Object.defineProperty(this, "fetch", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: fetch2
        });
        Object.defineProperty(this, "persistSession", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: persistSession
        });
        Object.defineProperty(this, "pdsUrl", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "session", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "refreshSessionPromise", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "server", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: new client_1.ComAtprotoServerNS(
            // Note that the use of the codegen "schemas" (to instantiate `this.api`),
            // as well as the use of `ComAtprotoServerNS` will cause this class to
            // reference (way) more code than it actually needs. It is not possible,
            // with the current state of the codegen, to generate a client that only
            // includes the methods that are actually used by this class. This is a
            // known limitation that should be addressed in a future version of the
            // codegen.
            new xrpc_1.XrpcClient((url, init) => {
              return (0, this.fetch)(new URL(url, this.serviceUrl), init);
            }, lexicons_1.schemas)
          )
        });
      }
      get did() {
        return this.session?.did;
      }
      get dispatchUrl() {
        return this.pdsUrl || this.serviceUrl;
      }
      get hasSession() {
        return !!this.session;
      }
      /**
       * Sets a WhatWG "fetch()" function to be used for making HTTP requests.
       */
      setFetch(fetch2 = globalThis.fetch) {
        this.fetch = fetch2;
      }
      async fetchHandler(url, init) {
        await this.refreshSessionPromise;
        const initialUri = new URL(url, this.dispatchUrl);
        const initialReq = new Request(initialUri, init);
        const initialToken = this.session?.accessJwt;
        if (!initialToken || initialReq.headers.has("authorization")) {
          return (0, this.fetch)(initialReq);
        }
        initialReq.headers.set("authorization", `Bearer ${initialToken}`);
        const initialRes = await (0, this.fetch)(initialReq);
        if (!this.session?.refreshJwt) {
          return initialRes;
        }
        const isExpiredToken = await isErrorResponse(initialRes, [400], ["ExpiredToken"]);
        if (!isExpiredToken) {
          return initialRes;
        }
        try {
          await this.refreshSession();
        } catch {
          return initialRes;
        }
        if (init?.signal?.aborted) {
          return initialRes;
        }
        if (ReadableStream && init?.body instanceof ReadableStream) {
          return initialRes;
        }
        const updatedToken = this.session?.accessJwt;
        if (!updatedToken || updatedToken === initialToken) {
          return initialRes;
        }
        await initialRes.body?.cancel();
        const updatedUri = new URL(url, this.dispatchUrl);
        const updatedReq = new Request(updatedUri, init);
        updatedReq.headers.set("authorization", `Bearer ${updatedToken}`);
        return await (0, this.fetch)(updatedReq);
      }
      /**
       * Create a new account and hydrate its session in this agent.
       */
      async createAccount(data, opts) {
        try {
          const res = await this.server.createAccount(data, opts);
          this.session = {
            accessJwt: res.data.accessJwt,
            refreshJwt: res.data.refreshJwt,
            handle: res.data.handle,
            did: res.data.did,
            email: data.email,
            emailConfirmed: false,
            emailAuthFactor: false,
            active: true
          };
          this.persistSession?.("create", this.session);
          this._updateApiEndpoint(res.data.didDoc);
          return res;
        } catch (e) {
          this.session = void 0;
          this.persistSession?.("create-failed", void 0);
          throw e;
        }
      }
      /**
       * Start a new session with this agent.
       */
      async login(opts) {
        try {
          const res = await this.server.createSession({
            identifier: opts.identifier,
            password: opts.password,
            authFactorToken: opts.authFactorToken,
            allowTakendown: opts.allowTakendown
          });
          this.session = {
            accessJwt: res.data.accessJwt,
            refreshJwt: res.data.refreshJwt,
            handle: res.data.handle,
            did: res.data.did,
            email: res.data.email,
            emailConfirmed: res.data.emailConfirmed,
            emailAuthFactor: res.data.emailAuthFactor,
            active: res.data.active ?? true,
            status: res.data.status
          };
          this._updateApiEndpoint(res.data.didDoc);
          this.persistSession?.("create", this.session);
          return res;
        } catch (e) {
          this.session = void 0;
          this.persistSession?.("create-failed", void 0);
          throw e;
        }
      }
      async logout() {
        if (this.session) {
          try {
            await this.server.deleteSession(void 0, {
              headers: {
                authorization: `Bearer ${this.session.refreshJwt}`
              }
            });
          } catch {
          } finally {
            this.session = void 0;
            this.persistSession?.("expired", void 0);
          }
        }
      }
      /**
       * Resume a pre-existing session with this agent.
       */
      async resumeSession(session) {
        this.session = session;
        try {
          const res = await this.server.getSession(void 0, {
            headers: { authorization: `Bearer ${session.accessJwt}` }
          }).catch(async (err) => {
            if (err instanceof xrpc_1.XRPCError && ["ExpiredToken", "InvalidToken"].includes(err.error) && session.refreshJwt) {
              try {
                const res2 = await this.server.refreshSession(void 0, {
                  headers: { authorization: `Bearer ${session.refreshJwt}` }
                });
                session.accessJwt = res2.data.accessJwt;
                session.refreshJwt = res2.data.refreshJwt;
                return this.server.getSession(void 0, {
                  headers: { authorization: `Bearer ${session.accessJwt}` }
                });
              } catch {
              }
            }
            throw err;
          });
          if (res.data.did !== session.did) {
            throw new xrpc_1.XRPCError(xrpc_1.ResponseType.InvalidRequest, "Invalid session", "InvalidDID");
          }
          session.email = res.data.email;
          session.handle = res.data.handle;
          session.emailConfirmed = res.data.emailConfirmed;
          session.emailAuthFactor = res.data.emailAuthFactor;
          session.active = res.data.active ?? true;
          session.status = res.data.status;
          if (this.session === session) {
            this._updateApiEndpoint(res.data.didDoc);
            this.persistSession?.("update", session);
          }
          return res;
        } catch (err) {
          if (this.session === session) {
            this.session = void 0;
            this.persistSession?.(err instanceof xrpc_1.XRPCError && ["ExpiredToken", "InvalidToken"].includes(err.error) ? "expired" : "network-error", void 0);
          }
          throw err;
        }
      }
      /**
       * Internal helper to refresh sessions
       * - Wraps the actual implementation in a promise-guard to ensure only
       *   one refresh is attempted at a time.
       */
      async refreshSession() {
        return this.refreshSessionPromise || (this.refreshSessionPromise = this._refreshSessionInner().finally(() => {
          this.refreshSessionPromise = void 0;
        }));
      }
      /**
       * Internal helper to refresh sessions (actual behavior)
       */
      async _refreshSessionInner() {
        if (!this.session?.refreshJwt) {
          return;
        }
        try {
          const res = await this.server.refreshSession(void 0, {
            headers: { authorization: `Bearer ${this.session.refreshJwt}` }
          });
          this.session = {
            ...this.session,
            accessJwt: res.data.accessJwt,
            refreshJwt: res.data.refreshJwt,
            handle: res.data.handle,
            did: res.data.did
          };
          this._updateApiEndpoint(res.data.didDoc);
          this.persistSession?.("update", this.session);
        } catch (err) {
          if (err instanceof xrpc_1.XRPCError && err.error && ["ExpiredToken", "InvalidToken"].includes(err.error)) {
            this.session = void 0;
            this.persistSession?.("expired", void 0);
          }
        }
      }
      /**
       * Helper to update the pds endpoint dynamically.
       *
       * The session methods (create, resume, refresh) may respond with the user's
       * did document which contains the user's canonical PDS endpoint. That endpoint
       * may differ from the endpoint used to contact the server. We capture that
       * PDS endpoint and update the client to use that given endpoint for future
       * requests. (This helps ensure smooth migrations between PDSes, especially
       * when the PDSes are operated by a single org.)
       */
      _updateApiEndpoint(didDoc2) {
        if ((0, common_web_1.isValidDidDoc)(didDoc2)) {
          const endpoint = (0, common_web_1.getPdsEndpoint)(didDoc2);
          this.pdsUrl = endpoint ? new URL(endpoint) : void 0;
        } else {
          this.pdsUrl = void 0;
        }
      }
    }
    atpAgent.CredentialSession = CredentialSession;
    function isErrorObject(v) {
      return xrpc_1.errorResponseBody.safeParse(v).success;
    }
    async function isErrorResponse(response, status, errorNames) {
      if (!status.includes(response.status))
        return false;
      try {
        const json = await peekJson(response, 10 * 1024);
        return isErrorObject(json) && errorNames.includes(json.error);
      } catch (err) {
        return false;
      }
    }
    async function peekJson(response, maxSize = Infinity) {
      if (extractType(response) !== "application/json")
        throw new Error("Not JSON");
      if (extractLength(response) > maxSize)
        throw new Error("Response too large");
      return response.clone().json();
    }
    function extractLength({ headers }) {
      return headers.get("Content-Length") ? Number(headers.get("Content-Length")) : NaN;
    }
    function extractType({ headers }) {
      return headers.get("Content-Type")?.split(";")[0]?.trim();
    }
    return atpAgent;
  }
  var bskyAgent = {};
  var hasRequiredBskyAgent;
  function requireBskyAgent() {
    if (hasRequiredBskyAgent) return bskyAgent;
    hasRequiredBskyAgent = 1;
    Object.defineProperty(bskyAgent, "__esModule", { value: true });
    bskyAgent.BskyAgent = void 0;
    const atp_agent_1 = requireAtpAgent();
    class BskyAgent extends atp_agent_1.AtpAgent {
      clone() {
        if (this.constructor === BskyAgent) {
          const agent2 = new BskyAgent(this.sessionManager);
          return this.copyInto(agent2);
        }
        throw new TypeError("Cannot clone a subclass of BskyAgent");
      }
    }
    bskyAgent.BskyAgent = BskyAgent;
    return bskyAgent;
  }
  var hasRequiredDist;
  function requireDist() {
    if (hasRequiredDist) return dist$5;
    hasRequiredDist = 1;
    (function(exports$1) {
      var __createBinding = dist$5 && dist$5.__createBinding || (Object.create ? (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      }) : (function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      }));
      var __exportStar = dist$5 && dist$5.__exportStar || function(m, exports$12) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$12, p)) __createBinding(exports$12, m, p);
      };
      Object.defineProperty(exports$1, "__esModule", { value: true });
      exports$1.lexicons = exports$1.default = exports$1.BskyAgent = exports$1.CredentialSession = exports$1.AtpAgent = exports$1.Agent = exports$1.LABELS = exports$1.DEFAULT_LABEL_SETTINGS = exports$1.asPredicate = exports$1.schemas = exports$1.parseLanguage = exports$1.stringifyLex = exports$1.lexToJson = exports$1.jsonToLex = exports$1.jsonStringToLex = exports$1.BlobRef = exports$1.AtUri = void 0;
      const lexicon_1 = requireDist$2();
      const lexicons_1 = requireLexicons();
      var syntax_1 = requireDist$5();
      Object.defineProperty(exports$1, "AtUri", { enumerable: true, get: function() {
        return syntax_1.AtUri;
      } });
      var lexicon_2 = requireDist$2();
      Object.defineProperty(exports$1, "BlobRef", { enumerable: true, get: function() {
        return lexicon_2.BlobRef;
      } });
      Object.defineProperty(exports$1, "jsonStringToLex", { enumerable: true, get: function() {
        return lexicon_2.jsonStringToLex;
      } });
      Object.defineProperty(exports$1, "jsonToLex", { enumerable: true, get: function() {
        return lexicon_2.jsonToLex;
      } });
      Object.defineProperty(exports$1, "lexToJson", { enumerable: true, get: function() {
        return lexicon_2.lexToJson;
      } });
      Object.defineProperty(exports$1, "stringifyLex", { enumerable: true, get: function() {
        return lexicon_2.stringifyLex;
      } });
      var common_web_1 = requireDist$4();
      Object.defineProperty(exports$1, "parseLanguage", { enumerable: true, get: function() {
        return common_web_1.parseLanguage;
      } });
      __exportStar(requireTypes$2(), exports$1);
      __exportStar(require_const(), exports$1);
      __exportStar(requireUtil$4(), exports$1);
      __exportStar(requireClient(), exports$1);
      var lexicons_2 = requireLexicons();
      Object.defineProperty(exports$1, "schemas", { enumerable: true, get: function() {
        return lexicons_2.schemas;
      } });
      var util_1 = requireUtil$5();
      Object.defineProperty(exports$1, "asPredicate", { enumerable: true, get: function() {
        return util_1.asPredicate;
      } });
      __exportStar(requireRichText(), exports$1);
      __exportStar(requireSanitization(), exports$1);
      __exportStar(requireUnicode(), exports$1);
      __exportStar(requireUtil$2(), exports$1);
      __exportStar(requireModeration(), exports$1);
      __exportStar(requireTypes(), exports$1);
      __exportStar(requireMocker(), exports$1);
      var labels_1 = requireLabels();
      Object.defineProperty(exports$1, "DEFAULT_LABEL_SETTINGS", { enumerable: true, get: function() {
        return labels_1.DEFAULT_LABEL_SETTINGS;
      } });
      Object.defineProperty(exports$1, "LABELS", { enumerable: true, get: function() {
        return labels_1.LABELS;
      } });
      var agent_1 = requireAgent();
      Object.defineProperty(exports$1, "Agent", { enumerable: true, get: function() {
        return agent_1.Agent;
      } });
      var atp_agent_1 = requireAtpAgent();
      Object.defineProperty(exports$1, "AtpAgent", { enumerable: true, get: function() {
        return atp_agent_1.AtpAgent;
      } });
      var atp_agent_2 = requireAtpAgent();
      Object.defineProperty(exports$1, "CredentialSession", { enumerable: true, get: function() {
        return atp_agent_2.CredentialSession;
      } });
      var bsky_agent_1 = requireBskyAgent();
      Object.defineProperty(exports$1, "BskyAgent", { enumerable: true, get: function() {
        return bsky_agent_1.BskyAgent;
      } });
      var atp_agent_3 = requireAtpAgent();
      Object.defineProperty(exports$1, "default", { enumerable: true, get: function() {
        return atp_agent_3.AtpAgent;
      } });
      exports$1.lexicons = new lexicon_1.Lexicons(lexicons_1.lexicons);
    })(dist$5);
    return dist$5;
  }
  var distExports = requireDist();
  class BlueskyAPI {
    constructor(service2 = "https://bsky.social", identifier, password) {
      this.service = service2;
      this.identifier = identifier;
      this.password = password;
      this.agent = new distExports.BskyAgent({ service: this.service });
      this.rateLimitedAt = null;
      this.rateLimitCooldownMs = 60 * 1e3;
    }
    /**
     * Check if we're currently rate limited
     * @returns {boolean} True if in rate limit cooldown period
     */
    isRateLimited() {
      if (!this.rateLimitedAt) return false;
      const elapsed = Date.now() - this.rateLimitedAt;
      if (elapsed >= this.rateLimitCooldownMs) {
        this.rateLimitedAt = null;
        return false;
      }
      return true;
    }
    /**
     * Get remaining cooldown time in seconds
     * @returns {number} Seconds until rate limit expires, or 0 if not limited
     */
    getRateLimitRemaining() {
      if (!this.rateLimitedAt) return 0;
      const remaining = this.rateLimitCooldownMs - (Date.now() - this.rateLimitedAt);
      return Math.max(0, Math.ceil(remaining / 1e3));
    }
    /**
     * Handle API errors, detecting rate limits
     * @param {Error} error - The error to check
     * @throws {Error} Re-throws the error after handling
     */
    handleApiError(error) {
      const isRateLimit = error.status === 429 || error.message?.includes("429") || error.message?.toLowerCase().includes("rate limit") || error.error?.includes("RateLimitExceeded");
      if (isRateLimit) {
        this.rateLimitedAt = Date.now();
        const cooldownSecs = Math.ceil(this.rateLimitCooldownMs / 1e3);
        console.warn(`API rate limited (429). Cooling down for ${cooldownSecs} seconds.`);
      }
      throw error;
    }
    /**
     * Check rate limit before making a request
     * @throws {Error} If currently rate limited
     */
    checkRateLimit() {
      if (this.isRateLimited()) {
        const remaining = this.getRateLimitRemaining();
        const error = new Error(`Rate limited. Please wait ${remaining} seconds.`);
        error.status = 429;
        error.isRateLimitCooldown = true;
        throw error;
      }
    }
    async login() {
      return this.agent.login({
        identifier: this.identifier,
        password: this.password
      });
    }
    async getPost(_uri) {
      await this.agent.getPostThread({ uri: "at://..." });
    }
    async getTimeline(cursor = null, limit = 100) {
      this.checkRateLimit();
      try {
        const params = { limit };
        if (cursor) {
          params.cursor = cursor;
        }
        const { data } = await this.agent.getTimeline(params);
        return data;
      } catch (error) {
        this.handleApiError(error);
      }
    }
    /**
     * Fetches timeline and extracts repost timestamps.
     * Returns a map of post ID -> repost timestamp (indexedAt from reason)
     * Post ID is extracted from the URI (last segment after app.bsky.feed.post/)
     */
    async getRepostTimestamps(cursor = null, limit = 100) {
      const data = await this.getTimeline(cursor, limit);
      const repostTimestamps = {};
      const reposterProfiles = {};
      for (const item of data.feed) {
        if (item.reason && item.reason.$type?.includes("reasonRepost")) {
          const postUri = item.post.uri;
          const repostTime = item.reason.indexedAt;
          if (postUri && repostTime) {
            const postId = postUri.split("/").pop();
            repostTimestamps[postId] = new Date(repostTime);
            if (item.reason.by) {
              reposterProfiles[postId] = {
                handle: item.reason.by.handle,
                displayName: item.reason.by.displayName,
                avatar: item.reason.by.avatar
              };
            }
          }
        }
      }
      return {
        timestamps: repostTimestamps,
        reposterProfiles,
        cursor: data.cursor
      };
    }
    async getAtprotoUri(postUrl) {
      const match2 = postUrl.match(/bsky\.app\/profile\/([^/]+)\/post\/([^/]+)/);
      if (!match2) {
        console.error("Invalid Bluesky post URL format.");
        return null;
      }
      const handle2 = match2[1];
      const postId = match2[2];
      if (handle2.startsWith("did:")) {
        return null;
      }
      try {
        const { data } = await this.agent.resolveHandle({ handle: handle2 });
        const did2 = data.did;
        const atprotoUri = `at://${did2}/app.bsky.feed.post/${postId}`;
        return atprotoUri;
      } catch (error) {
        console.error("Failed to resolve handle:", error);
        return null;
      }
    }
    async getThread(uri) {
      this.checkRateLimit();
      try {
        const res = await this.agent.getPostThread({ uri });
        const { thread } = res.data;
        return thread;
      } catch (error) {
        this.handleApiError(error);
      }
    }
    /**
     * Fetches a user's profile by handle or DID
     * @param {string} actor - Handle (e.g., "alice.bsky.social") or DID
     * @returns {Promise<Object>} Profile data including displayName, description, avatar, followersCount, etc.
     */
    async getProfile(actor) {
      this.checkRateLimit();
      try {
        const { data } = await this.agent.getProfile({ actor });
        return data;
      } catch (error) {
        this.handleApiError(error);
      }
    }
    /**
     * Fetches all lists owned by an actor
     * @param {string} actor - Handle or DID (defaults to logged-in user)
     * @returns {Promise<Array>} Array of list objects with uri, name, purpose
     */
    async getLists(actor = null) {
      this.checkRateLimit();
      const params = { actor: actor || this.agent.session?.did, limit: 100 };
      const lists = [];
      let cursor = null;
      try {
        do {
          if (cursor) params.cursor = cursor;
          const { data } = await this.agent.app.bsky.graph.getLists(params);
          lists.push(...data.lists);
          cursor = data.cursor;
        } while (cursor);
        return lists;
      } catch (error) {
        this.handleApiError(error);
      }
    }
    /**
     * Fetches all members of a list
     * @param {string} listUri - AT URI of the list
     * @returns {Promise<Array>} Array of member objects with did, handle, uri (listitem record URI)
     */
    async getListMembers(listUri) {
      this.checkRateLimit();
      const params = { list: listUri, limit: 100 };
      const members = [];
      let cursor = null;
      try {
        do {
          if (cursor) params.cursor = cursor;
          const { data } = await this.agent.app.bsky.graph.getList(params);
          members.push(...data.items.map((item) => ({
            did: item.subject.did,
            handle: item.subject.handle,
            uri: item.uri
            // listitem record URI for deletion
          })));
          cursor = data.cursor;
        } while (cursor);
        return members;
      } catch (error) {
        this.handleApiError(error);
      }
    }
    /**
     * Creates a new list
     * @param {string} name - Display name for the list
     * @param {string} purpose - 'curatelist' or 'modlist'
     * @param {string} description - Optional description
     * @returns {Promise<string>} URI of the created list
     */
    async createList(name, purpose = "app.bsky.graph.defs#curatelist", description = "") {
      const record2 = {
        $type: "app.bsky.graph.list",
        name,
        purpose,
        description,
        createdAt: (/* @__PURE__ */ new Date()).toISOString()
      };
      const { data } = await this.agent.com.atproto.repo.createRecord({
        repo: this.agent.session.did,
        collection: "app.bsky.graph.list",
        record: record2
      });
      return data.uri;
    }
    /**
     * Adds a user to a list
     * @param {string} listUri - AT URI of the list
     * @param {string} subjectDid - DID of the user to add
     * @returns {Promise<string>} URI of the list item record
     */
    async addToList(listUri, subjectDid) {
      const record2 = {
        $type: "app.bsky.graph.listitem",
        list: listUri,
        subject: subjectDid,
        createdAt: (/* @__PURE__ */ new Date()).toISOString()
      };
      const { data } = await this.agent.com.atproto.repo.createRecord({
        repo: this.agent.session.did,
        collection: "app.bsky.graph.listitem",
        record: record2
      });
      return data.uri;
    }
    /**
     * Removes a user from a list
     * @param {string} listitemUri - AT URI of the listitem record to delete
     * @returns {Promise<void>}
     */
    async removeFromList(listitemUri) {
      const match2 = listitemUri.match(/at:\/\/([^/]+)\/([^/]+)\/([^/]+)/);
      if (!match2) {
        throw new Error(`Invalid listitem URI: ${listitemUri}`);
      }
      const [, repo, collection, rkey] = match2;
      await this.agent.com.atproto.repo.deleteRecord({
        repo,
        collection,
        rkey
      });
    }
    /**
     * Resolves a handle to a DID
     * @param {string} handle - User handle (with or without @)
     * @returns {Promise<string|null>} DID or null if not found
     */
    async resolveHandleToDid(handle2) {
      this.checkRateLimit();
      let cleanHandle = handle2.replace(/^@/, "");
      if (!cleanHandle.includes(".")) {
        cleanHandle = `${cleanHandle}.bsky.social`;
      }
      try {
        const { data } = await this.agent.resolveHandle({ handle: cleanHandle });
        return data.did;
      } catch (error) {
        if (error.status === 429 || error.isRateLimitCooldown) {
          this.handleApiError(error);
        }
        console.warn(`Failed to resolve handle ${cleanHandle}:`, error);
        return null;
      }
    }
    async getReplies(uri) {
      const thread = this.getThread(uri);
      return thread.replies.map((i, reply) => {
        return reply.post.record.text;
      });
    }
    /**
     * Fetches notifications from the API
     * @param {number} limit - Maximum number of notifications to fetch
     * @param {string} cursor - Pagination cursor
     * @returns {Promise<{notifications: Array, cursor: string, seenAt: string}>}
     */
    async getNotifications(limit = 20, cursor = null) {
      this.checkRateLimit();
      try {
        const params = { limit };
        if (cursor) {
          params.cursor = cursor;
        }
        const { data } = await this.agent.listNotifications(params);
        return {
          notifications: data.notifications,
          cursor: data.cursor,
          seenAt: data.seenAt
        };
      } catch (error) {
        this.handleApiError(error);
      }
    }
    /**
     * Mark notifications as seen up to a specific time
     * @param {string} seenAt - ISO timestamp to mark as seen up to (defaults to current time)
     */
    async markNotificationsSeen(seenAt = null) {
      const timestamp = seenAt || (/* @__PURE__ */ new Date()).toISOString();
      await this.agent.api.app.bsky.notification.updateSeen({ seenAt: timestamp });
    }
    /**
     * Follow a user by DID
     * @param {string} did - The DID of the user to follow
     * @returns {Promise<{uri: string, cid: string}>} The follow record info
     */
    async follow(did2) {
      const { uri, cid: cid2 } = await this.agent.follow(did2);
      return { uri, cid: cid2 };
    }
    /**
     * Unfollow a user by deleting the follow record
     * @param {string} followUri - The URI of the follow record to delete
     * @returns {Promise<void>}
     */
    async unfollow(followUri) {
      await this.agent.deleteFollow(followUri);
    }
    /**
     * Get a user's profile to check follow status
     * @param {string} actor - Handle or DID
     * @returns {Promise<{did: string, following: string|null}>} Profile with follow URI if following
     */
    async getFollowStatus(actor) {
      const profile2 = await this.getProfile(actor);
      return {
        did: profile2.did,
        followUri: profile2.viewer?.following || null
      };
    }
    async unrollThread(thread) {
      const originalAuthor = thread.post.author.did;
      const collectPosts = async (threadNode, parentAuthorDid, posts = []) => {
        if (!threadNode.post) {
          return [];
        }
        if (threadNode.post.author.did === originalAuthor && parentAuthorDid === originalAuthor) {
          posts.push(threadNode.post);
        }
        if (threadNode.post.replyCount && !threadNode.replies) {
          threadNode.replies = (await this.getThread(threadNode.post.uri)).replies;
        }
        if (threadNode.replies) {
          for (const reply of threadNode.replies) {
            await collectPosts(reply, threadNode.post.author.did, posts);
          }
        }
        return posts;
      };
      const allPosts = await collectPosts(thread, originalAuthor);
      return allPosts;
    }
  }
  let debounceTimeout;
  function debounce(func, delay) {
    return function(...args) {
      clearTimeout(debounceTimeout);
      debounceTimeout = setTimeout(() => func.apply(this, args), delay);
    };
  }
  function isUserTyping() {
    const activeElement = document.activeElement;
    if (!activeElement) return false;
    const tagName = activeElement.tagName.toLowerCase();
    if (tagName === "input" || tagName === "textarea") return true;
    if (activeElement.closest(".tiptap")) return true;
    if (activeElement.isContentEditable) return true;
    return false;
  }
  function isModalOpen() {
    if (document.querySelector(".config-modal")) return true;
    if (document.querySelector(".shortcut-overlay")) return true;
    if (document.querySelector(".sync-dialog-overlay")) return true;
    return false;
  }
  function waitForElement$3(selector, onAdd, onRemove, onChange, ignoreExisting) {
    let pendingMutations = [];
    let rafId = null;
    const processMutations = () => {
      rafId = null;
      const mutations = pendingMutations;
      pendingMutations = [];
      const processedAdded = /* @__PURE__ */ new Set();
      const processedRemoved = /* @__PURE__ */ new Set();
      for (const mutation of mutations) {
        if (onAdd) {
          for (const node of mutation.addedNodes) {
            if (node.matches && node.matches(selector) && !processedAdded.has(node)) {
              processedAdded.add(node);
              onAdd(node, observer);
            }
            if (node.querySelectorAll) {
              for (const el of node.querySelectorAll(selector)) {
                if (!processedAdded.has(el)) {
                  processedAdded.add(el);
                  onAdd(el, observer);
                }
              }
            }
          }
        }
        if (onRemove) {
          for (const node of mutation.removedNodes) {
            if (node.matches && node.matches(selector) && !processedRemoved.has(node)) {
              processedRemoved.add(node);
              onRemove(node, observer);
            }
            if (node.querySelectorAll) {
              for (const el of node.querySelectorAll(selector)) {
                if (!processedRemoved.has(el)) {
                  processedRemoved.add(el);
                  onRemove(el, observer);
                }
              }
            }
          }
        }
        if (onChange && mutation.type === "attributes") {
          const attributeName = mutation.attributeName;
          const oldValue = mutation.oldValue;
          const newValue = mutation.target.getAttribute(attributeName);
          if (oldValue !== newValue) {
            onChange(attributeName, oldValue, newValue, mutation.target, observer);
          }
        }
      }
    };
    const observer = new MutationObserver((mutations) => {
      if (isUserTyping()) return;
      pendingMutations.push(...mutations);
      if (!rafId) {
        rafId = requestAnimationFrame(processMutations);
      }
    });
    const processExistingElements = () => {
      const elements = document.querySelectorAll(selector);
      elements.forEach((el) => onAdd(el, observer));
    };
    if (onAdd && !ignoreExisting) {
      processExistingElements();
    }
    observer.observe(document.body, { childList: true, subtree: true, attributes: !!onChange });
    return observer;
  }
  function observeChanges(target2, callback, subtree) {
    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        if (mutation.type === "attributes") {
          const attributeName = mutation.attributeName;
          const oldValue = mutation.oldValue;
          const newValue = mutation.target.getAttribute(attributeName);
          if (oldValue !== newValue) {
            callback(attributeName, oldValue, newValue, mutation.target);
          }
        }
      });
    });
    observer.observe(target2, {
      attributes: true,
      attributeOldValue: true,
      subtree: !!subtree
    });
    return observer;
  }
  function observeVisibilityChange$1($element, callback) {
    const target2 = $element[0];
    const observer = new MutationObserver(() => {
      const isVisible = $element.is(":visible");
      callback(isVisible);
    });
    observer.observe(target2, {
      attributes: true,
      childList: true,
      subtree: false
      // Only observe the target element
    });
    return () => observer.disconnect();
  }
  function splitTerms(input) {
    return input.split(/\s+/).filter((term) => term.length > 0);
  }
  function extractLastTerm(input) {
    const terms = splitTerms(input);
    return terms.length > 0 ? terms[terms.length - 1] : "";
  }
  function prefersReducedMotion(config2 = null) {
    if (config2) {
      const setting = config2.get("reducedMotion");
      if (setting === "Always") return true;
      if (setting === "Never") return false;
    }
    return window.matchMedia("(prefers-reduced-motion: reduce)").matches;
  }
  function prefersHighContrast(config2 = null) {
    if (config2 && config2.get("highContrastMode")) return true;
    return window.matchMedia("(prefers-contrast: more)").matches;
  }
  function getAnimationDuration$1(defaultMs, config2 = null) {
    return prefersReducedMotion(config2) ? 0 : defaultMs;
  }
  function announceToScreenReader$2(message2, priority = "polite") {
    const el = $("<div>").attr({
      role: "status",
      "aria-live": priority,
      "aria-atomic": "true"
    }).addClass("sr-only").text(message2);
    $("body").append(el);
    setTimeout(() => el.remove(), 1e3);
  }
  const utils$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    announceToScreenReader: announceToScreenReader$2,
    debounce,
    extractLastTerm,
    getAnimationDuration: getAnimationDuration$1,
    isModalOpen,
    isUserTyping,
    observeChanges,
    observeVisibilityChange: observeVisibilityChange$1,
    prefersHighContrast,
    prefersReducedMotion,
    splitTerms,
    waitForElement: waitForElement$3
  }, Symbol.toStringTag, { value: "Module" }));
  const CONFIG_SCHEMA = {
    Display: {
      icon: "\u{1F5A5}\uFE0F",
      fields: {
        showLoadingIndicator: {
          label: "Show loading indicator",
          type: "checkbox",
          default: true,
          help: "Show spinner while feed items are loading and sorting"
        },
        postWidthDesktop: {
          label: "Post width (px)",
          type: "number",
          default: 600,
          min: 400,
          max: 1200,
          help: "Maximum width of posts in the feed"
        },
        postMaxHeight: {
          label: "Collapse posts",
          type: "select",
          options: ["Off", "25vh", "50vh", "75vh"],
          default: "Off",
          help: "Collapse unfocused posts to max height; expands when selected"
        },
        postActionButtonPosition: {
          label: "Action buttons",
          type: "select",
          options: ["Bottom", "Left"],
          default: "Bottom",
          help: "Position of like/repost/reply buttons"
        },
        postTimestampFormat: {
          label: "Timestamp format",
          type: "text",
          default: "'$age' '('yyyy-MM-dd hh:mmaaa')'",
          placeholder: "date-fns format string",
          help: "Uses date-fns format; $age for relative time"
        },
        postTimestampFormatMobile: {
          label: "Timestamp (mobile)",
          type: "text",
          default: "'$age'",
          help: "Timestamp format on mobile devices"
        },
        videoPreviewPlayback: {
          label: "Video playback",
          type: "select",
          options: ["Play all", "Play selected", "Pause all"],
          default: "Play all",
          help: "Control video autoplay behavior"
        },
        videoDisableLoop: {
          label: "Disable video loop",
          type: "checkbox",
          default: false,
          help: "Stop videos from looping automatically"
        },
        hideRightSidebar: {
          label: "Hide right sidebar",
          type: "checkbox",
          default: false,
          help: "Hide the trending/who to follow sidebar"
        },
        compactLayout: {
          label: "Compact layout",
          type: "checkbox",
          default: false,
          help: "Remove whitespace next to the left navigation"
        },
        hideLoadNewButton: {
          label: 'Hide "Load New" button',
          type: "checkbox",
          default: false,
          help: "Hide the button that appears for new posts"
        },
        hideSuggestedFollows: {
          label: 'Hide "Suggested for you"',
          type: "checkbox",
          default: false,
          help: "Hide suggested profiles in feed"
        },
        showPostCounts: {
          label: "Show post counts",
          type: "select",
          options: ["All", "Selection", "None"],
          default: "All",
          help: "When to show read/unread post counts"
        },
        enableSmoothScrolling: {
          label: "Smooth scrolling",
          type: "checkbox",
          default: false,
          help: "Animate scrolling when navigating posts"
        },
        enablePageKeys: {
          label: "Page/Home/End navigation",
          type: "checkbox",
          default: true,
          help: "Use PgUp/PgDn/Home/End for post navigation"
        },
        scrollToFocus: {
          label: "Scroll to focus",
          type: "checkbox",
          default: true,
          help: "Focus posts when scrolling through the feed"
        },
        hoverToFocus: {
          label: "Hover to focus",
          type: "checkbox",
          default: true,
          help: "Focus posts when hovering with the mouse"
        },
        hoverToFocusSidecar: {
          label: "Hover to focus (sidecar)",
          type: "checkbox",
          default: true,
          help: "Focus sidecar items when hovering with the mouse",
          showWhen: { hoverToFocus: true }
        },
        readerModeFontSize: {
          label: "Reader mode font size (px)",
          type: "number",
          default: 16,
          min: 10,
          max: 32,
          help: "Font size for reader mode (V key)"
        }
      }
    },
    "Feed Map": {
      icon: "\u{1F5FA}\uFE0F",
      fields: {
        feedMapPosition: {
          label: "Position",
          type: "select",
          options: ["Top toolbar", "Bottom status bar", "Hidden"],
          default: "Bottom status bar",
          help: "Where to show the feed map"
        },
        feedMapStyle: {
          label: "Style",
          type: "select",
          options: ["Basic", "Advanced"],
          default: "Basic",
          help: "Basic: simple read/unread segments. Advanced: heatmap, icons, and zoom options"
        },
        feedMapScale: {
          label: "Scale (%)",
          type: "range",
          default: 100,
          min: 50,
          max: 400,
          step: 25,
          help: "Scale the feed map size (50-400%)"
        },
        feedMapTheme: {
          label: "Color theme",
          type: "select",
          options: ["Ocean", "Campfire", "Forest", "Monochrome"],
          default: "Ocean",
          help: "Color scheme for the feed map"
        },
        feedMapTooltip: {
          label: "Tooltip delay",
          type: "select",
          options: ["Instant", "Delayed"],
          default: "Instant",
          help: "Show post preview on hover instantly or after a short delay"
        },
        feedMapHeatmap: {
          label: "Heatmap mode",
          type: "select",
          options: ["None", "Engagement Rate", "Raw Engagement", "Weighted Engagement"],
          default: "None",
          help: "Color intensity based on post engagement metrics",
          showWhen: { feedMapStyle: "Advanced" }
        },
        feedMapIcons: {
          label: "Content icons",
          type: "checkbox",
          default: true,
          help: "Show icons for media, replies, and reposts in feed map",
          showWhen: { feedMapStyle: "Advanced" }
        },
        feedMapAvatars: {
          label: "Show avatars",
          type: "checkbox",
          default: true,
          help: "Show author avatars in zoom indicator segments",
          showWhen: { feedMapStyle: "Advanced" }
        },
        feedMapAvatarScale: {
          label: "Avatar scale",
          type: "range",
          default: 100,
          min: 25,
          max: 200,
          step: 5,
          help: "Avatar size as percentage (base 32px)",
          showWhen: { feedMapAvatars: true }
        },
        feedMapTimestamps: {
          label: "Show timestamps",
          type: "checkbox",
          default: true,
          help: "Show relative timestamps in zoom indicator segments",
          showWhen: { feedMapStyle: "Advanced" }
        },
        feedMapHandles: {
          label: "Show handles",
          type: "checkbox",
          default: true,
          help: "Show user handles in zoom indicator segments",
          showWhen: { feedMapStyle: "Advanced" }
        },
        feedMapZoomEnabled: {
          label: "Enable zoom view",
          type: "checkbox",
          default: false,
          help: "Show zoomed view of posts around selection",
          showWhen: { feedMapStyle: "Advanced" }
        },
        feedMapZoom: {
          label: "Zoom window size",
          type: "range",
          default: 5,
          min: 3,
          max: 20,
          step: 1,
          help: "Number of posts to show in zoom view",
          showWhen: { feedMapStyle: "Advanced", feedMapZoomEnabled: true }
        },
        feedMapAnimationSpeed: {
          label: "Animation interval",
          type: "range",
          default: 100,
          min: 0,
          max: 1e3,
          step: 50,
          help: "Zoom scroll animation duration (0=instant, 100=normal)",
          showWhen: { feedMapStyle: "Advanced" }
        }
      }
    },
    Notifications: {
      icon: "\u{1F514}",
      fields: {
        toastNotifications: {
          label: "Toast notifications",
          type: "checkbox",
          default: true,
          help: "Show popup notifications for new activity"
        },
        toastDuration: {
          label: "Duration (seconds)",
          type: "range",
          default: 4,
          min: 0,
          max: 10,
          step: 1,
          help: "How long notifications stay visible",
          showWhen: { toastNotifications: true },
          // Slider positions map to: 1, 2, 3, 4, 5, 10, 15, 30, 60, 300, 
          rangeValues: [1, 2, 3, 4, 5, 10, 15, 30, 60, 300, Infinity],
          formatValue: (v) => {
            const values = [1, 2, 3, 4, 5, 10, 15, 30, 60, 300, Infinity];
            const actual = values[v] || 5;
            return actual === Infinity ? "\u221E" : actual;
          }
        },
        toastPosition: {
          label: "Position",
          type: "select",
          options: ["Top Right", "Top Left", "Bottom Right", "Bottom Left"],
          default: "Top Right",
          help: "Where to show toast notifications",
          showWhen: { toastNotifications: true }
        },
        toastTestMode: {
          label: "Test mode",
          type: "checkbox",
          default: false,
          help: "Show most recent notification as new (for testing)",
          showWhen: { toastNotifications: true }
        }
      }
    },
    Clearsky: {
      icon: "\u{1F6AB}",
      fields: {
        clearskyEnabled: {
          label: "Enable Clearsky integration",
          type: "checkbox",
          default: true,
          help: "Highlight users who appear on Clearsky most-blocked lists"
        },
        clearskyStyleTypeAll: {
          label: "Top blocked style",
          type: "select",
          options: ["Background", "Border", "Underline", "Text color", "None"],
          default: "Background",
          help: "Style type for all-time most blocked list",
          showWhen: { clearskyEnabled: true }
        },
        clearskyColorAll: {
          label: "Top blocked color",
          type: "color",
          default: "#ff8080",
          help: "Color for all-time most blocked users",
          showWhen: { clearskyEnabled: true }
        },
        clearskyStyleTypeRecent: {
          label: "Recently blocked style",
          type: "select",
          options: ["Background", "Border", "Underline", "Text color", "None"],
          default: "Background",
          help: "Style type for recently blocked list",
          showWhen: { clearskyEnabled: true }
        },
        clearskyColorRecent: {
          label: "Recently blocked color",
          type: "color",
          default: "#cc4040",
          help: "Color for recently blocked users",
          showWhen: { clearskyEnabled: true }
        }
      }
    },
    "Threads & Sidecar": {
      icon: "\u{1F4AC}",
      fields: {
        unrollThreads: {
          label: "Unroll threads",
          type: "checkbox",
          default: false,
          help: "Expand self-reply threads inline"
        },
        unrolledPostSelection: {
          label: "Unrolled post selection",
          type: "checkbox",
          default: false,
          help: "Enable j/k navigation in unrolled threads"
        },
        showReplySidecar: {
          label: "Show replies sidecar",
          type: "checkbox",
          default: false,
          help: "Show replies panel next to posts"
        },
        showReplySidecarMinimumWidth: {
          label: "Sidecar min width (px)",
          type: "number",
          default: 600,
          min: 400,
          max: 1200,
          help: "Minimum viewport width to show sidecar"
        },
        sidecarWidthPercent: {
          label: "Sidecar width (%)",
          type: "number",
          default: 30,
          min: 20,
          max: 50,
          help: "Sidecar width relative to post"
        },
        sidecarReplySortOrder: {
          label: "Sidecar sort order",
          type: "select",
          options: ["Default", "Oldest First", "Newest First", "Most Liked First", "Most Reposted First"],
          default: "Default",
          help: "How to sort replies in the sidecar"
        },
        fixedSidecar: {
          label: "Sidecar panel style",
          type: "select",
          options: ["Fixed", "Inline"],
          default: "Fixed",
          help: "Fixed: separate panel. Inline: next to each post"
        },
        showReplyContext: {
          label: "Show reply context",
          type: "checkbox",
          default: false,
          help: "Show parent post even if previously read"
        }
      }
    },
    Appearance: {
      icon: "\u{1F3A8}",
      collapsed: true,
      fields: {
        focusRingColor: {
          label: "Focus ring color",
          type: "color",
          default: "#0066cc",
          help: "Color of selection outline"
        },
        focusRingWidth: {
          label: "Focus ring width (px)",
          type: "number",
          default: 2,
          min: 1,
          max: 5,
          help: "Thickness of selection outline"
        },
        threadIndicatorWidth: {
          label: "Thread indicator width (px)",
          type: "number",
          default: 4,
          min: 1,
          max: 10,
          help: "Width of the vertical thread line"
        },
        threadIndicatorColor: {
          label: "Thread indicator color",
          type: "text",
          default: "rgb(212, 219, 226)",
          help: "Color of the vertical thread line"
        },
        threadMargin: {
          label: "Thread margin",
          type: "text",
          default: "10px",
          help: "Spacing between thread groups"
        }
      }
    },
    "CSS Styles": {
      icon: "\u2728",
      collapsed: true,
      fields: {
        posts: {
          label: "All posts",
          type: "css",
          default: "padding: 1px;",
          help: "CSS applied to all posts"
        },
        unreadPosts: {
          label: "Unread posts",
          type: "css",
          default: "opacity: 100% !important;",
          help: "CSS for posts not yet seen"
        },
        unreadPostsLightMode: {
          label: "Unread (light)",
          type: "css",
          default: "background-color: white;",
          help: "Unread posts in light mode"
        },
        unreadPostsDarkMode: {
          label: "Unread (dark)",
          type: "css",
          default: "background-color: #202020;",
          help: "Unread posts in dark mode"
        },
        readPosts: {
          label: "Read posts",
          type: "css",
          default: "opacity: 75% !important;",
          help: "CSS for previously seen posts"
        },
        readPostsLightMode: {
          label: "Read (light)",
          type: "css",
          default: "background-color: #f0f0f0;",
          help: "Read posts in light mode"
        },
        readPostsDarkMode: {
          label: "Read (dark)",
          type: "css",
          default: "background-color: black;",
          help: "Read posts in dark mode"
        },
        selectionActive: {
          label: "Selected post",
          type: "css",
          default: "outline: var(--focus-ring-width, 2px) var(--focus-ring-color, #0066cc) solid !important; box-shadow: 0 0 0 4px color-mix(in srgb, var(--focus-ring-color, #0066cc) 15%, transparent);",
          help: "CSS for the currently selected post"
        },
        selectionChildFocused: {
          label: "Child focused",
          type: "css",
          default: "outline: var(--focus-ring-width, 2px) color-mix(in srgb, var(--focus-ring-color, #0066cc) 35%, transparent) solid !important;",
          help: "Post style when reply is focused"
        },
        selectionInactive: {
          label: "Unselected post",
          type: "css",
          default: "outline: var(--focus-ring-width, 2px) solid transparent;",
          help: "CSS for non-selected posts"
        },
        replySelectionActive: {
          label: "Selected reply",
          type: "css",
          default: "outline: 3px var(--focus-ring-color, #0066cc) solid !important; outline-offset: -1px;",
          help: "CSS for selected reply in sidecar"
        },
        replySelectionInactive: {
          label: "Unselected reply",
          type: "css",
          default: "outline: 1px rgb(212, 219, 226) solid",
          help: "CSS for non-selected replies"
        }
      }
    },
    "AT Protocol": {
      icon: "\u{1F511}",
      fields: {
        atprotoService: {
          label: "Service URL",
          type: "text",
          default: "https://bsky.social",
          help: "AT Protocol service endpoint"
        },
        atprotoIdentifier: {
          label: "Handle",
          type: "text",
          default: "",
          placeholder: "your.handle",
          help: "Your Bluesky handle or DID"
        },
        atprotoPassword: {
          label: "App Password",
          type: "password",
          default: "",
          placeholder: "xxxx-xxxx-xxxx-xxxx",
          help: "Use an App Password, not your main password"
        }
      }
    },
    "State Sync": {
      icon: "\u2601\uFE0F",
      collapsed: true,
      fields: {
        stateSyncEnabled: {
          label: "Enable cloud sync",
          type: "checkbox",
          default: false,
          help: "Sync read state across devices"
        },
        stateSyncConfig: {
          label: "Sync config (JSON)",
          type: "textarea",
          default: "",
          rows: 4,
          help: "Cloud sync provider configuration"
        },
        stateSyncTimeout: {
          label: "Sync timeout (ms)",
          type: "number",
          default: 5e3,
          min: 1e3,
          max: 6e4,
          help: "How long to wait for sync operations"
        }
      }
    },
    Rules: {
      icon: "\u{1F4CB}",
      fields: {
        rulesConfig: {
          label: "Filter rules",
          type: "textarea",
          default: "",
          rows: 6,
          placeholder: "Enter filter rules...",
          help: "Content filtering rules by category"
        },
        ruleColorCoding: {
          label: "Color-code rule matches",
          type: "checkbox",
          default: false,
          help: "Color handles/avatars in feed and feed map by author rules"
        },
        autoOrganizeRules: {
          label: "Auto-organize rules",
          type: "checkbox",
          default: false,
          help: "Automatically sort rules by type (all\u2192include\u2192from\u2192content) then value"
        }
      }
    },
    Timeouts: {
      icon: "\u23F1\uFE0F",
      fields: {
        timeoutDefaultDuration: {
          label: "Default timeout duration",
          type: "select",
          options: ["1h", "6h", "12h", "1d", "3d", "7d", "14d", "30d"],
          default: "1d",
          help: "Default duration when timing out an author (! hotkey)"
        }
      }
    },
    Advanced: {
      icon: "\u2699\uFE0F",
      collapsed: true,
      fields: {
        reducedMotion: {
          label: "Reduced motion",
          type: "select",
          options: ["System", "Always", "Never"],
          default: "System",
          help: "Control animation behavior"
        },
        highContrastMode: {
          label: "High contrast",
          type: "checkbox",
          default: false,
          help: "Increase visual contrast for accessibility"
        },
        enableSwipeGestures: {
          label: "Swipe gestures (mobile)",
          type: "checkbox",
          default: true,
          help: "Enable swipe actions on touch devices"
        },
        markReadOnScroll: {
          label: "Mark read on scroll",
          type: "checkbox",
          default: false,
          help: "Mark posts as read when scrolled past"
        },
        disableLoadMoreOnScroll: {
          label: "Disable auto-load on scroll",
          type: "checkbox",
          default: false,
          help: "Prevent loading more posts on scroll"
        },
        savePostState: {
          label: "Save post state",
          type: "checkbox",
          default: false,
          help: "Persist read/unread state locally"
        },
        stateSaveTimeout: {
          label: "State save timeout (ms)",
          type: "number",
          default: 1e3,
          min: 100,
          max: 1e4,
          help: "Delay before saving state changes"
        },
        historyMax: {
          label: "History max size",
          type: "number",
          default: constants.DEFAULT_HISTORY_MAX,
          min: 100,
          max: 1e5,
          help: "Maximum posts to track in history"
        },
        showDebuggingInfo: {
          label: "Debug mode",
          type: "checkbox",
          default: false,
          help: "Show developer debugging information"
        },
        performanceLogging: {
          label: "Performance logging",
          type: "checkbox",
          default: false,
          help: "Log performance metrics to console (helps diagnose slowdowns)"
        }
      }
    }
  };
  const HIDDEN_FIELDS = {
    savedSearches: { default: "[]" },
    rulesetColors: { default: "{}" }
    // Maps category name to color index
  };
  let instance$2 = null;
  class ConfigModal {
    constructor(config2, onSave = null) {
      if (instance$2) {
        instance$2.config = config2;
        instance$2.onSave = onSave;
        return instance$2;
      }
      this.config = config2;
      this.onSave = onSave;
      this.isVisible = false;
      this.modalEl = null;
      this.activeTab = "Display";
      this.pendingChanges = {};
      this.collapsedSections = {};
      this.rulesSubTab = "visual";
      this.parsedRules = [];
      this.collapsedCategories = {};
      this.cachedListNames = [];
      instance$2 = this;
    }
    toggle() {
      if (this.isVisible) {
        this.hide();
      } else {
        this.show();
      }
    }
    show() {
      if (this.isVisible) return;
      this.previousActiveElement = document.activeElement;
      this.isVisible = true;
      this.pendingChanges = {};
      this.prefillRule = null;
      this._listNamesFetched = false;
      Object.entries(CONFIG_SCHEMA).forEach(([tab, schema2]) => {
        if (schema2.collapsed) {
          this.collapsedSections[tab] = true;
        }
      });
      this.modalEl = this.createModal();
      document.body.appendChild(this.modalEl);
      const firstInput = this.modalEl.querySelector(".config-modal-close");
      if (firstInput) firstInput.focus();
      announceToScreenReader$2("Configuration dialog opened. Press Escape to close.");
      this.escapeHandler = (e) => {
        if (e.key === "Escape") {
          e.preventDefault();
          e.stopPropagation();
          this.hide();
        }
      };
      document.addEventListener("keydown", this.escapeHandler, true);
      this.refreshVisualEditor();
    }
    /**
     * Open the modal directly to Rules tab with a pre-filled rule for an author
     * @param {string} handle - The author handle (with or without @)
     * @param {string} categoryName - Optional category name (defaults to 'favorites')
     */
    showWithRule(handle2, categoryName = "favorites") {
      const normalizedHandle = handle2.startsWith("@") ? handle2 : `@${handle2}`;
      this.prefillRule = {
        handle: normalizedHandle,
        categoryName
      };
      this.activeTab = "Rules";
      this.rulesSubTab = "visual";
      this.show();
      if (this.prefillRule) {
        this.addPrefillRule();
      }
    }
    /**
     * Add the pre-filled rule to the visual editor
     */
    addPrefillRule() {
      if (!this.prefillRule) return;
      const { handle: handle2, categoryName } = this.prefillRule;
      let categoryIndex = this.parsedRules.findIndex((c) => c.name === categoryName);
      if (categoryIndex === -1) {
        this.parsedRules.push({ name: categoryName, rules: [] });
        categoryIndex = this.parsedRules.length - 1;
      }
      const category = this.parsedRules[categoryIndex];
      const ruleExists = category.rules.some(
        (r) => r.type === "from" && r.value.toLowerCase() === handle2.toLowerCase()
      );
      if (!ruleExists) {
        this.clearUnsavedFlags(categoryIndex);
        category.rules.push({ action: "allow", type: "from", value: handle2, _unsaved: true });
        this.syncVisualToRaw();
        this.refreshVisualEditor();
      }
      this.collapsedCategories[categoryIndex] = false;
      this.prefillRule = null;
    }
    hide() {
      if (!this.isVisible || !this.modalEl) return;
      const animDuration = getAnimationDuration$1(200, this.config);
      this.modalEl.classList.add("config-modal-hiding");
      setTimeout(() => {
        if (this.modalEl?.parentNode) {
          this.modalEl.parentNode.removeChild(this.modalEl);
        }
        this.modalEl = null;
        this.isVisible = false;
        this._listNamesFetched = false;
        if (this.previousActiveElement) {
          this.previousActiveElement.focus();
        }
      }, animDuration);
      document.removeEventListener("keydown", this.escapeHandler, true);
      announceToScreenReader$2("Configuration dialog closed.");
    }
    createModal() {
      const modal = document.createElement("div");
      modal.className = "config-modal";
      modal.setAttribute("role", "dialog");
      modal.setAttribute("aria-modal", "true");
      modal.setAttribute("aria-labelledby", "config-modal-title");
      modal.innerHTML = `
      <div class="config-modal-backdrop"></div>
      <div class="config-modal-content">
        <div class="config-modal-header">
          <h2 id="config-modal-title">Settings</h2>
          <button class="config-modal-close" aria-label="Close">&times;</button>
        </div>
        <div class="config-modal-body">
          <nav class="config-modal-tabs" role="tablist">
            ${this.renderTabs()}
          </nav>
          <div class="config-modal-panels">
            ${this.renderPanels()}
          </div>
        </div>
        <div class="config-modal-footer">
          <button class="config-btn config-btn-secondary" id="config-reset">Reset to Defaults</button>
          <div class="config-footer-right">
            <button class="config-btn config-btn-secondary" id="config-cancel">Cancel</button>
            <button class="config-btn config-btn-primary" id="config-save">Save</button>
          </div>
        </div>
      </div>
    `;
      modal.querySelector(".config-modal-backdrop").addEventListener("click", () => this.hide());
      modal.querySelector(".config-modal-close").addEventListener("click", () => this.hide());
      modal.querySelector("#config-cancel").addEventListener("click", () => this.hide());
      modal.querySelector("#config-save").addEventListener("click", () => this.save());
      modal.querySelector("#config-reset").addEventListener("click", () => this.resetToDefaults());
      modal.querySelectorAll(".config-tab").forEach((tab) => {
        tab.addEventListener("click", (e) => {
          const tabButton = e.currentTarget;
          this.switchTab(tabButton.dataset.tab);
        });
      });
      modal.querySelectorAll("input, select, textarea").forEach((input) => {
        input.addEventListener("change", (e) => this.handleInputChange(e));
        input.addEventListener("input", (e) => {
          if (e.target.type === "range") this.handleInputChange(e);
        });
      });
      modal.querySelectorAll(".config-field-reset").forEach((btn) => {
        btn.addEventListener("click", (e) => {
          e.preventDefault();
          e.stopPropagation();
          this.resetField(btn.dataset.key);
        });
      });
      this.attachRulesEventListeners(modal);
      return modal;
    }
    getFieldSchema(key) {
      for (const [, schema2] of Object.entries(CONFIG_SCHEMA)) {
        if (schema2.fields[key]) {
          return schema2.fields[key];
        }
      }
      return null;
    }
    resetField(key) {
      const field = this.getFieldSchema(key);
      if (!field) return;
      const defaultValue = field.default;
      const id = `config-${key}`;
      const input = this.modalEl.querySelector(`#${id}`);
      if (!input) return;
      if (field.type === "checkbox") {
        input.checked = Boolean(defaultValue);
      } else if (field.type === "color") {
        input.value = defaultValue;
        const textInput = this.modalEl.querySelector(`#${id}-text`);
        if (textInput) textInput.value = defaultValue;
      } else if (field.type === "range") {
        input.value = defaultValue;
        const valueDisplay = input.parentElement?.querySelector(".config-range-value");
        if (valueDisplay) {
          const displayValue = field.formatValue ? field.formatValue(defaultValue) : defaultValue;
          valueDisplay.textContent = displayValue;
        }
      } else {
        input.value = defaultValue;
      }
      this.pendingChanges[key] = defaultValue;
      const wrapper = input.closest(".config-field-wrapper");
      const resetBtn = wrapper?.querySelector(".config-field-reset");
      if (resetBtn) {
        resetBtn.classList.add("hidden");
      }
      announceToScreenReader$2(`${field.label} reset to default.`);
    }
    renderTabs() {
      return Object.entries(CONFIG_SCHEMA).map(
        ([name, schema2]) => `
        <button class="config-tab ${name === this.activeTab ? "active" : ""}"
                role="tab"
                data-tab="${name}"
                aria-selected="${name === this.activeTab}">
          <span class="config-tab-icon">${schema2.icon}</span>
          <span class="config-tab-label">${name}</span>
        </button>
      `
      ).join("");
    }
    renderPanels() {
      return Object.entries(CONFIG_SCHEMA).map(
        ([name, schema2]) => `
        <div class="config-panel ${name === this.activeTab ? "active" : ""}"
             role="tabpanel"
             data-panel="${name}">
          ${name === "Rules" ? this.renderRulesPanel() : name === "Timeouts" ? this.renderTimeoutsPanel() : this.renderFields(schema2.fields)}
        </div>
      `
      ).join("");
    }
    renderFields(fields) {
      return Object.entries(fields).map(([key, field]) => this.renderField(key, field)).join("");
    }
    renderField(key, field) {
      const value = this.config.get(key) ?? field.default ?? "";
      const id = `config-${key}`;
      const isModified = this.isFieldModified(key, field, value);
      const resetBtn = `<button type="button" class="config-field-reset ${isModified ? "" : "hidden"}"
                              data-key="${key}" data-default="${this.escapeHtml(String(field.default))}"
                              title="Reset to default">\u21BA</button>`;
      let showWhenAttrs = "";
      let isHidden = false;
      if (field.showWhen) {
        const [depKey, depValue] = Object.entries(field.showWhen)[0];
        const currentDepValue = this.config.get(depKey) ?? CONFIG_SCHEMA[this.activeTab]?.fields[depKey]?.default;
        isHidden = currentDepValue !== depValue;
        showWhenAttrs = `data-show-when-key="${depKey}" data-show-when-value="${depValue}"`;
      }
      let inputHtml = "";
      switch (field.type) {
        case "checkbox":
          inputHtml = `
          <label class="config-field-checkbox"${field.help ? ` data-help="${this.escapeHtml(field.help)}"` : ""}>
            <span class="config-checkbox-label">${field.label}</span>
            <input type="checkbox" id="${id}" name="${key}" ${value ? "checked" : ""}>
          </label>
        `;
          break;
        case "select":
          inputHtml = `
          <div class="config-field-wrapper">
            <label class="config-field">
              <span class="config-field-label">${field.label}</span>
              <select id="${id}" name="${key}">
                ${field.options.map((opt) => `<option value="${opt}" ${value === opt ? "selected" : ""}>${opt}</option>`).join("")}
              </select>
              ${field.help ? `<span class="config-field-help">${field.help}</span>` : ""}
            </label>
            ${resetBtn}
          </div>
        `;
          break;
        case "number":
          inputHtml = `
          <div class="config-field-wrapper">
            <label class="config-field">
              <span class="config-field-label">${field.label}</span>
              <input type="number" id="${id}" name="${key}" value="${value}"
                     ${field.min !== void 0 ? `min="${field.min}"` : ""}
                     ${field.max !== void 0 ? `max="${field.max}"` : ""}>
              ${field.help ? `<span class="config-field-help">${field.help}</span>` : ""}
            </label>
            ${resetBtn}
          </div>
        `;
          break;
        case "range": {
          const displayValue = field.formatValue ? field.formatValue(value) : value;
          inputHtml = `
          <div class="config-field-wrapper">
            <label class="config-field">
              <span class="config-field-label">${field.label}</span>
              <div class="config-range-input">
                <input type="range" id="${id}" name="${key}" value="${value}"
                       ${field.min !== void 0 ? `min="${field.min}"` : ""}
                       ${field.max !== void 0 ? `max="${field.max}"` : ""}
                       ${field.step !== void 0 ? `step="${field.step}"` : ""}>
                <span class="config-range-value">${displayValue}</span>
              </div>
              ${field.help ? `<span class="config-field-help">${field.help}</span>` : ""}
            </label>
            ${resetBtn}
          </div>
        `;
          break;
        }
        case "color":
          inputHtml = `
          <div class="config-field-wrapper">
            <label class="config-field">
              <span class="config-field-label">${field.label}</span>
              <div class="config-color-input">
                <input type="color" id="${id}" name="${key}" value="${value}">
                <input type="text" id="${id}-text" value="${value}" class="config-color-text">
              </div>
            </label>
            ${resetBtn}
          </div>
        `;
          break;
        case "password":
          inputHtml = `
          <div class="config-field-wrapper">
            <label class="config-field">
              <span class="config-field-label">${field.label}</span>
              <input type="password" id="${id}" name="${key}" value="${value}"
                     placeholder="${field.placeholder || ""}">
              ${field.help ? `<span class="config-field-help">${field.help}</span>` : ""}
            </label>
            ${resetBtn}
          </div>
        `;
          break;
        case "textarea":
        case "css":
          inputHtml = `
          <div class="config-field-wrapper config-field-textarea">
            <label class="config-field">
              <span class="config-field-label">${field.label}</span>
              <textarea id="${id}" name="${key}" rows="${field.rows || 2}"
                        placeholder="${field.placeholder || ""}">${this.escapeHtml(value)}</textarea>
              ${field.help ? `<span class="config-field-help">${field.help}</span>` : ""}
            </label>
            ${resetBtn}
          </div>
        `;
          break;
        default:
          inputHtml = `
          <div class="config-field-wrapper">
            <label class="config-field">
              <span class="config-field-label">${field.label}</span>
              <input type="text" id="${id}" name="${key}" value="${this.escapeHtml(value)}"
                     placeholder="${field.placeholder || ""}">
              ${field.help ? `<span class="config-field-help">${field.help}</span>` : ""}
            </label>
            ${resetBtn}
          </div>
        `;
      }
      if (showWhenAttrs) {
        return `<div class="config-field-conditional ${isHidden ? "hidden" : ""}" ${showWhenAttrs}>${inputHtml}</div>`;
      }
      return inputHtml;
    }
    isFieldModified(key, field, value) {
      const defaultVal = field.default;
      if (field.type === "checkbox") {
        return Boolean(value) !== Boolean(defaultVal);
      }
      if (field.type === "number") {
        return Number(value) !== Number(defaultVal);
      }
      return String(value) !== String(defaultVal);
    }
    // ==================== Rule Builder Methods ====================
    /**
     * Parse raw rules text into structured format for visual editor
     */
    parseRules(text) {
      if (!text) return [];
      const lines = text.split("\n");
      const categories = [];
      let currentCategory = null;
      for (let line of lines) {
        line = line.trim();
        if (!line || line.startsWith(";") || line.startsWith("#")) continue;
        const sectionMatch = line.match(/^\[([^\]]+?)(?:\s*(?:->|)\s*(.*?))?\]$/);
        if (sectionMatch) {
          currentCategory = {
            name: sectionMatch[1].trim(),
            backingList: sectionMatch[2]?.trim() || null,
            rules: []
          };
          categories.push(currentCategory);
          continue;
        }
        if (!currentCategory) continue;
        const ruleMatch = line.match(/^(allow|deny)\s+(all|from|content|include|list)\s*"?([^"]*)"?$/i);
        if (ruleMatch) {
          const [, action, type, value] = ruleMatch;
          currentCategory.rules.push({
            action: action.toLowerCase(),
            type: type.toLowerCase(),
            value: value || ""
          });
          continue;
        }
        if (line.startsWith("$")) {
          currentCategory.rules.push({ action: "allow", type: "include", value: line.substring(1) });
          continue;
        }
        if (line.startsWith("&")) {
          const listMatch = line.match(/^&"?([^"]+)"?$/);
          if (listMatch) {
            currentCategory.rules.push({ action: "allow", type: "list", value: listMatch[1] });
          }
          continue;
        }
        if (line.startsWith("@")) {
          currentCategory.rules.push({ action: "allow", type: "from", value: line });
          continue;
        }
        currentCategory.rules.push({ action: "allow", type: "content", value: line });
      }
      return categories;
    }
    /**
     * Serialize structured rules back to text format
     */
    serializeRules(categories) {
      const lines = [];
      for (const category of categories) {
        if (lines.length > 0) lines.push("");
        if (category.backingList) {
          lines.push(`[${category.name} -> ${category.backingList}]`);
        } else {
          lines.push(`[${category.name}]`);
        }
        for (const rule of category.rules) {
          if (rule.type === "all") {
            lines.push(`${rule.action} all`);
          } else if (rule.action === "deny") {
            lines.push(`${rule.action} ${rule.type} ${rule.value}`);
          } else if (rule.type === "include" && rule.action === "allow") {
            lines.push(`$${rule.value}`);
          } else if (rule.type === "list" && rule.action === "allow") {
            if (rule.value.includes(" ")) {
              lines.push(`&"${rule.value}"`);
            } else {
              lines.push(`&${rule.value}`);
            }
          } else if (rule.type === "from" && rule.value.startsWith("@")) {
            lines.push(rule.value);
          } else if (rule.type === "content") {
            lines.push(rule.value);
          } else {
            lines.push(`${rule.action} ${rule.type} ${rule.value}`);
          }
        }
      }
      return lines.join("\n");
    }
    /**
     * Render the Rules panel with sub-tabs
     */
    renderRulesPanel() {
      const rulesConfig = this.config.get("rulesConfig") ?? "";
      this.parsedRules = this.parseRules(rulesConfig);
      const ruleColorCoding = this.config.get("ruleColorCoding") ?? false;
      const autoOrganizeRules = this.config.get("autoOrganizeRules") ?? false;
      return `
      <div class="rules-panel">
        <div class="rules-options rules-options-top">
          <label class="config-checkbox-label">
            <input type="checkbox" name="ruleColorCoding" ${ruleColorCoding ? "checked" : ""}>
            <span>Color-code rule matches</span>
            <span class="config-field-help">Color handles/avatars in feed and feed map by author rules</span>
          </label>
          <label class="config-checkbox-label">
            <input type="checkbox" name="autoOrganizeRules" ${autoOrganizeRules ? "checked" : ""}>
            <span>Auto-organize rules</span>
            <span class="config-field-help">Automatically sort rules by type then value</span>
          </label>
        </div>
        <div class="rules-subtabs">
          <button class="rules-subtab ${this.rulesSubTab === "visual" ? "active" : ""}"
                  data-subtab="visual">Visual</button>
          <button class="rules-subtab ${this.rulesSubTab === "raw" ? "active" : ""}"
                  data-subtab="raw">Raw</button>
        </div>
        <div class="rules-content">
          <div class="rules-visual ${this.rulesSubTab === "visual" ? "active" : ""}">
            ${this.renderVisualEditor()}
          </div>
          <div class="rules-raw ${this.rulesSubTab === "raw" ? "active" : ""}">
            <textarea id="config-rulesConfig" name="rulesConfig" rows="12"
                      placeholder="Enter filter rules...">${this.escapeHtml(rulesConfig)}</textarea>
          </div>
        </div>
      </div>
    `;
    }
    /**
     * Render the Timeouts panel
     */
    renderTimeoutsPanel() {
      const defaultDuration = this.config.get("timeoutDefaultDuration") || "1d";
      const timeouts = state.timeouts || {};
      const activeTimeouts = Object.entries(timeouts).filter(([, expiresAt]) => Date.now() < expiresAt).sort((a, b) => a[1] - b[1]);
      return `
      <div class="timeouts-panel">
        <div class="config-field">
          <label class="config-field-label">Default timeout duration</label>
          <select id="config-timeoutDefaultDuration" name="timeoutDefaultDuration" class="config-field-input">
            ${["1h", "6h", "12h", "1d", "3d", "7d", "14d", "30d"].map((d) => `
              <option value="${d}" ${d === defaultDuration ? "selected" : ""}>${this.formatDurationLabel(d)}</option>
            `).join("")}
          </select>
          <span class="config-field-help">Default duration when timing out an author (! hotkey)</span>
        </div>

        <div class="timeouts-active-section">
          <h3 class="timeouts-section-title">Active Timeouts</h3>
          ${activeTimeouts.length === 0 ? `
            <div class="timeouts-empty">
              No active timeouts. Press <kbd>!</kbd> on a post to timeout an author.
            </div>
          ` : `
            <div class="timeouts-list">
              ${activeTimeouts.map(([handle2, expiresAt]) => `
                <div class="timeout-item" data-handle="${this.escapeHtml(handle2)}">
                  <span class="timeout-handle">@${this.escapeHtml(handle2)}</span>
                  <span class="timeout-expires">expires in ${this.formatTimeRemaining(expiresAt - Date.now())}</span>
                  <button type="button" class="timeout-clear-btn" data-handle="${this.escapeHtml(handle2)}"
                          title="Remove timeout">\u2715</button>
                </div>
              `).join("")}
            </div>
            <button type="button" class="timeout-clear-all-btn">Clear All Timeouts</button>
          `}
        </div>
      </div>
    `;
    }
    /**
     * Format duration string for display
     */
    formatDurationLabel(duration) {
      const labels2 = {
        "1h": "1 hour",
        "6h": "6 hours",
        "12h": "12 hours",
        "1d": "1 day",
        "3d": "3 days",
        "7d": "7 days",
        "14d": "14 days",
        "30d": "30 days"
      };
      return labels2[duration] || duration;
    }
    /**
     * Format remaining time for display
     */
    formatTimeRemaining(ms) {
      if (ms <= 0) return "expired";
      const hours = Math.floor(ms / (1e3 * 60 * 60));
      const days = Math.floor(hours / 24);
      const remainingHours = hours % 24;
      if (days > 0) {
        return remainingHours > 0 ? `${days}d ${remainingHours}h` : `${days} day${days > 1 ? "s" : ""}`;
      }
      if (hours > 0) {
        return `${hours} hour${hours > 1 ? "s" : ""}`;
      }
      const minutes = Math.floor(ms / (1e3 * 60));
      return `${minutes} minute${minutes !== 1 ? "s" : ""}`;
    }
    /**
     * Refresh the Timeouts panel
     */
    refreshTimeoutsPanel() {
      const panel = this.modalEl.querySelector('[data-panel="Timeouts"]');
      if (panel) {
        panel.innerHTML = this.renderTimeoutsPanel();
        this.attachTimeoutsEventListeners();
      }
    }
    /**
     * Attach event listeners for the Timeouts panel
     */
    attachTimeoutsEventListeners() {
      const panel = this.modalEl.querySelector(".timeouts-panel");
      if (!panel) return;
      const durationSelect = panel.querySelector("#config-timeoutDefaultDuration");
      if (durationSelect) {
        durationSelect.addEventListener("change", (e) => {
          this.handleInputChange(e);
        });
      }
      panel.querySelectorAll(".timeout-clear-btn").forEach((btn) => {
        btn.addEventListener("click", (e) => {
          const handle2 = e.target.dataset.handle;
          this.clearTimeout(handle2);
        });
      });
      const clearAllBtn = panel.querySelector(".timeout-clear-all-btn");
      if (clearAllBtn) {
        clearAllBtn.addEventListener("click", () => {
          if (confirm("Clear all active timeouts?")) {
            this.clearAllTimeouts();
          }
        });
      }
    }
    /**
     * Clear a single timeout
     */
    clearTimeout(handle2) {
      const { [handle2]: _removed, ...remainingTimeouts } = state.timeouts || {};
      state.stateManager.updateState({ timeouts: remainingTimeouts });
      state.stateManager.saveStateImmediately(true, true);
      this.refreshTimeoutsPanel();
      window.dispatchEvent(new CustomEvent("bsky-nav-timeout-cleared", { detail: { handle: handle2 } }));
    }
    /**
     * Clear all timeouts
     */
    clearAllTimeouts() {
      state.stateManager.updateState({ timeouts: {} });
      state.stateManager.saveStateImmediately(true, true);
      this.refreshTimeoutsPanel();
      window.dispatchEvent(new CustomEvent("bsky-nav-timeout-cleared", { detail: { all: true } }));
    }
    /**
     * Render the visual rule editor
     */
    renderVisualEditor() {
      if (this.parsedRules.length === 0) {
        return `
        <div class="rules-empty">
          No filter rules defined. Click "Add Category" to create one.
        </div>
        <button type="button" class="rules-add-category">+ Add Category</button>
      `;
      }
      const categoriesHtml = this.parsedRules.map((category, catIndex) => {
        const isCollapsed = this.collapsedCategories[catIndex];
        const colorIndex = this.getColorIndexForCategory(category.name);
        const color = constants.FILTER_LIST_COLORS[colorIndex];
        return `
        <div class="rules-category" draggable="true" data-category="${catIndex}">
          <div class="rules-category-header">
            <span class="rules-category-drag-handle" title="Drag to reorder">\u22EE\u22EE</span>
            <button type="button" class="rules-category-toggle ${isCollapsed ? "collapsed" : ""}"
                    data-category="${catIndex}">
              <span class="rules-toggle-icon">${isCollapsed ? "\u25B6" : "\u25BC"}</span>
            </button>
            <div class="rules-color-picker" data-category="${catIndex}">
              <button type="button" class="rules-color-swatch" style="background-color: ${color}"
                      title="Click to change color" data-category="${catIndex}"></button>
              <div class="rules-color-dropdown">
                ${constants.FILTER_LIST_COLORS.map((c, i) => `
                  <button type="button" class="rules-color-option ${i === colorIndex ? "selected" : ""}"
                          style="background-color: ${c}" data-color-index="${i}" data-category="${catIndex}"></button>
                `).join("")}
              </div>
            </div>
            <input type="text" class="rules-category-name" value="${this.escapeHtml(category.name)}"
                   data-category="${catIndex}">
            <select class="rules-backing-list" data-category="${catIndex}"
                    title="Backing list (authors in list are automatically matched)"
                    ${!this.hasApiAccess() ? "disabled" : ""}>
              <option value="">No backing list</option>
              ${(this.cachedListNames || []).map((name) => `
                <option value="${this.escapeHtml(name)}"
                        ${category.backingList === name ? "selected" : ""}>
                  ${this.escapeHtml(name)}
                </option>
              `).join("")}
              ${category.backingList && !(this.cachedListNames || []).includes(category.backingList) ? `
                <option value="${this.escapeHtml(category.backingList)}" selected>
                  ${this.escapeHtml(category.backingList)}
                </option>
              ` : ""}
            </select>
            <button type="button" class="rules-sync-btn" data-category="${this.escapeHtml(category.name)}"
                    title="Sync with Bluesky list" ${!this.hasApiAccess() ? "disabled" : ""}>
              \u27F3
            </button>
            <button type="button" class="rules-category-organize" data-category="${catIndex}"
                    title="Sort rules in this category">\u21C5</button>
            <button type="button" class="rules-category-delete" data-category="${catIndex}"
                    title="Delete category">\u{1F5D1}</button>
          </div>
          <div class="rules-category-body ${isCollapsed ? "collapsed" : ""}">
            ${this.renderRuleRows(category.rules, catIndex)}
            <button type="button" class="rules-add-rule" data-category="${catIndex}">+ Add Rule</button>
          </div>
        </div>
      `;
      }).join("");
      return `
      ${categoriesHtml}
      <button type="button" class="rules-add-category">+ Add Category</button>
    `;
    }
    /**
     * Render rule rows for a category
     */
    renderRuleRows(rules, catIndex) {
      if (rules.length === 0) {
        return `<div class="rules-empty-category">No rules in this category.</div>`;
      }
      const currentCategoryName = this.parsedRules[catIndex]?.name;
      const otherCategories = this.parsedRules.map((c) => c.name).filter((name) => name !== currentCategoryName);
      return rules.map((rule, ruleIndex) => {
        let valueHtml;
        if (rule.type === "include") {
          valueHtml = `
          <select class="rules-value rules-include-select" data-category="${catIndex}" data-rule="${ruleIndex}">
            <option value="">Select category...</option>
            ${otherCategories.map((name) => `
              <option value="${this.escapeHtml(name)}" ${rule.value === name ? "selected" : ""}>${this.escapeHtml(name)}</option>
            `).join("")}
          </select>
        `;
        } else if (rule.type === "list") {
          const listNames = this.cachedListNames || [];
          const hasCurrentValue = rule.value && !listNames.includes(rule.value);
          const currentValueOption = hasCurrentValue ? `<option value="${this.escapeHtml(rule.value)}" selected>${this.escapeHtml(rule.value)}</option>` : "";
          const listOptions2 = listNames.map((name) => `
          <option value="${this.escapeHtml(name)}" ${rule.value === name ? "selected" : ""}>${this.escapeHtml(name)}</option>
        `).join("");
          valueHtml = `
          <select class="rules-value rules-list-select" data-category="${catIndex}" data-rule="${ruleIndex}">
            <option value="">Select list...</option>
            ${currentValueOption}
            ${listOptions2}
          </select>
        `;
        } else if (rule.type === "all") {
          valueHtml = `<input type="text" class="rules-value" value="" disabled data-category="${catIndex}" data-rule="${ruleIndex}">`;
        } else {
          valueHtml = `
          <input type="text" class="rules-value" value="${this.escapeHtml(rule.value)}"
                 placeholder="${rule.type === "from" ? "@handle or regex" : "keyword or regex"}"
                 data-category="${catIndex}" data-rule="${ruleIndex}">
        `;
        }
        const unsavedClass = rule._unsaved ? " rules-row-unsaved" : "";
        const saveButton = rule._unsaved ? `
        <button type="button" class="rules-save-rule" data-category="${catIndex}" data-rule="${ruleIndex}"
                title="Save this rule">\u{1F4BE}</button>
      ` : "";
        return `
        <div class="rules-row${unsavedClass}" draggable="true" data-category="${catIndex}" data-rule="${ruleIndex}">
          <span class="rules-drag-handle" title="Drag to reorder">\u22EE\u22EE</span>
          <select class="rules-action" data-category="${catIndex}" data-rule="${ruleIndex}">
            <option value="allow" ${rule.action === "allow" ? "selected" : ""}>Allow</option>
            <option value="deny" ${rule.action === "deny" ? "selected" : ""}>Deny</option>
          </select>
          <select class="rules-type" data-category="${catIndex}" data-rule="${ruleIndex}">
            <option value="from" ${rule.type === "from" ? "selected" : ""}>From (author)</option>
            <option value="content" ${rule.type === "content" ? "selected" : ""}>Content (text)</option>
            <option value="include" ${rule.type === "include" ? "selected" : ""}>Include (category)</option>
            <option value="list" ${rule.type === "list" ? "selected" : ""}>List (&name)</option>
            <option value="all" ${rule.type === "all" ? "selected" : ""}>All</option>
          </select>
          ${valueHtml}
          ${saveButton}
          <button type="button" class="rules-delete-rule" data-category="${catIndex}" data-rule="${ruleIndex}"
                  title="Delete rule">\u{1F5D1}</button>
        </div>
      `;
      }).join("");
    }
    /**
     * Update raw textarea from parsed rules
     * @param {boolean} skipAutoOrganize - Skip auto-organize (used when manually organizing)
     */
    syncVisualToRaw(skipAutoOrganize = false) {
      if (!skipAutoOrganize && this.config.get("autoOrganizeRules")) {
        this.organizeAllRules();
      }
      const rawText = this.serializeRules(this.parsedRules);
      const textarea = this.modalEl.querySelector("#config-rulesConfig");
      if (textarea) {
        textarea.value = rawText;
      }
      this.pendingChanges["rulesConfig"] = rawText;
    }
    /**
     * Re-render just the visual editor content
     */
    async refreshVisualEditor() {
      if (this._refreshPending) {
        this._refreshQueued = true;
        return;
      }
      this._refreshPending = true;
      try {
        if (!this._listNamesFetched) {
          this._listNamesFetched = true;
          await this.updateCachedListNames(true);
        }
        const visualContainer = this.modalEl.querySelector(".rules-visual");
        if (visualContainer) {
          visualContainer.innerHTML = this.renderVisualEditor();
          this.attachRulesEventListeners();
        }
      } finally {
        this._refreshPending = false;
        if (this._refreshQueued) {
          this._refreshQueued = false;
          setTimeout(() => this.refreshVisualEditor(), 0);
        }
      }
    }
    /**
     * Update cached list names from API
     */
    async updateCachedListNames(forceRefresh = false) {
      const listCache = unsafeWindow.blueskyNavigatorState?.listCache;
      if (listCache) {
        try {
          this.cachedListNames = await listCache.getListNames(forceRefresh);
        } catch (e) {
          console.warn("Failed to fetch list names:", e);
        }
      }
    }
    /**
     * Force refresh of cached list names (call after creating/deleting lists)
     */
    async refreshListNames() {
      this.cachedListNames = null;
      await this.updateCachedListNames();
    }
    /**
     * Get the color index for a category (custom or default based on name hash)
     * @param {string} categoryName - The category name
     * @returns {number} The color index
     */
    getColorIndexForCategory(categoryName) {
      try {
        const rulesetColors = JSON.parse(this.config.get("rulesetColors") || "{}");
        if (categoryName in rulesetColors) {
          return rulesetColors[categoryName] % constants.FILTER_LIST_COLORS.length;
        }
      } catch (e) {
      }
      let hash = 0;
      for (let i = 0; i < categoryName.length; i++) {
        hash = (hash << 5) - hash + categoryName.charCodeAt(i);
        hash = hash & hash;
      }
      return Math.abs(hash) % constants.FILTER_LIST_COLORS.length;
    }
    /**
     * Set the color index for a category
     * @param {string} categoryName - The category name
     * @param {number} colorIndex - The color index
     */
    setColorForCategory(categoryName, colorIndex) {
      try {
        const rulesetColors = JSON.parse(this.config.get("rulesetColors") || "{}");
        rulesetColors[categoryName] = colorIndex;
        this.config.set("rulesetColors", JSON.stringify(rulesetColors));
        this.pendingChanges["rulesetColors"] = JSON.stringify(rulesetColors);
      } catch (e) {
        const rulesetColors = { [categoryName]: colorIndex };
        this.config.set("rulesetColors", JSON.stringify(rulesetColors));
        this.pendingChanges["rulesetColors"] = JSON.stringify(rulesetColors);
      }
    }
    /**
     * Organize rules in a category by type and value.
     * Type order: all, include, list, from, content
     * Within same type, sort by value alphabetically.
     * This sorting is safe because rules of different types don't overlap.
     * Unsaved rules are kept at the bottom (not sorted) until saved.
     * @param {number} catIndex - The category index
     */
    organizeRulesInCategory(catIndex) {
      const category = this.parsedRules[catIndex];
      if (!category || !category.rules) return;
      const savedRules = category.rules.filter((r) => !r._unsaved);
      const unsavedRules = category.rules.filter((r) => r._unsaved);
      const typeOrder = { all: 0, include: 1, list: 2, from: 3, content: 4 };
      savedRules.sort((a, b) => {
        const typeA = typeOrder[a.type] ?? 99;
        const typeB = typeOrder[b.type] ?? 99;
        if (typeA !== typeB) return typeA - typeB;
        if (a.action !== b.action) {
          return a.action === "deny" ? -1 : 1;
        }
        return (a.value || "").localeCompare(b.value || "", void 0, { sensitivity: "base" });
      });
      category.rules = [...savedRules, ...unsavedRules];
    }
    /**
     * Organize all categories' rules
     */
    organizeAllRules() {
      for (let i = 0; i < this.parsedRules.length; i++) {
        this.organizeRulesInCategory(i);
      }
    }
    /**
     * Clear unsaved flags from rules in a category (or all categories if catIndex is null)
     * @param {number|null} catIndex - Category index, or null for all categories
     */
    clearUnsavedFlags(catIndex = null) {
      const categories = catIndex !== null ? [this.parsedRules[catIndex]] : this.parsedRules;
      for (const category of categories) {
        if (category && category.rules) {
          for (const rule of category.rules) {
            delete rule._unsaved;
          }
        }
      }
    }
    /**
     * Clear all unsaved flags (called on save)
     */
    clearAllUnsavedFlags() {
      this.clearUnsavedFlags(null);
    }
    /**
     * Attach event listeners for the rules panel
     */
    attachRulesEventListeners(modal = null) {
      const container = modal || this.modalEl;
      if (!container) return;
      const panel = container.querySelector(".rules-panel");
      if (!panel) return;
      panel.querySelectorAll(".rules-subtab").forEach((tab) => {
        tab.addEventListener("click", (e) => {
          this.rulesSubTab = e.target.dataset.subtab;
          if (this.rulesSubTab === "visual") {
            const textarea2 = this.modalEl.querySelector("#config-rulesConfig");
            if (textarea2) {
              this.parsedRules = this.parseRules(textarea2.value);
            }
          }
          panel.querySelectorAll(".rules-subtab").forEach((t) => t.classList.toggle("active", t.dataset.subtab === this.rulesSubTab));
          panel.querySelector(".rules-visual").classList.toggle("active", this.rulesSubTab === "visual");
          panel.querySelector(".rules-raw").classList.toggle("active", this.rulesSubTab === "raw");
          if (this.rulesSubTab === "visual") {
            this.refreshVisualEditor();
          }
        });
      });
      panel.querySelectorAll(".rules-category-toggle").forEach((btn) => {
        btn.addEventListener("click", (e) => {
          const catIndex = parseInt(e.currentTarget.dataset.category);
          this.collapsedCategories[catIndex] = !this.collapsedCategories[catIndex];
          this.refreshVisualEditor();
        });
      });
      panel.querySelectorAll(".rules-color-swatch").forEach((btn) => {
        btn.addEventListener("click", (e) => {
          e.stopPropagation();
          const picker = e.target.closest(".rules-color-picker");
          const dropdown = picker.querySelector(".rules-color-dropdown");
          panel.querySelectorAll(".rules-color-dropdown.open").forEach((d) => {
            if (d !== dropdown) d.classList.remove("open");
          });
          dropdown.classList.toggle("open");
        });
      });
      panel.querySelectorAll(".rules-color-option").forEach((btn) => {
        btn.addEventListener("click", (e) => {
          const catIndex = parseInt(e.target.dataset.category);
          const colorIndex = parseInt(e.target.dataset.colorIndex);
          const categoryName = this.parsedRules[catIndex].name;
          this.setColorForCategory(categoryName, colorIndex);
          this.refreshVisualEditor();
        });
      });
      document.addEventListener("click", (e) => {
        if (!e.target.closest(".rules-color-picker")) {
          panel.querySelectorAll(".rules-color-dropdown.open").forEach((d) => d.classList.remove("open"));
        }
      }, { once: true });
      panel.querySelectorAll(".rules-category-name").forEach((input) => {
        input.addEventListener("change", (e) => {
          const catIndex = parseInt(e.target.dataset.category);
          this.parsedRules[catIndex].name = e.target.value;
          this.syncVisualToRaw();
        });
      });
      panel.querySelectorAll(".rules-backing-list").forEach((select) => {
        select.addEventListener("change", (e) => {
          const catIndex = parseInt(e.target.dataset.category);
          const listName = e.target.value || null;
          this.parsedRules[catIndex].backingList = listName;
          this.syncVisualToRaw();
        });
      });
      panel.querySelectorAll(".rules-category-delete").forEach((btn) => {
        btn.addEventListener("click", (e) => {
          const catIndex = parseInt(e.target.dataset.category);
          if (confirm(`Delete category "${this.parsedRules[catIndex].name}" and all its rules?`)) {
            this.parsedRules.splice(catIndex, 1);
            this.syncVisualToRaw();
            this.refreshVisualEditor();
          }
        });
      });
      panel.querySelectorAll(".rules-add-category").forEach((btn) => {
        btn.addEventListener("click", () => {
          this.parsedRules.push({ name: "new-category", rules: [] });
          this.syncVisualToRaw();
          this.refreshVisualEditor();
        });
      });
      panel.querySelectorAll(".rules-sync-btn").forEach((btn) => {
        btn.addEventListener("click", (e) => {
          e.stopPropagation();
          const category = btn.dataset.category;
          this.showSyncMenu(btn, category);
        });
      });
      panel.querySelectorAll(".rules-category-organize").forEach((btn) => {
        btn.addEventListener("click", (e) => {
          const catIndex = parseInt(e.target.dataset.category);
          this.organizeRulesInCategory(catIndex);
          this.syncVisualToRaw();
          this.refreshVisualEditor();
        });
      });
      let draggedCategory = null;
      let draggedCategoryIndex = null;
      panel.querySelectorAll(".rules-category").forEach((category) => {
        category.addEventListener("dragstart", (e) => {
          if (!e.target.classList.contains("rules-category") && !e.target.closest(".rules-category-drag-handle")) {
            e.preventDefault();
            return;
          }
          draggedCategory = category;
          draggedCategoryIndex = parseInt(category.dataset.category);
          category.classList.add("dragging");
          e.dataTransfer.effectAllowed = "move";
          e.dataTransfer.setData("text/plain", "category");
        });
        category.addEventListener("dragend", () => {
          if (draggedCategory) {
            draggedCategory.classList.remove("dragging");
          }
          panel.querySelectorAll(".rules-category").forEach((c) => c.classList.remove("drag-over"));
          draggedCategory = null;
          draggedCategoryIndex = null;
        });
        category.addEventListener("dragover", (e) => {
          if (e.dataTransfer.types.includes("text/plain") && draggedCategory) {
            e.preventDefault();
            e.dataTransfer.dropEffect = "move";
            if (category !== draggedCategory) {
              category.classList.add("drag-over");
            }
          }
        });
        category.addEventListener("dragleave", () => {
          category.classList.remove("drag-over");
        });
        category.addEventListener("drop", (e) => {
          if (!draggedCategory) return;
          e.preventDefault();
          category.classList.remove("drag-over");
          const targetCategoryIndex = parseInt(category.dataset.category);
          if (targetCategoryIndex === draggedCategoryIndex) return;
          const [movedCategory] = this.parsedRules.splice(draggedCategoryIndex, 1);
          this.parsedRules.splice(targetCategoryIndex, 0, movedCategory);
          this.syncVisualToRaw();
          this.refreshVisualEditor();
        });
      });
      panel.querySelectorAll(".rules-add-rule").forEach((btn) => {
        btn.addEventListener("click", (e) => {
          const catIndex = parseInt(e.target.dataset.category);
          this.clearUnsavedFlags(catIndex);
          this.parsedRules[catIndex].rules.push({ action: "allow", type: "content", value: "", _unsaved: true });
          this.syncVisualToRaw();
          this.refreshVisualEditor();
        });
      });
      panel.querySelectorAll(".rules-action").forEach((select) => {
        select.addEventListener("change", (e) => {
          const catIndex = parseInt(e.target.dataset.category);
          const ruleIndex = parseInt(e.target.dataset.rule);
          this.parsedRules[catIndex].rules[ruleIndex].action = e.target.value;
          this.syncVisualToRaw();
        });
      });
      panel.querySelectorAll(".rules-type").forEach((select) => {
        select.addEventListener("change", (e) => {
          const catIndex = parseInt(e.target.dataset.category);
          const ruleIndex = parseInt(e.target.dataset.rule);
          const rule = this.parsedRules[catIndex].rules[ruleIndex];
          rule.type = e.target.value;
          if (rule.type === "all") {
            rule.value = "";
          }
          this.syncVisualToRaw();
          this.refreshVisualEditor();
        });
      });
      panel.querySelectorAll(".rules-value").forEach((input) => {
        input.addEventListener("change", (e) => {
          const catIndex = parseInt(e.target.dataset.category);
          const ruleIndex = parseInt(e.target.dataset.rule);
          this.parsedRules[catIndex].rules[ruleIndex].value = e.target.value;
          this.syncVisualToRaw();
        });
      });
      panel.querySelectorAll(".rules-delete-rule").forEach((btn) => {
        btn.addEventListener("click", (e) => {
          const catIndex = parseInt(e.target.dataset.category);
          const ruleIndex = parseInt(e.target.dataset.rule);
          this.parsedRules[catIndex].rules.splice(ruleIndex, 1);
          this.syncVisualToRaw();
          this.refreshVisualEditor();
        });
      });
      panel.querySelectorAll(".rules-save-rule").forEach((btn) => {
        btn.addEventListener("click", (e) => {
          const catIndex = parseInt(e.target.dataset.category);
          const ruleIndex = parseInt(e.target.dataset.rule);
          delete this.parsedRules[catIndex].rules[ruleIndex]._unsaved;
          if (this.config.get("autoOrganizeRules")) {
            this.organizeRulesInCategory(catIndex);
          }
          this.syncVisualToRaw(true);
          this.refreshVisualEditor();
        });
      });
      panel.querySelectorAll(".rules-list-select").forEach((select) => {
        select.addEventListener("change", (e) => {
          const catIndex = parseInt(e.target.dataset.category);
          const ruleIndex = parseInt(e.target.dataset.rule);
          this.parsedRules[catIndex].rules[ruleIndex].value = e.target.value;
          this.syncVisualToRaw();
        });
      });
      let draggedRow = null;
      let draggedCatIndex = null;
      let draggedRuleIndex = null;
      panel.querySelectorAll(".rules-row").forEach((row) => {
        row.addEventListener("dragstart", (e) => {
          draggedRow = row;
          draggedCatIndex = parseInt(row.dataset.category);
          draggedRuleIndex = parseInt(row.dataset.rule);
          row.classList.add("dragging");
          e.dataTransfer.effectAllowed = "move";
          e.dataTransfer.setData("text/plain", "");
        });
        row.addEventListener("dragend", () => {
          if (draggedRow) {
            draggedRow.classList.remove("dragging");
          }
          panel.querySelectorAll(".rules-row").forEach((r) => r.classList.remove("drag-over"));
          draggedRow = null;
          draggedCatIndex = null;
          draggedRuleIndex = null;
        });
        row.addEventListener("dragover", (e) => {
          e.preventDefault();
          e.dataTransfer.dropEffect = "move";
          const targetCatIndex = parseInt(row.dataset.category);
          if (targetCatIndex === draggedCatIndex && row !== draggedRow) {
            row.classList.add("drag-over");
          }
        });
        row.addEventListener("dragleave", () => {
          row.classList.remove("drag-over");
        });
        row.addEventListener("drop", (e) => {
          e.preventDefault();
          row.classList.remove("drag-over");
          const targetCatIndex = parseInt(row.dataset.category);
          const targetRuleIndex = parseInt(row.dataset.rule);
          if (targetCatIndex !== draggedCatIndex || targetRuleIndex === draggedRuleIndex) {
            return;
          }
          const rules = this.parsedRules[draggedCatIndex].rules;
          const [movedRule] = rules.splice(draggedRuleIndex, 1);
          rules.splice(targetRuleIndex, 0, movedRule);
          this.syncVisualToRaw();
          this.refreshVisualEditor();
        });
      });
      const textarea = panel.querySelector("#config-rulesConfig");
      if (textarea) {
        textarea.addEventListener("change", (e) => {
          this.pendingChanges["rulesConfig"] = e.target.value;
        });
      }
    }
    switchTab(tabName) {
      this.activeTab = tabName;
      this.modalEl.querySelectorAll(".config-tab").forEach((tab) => {
        const isActive = tab.dataset.tab === tabName;
        tab.classList.toggle("active", isActive);
        tab.setAttribute("aria-selected", isActive);
      });
      this.modalEl.querySelectorAll(".config-panel").forEach((panel) => {
        panel.classList.toggle("active", panel.dataset.panel === tabName);
      });
      if (tabName === "Timeouts") {
        this.attachTimeoutsEventListeners();
      }
    }
    handleInputChange(e) {
      const { name, type, value, checked } = e.target;
      const newValue = type === "checkbox" ? checked : value;
      this.pendingChanges[name] = newValue;
      if (e.target.type === "color") {
        const textInput = this.modalEl.querySelector(`#${e.target.id}-text`);
        if (textInput) textInput.value = value;
      }
      if (e.target.type === "range") {
        const valueDisplay = e.target.parentElement.querySelector(".config-range-value");
        if (valueDisplay) {
          const field2 = this.getFieldSchema(name);
          const displayValue = field2?.formatValue ? field2.formatValue(value) : value;
          valueDisplay.textContent = displayValue;
        }
      }
      if (name.startsWith("feedMap")) {
        this.updateFeedMapPreview(name, newValue);
      }
      const field = this.getFieldSchema(name);
      if (field) {
        const wrapper = e.target.closest(".config-field-wrapper");
        const resetBtn = wrapper?.querySelector(".config-field-reset");
        if (resetBtn) {
          const isModified = this.isFieldModified(name, field, newValue);
          resetBtn.classList.toggle("hidden", !isModified);
        }
      }
      this.updateConditionalFields(name, newValue);
    }
    updateConditionalFields(changedKey, newValue) {
      if (!this.modalEl) return;
      const conditionalFields = this.modalEl.querySelectorAll(`[data-show-when-key="${changedKey}"]`);
      conditionalFields.forEach((field) => {
        const requiredValue = field.dataset.showWhenValue;
        const shouldShow = String(newValue) === requiredValue;
        field.classList.toggle("hidden", !shouldShow);
      });
    }
    save() {
      this.clearAllUnsavedFlags();
      if (this.config.get("autoOrganizeRules")) {
        this.organizeAllRules();
        this.syncVisualToRaw(true);
      }
      Object.entries(this.pendingChanges).forEach(([key, value]) => {
        this.config.set(key, value);
      });
      if (this.onSave) {
        this.onSave(this.pendingChanges);
      }
      this.hide();
      announceToScreenReader$2("Settings saved.");
    }
    resetToDefaults() {
      if (!confirm("Reset all settings to defaults? This cannot be undone.")) {
        return;
      }
      Object.entries(CONFIG_SCHEMA).forEach(([, schema2]) => {
        Object.entries(schema2.fields).forEach(([key, field]) => {
          this.config.set(key, field.default);
          this.pendingChanges[key] = field.default;
        });
      });
      const panelsContainer = this.modalEl.querySelector(".config-modal-panels");
      panelsContainer.innerHTML = this.renderPanels();
      this.modalEl.querySelectorAll("input, select, textarea").forEach((input) => {
        input.addEventListener("change", (e) => this.handleInputChange(e));
      });
      announceToScreenReader$2("Settings reset to defaults.");
    }
    escapeHtml(text) {
      if (text === null || text === void 0) return "";
      const div = document.createElement("div");
      div.textContent = String(text);
      return div.innerHTML;
    }
    /**
     * Checks if AT Protocol API is available
     */
    hasApiAccess() {
      return !!unsafeWindow.blueskyNavigatorState?.listCache?.api;
    }
    /**
     * Shows the sync options menu
     */
    showSyncMenu(anchorEl, category) {
      this.modalEl.querySelectorAll(".rules-sync-menu").forEach((m) => m.remove());
      const menu = document.createElement("div");
      menu.className = "rules-sync-menu";
      menu.innerHTML = `
      <button class="sync-menu-item" data-action="push">Push to List...</button>
      <button class="sync-menu-item" data-action="pull">Pull from List...</button>
      <button class="sync-menu-item" data-action="bidirectional">Bidirectional Sync...</button>
      <hr class="sync-menu-divider">
      <button class="sync-menu-item" data-action="dedupe">Remove Duplicates...</button>
    `;
      const rect = anchorEl.getBoundingClientRect();
      const modalBody = this.modalEl.querySelector(".config-modal-body");
      const modalRect = modalBody.getBoundingClientRect();
      menu.style.position = "absolute";
      menu.style.top = `${rect.bottom - modalRect.top + 5}px`;
      menu.style.left = `${rect.left - modalRect.left}px`;
      menu.querySelectorAll(".sync-menu-item").forEach((item) => {
        item.addEventListener("click", () => {
          menu.remove();
          if (item.dataset.action === "dedupe") {
            this.showDedupeDialog(category);
          } else {
            this.showSyncDialog(category, item.dataset.action);
          }
        });
      });
      const closeHandler = (e) => {
        if (!menu.contains(e.target)) {
          menu.remove();
          document.removeEventListener("click", closeHandler);
        }
      };
      setTimeout(() => document.addEventListener("click", closeHandler), 0);
      modalBody.appendChild(menu);
    }
    /**
     * Shows the sync dialog for a category
     */
    async showSyncDialog(category, action) {
      const listCache = unsafeWindow.blueskyNavigatorState?.listCache;
      if (!listCache) {
        alert("AT Protocol agent not configured. Please set up your app password in settings.");
        return;
      }
      const listNames = await listCache.getListNames();
      const categoryIndex = this.parsedRules.findIndex((c) => c.name === category);
      const categoryRules = categoryIndex >= 0 ? this.parsedRules[categoryIndex].rules : [];
      const handles = categoryRules.filter((r) => r.type === "from" && r.value.startsWith("@")).map((r) => r.value.replace(/^@/, ""));
      const dialog = document.createElement("div");
      dialog.className = "sync-dialog-overlay";
      if (action === "push") {
        dialog.innerHTML = this.renderPushDialog(category, listNames, handles);
      } else if (action === "pull") {
        dialog.innerHTML = this.renderPullDialog(category, listNames);
      } else {
        dialog.innerHTML = this.renderBidirectionalDialog(category, listNames, handles);
      }
      this.setupSyncDialogEvents(dialog, category, action, listCache);
      document.body.appendChild(dialog);
    }
    /**
     * Render push dialog
     */
    renderPushDialog(category, listNames, handles) {
      const listOptions2 = listNames.map(
        (name) => `<option value="${this.escapeHtml(name)}">${this.escapeHtml(name)}</option>`
      ).join("");
      return `
      <div class="sync-dialog">
        <div class="sync-dialog-header">
          <h3>Push "${this.escapeHtml(category)}" to Bluesky List</h3>
          <button class="sync-dialog-close">&times;</button>
        </div>
        <div class="sync-dialog-body">
          <div class="sync-option">
            <label>
              <input type="radio" name="listChoice" value="new" checked>
              Create new list:
            </label>
            <input type="text" class="sync-new-list-name" placeholder="List name">
          </div>
          <div class="sync-option">
            <label>
              <input type="radio" name="listChoice" value="existing">
              Existing list:
            </label>
            <select class="sync-existing-list">
              <option value="">Select a list...</option>
              ${listOptions2}
            </select>
          </div>
          <div class="sync-preview">
            <strong>${handles.length}</strong> handles will be synced
          </div>
        </div>
        <div class="sync-dialog-footer">
          <button class="sync-cancel">Cancel</button>
          <button class="sync-confirm" data-action="push">Push to List</button>
        </div>
      </div>
    `;
    }
    /**
     * Render pull dialog
     */
    renderPullDialog(category, listNames) {
      const listOptions2 = listNames.map(
        (name) => `<option value="${this.escapeHtml(name)}">${this.escapeHtml(name)}</option>`
      ).join("");
      return `
      <div class="sync-dialog">
        <div class="sync-dialog-header">
          <h3>Pull from Bluesky List to "${this.escapeHtml(category)}"</h3>
          <button class="sync-dialog-close">&times;</button>
        </div>
        <div class="sync-dialog-body">
          <div class="sync-option">
            <label>Select source list:</label>
            <select class="sync-existing-list">
              <option value="">Select a list...</option>
              ${listOptions2}
            </select>
          </div>
          <div class="sync-option">
            <label>
              <input type="radio" name="ruleAction" value="allow" checked> Add as: allow from @handle
            </label>
            <label>
              <input type="radio" name="ruleAction" value="deny"> Add as: deny from @handle
            </label>
          </div>
          <div class="sync-preview"></div>
        </div>
        <div class="sync-dialog-footer">
          <button class="sync-cancel">Cancel</button>
          <button class="sync-confirm" data-action="pull">Import Handles</button>
        </div>
      </div>
    `;
    }
    /**
     * Render bidirectional dialog (combines push and pull)
     */
    renderBidirectionalDialog(category, listNames, handles) {
      const listOptions2 = listNames.map(
        (name) => `<option value="${this.escapeHtml(name)}">${this.escapeHtml(name)}</option>`
      ).join("");
      return `
      <div class="sync-dialog">
        <div class="sync-dialog-header">
          <h3>Bidirectional Sync: "${this.escapeHtml(category)}"</h3>
          <button class="sync-dialog-close">&times;</button>
        </div>
        <div class="sync-dialog-body">
          <div class="sync-option">
            <label>
              <input type="radio" name="listChoice" value="new" checked>
              Create new list:
            </label>
            <input type="text" class="sync-new-list-name" placeholder="List name">
          </div>
          <div class="sync-option">
            <label>
              <input type="radio" name="listChoice" value="existing">
              Existing list:
            </label>
            <select class="sync-existing-list">
              <option value="">Select a list...</option>
              ${listOptions2}
            </select>
          </div>
          <div class="sync-preview">
            <strong>${handles.length}</strong> handles will be pushed to list
          </div>
          <div class="sync-option">
            <label>Rule action for pulled handles:</label>
            <label>
              <input type="radio" name="ruleAction" value="allow" checked> Add as: allow from @handle
            </label>
            <label>
              <input type="radio" name="ruleAction" value="deny"> Add as: deny from @handle
            </label>
          </div>
        </div>
        <div class="sync-dialog-footer">
          <button class="sync-cancel">Cancel</button>
          <button class="sync-confirm" data-action="bidirectional">Sync Both Ways</button>
        </div>
      </div>
    `;
    }
    /**
     * Setup event listeners for sync dialog
     */
    setupSyncDialogEvents(dialog, category, action, listCache) {
      dialog.querySelector(".sync-dialog-close").addEventListener("click", () => dialog.remove());
      dialog.querySelector(".sync-cancel").addEventListener("click", () => dialog.remove());
      dialog.addEventListener("click", (e) => {
        if (e.target === dialog) dialog.remove();
      });
      if (action === "pull" || action === "bidirectional") {
        const select = dialog.querySelector(".sync-existing-list");
        select.addEventListener("change", async () => {
          const listName = select.value;
          if (!listName) return;
          const members = await listCache.getMembers(listName);
          const categoryIndex = this.parsedRules.findIndex((c) => c.name === category);
          const existingHandles = new Set(
            (categoryIndex >= 0 ? this.parsedRules[categoryIndex].rules : []).filter((r) => r.type === "from").map((r) => r.value.replace(/^@/, "").toLowerCase())
          );
          const newHandles = members ? [...members.keys()].filter((h) => !existingHandles.has(h)) : [];
          dialog.querySelector(".sync-preview").innerHTML = `<strong>${newHandles.length}</strong> new handles will be added`;
        });
      }
      dialog.querySelector(".sync-confirm").addEventListener("click", async () => {
        await this.executeSyncAction(dialog, category, action, listCache);
      });
    }
    /**
     * Execute sync action (placeholder - actual logic in Task 9/10)
     */
    async executeSyncAction(dialog, category, action, listCache) {
      const confirmBtn = dialog.querySelector(".sync-confirm");
      confirmBtn.disabled = true;
      confirmBtn.textContent = "Syncing...";
      try {
        if (action === "push") {
          await this.executePushSync(dialog, category, listCache);
        } else if (action === "pull") {
          await this.executePullSync(dialog, category, listCache);
        } else {
          await this.executePushSync(dialog, category, listCache);
          await this.executePullSync(dialog, category, listCache);
        }
        dialog.remove();
        this.showSyncSuccess("Sync completed successfully");
      } catch (error) {
        console.error("Sync failed:", error);
        confirmBtn.disabled = false;
        confirmBtn.textContent = action === "push" ? "Push to List" : action === "pull" ? "Import Handles" : "Sync Both Ways";
        alert(`Sync failed: ${error.message}`);
      }
    }
    /**
     * Execute push sync - pushes handles from category rules to a Bluesky list
     */
    async executePushSync(dialog, category, listCache) {
      const api = listCache.api;
      const isNewList = dialog.querySelector('input[name="listChoice"][value="new"]').checked;
      let listUri;
      let listName;
      let existingDids = /* @__PURE__ */ new Set();
      if (isNewList) {
        listName = dialog.querySelector(".sync-new-list-name").value.trim();
        if (!listName) throw new Error("Please enter a list name");
        listUri = await api.createList(listName);
        dialog.dataset.createdListName = listName;
        dialog.dataset.createdListUri = listUri;
        listCache.invalidate();
        this.cachedListNames = null;
      } else {
        listName = dialog.querySelector(".sync-existing-list").value;
        if (!listName) throw new Error("Please select a list");
        listUri = await listCache.getListUri(listName);
        if (!listUri) throw new Error(`List "${listName}" not found. Try refreshing the page.`);
        const existingMembers = await api.getListMembers(listUri);
        existingDids = new Set(existingMembers.map((m) => m.did));
      }
      const categoryIndex = this.parsedRules.findIndex((c) => c.name === category);
      const categoryRules = categoryIndex >= 0 ? this.parsedRules[categoryIndex].rules : [];
      const handles = categoryRules.filter((r) => r.type === "from" && r.value.startsWith("@")).map((r) => r.value.replace(/^@/, ""));
      const progressEl = dialog.querySelector(".sync-progress");
      const updateProgress = (current, total2, status) => {
        if (progressEl) {
          progressEl.textContent = `${status} (${current}/${total2})`;
        }
      };
      let processed = 0;
      const total = handles.length;
      for (const handle2 of handles) {
        processed++;
        updateProgress(processed, total, `Resolving ${handle2}...`);
        if (processed % 5 === 0) {
          await new Promise((resolve) => setTimeout(resolve, 100));
        }
        const did2 = await api.resolveHandleToDid(handle2);
        if (did2 && !existingDids.has(did2)) {
          updateProgress(processed, total, `Adding ${handle2}...`);
          await api.addToList(listUri, did2);
        }
      }
      listCache.invalidate(listName);
    }
    /**
     * Execute pull sync - imports list members as rules
     */
    async executePullSync(dialog, category, listCache) {
      let listName = dialog.dataset.createdListName || dialog.querySelector(".sync-existing-list").value;
      if (!listName) throw new Error("Please select a list");
      const ruleAction = dialog.querySelector('input[name="ruleAction"]:checked')?.value || "allow";
      const members = await listCache.getMembers(listName);
      if (!members || members.size === 0) {
        throw new Error("List is empty or could not be fetched");
      }
      let categoryIndex = this.parsedRules.findIndex((c) => c.name === category);
      const categoryRules = categoryIndex >= 0 ? this.parsedRules[categoryIndex].rules : [];
      const existingHandles = new Set(
        categoryRules.filter((r) => r.type === "from").map((r) => {
          let handle2 = r.value.replace(/^@/, "").toLowerCase();
          if (!handle2.includes(".")) {
            handle2 = `${handle2}.bsky.social`;
          }
          return handle2;
        })
      );
      for (const handle2 of members.keys()) {
        if (!existingHandles.has(handle2.toLowerCase())) {
          if (categoryIndex === -1) {
            this.parsedRules.push({ name: category, rules: [] });
            categoryIndex = this.parsedRules.length - 1;
          }
          this.parsedRules[categoryIndex].rules.push({
            action: ruleAction,
            type: "from",
            value: `@${handle2}`
          });
        }
      }
      this.syncVisualToRaw();
      const newRulesConfig = this.pendingChanges["rulesConfig"];
      this.config.set("rulesConfig", newRulesConfig);
      if (unsafeWindow.blueskyNavigatorState) {
        unsafeWindow.blueskyNavigatorState.rulesConfig = newRulesConfig;
      }
      this.refreshVisualEditor();
    }
    /**
     * Show sync success toast
     */
    showSyncSuccess(message2) {
      const toast = document.createElement("div");
      toast.className = "sync-toast";
      toast.textContent = message2;
      document.body.appendChild(toast);
      setTimeout(() => {
        toast.classList.add("sync-toast-hiding");
        setTimeout(() => toast.remove(), 300);
      }, 3e3);
    }
    /**
     * Show deduplication dialog for a category
     */
    async showDedupeDialog(category) {
      const listCache = unsafeWindow.blueskyNavigatorState?.listCache;
      if (!listCache) {
        alert("AT Protocol agent not configured. Please set up your app password in settings.");
        return;
      }
      const duplicates = await this.findDuplicateHandles(category, listCache);
      const dialog = document.createElement("div");
      dialog.className = "sync-dialog-overlay";
      dialog.innerHTML = this.renderDedupeDialog(category, duplicates);
      dialog.querySelector(".sync-dialog-close").addEventListener("click", () => dialog.remove());
      dialog.querySelector(".sync-cancel").addEventListener("click", () => dialog.remove());
      dialog.addEventListener("click", (e) => {
        if (e.target === dialog) dialog.remove();
      });
      const confirmBtn = dialog.querySelector(".sync-confirm");
      if (duplicates.length === 0) {
        confirmBtn.disabled = true;
      } else {
        confirmBtn.addEventListener("click", async () => {
          confirmBtn.disabled = true;
          confirmBtn.textContent = "Removing...";
          try {
            await this.executeDeduplication(category, duplicates);
            dialog.remove();
            this.showSyncSuccess(`Removed ${duplicates.length} duplicate rule(s)`);
          } catch (error) {
            console.error("Deduplication failed:", error);
            confirmBtn.disabled = false;
            confirmBtn.textContent = "Remove Duplicates";
            alert(`Deduplication failed: ${error.message}`);
          }
        });
      }
      document.body.appendChild(dialog);
    }
    /**
     * Find handles in a category that are duplicated in list rules
     * @param {string} category - Category name
     * @param {object} listCache - ListCache instance
     * @returns {Promise<Array>} Array of {handle, listName, action, ruleIndex}
     */
    async findDuplicateHandles(category, listCache) {
      const categoryIndex = this.parsedRules.findIndex((c) => c.name === category);
      if (categoryIndex < 0) return [];
      const categoryRules = this.parsedRules[categoryIndex].rules;
      const duplicates = [];
      const listMembers2 = /* @__PURE__ */ new Map();
      for (const rule of categoryRules) {
        if (rule.type === "list") {
          const listName = rule.value;
          const members = await listCache.getMembers(listName);
          if (members && members.size > 0) {
            listMembers2.set(listName, {
              members: new Set(members.keys()),
              // keys are already lowercase
              action: rule.action
            });
          }
        }
      }
      if (listMembers2.size === 0) return [];
      categoryRules.forEach((rule, ruleIndex) => {
        if (rule.type === "from" && rule.value.startsWith("@")) {
          let handle2 = rule.value.replace(/^@/, "").toLowerCase();
          if (!handle2.includes(".")) {
            handle2 = `${handle2}.bsky.social`;
          }
          for (const [listName, listInfo] of listMembers2) {
            if (listInfo.members.has(handle2) && listInfo.action === rule.action) {
              duplicates.push({
                handle: rule.value,
                listName,
                action: rule.action,
                ruleIndex
              });
              break;
            }
          }
        }
      });
      return duplicates;
    }
    /**
     * Render deduplication dialog
     */
    renderDedupeDialog(category, duplicates) {
      let content;
      if (duplicates.length === 0) {
        content = `
        <p>No duplicate handles found in "${this.escapeHtml(category)}".</p>
        <p class="sync-dialog-hint">Duplicates are @handle rules where the handle is already included in a list rule with the same action (allow/deny).</p>
      `;
      } else {
        const duplicatesList = duplicates.map((d) => `
        <div class="dedupe-item">
          <span class="dedupe-handle">${this.escapeHtml(d.handle)}</span>
          <span class="dedupe-info">\u2192 in list "${this.escapeHtml(d.listName)}" (${d.action})</span>
        </div>
      `).join("");
        content = `
        <p>Found <strong>${duplicates.length}</strong> handle rule(s) that are already covered by list rules:</p>
        <div class="dedupe-list">${duplicatesList}</div>
        <p class="sync-dialog-hint">These individual @handle rules can be removed since they're already included in the referenced lists.</p>
      `;
      }
      return `
      <div class="sync-dialog">
        <div class="sync-dialog-header">
          <h3>Remove Duplicates: "${this.escapeHtml(category)}"</h3>
          <button class="sync-dialog-close">&times;</button>
        </div>
        <div class="sync-dialog-body">
          ${content}
        </div>
        <div class="sync-dialog-footer">
          <button class="sync-cancel">Cancel</button>
          <button class="sync-confirm" data-action="dedupe">${duplicates.length > 0 ? "Remove Duplicates" : "OK"}</button>
        </div>
      </div>
    `;
    }
    /**
     * Execute deduplication - remove duplicate handle rules
     */
    async executeDeduplication(category, duplicates) {
      const categoryIndex = this.parsedRules.findIndex((c) => c.name === category);
      if (categoryIndex < 0) return;
      const sortedDuplicates = [...duplicates].sort((a, b) => b.ruleIndex - a.ruleIndex);
      for (const dup of sortedDuplicates) {
        this.parsedRules[categoryIndex].rules.splice(dup.ruleIndex, 1);
      }
      this.syncVisualToRaw();
      const newRulesConfig = this.pendingChanges["rulesConfig"];
      this.config.set("rulesConfig", newRulesConfig);
      if (unsafeWindow.blueskyNavigatorState) {
        unsafeWindow.blueskyNavigatorState.rulesConfig = newRulesConfig;
      }
      this.refreshVisualEditor();
    }
    /**
     * Update feed map preview dynamically when settings change
     */
    updateFeedMapPreview(name, value) {
      const wrapper = document.querySelector(".feed-map-wrapper");
      const container = document.querySelector(".feed-map-container");
      const target2 = wrapper || container;
      switch (name) {
        case "feedMapScale": {
          const scaleValue = parseInt(value, 10) / 100;
          if (target2) {
            target2.style.setProperty("--indicator-scale", scaleValue);
          }
          break;
        }
        case "feedMapStyle": {
          const wrapper2 = document.querySelector(".feed-map-wrapper");
          if (wrapper2) {
            wrapper2.classList.remove("feed-map-basic", "feed-map-advanced");
            wrapper2.classList.add(value === "Advanced" ? "feed-map-advanced" : "feed-map-basic");
          }
          document.dispatchEvent(new CustomEvent("feedMapSettingChanged", {
            detail: { setting: name, value }
          }));
          break;
        }
        case "feedMapTheme": {
          const wrapper2 = document.querySelector(".feed-map-wrapper");
          if (wrapper2) {
            wrapper2.classList.remove(
              "feed-map-theme-ocean",
              "feed-map-theme-campfire",
              "feed-map-theme-forest",
              "feed-map-theme-monochrome"
            );
            wrapper2.classList.add(`feed-map-theme-${value.toLowerCase()}`);
          }
          document.dispatchEvent(new CustomEvent("feedMapSettingChanged", {
            detail: { setting: name, value }
          }));
          break;
        }
        case "feedMapHeatmap":
        case "feedMapZoom":
          document.dispatchEvent(new CustomEvent("feedMapSettingChanged", {
            detail: { setting: name, value }
          }));
          break;
        case "feedMapIcons":
        case "feedMapAvatars":
        case "feedMapAvatarScale":
        case "feedMapTimestamps":
        case "feedMapHandles":
        case "ruleColorCoding":
          document.dispatchEvent(new CustomEvent("feedMapSettingChanged", {
            detail: { setting: name, value }
          }));
          break;
        case "feedMapPosition":
          document.dispatchEvent(new CustomEvent("feedMapSettingChanged", {
            detail: { setting: name, value }
          }));
          break;
      }
    }
  }
  const STORAGE_KEY = "bluesky_navigator_config";
  const OLD_GM_CONFIG_KEY = "GM_config";
  class ConfigWrapper {
    constructor(options = {}) {
      this.id = options.id || "config";
      this.onSave = options.onSave || null;
      this.onInit = options.onInit || null;
      this.values = {};
      this.defaults = {};
      this.modal = null;
      this.buildDefaults();
      this.migrateFromLegacyStorage();
      this.load();
      this.modal = null;
      setTimeout(() => {
        this.modal = new ConfigModal(this, (changes) => {
          if (this.onSave) {
            this.onSave(changes);
          }
        });
        if (this.onInit) {
          this.onInit();
        }
      }, 0);
    }
    /**
     * Build default values from CONFIG_SCHEMA
     */
    buildDefaults() {
      Object.entries(CONFIG_SCHEMA).forEach(([, tab]) => {
        Object.entries(tab.fields).forEach(([key, field]) => {
          this.defaults[key] = field.default;
        });
      });
      Object.entries(HIDDEN_FIELDS).forEach(([key, field]) => {
        this.defaults[key] = field.default;
      });
    }
    /**
     * Migrate settings from legacy storage format
     * Old versions stored values under 'GM_config' key
     * Migration only runs once - tracked via _migrationComplete flag
     */
    migrateFromLegacyStorage() {
      try {
        const existingNew = GM_getValue(STORAGE_KEY, null);
        let newValues = {};
        if (existingNew !== null) {
          newValues = typeof existingNew === "string" ? JSON.parse(existingNew) : existingNew;
          if (newValues._migrationComplete) {
            return;
          }
        }
        const oldData = GM_getValue(OLD_GM_CONFIG_KEY, null);
        if (oldData === null) {
          newValues._migrationComplete = true;
          GM_setValue(STORAGE_KEY, JSON.stringify(newValues));
          return;
        }
        let oldValues;
        if (typeof oldData === "string") {
          oldValues = JSON.parse(oldData);
        } else if (typeof oldData === "object") {
          oldValues = oldData;
        } else {
          console.warn("[ConfigWrapper] Old config data is in unexpected format:", typeof oldData);
          newValues._migrationComplete = true;
          GM_setValue(STORAGE_KEY, JSON.stringify(newValues));
          return;
        }
        if (!oldValues || Object.keys(oldValues).length === 0) {
          newValues._migrationComplete = true;
          GM_setValue(STORAGE_KEY, JSON.stringify(newValues));
          return;
        }
        const merged = { ...newValues, ...oldValues, _migrationComplete: true };
        GM_setValue(STORAGE_KEY, JSON.stringify(merged));
      } catch (e) {
        console.error("[ConfigWrapper] Failed to migrate old config:", e);
      }
    }
    /**
     * Load config from GM_getValue
     */
    load() {
      try {
        const stored = GM_getValue(STORAGE_KEY, "{}");
        const parsed = typeof stored === "string" ? JSON.parse(stored) : stored;
        this.values = { ...this.defaults, ...parsed };
      } catch (e) {
        console.error("Failed to load config:", e);
        this.values = { ...this.defaults };
      }
    }
    /**
     * Save config to GM_setValue
     */
    save() {
      try {
        GM_setValue(STORAGE_KEY, JSON.stringify(this.values));
      } catch (e) {
        console.error("Failed to save config:", e);
      }
    }
    /**
     * Get a config value
     */
    get(key) {
      if (key in this.values) {
        return this.values[key];
      }
      if (key in this.defaults) {
        return this.defaults[key];
      }
      return void 0;
    }
    /**
     * Set a config value
     */
    set(key, value) {
      this.values[key] = value;
      this.save();
    }
    /**
     * Open the config modal
     */
    open() {
      if (this.modal) {
        this.modal.show();
      } else {
        this.modal = new ConfigModal(this, (changes) => {
          if (this.onSave) {
            this.onSave(changes);
          }
        });
        this.modal.show();
      }
    }
    /**
     * Close the config modal
     */
    close() {
      if (this.modal) {
        this.modal.hide();
      }
    }
    /**
     * Reset all values to defaults
     */
    reset() {
      this.values = { ...this.defaults };
      this.save();
    }
    /**
     * Clear new config storage for testing migration (call from console)
     * Usage: config.clearNewConfig() then refresh
     */
    clearNewConfig() {
      GM_setValue(STORAGE_KEY, null);
    }
    /**
     * Debug: show what's in storage
     * Usage: config.debugStorage()
     */
    debugStorage() {
      const oldData = GM_getValue(OLD_GM_CONFIG_KEY, null);
      const newData = GM_getValue(STORAGE_KEY, null);
      return { legacy: oldData, current: newData };
    }
    /**
     * Force migration from legacy storage (can be called manually from console)
     * Usage: config.forceMigrateLegacy()
     */
    forceMigrateLegacy() {
      try {
        const oldData = GM_getValue(OLD_GM_CONFIG_KEY, null);
        if (oldData === null) {
          return false;
        }
        let oldValues;
        if (typeof oldData === "string") {
          oldValues = JSON.parse(oldData);
        } else if (typeof oldData === "object") {
          oldValues = oldData;
        } else {
          return false;
        }
        if (!oldValues || Object.keys(oldValues).length === 0) {
          return false;
        }
        this.values = { ...this.values, ...oldValues, _migrationComplete: true };
        this.save();
        return true;
      } catch (e) {
        console.error("[ConfigWrapper] Failed to force migrate:", e);
        return false;
      }
    }
    /**
     * Reset migration flag to allow re-migration (call from console)
     * Usage: config.resetMigrationFlag() then refresh
     */
    resetMigrationFlag() {
      delete this.values._migrationComplete;
      this.save();
    }
  }
  class ListCache {
    /**
     * @param {BlueskyAPI} api - API instance for fetching lists
     * @param {number} cacheDurationMs - Cache duration in milliseconds (default 5 min)
     */
    constructor(api, cacheDurationMs = 5 * 60 * 1e3) {
      this.api = api;
      this.cacheDurationMs = cacheDurationMs;
      this.cache = /* @__PURE__ */ new Map();
      this.listNameToUri = /* @__PURE__ */ new Map();
      this.listDisplayNames = /* @__PURE__ */ new Map();
      this.listsMetadataFetched = false;
      this.listsMetadataFetchedAt = null;
      this.pendingMetadataFetch = null;
      this.pendingMemberFetches = /* @__PURE__ */ new Map();
      this.authFailedAt = null;
      this.authFailureCooldownMs = 60 * 1e3;
    }
    /**
     * Ensures list metadata (name -> URI mapping) is loaded
     * @param {boolean} forceRefresh - Force refresh even if cached
     * @private
     */
    async ensureListsMetadata(forceRefresh = false) {
      if (!this.api) return;
      if (!this.api.agent?.session) {
        try {
          await this.api.login();
        } catch (error) {
          this.authFailedAt = Date.now();
          console.warn("List cache: Login failed, will retry in 1 minute");
          return;
        }
      }
      if (this.authFailedAt && Date.now() - this.authFailedAt < this.authFailureCooldownMs) {
        return;
      }
      if (forceRefresh && this.pendingMetadataFetch) {
        await this.pendingMetadataFetch;
      }
      const metadataCacheMs = 5 * 60 * 1e3;
      const cacheExpired = this.listsMetadataFetchedAt && Date.now() - this.listsMetadataFetchedAt >= metadataCacheMs;
      if (this.listsMetadataFetched && !forceRefresh && !cacheExpired) {
        return;
      }
      if (this.pendingMetadataFetch) {
        return this.pendingMetadataFetch;
      }
      this.pendingMetadataFetch = (async () => {
        try {
          const lists = await this.api.getLists();
          const newNameToUri = /* @__PURE__ */ new Map();
          const newDisplayNames = /* @__PURE__ */ new Map();
          for (const list2 of lists) {
            const normalizedName = list2.name.toLowerCase();
            newNameToUri.set(normalizedName, list2.uri);
            newDisplayNames.set(normalizedName, list2.name);
          }
          this.listNameToUri = newNameToUri;
          this.listDisplayNames = newDisplayNames;
          this.listsMetadataFetched = true;
          this.listsMetadataFetchedAt = Date.now();
          this.authFailedAt = null;
        } catch (error) {
          const isAuthError = error.message?.includes("Authentication") || error.status === 401;
          if (isAuthError) {
            this.authFailedAt = Date.now();
            console.warn("List cache: Authentication failed, will retry in 1 minute");
          } else {
            console.warn("Failed to fetch lists metadata:", error);
          }
        } finally {
          this.pendingMetadataFetch = null;
        }
      })();
      return this.pendingMetadataFetch;
    }
    /**
     * Gets the cached members for a list, fetching if needed
     * @param {string} listName - Display name of the list
     * @returns {Promise<Map<string, { uri: string }>|null>} Map of handles (lowercase) to { uri } or null if list not found
     */
    async getMembers(listName) {
      const normalizedName = listName.toLowerCase();
      const cached = this.cache.get(normalizedName);
      if (cached && Date.now() - cached.fetchedAt < this.cacheDurationMs) {
        return cached.members;
      }
      if (this.pendingMemberFetches.has(normalizedName)) {
        return this.pendingMemberFetches.get(normalizedName);
      }
      const fetchPromise = (async () => {
        try {
          await this.ensureListsMetadata();
          const listUri = this.listNameToUri.get(normalizedName);
          if (!listUri) {
            if (!this.authFailedAt) {
              console.warn(`List not found: ${listName}`);
            }
            return null;
          }
          const members = await this.api.getListMembers(listUri);
          const memberMap = /* @__PURE__ */ new Map();
          for (const m of members) {
            memberMap.set(m.handle.toLowerCase(), { uri: m.uri });
          }
          this.cache.set(normalizedName, {
            members: memberMap,
            fetchedAt: Date.now(),
            uri: listUri
          });
          return memberMap;
        } catch (error) {
          console.warn(`Failed to fetch list members for ${listName}:`, error);
          return null;
        } finally {
          this.pendingMemberFetches.delete(normalizedName);
        }
      })();
      this.pendingMemberFetches.set(normalizedName, fetchPromise);
      return fetchPromise;
    }
    /**
     * Normalizes a handle by adding .bsky.social suffix if missing
     * @param {string} handle - Handle to normalize
     * @returns {string} Normalized handle
     * @private
     */
    normalizeHandle(handle2) {
      let normalized = handle2.replace(/^@/, "").toLowerCase();
      if (!normalized.includes(".")) {
        normalized = `${normalized}.bsky.social`;
      }
      return normalized;
    }
    /**
     * Checks if a handle is in a list
     * @param {string} handle - Handle to check (with or without @)
     * @param {string} listName - Display name of the list
     * @returns {Promise<boolean>} True if handle is in list
     */
    async isInList(handle2, listName) {
      const members = await this.getMembers(listName);
      if (!members) return false;
      const normalizedHandle = this.normalizeHandle(handle2);
      return members.has(normalizedHandle);
    }
    /**
     * Synchronously checks if a handle is in a list (from cache only)
     * @param {string} handle - Handle to check
     * @param {string} listName - List name
     * @returns {boolean|undefined} True/false if cached, undefined if not cached
     */
    isInListSync(handle2, listName) {
      const normalizedName = listName.toLowerCase();
      const cached = this.cache.get(normalizedName);
      if (!cached || Date.now() - cached.fetchedAt >= this.cacheDurationMs) {
        return void 0;
      }
      const normalizedHandle = this.normalizeHandle(handle2);
      return cached.members.has(normalizedHandle);
    }
    /**
     * Gets the listitem URI for a handle in a list (for deletion)
     * @param {string} handle - Handle to look up
     * @param {string} listName - List name
     * @returns {Promise<string|null>} Listitem URI or null if not found
     */
    async getMemberUri(handle2, listName) {
      const members = await this.getMembers(listName);
      if (!members) return null;
      const normalizedHandle = this.normalizeHandle(handle2);
      const member = members.get(normalizedHandle);
      return member?.uri || null;
    }
    /**
     * Optimistically adds a handle to the cached members for a list.
     * Use after successfully adding via API to avoid waiting for eventual consistency.
     * @param {string} handle - Handle to add
     * @param {string} listName - List name
     * @param {string} [listitemUri] - Optional listitem URI (for future deletion)
     */
    addMemberToCache(handle2, listName, listitemUri = null) {
      const normalizedName = listName.toLowerCase();
      const normalizedHandle = this.normalizeHandle(handle2);
      let cached = this.cache.get(normalizedName);
      if (!cached) {
        cached = {
          members: /* @__PURE__ */ new Map(),
          fetchedAt: Date.now(),
          uri: null
        };
        this.cache.set(normalizedName, cached);
      }
      cached.members.set(normalizedHandle, { uri: listitemUri });
    }
    /**
     * Optimistically removes a handle from the cached members for a list.
     * Use after successfully removing via API to avoid waiting for eventual consistency.
     * @param {string} handle - Handle to remove
     * @param {string} listName - List name
     */
    removeMemberFromCache(handle2, listName) {
      const normalizedName = listName.toLowerCase();
      const normalizedHandle = this.normalizeHandle(handle2);
      const cached = this.cache.get(normalizedName);
      if (cached?.members) {
        cached.members.delete(normalizedHandle);
      }
    }
    /**
     * Invalidates cache for a specific list or all lists
     * @param {string} [listName] - List name to invalidate, or all if omitted
     */
    invalidate(listName = null) {
      if (listName) {
        const normalizedName = listName.toLowerCase();
        this.cache.delete(normalizedName);
        this.pendingMemberFetches.delete(normalizedName);
      } else {
        this.cache.clear();
        this.listNameToUri.clear();
        this.listDisplayNames.clear();
        this.listsMetadataFetched = false;
        this.listsMetadataFetchedAt = null;
        this.pendingMetadataFetch = null;
        this.pendingMemberFetches.clear();
      }
    }
    /**
     * Forces a refresh of a list's members
     * @param {string} listName - List name to refresh
     * @returns {Promise<Set<string>|null>} Refreshed member set
     */
    async refresh(listName) {
      this.invalidate(listName);
      return this.getMembers(listName);
    }
    /**
     * Gets the URI for a list by name
     * @param {string} listName - Display name of the list
     * @returns {Promise<string|null>} List URI or null
     */
    async getListUri(listName) {
      await this.ensureListsMetadata();
      return this.listNameToUri.get(listName.toLowerCase()) || null;
    }
    /**
     * Gets all known list names (with original case)
     * @param {boolean} forceRefresh - Force refresh from API
     * @returns {Promise<string[]>} Array of list names with original case
     */
    async getListNames(forceRefresh = false) {
      await this.ensureListsMetadata(forceRefresh);
      return Array.from(this.listDisplayNames.values());
    }
  }
  const style = `/* style.css */

/* ==========================================================================
   Hidden View Full Thread - Hide redundant "View full thread" when thread is unrolled
   ========================================================================== */

div.thread.unrolled-view-full-thread-hidden,
.unrolled-view-full-thread-hidden {
  display: none !important;
  visibility: hidden !important;
  height: 0 !important;
  overflow: hidden !important;
  margin: 0 !important;
  padding: 0 !important;
}

/* ==========================================================================
   Feed Loading State - Hide items until sorted (only when loading indicator enabled)
   ========================================================================== */

/* Hide all feed items by default until processing is complete */
body.bsky-nav-loading-enabled div[data-testid^="feedItem-by-"],
body.bsky-nav-loading-enabled div[data-testid^="postThreadItem-by-"] {
  opacity: 0 !important;
  pointer-events: none;
}

/* Show items when feed is ready (class added after sorting) */
body.bsky-nav-feed-ready div[data-testid^="feedItem-by-"],
body.bsky-nav-feed-ready div[data-testid^="postThreadItem-by-"] {
  opacity: 1 !important;
  pointer-events: auto;
}

/* Ensure sidecar container uses row direction for post detail pages */
/* The sidecar is appended to the parent of the post item */
div[data-testid="postThreadScreen"] div:has(> div[data-testid^="postThreadItem-by-"].has-sidecar) {
  display: flex !important;
  flex-direction: row !important;
}
div[data-testid="postThreadScreen"] .sidecar-replies {
  order: 1; /* Ensure sidecar is on the right */
}

/* ==========================================================================
   CSS Custom Properties (Accessibility & Theming)
   ========================================================================== */

:root {
  --focus-ring-color: #0066cc;
  --focus-ring-width: 2px;
  --transition-duration: 200ms;
  --animation-duration: 300ms;
  --bsky-nav-max-width: 600px;

  /* Z-index hierarchy (ascending order)
     Use these variables for consistent stacking:
     - base: local stacking within components
     - raised: slightly elevated elements
     - toolbar: fixed toolbars, tabs, sticky headers
     - dropdown: menus, dropdowns, nav buttons
     - panel: floating panels (sidecar)
     - modal: modals, overlays, config
     - tooltip: tooltips (always on top)
  */
  --z-base: 1;
  --z-raised: 10;
  --z-toolbar: 100;
  --z-dropdown: 1000;
  --z-panel: 5000;
  --z-modal: 10000;
  --z-tooltip: 11000;
}

/* High Contrast Mode */
@media (prefers-contrast: more) {
  :root {
    --focus-ring-color: #000000;
    --focus-ring-width: 3px;
  }
}

/* Reduced Motion Support */
@media (prefers-reduced-motion: reduce) {
  :root {
    --transition-duration: 0ms;
    --animation-duration: 0ms;
  }

  *,
  *::before,
  *::after {
    animation-duration: 0.01ms !important;
    animation-iteration-count: 1 !important;
    transition-duration: 0.01ms !important;
  }
}

/* ==========================================================================
   Desktop Full-Width Layout
   ========================================================================== */

/* Hide element utility */
.bsky-nav-hidden {
  display: none !important;
}

/* Desktop post width - applied via JS to specific feed containers */


/* Screen reader only utility class */
.sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border: 0;
}

/* ==========================================================================
   Base Styles
   ========================================================================== */

div[style^="position: fixed; inset: 0px 0px 0px 50%;"] {
    border: none;
}

div#logContainer {
    width: 100%;
    bottom: 0;
    pointer-events: none;
    height: 25%;
    position: fixed;
    background: rgba(0, 0, 0, 0.2);
    color: #e0e0e0;
    font-family: monospace;
    font-size: 12px;
    z-index: var(--z-modal);
    padding: 10px;
    padding-top: 30px;
}

#logHeader {
    position: relative;
    width: 100%;
    background: #333;
    color: white;
    padding: 5px 10px;
    box-sizing: border-box;
    pointer-events: auto;
}

button#clearLogs {
    position: absolute;
    top: 0;
    left: 0;
    width: 100px;
    background: red;
    color: white;
    border: none;
    padding: 2px 5px;
    cursor: pointer;
}

#logContent {
    overflow-y: auto;
    max-height: calc(70% - 30px);
    padding: 10px;
    box-sizing: border-box;
}

div#bsky-navigator-toolbar {
    display: flex;
    flex-direction: column;
    position: sticky;
    top: 0;
    width: 100%;
    background-color: #ffffff;
    border-bottom: 1px solid rgb(192, 192, 192);
    z-index: var(--z-toolbar);
    overflow: visible;
}

.toolbar-row {
    display: flex;
    flex-direction: row;
    align-items: center;
    width: 100%;
    height: 32px;
    gap: 8px;
    padding: 0 8px;
    overflow: visible;
}

@media (prefers-color-scheme: dark) {
    div#bsky-navigator-toolbar {
        background-color: #29333d
    }
}

.toolbar-icon {
    position: relative;
    margin: 0px;
    width: 24px;
    height: 24px;
    padding: 0px 8px;
    flex: 1;
}


.toolbar-icon-pending {
    animation: fadeInOut 1s infinite;
    animation-duration: var(--animation-duration, 1s);
}

/* Width controls in toolbar */
.width-controls {
    display: flex;
    align-items: center;
    gap: 4px;
    padding: 0 4px;
}

.width-btn {
    width: 20px;
    height: 20px;
    border: 1px solid #ccc;
    border-radius: 4px;
    background: transparent;
    cursor: pointer;
    font-size: 14px;
    font-weight: bold;
    line-height: 1;
    color: inherit;
}

.width-btn:hover {
    background: rgba(128, 128, 128, 0.2);
}

.width-display {
    font-size: 12px;
    min-width: 35px;
    text-align: center;
}

@media (prefers-color-scheme: dark) {
    .width-btn {
        border-color: #666;
    }
}

.indicator-image {
    width: 24px;
    height: 24px;
}

@media (prefers-color-scheme: dark) {
    .indicator-image {
        filter: invert(1) brightness(2);
    }
}

div#infoIndicator {
    flex: 3;
}

div#infoIndicatorText {
    font-size: 0.8em;
}

div#itemTimestampStats {
    font-size: 0.7em;
}

#bsky-navigator-search {
    flex: 1;
    min-width: 0;
    margin: 0px 8px;
    z-index: var(--z-raised);
    font: 14px "DejaVu Sans Mono", "Lucida Console", "Courier New", monospace;
}

.ui-autocomplete {
    position: absolute !important;
    background-color: white !important;
    border: 1px solid #ccc !important;
    z-index: var(--z-dropdown) !important;
    max-height: 200px !important;
    overflow-y: auto !important;
    list-style-type: none !important;
    font: 14px "DejaVu Sans Mono", "Lucida Console", "Courier New", monospace;
    padding: 2px !important;
}

.ui-menu-item {
    padding: 2px !important;
    font-size: 14px !important;
    color: black !important;
}

/* Highlight hovered item */
.ui-state-active {
    background-color: #007bff !important;
    color: white !important;
}

@media only screen and not (max-width: 800px) {
    div#statusBar {
        display: flex;
        flex-wrap: wrap;
        width: 100%;
        min-height: 32px;
        margin-left: auto;
        margin-right: auto;
        position: sticky;
        z-index: var(--z-raised);
        align-items: center;
        background-color: #ffffff;
        bottom: 0;
        font-size: 1em;
        padding: 1px;
        border-top: 1px solid rgb(192, 192, 192);
        overflow: clip;
    }

    div#statusBar.has-feed-map {
        overflow: visible;
    }
}

@media only screen and (max-width: 800px) {
    div#statusBar {
        display: flex;
        flex-wrap: wrap;
        width: 100%;
        min-height: 32px;
        margin-left: auto;
        margin-right: auto;
        position: sticky;
        z-index: var(--z-raised);
        align-items: center;
        background-color: #ffffff;
        bottom: 58px;
        font-size: 1em;
        padding: 1px;
        overflow: clip;
    }

    div#statusBar.has-feed-map {
        overflow: visible;
    }
}

@media (prefers-color-scheme: dark) {
    div#statusBar {
        background-color: #29333d;
    }
}

div#statusBarLeft {
    display: flex;
    flex: 1;
    text-align: left;
    padding: 1px;
}

div#statusBarCenter {
    display: flex;
    flex: 1 1 auto;
    text-align: center;
    padding: 1px;
}

div#statusBarRight {
    display: flex;
    flex: 1;
    text-align: right;
    padding: 1px;
}

#prevButton {
    z-index: var(--z-dropdown);
    position: absolute;
    top: 30%;
    right: -10px;
    opacity: 20%;
}

#prevButton.mobile {
    position: fixed;
    left: 1%;
    top: 25%;
}

#nextButton {
    z-index: var(--z-dropdown);
    position: absolute;
    bottom: 30%;
    right: -10px;
    opacity: 20%;
}

#nextButton.mobile {
    position: fixed;
    left: 1%;
    bottom: 20%;
}

nav.r-1wyvozj {
    overflow: inherit;
}

@keyframes oscillateBorderBottom {
    0% {
        border-bottom-color: rgba(0, 128, 0, 1);
    }
    50% {
        border-bottom-color: rgba(0, 128, 0, 0.3);
    }
    100% {
        border-bottom-color: rgba(0, 128, 0, 1);
    }
}

@keyframes oscillateBorderTop {
    0% {
        border-top-color: rgba(0, 128, 0, 1);
    }
    50% {
        border-top-color: rgba(0, 128, 0, 0.3);
    }
    100% {
        border-top-color: rgba(0, 128, 0, 1);
    }
}

@keyframes fadeInOut {
    0% {
        opacity: 0.2;
    }
    50% {
        opacity: 1;
    }
    100% {
        opacity: 0.2;
    }
}

div.loading-indicator-reverse {
    border-bottom: 10px solid;
    animation: oscillateBorderBottom 0.2s infinite;
    animation-duration: var(--animation-duration, 0.2s);
}

div.loading-indicator-forward {
    border-top: 10px solid;
    animation: oscillateBorderTop 0.2s infinite;
    animation-duration: var(--animation-duration, 0.2s);
}

.filtered {
    display: none !important;
}

/* Hide parent containers of filtered items to remove leftover borders */
div:has(> .item.filtered),
div:has(> div > .item.filtered) {
    display: none !important;
}

/* But don't hide thread containers that have some visible direct child items */
/* Use direct child selector to avoid matching nested quote posts */
.thread:has(> div > .item:not(.filtered)) {
    display: block !important;
}

/* Enable hover cards on embedded/quote post profile links */
/* The embedded post container captures all clicks, but we want hover to work on profile links */
div[aria-label^="Post by"] a[aria-label="View profile"],
div[aria-label^="Post by"] a[aria-label$="'s avatar"] {
    position: relative;
    z-index: 1;
    pointer-events: auto !important;
}

/* .filter-preview-hidden removed - now using actual hiding instead of gray preview */

#messageContainer {
    inset: 5%;
    padding: 10px;
}

.messageTitle {
    font-size: 1.5em;
    text-align: center;
}

.messageBody {
    font-size: 1.2em;
}

#messageActions a {
    color: #8040c0;
}

#messageActions a:hover {
    text-decoration: underline;
    cursor: pointer;
}

/* Feed loading indicator */
#feedLoadingIndicator {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    background: rgba(255, 255, 255, 0.95);
    z-index: 999;
    gap: 12px;
    min-height: 200px;
}

#feedLoadingIndicator .spinner {
    width: 40px;
    height: 40px;
    border: 3px solid #e5e7eb;
    border-top-color: #3b82f6;
    border-radius: 50%;
    animation: spin 0.8s linear infinite;
}

#feedLoadingIndicator .loading-text {
    color: #6b7280;
    font-size: 14px;
}

@keyframes spin {
    to {
        transform: rotate(360deg);
    }
}

@media (prefers-color-scheme: dark) {
    #feedLoadingIndicator {
        background: rgba(17, 24, 39, 0.9);
    }

    #feedLoadingIndicator .spinner {
        border-color: #374151;
        border-top-color: #60a5fa;
    }

    #feedLoadingIndicator .loading-text {
        color: #9ca3af;
    }
}

/* Reduced motion support */
@media (prefers-reduced-motion: reduce) {
    #feedLoadingIndicator .spinner {
        animation: none;
        border-top-color: #3b82f6;
        border-right-color: #3b82f6;
    }
}

.preferences-icon-overlay {
    background-color: #cccccc;
    cursor: pointer;
    justify-content: center;
    z-index: var(--z-dropdown);
}

.preferences-icon-overlay-sync-ready {
    background-color: #d5f5e3;
}

.preferences-icon-overlay-sync-pending {
    animation: fadeInOut 1s infinite;
    animation-duration: var(--animation-duration, 1s);
    background-color: #f9e79f;
}

.preferences-icon-overlay-sync-success {
    background-color: #2ecc71;
}

.preferences-icon-overlay-sync-failure {
    background-color: #ec7063 ;
}

.preferences-icon-overlay span {
    color: white;
    font-size: 16px;
}

div.item-banner {
    position: absolute;
    top: 0;
    left: 0;
    font-family: "Lucida Console", "Courier New", monospace;
    font-size: 0.7em;
    z-index: var(--z-raised);
    color: black;
    text-shadow: 1px 1px rgba(255, 255, 255,0.8);
    background: rgba(128, 192, 192, 0.3);
    padding: 3px;
    border-radius: 4px;
}

.image-highlight {
    filter: invert(36%) sepia(28%) saturate(5764%) hue-rotate(194deg) brightness(102%) contrast(105%);
}

.load-time-icon {
    position: absolute;
    left: 8px;
    bottom: -1px;
    width: 24px;
    height: 24px;
    opacity: 0.8;
    filter: invert(93%) sepia(49%) saturate(2805%) hue-rotate(328deg) brightness(99%) contrast(96%) drop-shadow( 0.2px  0px 0px black)
        drop-shadow(-0.2px  0px 0px black)
        drop-shadow( 0px  0.2px 0px black)
        drop-shadow( 0px -0.2px 0px black);
}

.image-flip-x {
    transform: scaleX(-1);
    -webkit-transform: scaleX(-1);
}

.popup {
    display: none;
    position: fixed;
    max-height: 80vH;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    /* transform: scale(0.25); /\\* Scale down to 75% *\\/ */
    background: white;
    padding: 15px;
    border-radius: 12px;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    width: 400px;
    z-index: var(--z-dropdown);
}

/* Hide the reply connector line in threaded posts - only on desktop */
@media only screen and (min-width: 801px) {
    div:has(>div.item) > nav + div {
        display: none;
    }
}

/* Sidecar layout - desktop only */
@media only screen and (min-width: 801px) {
    div:has(>div.item) {
        display: flex;
        flex-direction: row;
        align-items: stretch;
    }

    .item {
        display: flex;
        flex: 2;
        max-height: 100%;
    }

    .item > div:first-of-type {
        flex: 1;
        align-items: stretch;
    }

    .item > div:first-of-type > div:last-of-type {
        flex: 1;
    }
}

.unrolled-reply {
    position: relative;
    padding-left: 44px;
    margin: 1px;
    border: 1px solid transparent;
    box-sizing: border-box;
}

.unrolled-post-number {
    position: absolute;
    left: 4px;
    top: 1.5em;
    min-width: 24px;
    height: 24px;
    padding: 0 4px;
    display: flex;
    align-items: center;
    justify-content: center;
    background-color: #f3f4f6;
    border-radius: 12px;
    font-size: 10px;
    font-weight: 600;
    color: #6b7280;
    text-decoration: none;
    transition: background-color 0.2s ease, color 0.2s ease;
}

.unrolled-post-total {
    font-weight: 400;
    opacity: 0.7;
}

.unrolled-post-number:hover {
    background-color: #e5e7eb;
    color: #374151;
    text-decoration: none;
}

/* First post in unrolled thread - green text */
.unrolled-post-first {
    color: #16a34a !important;
}

.unrolled-post-first:hover {
    color: #15803d !important;
}

/* Last post in unrolled thread - red text */
.unrolled-post-last {
    color: #dc2626 !important;
}

.unrolled-post-last:hover {
    color: #b91c1c !important;
}

.unrolled-divider {
    margin-top: 1em;
    margin-bottom: 0.5em;
    border: none;
    border-top: 1px solid #e5e7eb;
}

@media (prefers-color-scheme: dark) {
    .unrolled-post-number {
        background-color: #374151;
        color: #d1d5db;
    }

    .unrolled-post-number:hover {
        background-color: #4b5563;
        color: #f3f4f6;
    }

    .unrolled-divider {
        border-top-color: #374151;
    }
}

.sidecar-replies {
    flex: 1 1 0;
    min-height: 0;
    overflow-y: auto;
    font-size: 0.8em;
    padding-left: 10px;
    display: flex;
    flex-direction: column;
    max-height: 50vH;
}

/* Hide sidecar on mobile */
@media only screen and (max-width: 800px) {
    .sidecar-replies {
        display: none;
    }
}

/* ==========================================================================
   Fixed Sidecar Panel
   ========================================================================== */

.fixed-sidecar-panel {
    position: fixed;
    top: 60px;
    right: 16px; /* Default fallback, JS will override */
    width: 350px;
    max-height: calc(100vh - 120px);
    background-color: #ffffff;
    border: 1px solid #e5e7eb;
    border-radius: 12px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    z-index: var(--z-panel);
    display: flex;
    flex-direction: column;
    overflow: hidden;
    opacity: 0;
    transform: translateX(20px);
    transition: opacity 0.2s ease, transform 0.2s ease;
    pointer-events: none;
}

.fixed-sidecar-panel.visible {
    opacity: 1 !important;
    transform: translateX(0) !important;
    pointer-events: auto !important;
}

.fixed-sidecar-panel-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 12px 16px;
    border-bottom: 1px solid #e5e7eb;
    background-color: #f9fafb;
    flex-shrink: 0;
}

.fixed-sidecar-panel-title {
    font-weight: 600;
    font-size: 14px;
    color: #1f2937;
}

.fixed-sidecar-panel-close {
    background: none;
    border: none;
    cursor: pointer;
    padding: 4px;
    color: #6b7280;
    border-radius: 4px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.fixed-sidecar-panel-close:hover {
    background-color: #e5e7eb;
    color: #1f2937;
}

.fixed-sidecar-panel-content {
    flex: 1;
    overflow-y: auto;
    padding: 0;
}

.fixed-sidecar-panel-content .sidecar-replies {
    display: flex !important;
    max-height: none;
    padding: 8px;
}

.fixed-sidecar-panel-empty {
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 32px 16px;
    color: #6b7280;
    font-size: 13px;
    text-align: center;
}

/* Fixed sidecar toggle button - positioned next to selected item */
.fixed-sidecar-toggle {
    position: fixed;
    /* top and left are set by JS based on selected item position */
    width: 40px;
    height: 40px;
    border-radius: 50%;
    background-color: var(--background-color, white);
    border: 1px solid var(--border-color, #e5e7eb);
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: var(--z-panel, 5000);
    opacity: 0;
    visibility: hidden;
    transition: opacity var(--animation-duration, 200ms) ease, visibility var(--animation-duration, 200ms) ease, transform 150ms ease;
    pointer-events: auto;
}

.fixed-sidecar-toggle.visible {
    opacity: 1;
    visibility: visible;
}

.fixed-sidecar-toggle:hover {
    background-color: var(--hover-background, #f3f4f6);
    transform: scale(1.1);
}

.fixed-sidecar-toggle:active {
    transform: scale(0.95);
}

.fixed-sidecar-toggle svg {
    color: var(--text-secondary, #6b7280);
}

.fixed-sidecar-toggle:hover svg {
    color: var(--text-primary, #1f2937);
}

/* Indicator dot when thread has context */
.fixed-sidecar-toggle.has-context::after {
    content: '';
    position: absolute;
    top: 4px;
    right: 4px;
    width: 10px;
    height: 10px;
    border-radius: 50%;
    background-color: #3b82f6;
    border: 2px solid var(--background-color, white);
}

/* Reply count badge on toggle button */
.fixed-sidecar-toggle-count {
    position: absolute;
    bottom: -2px;
    right: -2px;
    min-width: 18px;
    height: 18px;
    padding: 0 5px;
    font-size: 11px;
    font-weight: 600;
    line-height: 18px;
    text-align: center;
    color: white;
    background-color: #3b82f6;
    border-radius: 9px;
    border: 2px solid var(--background-color, white);
    display: none;
}

/* Hide fixed sidecar on mobile */
@media only screen and (max-width: 800px) {
    .fixed-sidecar-panel,
    .fixed-sidecar-toggle {
        display: none;
    }
}

/* Dark mode for fixed sidecar */
@media (prefers-color-scheme: dark) {
    .fixed-sidecar-panel {
        background-color: #1f2937;
        border-color: #374151;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }

    .fixed-sidecar-panel-header {
        background-color: #111827;
        border-color: #374151;
    }

    .fixed-sidecar-panel-title {
        color: #f9fafb;
    }

    .fixed-sidecar-panel-close {
        color: #9ca3af;
    }

    .fixed-sidecar-panel-close:hover {
        background-color: #374151;
        color: #f9fafb;
    }

    .fixed-sidecar-panel-empty {
        color: #9ca3af;
    }

    .fixed-sidecar-toggle {
        background-color: #1f2937;
        border-color: #374151;
    }

    .fixed-sidecar-toggle:hover {
        background-color: #374151;
    }

    .fixed-sidecar-toggle svg {
        color: #9ca3af;
    }

    .fixed-sidecar-toggle:hover svg {
        color: #f9fafb;
    }
}

/* Fixed sidecar connector arrow */
.fixed-sidecar-connector {
    position: fixed;
    top: 0;
    left: 0;
    pointer-events: none;
    z-index: calc(var(--z-panel, 5000) - 1);
    opacity: 0;
    visibility: hidden;
    transition: opacity var(--animation-duration, 200ms) ease;
}

.fixed-sidecar-connector.visible {
    opacity: 1;
    visibility: visible;
}

.fixed-sidecar-connector-path {
    stroke: var(--accent-color, #3b82f6);
    stroke-width: 2;
    fill: none;
    stroke-dasharray: 6, 4;
}

.fixed-sidecar-connector marker path {
    fill: var(--accent-color, #3b82f6);
}

@media (prefers-color-scheme: dark) {
    .fixed-sidecar-connector-path {
        stroke: #60a5fa;
    }
    .fixed-sidecar-connector marker path {
        fill: #60a5fa;
    }
}

.sidecar-parent-indicator {
    position: absolute;
}

.sidecar-post {
    display: flex;
    flex-direction: column;
    padding: 5px;
    flex-shrink: 0;
    font-family: InterVariable, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji";
}

.sidecar-post a {
    text-decoration: none;
}

.sidecar-post a:hover {
    text-decoration: underline;
}

.sidecar-post-user-info {
    display: flex;
    flex-direction: row;
    font-size: 0.9em;
}

.sidecar-post-avatar {
    width: 24px;
    height: 24px;
    padding: 2px;
}

.sidecar-post-username {
    font-weight: 600;
    color: rgb(11, 15, 20);
}

.sidecar-post-handle {
    color: rgb(66, 87, 108);
    font-variant: no-contextual;
}

.sidecar-post-content {
    padding: 5px 0px;
}

.sidecar-post-content a {
    color: rgb(16, 131, 254);
}

.sidecar-post-footer {
    color: rgb(66, 87, 108);
    display: flex;
    flex-direction: row;
    font-size: 11px;
}

.sidecar-post-footer svg, .sidecar-post-footer span {
    display: inline-flex;
    vertical-align: middle;
    /* flex: 1; */
    color: rgb(111, 134, 159);
}

.sidecar-post-timestamp {
    display: inline-flex;
    vertical-align: middle;
    flex: 3;
}

.sidecar-parent .sidecar-post {
    border: 3px dashed rgb(111, 134, 159);
    padding: 5px;
}

.sidecar-post-counts {
    display: flex;
    flex: 2;
}

.sidecar-count {
    display: flex;
    flex: 1;
    justify-content: right;
    align-items: center;
}

.sidecar-count-icon > svg {
  height: 1em;
}

/* ==========================================================================
   Like/Repost Animation Feedback
   ========================================================================== */

@keyframes likeHeartPop {
  0% {
    transform: scale(1);
  }
  50% {
    transform: scale(1.3);
  }
  100% {
    transform: scale(1);
  }
}

@keyframes unlikeHeartShrink {
  0% {
    transform: scale(1);
  }
  50% {
    transform: scale(0.8);
  }
  100% {
    transform: scale(1);
  }
}

.like-animation-like {
  animation: likeHeartPop var(--animation-duration, 300ms) ease-out;
}

.like-animation-like svg {
  fill: #ec4899;
  color: #ec4899;
}

.like-animation-unlike {
  animation: unlikeHeartShrink var(--animation-duration, 300ms) ease-out;
}

@keyframes repostPop {
  0% {
    transform: scale(1) rotate(0deg);
  }
  50% {
    transform: scale(1.2) rotate(15deg);
  }
  100% {
    transform: scale(1) rotate(0deg);
  }
}

.repost-animation {
  animation: repostPop var(--animation-duration, 300ms) ease-out;
}

.repost-animation svg {
  fill: #22c55e;
  color: #22c55e;
}

/* ==========================================================================
   Filter Indicator Pill
   ========================================================================== */

.filter-pill {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 4px 8px 4px 12px;
  margin: 0 8px;
  background-color: #3b82f6;
  color: white;
  border-radius: 16px;
  font-size: 12px;
  font-weight: 500;
  max-width: 200px;
  animation: pillSlideIn var(--animation-duration, 200ms) ease-out;
}

@keyframes pillSlideIn {
  from {
    opacity: 0;
    transform: translateX(-10px);
  }
  to {
    opacity: 1;
    transform: translateX(0);
  }
}

.filter-pill-text {
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.filter-pill-clear {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 18px;
  height: 18px;
  padding: 0;
  margin: 0;
  border: none;
  border-radius: 50%;
  background-color: rgba(255, 255, 255, 0.3);
  color: white;
  font-size: 14px;
  font-weight: bold;
  line-height: 1;
  cursor: pointer;
  transition: background-color var(--transition-duration, 200ms) ease;
}

.filter-pill-clear:hover {
  background-color: rgba(255, 255, 255, 0.5);
}

.filter-pill-clear:focus {
  outline: 2px solid white;
  outline-offset: 1px;
}

@media (prefers-color-scheme: dark) {
  .filter-pill {
    background-color: #2563eb;
  }
}

@media (prefers-contrast: more) {
  .filter-pill {
    background-color: #1d4ed8;
    border: 2px solid white;
  }
}

/* ==========================================================================
   New Posts Floating Pill
   ========================================================================== */

.new-posts-pill {
  position: fixed;
  top: 80px;
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 10px 20px;
  background-color: #3b82f6;
  color: white;
  border: none;
  border-radius: 24px;
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  z-index: var(--z-panel);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
  animation: newPostsPillBounce var(--animation-duration, 500ms) ease-out;
  transition: transform var(--transition-duration, 200ms) ease,
              background-color var(--transition-duration, 200ms) ease;
}

.new-posts-pill:hover {
  background-color: #2563eb;
  transform: translateX(-50%) scale(1.05);
}

.new-posts-pill:focus {
  outline: 2px solid white;
  outline-offset: 2px;
}

.new-posts-pill:active {
  transform: translateX(-50%) scale(0.98);
}

.new-posts-pill svg {
  flex-shrink: 0;
}

@keyframes newPostsPillBounce {
  0% {
    opacity: 0;
    transform: translateX(-50%) translateY(-20px);
  }
  60% {
    transform: translateX(-50%) translateY(5px);
  }
  100% {
    opacity: 1;
    transform: translateX(-50%) translateY(0);
  }
}

.new-posts-pill-hiding {
  animation: newPostsPillHide var(--animation-duration, 200ms) ease-in forwards;
}

@keyframes newPostsPillHide {
  to {
    opacity: 0;
    transform: translateX(-50%) translateY(-20px);
  }
}

@media (prefers-color-scheme: dark) {
  .new-posts-pill {
    background-color: #2563eb;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
  }

  .new-posts-pill:hover {
    background-color: #3b82f6;
  }
}

@media (prefers-contrast: more) {
  .new-posts-pill {
    background-color: #1d4ed8;
    border: 2px solid white;
  }
}

/* Mobile positioning */
@media only screen and (max-width: 800px) {
  .new-posts-pill {
    top: auto;
    bottom: 70px;
  }
}

/* ==========================================================================
   Skeleton Loading States
   ========================================================================== */

.sidecar-skeleton {
  padding: 10px;
}

.skeleton-post {
  padding: 10px 0;
  border-bottom: 1px solid #e5e7eb;
}

.skeleton-post:last-child {
  border-bottom: none;
}

.skeleton-header {
  display: flex;
  align-items: center;
  gap: 10px;
  margin-bottom: 12px;
}

.skeleton-avatar {
  width: 32px;
  height: 32px;
  border-radius: 50%;
  flex-shrink: 0;
}

.skeleton-author {
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.skeleton-body {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.skeleton-line {
  height: 12px;
  border-radius: 4px;
}

.skeleton-line-short {
  width: 30%;
}

.skeleton-line-medium {
  width: 60%;
}

.skeleton-line-full {
  width: 100%;
}

.skeleton-shimmer {
  background: linear-gradient(
    90deg,
    #e5e7eb 25%,
    #f3f4f6 50%,
    #e5e7eb 75%
  );
  background-size: 200% 100%;
  animation: shimmer 1.5s infinite;
}

@keyframes shimmer {
  0% {
    background-position: 200% 0;
  }
  100% {
    background-position: -200% 0;
  }
}

/* Respect reduced motion */
@media (prefers-reduced-motion: reduce) {
  .skeleton-shimmer {
    animation: none;
    background: #e5e7eb;
  }
}

/* Dark mode skeleton */
@media (prefers-color-scheme: dark) {
  .skeleton-shimmer {
    background: linear-gradient(
      90deg,
      #374151 25%,
      #4b5563 50%,
      #374151 75%
    );
    background-size: 200% 100%;
  }

  @media (prefers-reduced-motion: reduce) {
    .skeleton-shimmer {
      background: #374151;
    }
  }

  .skeleton-post {
    border-bottom-color: #374151;
  }
}

/* ==========================================================================
   Keyboard Shortcut Overlay
   ========================================================================== */

.shortcut-overlay {
  position: fixed;
  inset: 0;
  z-index: var(--z-modal);
  display: flex;
  align-items: center;
  justify-content: center;
  animation: overlayFadeIn var(--animation-duration, 200ms) ease-out;
}

@keyframes overlayFadeIn {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}

.shortcut-overlay-hiding {
  animation: overlayFadeOut var(--animation-duration, 200ms) ease-in forwards;
}

@keyframes overlayFadeOut {
  to {
    opacity: 0;
  }
}

.shortcut-overlay-backdrop {
  position: absolute;
  inset: 0;
  background-color: rgba(0, 0, 0, 0.5);
}

.shortcut-overlay-content {
  position: relative;
  background-color: white;
  border-radius: 12px;
  box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
  max-width: 700px;
  max-height: 80vh;
  width: 90%;
  display: flex;
  flex-direction: column;
  animation: overlaySlideUp var(--animation-duration, 200ms) ease-out;
}

@keyframes overlaySlideUp {
  from {
    transform: translateY(20px);
    opacity: 0;
  }
  to {
    transform: translateY(0);
    opacity: 1;
  }
}

.shortcut-overlay-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 16px 20px;
  border-bottom: 1px solid #e5e7eb;
}

.shortcut-overlay-header h2 {
  margin: 0;
  font-size: 18px;
  font-weight: 600;
  color: #111827;
}

.shortcut-overlay-close {
  width: 32px;
  height: 32px;
  border: none;
  border-radius: 6px;
  background-color: transparent;
  color: #6b7280;
  font-size: 24px;
  line-height: 1;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: background-color var(--transition-duration, 200ms) ease;
}

.shortcut-overlay-close:hover {
  background-color: #f3f4f6;
  color: #111827;
}

.shortcut-overlay-close:focus {
  outline: 2px solid var(--focus-ring-color, #0066cc);
  outline-offset: 2px;
}

.shortcut-overlay-body {
  padding: 20px;
  overflow-y: auto;
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
  gap: 24px;
}

.shortcut-category {
  min-width: 0;
}

.shortcut-category-title {
  margin: 0 0 12px 0;
  font-size: 13px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.05em;
  color: #6b7280;
}

.shortcut-list {
  margin: 0;
  padding: 0;
}

.shortcut-item {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 6px 0;
  gap: 16px;
}

.shortcut-keys {
  display: flex;
  gap: 4px;
  flex-shrink: 0;
}

.shortcut-keys kbd {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  min-width: 24px;
  height: 24px;
  padding: 0 6px;
  background-color: #f3f4f6;
  border: 1px solid #d1d5db;
  border-radius: 4px;
  font-family: inherit;
  font-size: 12px;
  font-weight: 500;
  color: #374151;
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
}

.shortcut-desc {
  margin: 0;
  font-size: 14px;
  color: #374151;
  text-align: right;
}

.shortcut-overlay-footer {
  padding: 12px 20px;
  border-top: 1px solid #e5e7eb;
  text-align: center;
  font-size: 13px;
  color: #6b7280;
}

.shortcut-overlay-footer kbd {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  min-width: 20px;
  height: 20px;
  padding: 0 4px;
  background-color: #f3f4f6;
  border: 1px solid #d1d5db;
  border-radius: 4px;
  font-family: inherit;
  font-size: 11px;
  font-weight: 500;
  color: #374151;
  margin: 0 2px;
}

/* Dark mode */
@media (prefers-color-scheme: dark) {
  .shortcut-overlay-content {
    background-color: #1f2937;
  }

  .shortcut-overlay-header {
    border-bottom-color: #374151;
  }

  .shortcut-overlay-header h2 {
    color: #f9fafb;
  }

  .shortcut-overlay-close {
    color: #9ca3af;
  }

  .shortcut-overlay-close:hover {
    background-color: #374151;
    color: #f9fafb;
  }

  .shortcut-category-title {
    color: #9ca3af;
  }

  .shortcut-keys kbd,
  .shortcut-overlay-footer kbd {
    background-color: #374151;
    border-color: #4b5563;
    color: #e5e7eb;
  }

  .shortcut-desc {
    color: #d1d5db;
  }

  .shortcut-overlay-footer {
    border-top-color: #374151;
    color: #9ca3af;
  }
}

/* High contrast */
@media (prefers-contrast: more) {
  .shortcut-overlay-content {
    border: 2px solid black;
  }

  .shortcut-keys kbd {
    border-width: 2px;
    border-color: black;
  }
}

/* ==========================================================================
   Post View Modal
   ========================================================================== */

.post-view-modal {
  position: fixed;
  inset: 0;
  z-index: var(--z-modal);
  display: flex;
  align-items: center;
  justify-content: center;
  animation: overlayFadeIn var(--animation-duration, 200ms) ease-out;
}

.post-view-modal-hiding {
  animation: overlayFadeOut var(--animation-duration, 200ms) ease-in forwards;
}

.post-view-modal-backdrop {
  position: absolute;
  inset: 0;
  background-color: rgba(0, 0, 0, 0.5);
}

.post-view-modal-content {
  position: relative;
  background-color: white;
  border-radius: 12px;
  box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
  max-width: 1200px;
  max-height: 90vh;
  width: 95%;
  display: flex;
  flex-direction: column;
  overflow: hidden;
  animation: overlaySlideUp var(--animation-duration, 200ms) ease-out;
}

.post-view-modal-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 12px 16px;
  border-bottom: 1px solid #e5e7eb;
  flex-shrink: 0;
}

.post-view-modal-header h2 {
  margin: 0;
  font-size: 16px;
  font-weight: 600;
  color: #111827;
}

.post-view-modal-close {
  width: 32px;
  height: 32px;
  border: none;
  border-radius: 6px;
  background-color: transparent;
  color: #6b7280;
  font-size: 24px;
  line-height: 1;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: background-color var(--transition-duration, 200ms) ease;
}

.post-view-modal-close:hover {
  background-color: #f3f4f6;
  color: #111827;
}

.post-view-modal-close:focus {
  outline: 2px solid var(--focus-ring-color, #0066cc);
  outline-offset: 2px;
}

.post-view-modal-body {
  display: flex;
  flex-direction: row;
  flex: 1;
  overflow: hidden;
  min-height: 0;
}

.post-view-modal-post {
  flex: 3;
  overflow-y: auto;
  padding: 16px;
  border-right: 1px solid #e5e7eb;
}

/* Ensure cloned post takes full width and isn't constrained by feed styles */
.post-view-modal-post > * {
  width: 100% !important;
  max-width: 100% !important;
  flex: 1 1 auto !important;
}

.post-view-modal-sidecar {
  flex: 2;
  overflow-y: auto;
  padding: 16px;
  font-size: 0.9em;
}

/* Ensure sidecar content is always visible in the modal */
.post-view-modal-sidecar-content {
  display: flex;
  flex-direction: column;
  height: 100%;
}

.post-view-modal-sidecar-content .sidecar-replies {
  display: flex !important;
  flex-direction: column;
  flex: 1;
}

.post-view-modal-loading {
  color: #6b7280;
  text-align: center;
  padding: 20px;
}

/* Mobile: stack vertically */
@media (max-width: 800px) {
  .post-view-modal-content {
    max-width: 100%;
    max-height: 100%;
    width: 100%;
    height: 100%;
    border-radius: 0;
  }

  .post-view-modal-body {
    flex-direction: column;
  }

  .post-view-modal-post {
    flex: none;
    max-height: 50%;
    border-right: none;
    border-bottom: 1px solid #e5e7eb;
  }

  .post-view-modal-sidecar {
    flex: 1;
    min-height: 0;
  }
}

/* Dark mode */
@media (prefers-color-scheme: dark) {
  .post-view-modal-content {
    background-color: #1f2937;
  }

  .post-view-modal-header {
    border-bottom-color: #374151;
  }

  .post-view-modal-header h2 {
    color: #f9fafb;
  }

  .post-view-modal-close {
    color: #9ca3af;
  }

  .post-view-modal-close:hover {
    background-color: #374151;
    color: #f9fafb;
  }

  .post-view-modal-post {
    border-right-color: #374151;
  }

  .post-view-modal-sidecar {
    border-top-color: #374151;
  }

  .post-view-modal-loading {
    color: #9ca3af;
  }
}

@media (max-width: 800px) and (prefers-color-scheme: dark) {
  .post-view-modal-post {
    border-bottom-color: #374151;
  }
}

/* High contrast */
@media (prefers-contrast: more) {
  .post-view-modal-content {
    border: 2px solid black;
  }
}

/* ==========================================================================
   Reader Mode
   ========================================================================== */

.post-view-modal-content-reader {
  max-width: 95vw;
  width: 95vw;
  max-height: 95vh;
}

.post-view-modal-body-reader {
  flex-direction: column;
}

.post-view-modal-reader-content {
  flex: 1;
  overflow-y: auto;
  padding: 20px;
  font-family: InterVariable, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
}

/* Reader mode font size controls */
.reader-mode-font-controls {
  display: flex;
  align-items: center;
  gap: 4px;
  margin-left: auto;
  margin-right: 16px;
}

.reader-mode-font-btn {
  width: 28px;
  height: 28px;
  border: 1px solid #d1d5db;
  border-radius: 4px;
  background: #f9fafb;
  color: #374151;
  font-size: 16px;
  font-weight: 600;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: background-color 0.15s, border-color 0.15s;
}

.reader-mode-font-btn:hover {
  background: #f3f4f6;
  border-color: #9ca3af;
}

.reader-mode-font-btn:active {
  background: #e5e7eb;
}

.reader-mode-font-input {
  width: 48px;
  height: 28px;
  border: 1px solid #d1d5db;
  border-radius: 4px;
  text-align: center;
  font-size: 14px;
  color: #374151;
  background: white;
}

.reader-mode-font-input:focus {
  outline: none;
  border-color: #3b82f6;
  box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
}

/* Hide number input spinners */
.reader-mode-font-input::-webkit-outer-spin-button,
.reader-mode-font-input::-webkit-inner-spin-button {
  -webkit-appearance: none;
  margin: 0;
}

.reader-mode-font-input[type=number] {
  -moz-appearance: textfield;
}

@media (prefers-color-scheme: dark) {
  .reader-mode-font-btn {
    background: #374151;
    border-color: #4b5563;
    color: #e5e7eb;
  }

  .reader-mode-font-btn:hover {
    background: #4b5563;
    border-color: #6b7280;
  }

  .reader-mode-font-btn:active {
    background: #1f2937;
  }

  .reader-mode-font-input {
    background: #1f2937;
    border-color: #4b5563;
    color: #e5e7eb;
  }

  .reader-mode-font-input:focus {
    border-color: #60a5fa;
    box-shadow: 0 0 0 2px rgba(96, 165, 250, 0.2);
  }
}

.reader-mode-thread {
  max-width: 100%;
}

.reader-mode-author {
  font-size: 14px;
  font-weight: 600;
  color: #6b7280;
  padding-bottom: 16px;
  margin-bottom: 16px;
  border-bottom: 1px solid #e5e7eb;
}

.reader-mode-post {
  position: relative;
  padding: 16px 0 16px 52px;
}

.reader-mode-post-number {
  position: absolute;
  left: 0;
  top: 16px;
  min-width: 28px;
  height: 28px;
  padding: 0 6px;
  display: flex;
  align-items: center;
  justify-content: center;
  background-color: #f3f4f6;
  border-radius: 14px;
  font-size: 11px;
  font-weight: 600;
  color: #6b7280;
}

.reader-mode-post-total {
  font-weight: 400;
  opacity: 0.7;
}

.reader-mode-post-content {
  font-size: inherit;
  line-height: 1.6;
  color: #111827;
}

.reader-mode-post-content a {
  color: #3b82f6;
  text-decoration: none;
}

.reader-mode-post-content a:hover {
  text-decoration: underline;
}

.reader-mode-post-footer {
  margin-top: 12px;
  font-size: 12px;
  color: #6b7280;
}

.reader-mode-divider {
  border: none;
  border-top: 1px solid #e5e7eb;
  margin: 0;
}

/* Modal navigation selection - consistent with feed/post selection styling */
.modal-item-selected {
  outline: 2px solid var(--focus-ring-color, #0066cc) !important;
  outline-offset: -2px;
}

/* Reader mode dark mode */
@media (prefers-color-scheme: dark) {
  .reader-mode-author {
    color: #9ca3af;
    border-bottom-color: #374151;
  }

  .reader-mode-post-number {
    background-color: #374151;
    color: #d1d5db;
  }

  .reader-mode-post-content {
    color: #f3f4f6;
  }

  .reader-mode-post-content a {
    color: #60a5fa;
  }

  .reader-mode-post-footer {
    color: #9ca3af;
  }

  .reader-mode-divider {
    border-top-color: #374151;
  }
}

/* Reader mode mobile */
@media (max-width: 800px) {
  .post-view-modal-content-reader {
    max-width: 100%;
    width: 100%;
    height: 100%;
    border-radius: 0;
  }

  .reader-mode-post {
    padding-left: 32px;
  }

  .reader-mode-post-number {
    width: 24px;
    height: 24px;
    font-size: 11px;
  }
}

/* ==========================================================================
   Scroll Position Indicator
   ========================================================================== */

.feed-map-position-indicator {
  width: calc(100% + 2px);
  height: 6px;
  background-color: #e5e7eb;
  overflow: hidden;
  flex-basis: 100%;
  order: -1;
  margin: -1px -1px 0 -1px;
  display: flex;
  position: relative;
  user-select: none;
  -webkit-user-select: none;
  outline: none;
  -webkit-tap-highlight-color: transparent;
}

.feed-map-position-indicator:focus,
.feed-map-position-indicator:focus-visible,
.feed-map-position-indicator:active,
.feed-map-position-indicator:focus-within {
  outline: none !important;
  box-shadow: none !important;
}

.feed-map-segment:focus,
.feed-map-segment:focus-visible,
.feed-map-segment:active {
  outline: none !important;
  box-shadow: none !important;
}

/* Prevent text selection highlight on feed map */
.feed-map-wrapper,
.feed-map-wrapper * {
  user-select: none;
  -webkit-user-select: none;
  -webkit-tap-highlight-color: transparent;
}

/* Empty state when no results match filter */
.feed-map-empty {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100%;
  min-height: 20px;
  font-size: 10px;
  font-weight: 500;
  color: #9ca3af;
  background: repeating-linear-gradient(
    -45deg,
    transparent,
    transparent 4px,
    rgba(156, 163, 175, 0.15) 4px,
    rgba(156, 163, 175, 0.15) 8px
  );
}

/* Allow indicator to expand for empty state */
.feed-map-position-indicator:has(.feed-map-empty) {
  height: auto !important;
  min-height: 20px;
  overflow: visible;
}

/* Basic style - simple thin indicator */
.feed-map-basic .feed-map-position-indicator {
  height: calc(8px * var(--indicator-scale, 1));
}

/* Advanced style - main indicator is compact overview */
.feed-map-advanced .feed-map-position-indicator {
  height: calc(12px * var(--indicator-scale, 1));
}

/* Advanced style - zoom indicator auto-scales to fit content */
.feed-map-position-indicator-zoom {
  height: auto;
  min-height: calc(12px * var(--indicator-scale, 1));
  padding: 2px 0;
  overflow: visible;
  align-items: stretch;
  width: 100%;
}

/* Toolbar position: place at bottom of toolbar */
.feed-map-position-indicator-toolbar {
  order: 999;
  margin: 0 -1px -1px -1px;
}

/* Individual post segment */
.feed-map-segment {
  height: 100%;
  flex: 1;
  background-color: transparent;
  border-right: 2px solid white;
  box-sizing: border-box;
  transition: background-color var(--transition-duration, 150ms) ease;
}

/* Basic mode needs visible segment colors for read/unread to work.
   Default uses gray background with brightness filter. Themes override unread color. */
.feed-map-basic .feed-map-segment {
  background-color: #9ca3af; /* Default unread: medium gray */
}

.feed-map-basic .feed-map-segment-read {
  filter: brightness(0.6);
}

/* Basic mode theme colors - unread segments use theme's light color */
.feed-map-basic.feed-map-theme-ocean .feed-map-segment { background-color: #7dd3fc; } /* sky-300 */
.feed-map-basic.feed-map-theme-campfire .feed-map-segment { background-color: #fcd34d; } /* amber-300 */
.feed-map-basic.feed-map-theme-forest .feed-map-segment { background-color: #86efac; } /* green-300 */
.feed-map-basic.feed-map-theme-monochrome .feed-map-segment { background-color: #d1d5db; } /* gray-300 */

.feed-map-segment:last-child {
  border-right: none;
}

/* Segment states */
.feed-map-segment-read {
  filter: brightness(0.6);
}

.feed-map-segment-current {
  outline: 2px solid #3b82f6;
  outline-offset: -1px;
  z-index: var(--z-base);
}

/* Filtered posts - grayed out in feed map */
.feed-map-segment-filtered {
  opacity: 0.25;
  filter: grayscale(1);
}

/* ========================================
   SCROLL INDICATOR THEMES
   ======================================== */

/* Ratioed posts - distinctive styling for posts with more replies than likes */
.feed-map-segment-ratioed {
  background-color: #ef4444 !important; /* Default red */
}

/* === CAMPFIRE THEME (amber/orange) === */
/* Unread: light amber, Read: dimmed (via filter), Current: orange outline */
.feed-map-theme-campfire .feed-map-position-indicator { background-color: #fffbeb; }
.feed-map-theme-campfire .feed-map-segment-current { outline-color: #f59e0b !important; }
.feed-map-theme-campfire .feed-map-segment-ratioed { background-color: #ef4444 !important; }

/* Heatmap intensity levels (engagement-based) - Default theme */
.feed-map-segment-heat-1 { background-color: #fef3c7; } /* lightest - low engagement */
.feed-map-segment-heat-2 { background-color: #fde68a; }
.feed-map-segment-heat-3 { background-color: #fcd34d; }
.feed-map-segment-heat-4 { background-color: #fbbf24; }
.feed-map-segment-heat-5 { background-color: #f59e0b; }
.feed-map-segment-heat-6 { background-color: #d97706; }
.feed-map-segment-heat-7 { background-color: #b45309; }
.feed-map-segment-heat-8 { background-color: #92400e; } /* darkest - high engagement */

/* === OCEAN THEME (blue/teal) === */
/* Unread: light sky, Read: dimmed (via filter), Current: yellow outline (contrasts with blue) */
.feed-map-theme-ocean .feed-map-position-indicator { background-color: #e0f2fe; }
.feed-map-theme-ocean .feed-map-segment-current { outline-color: #eab308 !important; }
.feed-map-theme-ocean .feed-map-segment-ratioed { background-color: #f97316 !important; }
.feed-map-theme-ocean .feed-map-segment-heat-1 { background-color: #e0f2fe; }
.feed-map-theme-ocean .feed-map-segment-heat-2 { background-color: #bae6fd; }
.feed-map-theme-ocean .feed-map-segment-heat-3 { background-color: #7dd3fc; }
.feed-map-theme-ocean .feed-map-segment-heat-4 { background-color: #38bdf8; }
.feed-map-theme-ocean .feed-map-segment-heat-5 { background-color: #0ea5e9; }
.feed-map-theme-ocean .feed-map-segment-heat-6 { background-color: #0284c7; }
.feed-map-theme-ocean .feed-map-segment-heat-7 { background-color: #0369a1; }
.feed-map-theme-ocean .feed-map-segment-heat-8 { background-color: #075985; }

/* === FOREST THEME (green) === */
/* Unread: light green, Read: dimmed (via filter), Current: lime outline */
.feed-map-theme-forest .feed-map-position-indicator { background-color: #dcfce7; }
.feed-map-theme-forest .feed-map-segment-current { outline-color: #84cc16 !important; }
.feed-map-theme-forest .feed-map-segment-ratioed { background-color: #ea580c !important; }
.feed-map-theme-forest .feed-map-segment-heat-1 { background-color: #dcfce7; }
.feed-map-theme-forest .feed-map-segment-heat-2 { background-color: #bbf7d0; }
.feed-map-theme-forest .feed-map-segment-heat-3 { background-color: #86efac; }
.feed-map-theme-forest .feed-map-segment-heat-4 { background-color: #4ade80; }
.feed-map-theme-forest .feed-map-segment-heat-5 { background-color: #22c55e; }
.feed-map-theme-forest .feed-map-segment-heat-6 { background-color: #16a34a; }
.feed-map-theme-forest .feed-map-segment-heat-7 { background-color: #15803d; }
.feed-map-theme-forest .feed-map-segment-heat-8 { background-color: #166534; }

/* === MONOCHROME THEME (grayscale) === */
/* Unread: light gray, Read: dimmed (via filter), Current: dark outline */
.feed-map-theme-monochrome .feed-map-position-indicator { background-color: #e5e7eb; }
.feed-map-theme-monochrome .feed-map-segment-current { outline-color: #1f2937 !important; }
.feed-map-theme-monochrome .feed-map-segment-ratioed { background-color: #dc2626 !important; }
.feed-map-theme-monochrome .feed-map-segment-heat-1 { background-color: #f3f4f6; }
.feed-map-theme-monochrome .feed-map-segment-heat-2 { background-color: #e5e7eb; }
.feed-map-theme-monochrome .feed-map-segment-heat-3 { background-color: #d1d5db; }
.feed-map-theme-monochrome .feed-map-segment-heat-4 { background-color: #9ca3af; }
.feed-map-theme-monochrome .feed-map-segment-heat-5 { background-color: #6b7280; }
.feed-map-theme-monochrome .feed-map-segment-heat-6 { background-color: #4b5563; }
.feed-map-theme-monochrome .feed-map-segment-heat-7 { background-color: #374151; }
.feed-map-theme-monochrome .feed-map-segment-heat-8 { background-color: #1f2937; }

/* Content type icons in segments */
.feed-map-segment-icon {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  pointer-events: none;
  display: var(--feed-map-icon-display, flex);
  align-items: center;
  justify-content: center;
  height: 100%;
  width: 100%;
}

.feed-map-icon-stack {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 0;
  height: 100%;
}

.feed-map-icon-stack img {
  height: 45%;
  width: auto;
  max-width: 90%;
  flex-shrink: 0;
  opacity: 0.9;
  object-fit: contain;
}

/* Content type icon colors with outline for visibility */
.feed-map-icon-stack img[alt="text"] {
  /* Blue with white outline */
  filter: brightness(0) saturate(100%) invert(40%) sepia(98%) saturate(1000%) hue-rotate(200deg) brightness(95%)
    drop-shadow(0 0 1px white) drop-shadow(0 0 1px white);
}

.feed-map-icon-stack img[alt="image"] {
  /* Green with white outline */
  filter: brightness(0) saturate(100%) invert(55%) sepia(75%) saturate(500%) hue-rotate(80deg) brightness(95%)
    drop-shadow(0 0 1px white) drop-shadow(0 0 1px white);
}

.feed-map-icon-stack img[alt="video"] {
  /* Red with white outline */
  filter: brightness(0) saturate(100%) invert(30%) sepia(100%) saturate(2000%) hue-rotate(350deg) brightness(95%)
    drop-shadow(0 0 1px white) drop-shadow(0 0 1px white);
}

.feed-map-icon-stack img[alt="embed"] {
  /* Purple with white outline */
  filter: brightness(0) saturate(100%) invert(35%) sepia(80%) saturate(800%) hue-rotate(250deg) brightness(90%)
    drop-shadow(0 0 1px white) drop-shadow(0 0 1px white);
}

/* Post type icons - grayscale with white outline */
.feed-map-icon-stack img[alt="post"],
.feed-map-icon-stack img[alt="reply"],
.feed-map-icon-stack img[alt="repost"],
.feed-map-icon-stack img[alt="thread"] {
  filter: brightness(0) invert(0.3) drop-shadow(0 0 1px white) drop-shadow(0 0 1px white);
  opacity: 0.9;
}

/* Thread icon is taller SVG - constrain to match others */
.feed-map-icon-stack img[alt="thread"] {
  height: 40%;
}

/* Thread progress bar for unrolled threads - styled like mini basic feed map */
.feed-map-segment-progress {
  position: absolute;
  bottom: 1px;
  left: 2px;
  right: 2px;
  height: 3px;
  background-color: #e5e7eb;
  border-radius: 1.5px;
  overflow: hidden;
  display: flex;
}

/* Individual thread segment */
.feed-map-thread-segment {
  flex: 1;
  height: 100%;
  background-color: #d1d5db;
  border-right: 1px solid #e5e7eb;
  box-sizing: border-box;
}

.feed-map-thread-segment:last-child {
  border-right: none;
}

/* Visited segments use darker color */
.feed-map-thread-segment-visited {
  background-color: #9ca3af;
}

/* Theme-specific thread segment colors - match basic feed map */
.feed-map-theme-campfire .feed-map-segment-progress { background-color: #fffbeb; }
.feed-map-theme-campfire .feed-map-thread-segment { background-color: #fef3c7; border-right-color: #fffbeb; }
.feed-map-theme-campfire .feed-map-thread-segment-visited { background-color: #fcd34d; }

.feed-map-theme-ocean .feed-map-segment-progress { background-color: #e0f2fe; }
.feed-map-theme-ocean .feed-map-thread-segment { background-color: #bae6fd; border-right-color: #e0f2fe; }
.feed-map-theme-ocean .feed-map-thread-segment-visited { background-color: #7dd3fc; }

.feed-map-theme-forest .feed-map-segment-progress { background-color: #dcfce7; }
.feed-map-theme-forest .feed-map-thread-segment { background-color: #bbf7d0; border-right-color: #dcfce7; }
.feed-map-theme-forest .feed-map-thread-segment-visited { background-color: #86efac; }

.feed-map-theme-monochrome .feed-map-segment-progress { background-color: #e5e7eb; }
.feed-map-theme-monochrome .feed-map-thread-segment { background-color: #f3f4f6; border-right-color: #e5e7eb; }
.feed-map-theme-monochrome .feed-map-thread-segment-visited { background-color: #d1d5db; }

/* Progress bar in zoom segments - slightly taller for visibility */
.feed-map-segment-zoom .feed-map-segment-progress {
  height: 4px;
  border-radius: 2px;
}

.feed-map-segment {
  position: relative;
  overflow: hidden;
}

/* Zoom indicator segments - larger for better visibility */
.feed-map-segment-zoom {
  flex: 1 1 0;
  min-width: calc(20px * var(--indicator-scale, 1));
  height: auto !important;
  min-height: calc(24px * var(--indicator-scale, 1));
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: flex-start;
  padding: calc(4px * var(--indicator-scale, 1)) 0;
  gap: calc(2px * var(--indicator-scale, 1));
  overflow: hidden;
}

.feed-map-segment-zoom .feed-map-icon-stack {
  flex-direction: row;
  gap: 2px;
}

.feed-map-segment-zoom .feed-map-icon-stack img {
  height: 60%;
  width: auto;
}

/* Avatar in zoom segments */
.feed-map-segment-avatar {
  aspect-ratio: 1;
  border-radius: 50%;
  object-fit: cover;
  opacity: 0.9;
  flex-shrink: 0;
  box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.8);
}

/* Container for avatar with reposter overlay */
.feed-map-segment-avatar-container {
  position: relative;
  display: inline-block;
  flex-shrink: 0;
}

/* Reposter avatar - smaller circle at bottom-left */
.feed-map-segment-reposter-avatar {
  position: absolute;
  bottom: -2px;
  left: -2px;
  aspect-ratio: 1;
  border-radius: 50%;
  object-fit: cover;
  box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.9);
  background-color: white;
}


/* Icons in zoom segments - always at top */
.feed-map-segment-zoom .feed-map-segment-icon {
  position: static;
  transform: none;
  height: calc(16px * var(--indicator-scale, 1));
  width: auto;
  order: -1; /* Icons appear first (top) */
  flex-shrink: 0;
}

.feed-map-segment-zoom .feed-map-icon-stack {
  flex-direction: row;
  height: calc(16px * var(--indicator-scale, 1));
  gap: 0;
  flex-shrink: 0;
}

.feed-map-segment-zoom .feed-map-icon-stack img {
  height: calc(16px * var(--indicator-scale, 1));
  width: auto;
}

/* Relative time in zoom segments */
.feed-map-segment-time {
  font-size: calc(8px * var(--indicator-scale, 1));
  line-height: 1;
  color: rgba(0, 0, 0, 0.9);
  pointer-events: none;
  flex-shrink: 0;
}

/* Handle in zoom segments */
.feed-map-segment-handle {
  font-family: ui-monospace, monospace;
  line-height: 1.2;
  color: rgba(0, 0, 0, 0.9);
  overflow: hidden;
  text-overflow: ellipsis;
  max-width: 100%;
  padding: 0 calc(2px * var(--indicator-scale, 1));
  flex-shrink: 0;
  display: flex;
  flex-direction: column;
  align-items: flex-start;
}

.feed-map-segment-handle-name {
  font-size: calc(11px * var(--indicator-scale, 1));
  font-weight: bold;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  max-width: 100%;
  text-shadow:
    -1px -1px 0 rgba(255, 255, 255, 0.8),
    1px -1px 0 rgba(255, 255, 255, 0.8),
    -1px 1px 0 rgba(255, 255, 255, 0.8),
    1px 1px 0 rgba(255, 255, 255, 0.8),
    0 0 3px rgba(255, 255, 255, 0.6);
}

.feed-map-segment-handle-domain {
  font-size: calc(7px * var(--indicator-scale, 1));
  opacity: 0.7;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  max-width: 100%;
  text-shadow:
    -1px -1px 0 rgba(255, 255, 255, 0.6),
    1px -1px 0 rgba(255, 255, 255, 0.6),
    -1px 1px 0 rgba(255, 255, 255, 0.6),
    1px 1px 0 rgba(255, 255, 255, 0.6);
}


/* Empty segments (no corresponding item) */
.feed-map-segment-empty {
  background-color: transparent !important;
  opacity: 0.3;
}

/* Virtualized segments (item scrolled out of DOM) - style same as empty */
.feed-map-segment-virtualized {
  background-color: transparent !important;
  opacity: 0.3;
}

/* Wrapper for indicators with zoom */
.feed-map-wrapper {
  display: flex;
  flex-direction: column;
  width: 100%;
  user-select: none;
  -webkit-user-select: none;
  position: relative;
  z-index: var(--z-base);
}

/* Zoom indicator connector */
.feed-map-connector {
  display: block;
  width: 100%;
  height: calc(20px * var(--indicator-scale, 1));
  position: relative;
  overflow: visible;
  margin-top: calc(-2px * var(--indicator-scale, 1));
}

.feed-map-connector-svg {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
}

.feed-map-connector-path {
  stroke: rgba(80, 80, 80, 0.8);
  stroke-width: 3;
  fill: none;
}

@media (prefers-color-scheme: dark) {
  .feed-map-connector-path {
    stroke: rgba(200, 200, 200, 0.8);
  }
}

/* Zoom indicator container - inherits from .feed-map-container */
.feed-map-zoom-container {
  margin-top: 0;
  overflow-y: visible;
}

.feed-map-position-indicator-zoom {
  border: 1px solid rgba(0, 0, 0, 0.2);
  border-radius: 3px;
  overflow-x: hidden;
  overflow-y: visible;
  height: auto !important;
  width: 100%;
}

/* Inner wrapper for smooth scroll animation */
.feed-map-zoom-inner {
  display: flex;
  width: 100%;
  height: auto;
  min-height: 100%;
  will-change: transform;
  align-items: stretch;
}

.feed-map-zoom-inner.feed-map-zoom-animating {
  transition: transform calc(800ms * var(--zoom-animation-speed, 1)) ease-out;
}

/* When zoom is enabled, allow brackets to overflow */
.feed-map-wrapper .feed-map-position-indicator:first-child,
.feed-map-wrapper .feed-map-container:first-child .feed-map-position-indicator {
  overflow: visible;
}

/* Zoom highlight on main indicator showing zoomed region - bracket style */
.feed-map-position-zoom-highlight {
  position: absolute;
  top: -4px;
  height: calc(100% + 8px);
  background-color: transparent;
  pointer-events: none;
  box-sizing: border-box;
  z-index: var(--z-raised);
}

/* Left bracket [ */
.feed-map-position-zoom-highlight::before {
  content: '';
  position: absolute;
  left: 0;
  top: 0;
  width: 6px;
  height: 100%;
  border-left: 1px solid rgba(0, 0, 0, 0.8);
  border-top: 1px solid rgba(0, 0, 0, 0.8);
  border-bottom: 1px solid rgba(0, 0, 0, 0.8);
  box-sizing: border-box;
}

/* Right bracket ] */
.feed-map-position-zoom-highlight::after {
  content: '';
  position: absolute;
  right: 0;
  top: 0;
  width: 6px;
  height: 100%;
  border-right: 1px solid rgba(0, 0, 0, 0.8);
  border-top: 1px solid rgba(0, 0, 0, 0.8);
  border-bottom: 1px solid rgba(0, 0, 0, 0.8);
  box-sizing: border-box;
}

/* Zoom row end indicators - show when scrolled to start/end */
.feed-map-position-indicator-zoom::before,
.feed-map-position-indicator-zoom::after {
  content: '';
  position: absolute;
  top: 0;
  width: 3px;
  height: 100%;
  background-color: var(--bsky-blue, #1185fe);
  opacity: 0;
  transition: opacity calc(var(--animation-duration, 300ms) * 0.5) ease-out;
  z-index: var(--z-base);
  border-radius: 2px;
}

.feed-map-position-indicator-zoom::before {
  left: 0;
}

.feed-map-position-indicator-zoom::after {
  right: 0;
}

.feed-map-position-indicator-zoom.feed-map-zoom-at-start::before {
  opacity: 0.8;
}

.feed-map-position-indicator-zoom.feed-map-zoom-at-end::after {
  opacity: 0.8;
}

@media (prefers-color-scheme: dark) {
  /* Dark mode: use dark outline instead of white, keep colors but brighten */
  .feed-map-icon-stack img[alt="text"] {
    filter: brightness(0) saturate(100%) invert(60%) sepia(98%) saturate(800%) hue-rotate(200deg) brightness(110%)
      drop-shadow(0 0 1px rgba(0,0,0,0.8)) drop-shadow(0 0 1px rgba(0,0,0,0.8));
  }

  .feed-map-icon-stack img[alt="image"] {
    filter: brightness(0) saturate(100%) invert(70%) sepia(60%) saturate(500%) hue-rotate(80deg) brightness(110%)
      drop-shadow(0 0 1px rgba(0,0,0,0.8)) drop-shadow(0 0 1px rgba(0,0,0,0.8));
  }

  .feed-map-icon-stack img[alt="video"] {
    filter: brightness(0) saturate(100%) invert(50%) sepia(100%) saturate(1500%) hue-rotate(350deg) brightness(110%)
      drop-shadow(0 0 1px rgba(0,0,0,0.8)) drop-shadow(0 0 1px rgba(0,0,0,0.8));
  }

  .feed-map-icon-stack img[alt="embed"] {
    filter: brightness(0) saturate(100%) invert(55%) sepia(80%) saturate(600%) hue-rotate(250deg) brightness(110%)
      drop-shadow(0 0 1px rgba(0,0,0,0.8)) drop-shadow(0 0 1px rgba(0,0,0,0.8));
  }


  /* Post type icons */
  .feed-map-icon-stack img[alt="post"],
  .feed-map-icon-stack img[alt="reply"],
  .feed-map-icon-stack img[alt="repost"],
  .feed-map-icon-stack img[alt="thread"] {
    filter: invert(1) drop-shadow(0 0 1px rgba(0,0,0,0.8));
    opacity: 0.8;
  }

  .feed-map-position-indicator-zoom {
    border-color: rgba(255, 255, 255, 0.2);
  }

  .feed-map-position-zoom-highlight::before {
    border-left-color: rgba(255, 255, 255, 0.8);
    border-top-color: rgba(255, 255, 255, 0.8);
    border-bottom-color: rgba(255, 255, 255, 0.8);
  }

  .feed-map-position-zoom-highlight::after {
    border-right-color: rgba(255, 255, 255, 0.8);
    border-top-color: rgba(255, 255, 255, 0.8);
    border-bottom-color: rgba(255, 255, 255, 0.8);
  }
}

/* Viewport indicator overlay */
.feed-map-viewport-indicator {
  position: absolute;
  top: -1px;
  height: calc(100% + 2px);
  background-color: rgba(255, 255, 255, 0.2);
  border: 2px solid rgba(0, 0, 0, 0.35);
  border-radius: 2px;
  pointer-events: none;
  transition: left var(--transition-duration, 100ms) ease-out,
              width var(--transition-duration, 100ms) ease-out;
  box-sizing: border-box;
}

/* Legacy fill element (hidden when using segments) */
.feed-map-position-fill {
  display: none;
}

/* Date/time labels for scroll indicator */
.feed-map-container {
  display: flex;
  align-items: center;
  width: calc(100% + 2px);
  margin: -1px -1px 0 -1px;
  flex-basis: 100%;
  order: -1;
}

.feed-map-container-toolbar {
  margin: 0 -1px -1px -1px;
}

/* Toolbar position: place at bottom of toolbar */
.feed-map-wrapper {
  order: 999;
}

/* Status bar position: place at top, full width row */
.feed-map-wrapper.feed-map-wrapper-statusbar,
.feed-map-container.feed-map-container-statusbar {
  width: 100% !important;
  flex: 0 0 100% !important;
  background: transparent;
  order: -1 !important;
  margin: 0 !important;
}

/* Statusbar: connector between zoom (above) and main (below) - match toolbar styling */
.feed-map-wrapper-statusbar .feed-map-connector {
  height: calc(16px * var(--indicator-scale, 1));
  margin-top: calc(-2px * var(--indicator-scale, 1));
  margin-bottom: calc(-2px * var(--indicator-scale, 1));
}

.feed-map-wrapper-statusbar .feed-map-connector .feed-map-connector-path {
  stroke-width: 2 !important;
}

/* Reset the indicator width inside status bar */
.feed-map-container-statusbar .feed-map-position-indicator {
  width: 100% !important;
  margin: 0 !important;
}

/* Allow status bar to expand when scroll indicator is present */
div#statusBar.has-feed-map {
  overflow: visible;
}

/* Reset order for containers inside the wrapper to maintain DOM order */
.feed-map-wrapper > .feed-map-container {
  order: 0;
}

.feed-map-wrapper > .feed-map-connector {
  order: 0;
}

.feed-map-label {
  font-size: 10px;
  color: #6b7280;
  white-space: nowrap;
  padding: 0 4px;
  flex-shrink: 0;
  width: 60px;
  min-width: 60px;
}

/* Basic style - hide date labels, zoom highlight, zoom indicator, and connector */
.feed-map-basic .feed-map-label {
  display: none;
}

.feed-map-basic .feed-map-position-zoom-highlight {
  display: none;
}

.feed-map-basic .feed-map-zoom-container {
  display: none;
}

.feed-map-basic .feed-map-connector {
  display: none;
}

.feed-map-label-start {
  text-align: left;
}

.feed-map-label-end {
  text-align: right;
}

.feed-map-container .feed-map-position-indicator {
  flex: 1;
  width: auto;
  margin: 0;
  flex-basis: auto;
  order: 0;
}

@media (prefers-color-scheme: dark) {
  .feed-map-position-indicator {
    background-color: #374151;
  }

  .feed-map-empty {
    color: #6b7280;
    background: repeating-linear-gradient(
      -45deg,
      transparent,
      transparent 4px,
      rgba(107, 114, 128, 0.2) 4px,
      rgba(107, 114, 128, 0.2) 8px
    );
  }

  .feed-map-segment {
    border-right-color: #374151;
  }

  .feed-map-segment-read {
    filter: brightness(0.5);
  }

  .feed-map-segment-time {
    color: rgba(255, 255, 255, 0.5);
    text-shadow: 0 0 2px rgba(0, 0, 0, 0.8), 0 0 2px rgba(0, 0, 0, 0.8);
  }

  .feed-map-segment-handle {
    color: rgba(255, 255, 255, 0.9);
  }

  .feed-map-segment-handle-name {
    text-shadow:
      -1px -1px 0 rgba(0, 0, 0, 0.8),
      1px -1px 0 rgba(0, 0, 0, 0.8),
      -1px 1px 0 rgba(0, 0, 0, 0.8),
      1px 1px 0 rgba(0, 0, 0, 0.8),
      0 0 3px rgba(0, 0, 0, 0.6);
  }

  .feed-map-segment-handle-domain {
    text-shadow:
      -1px -1px 0 rgba(0, 0, 0, 0.6),
      1px -1px 0 rgba(0, 0, 0, 0.6),
      -1px 1px 0 rgba(0, 0, 0, 0.6),
      1px 1px 0 rgba(0, 0, 0, 0.6);
  }

  /* Basic mode dark: theme colors with brightness filter for read */
  .feed-map-basic .feed-map-segment { background-color: #4b5563; }
  .feed-map-basic.feed-map-theme-ocean .feed-map-segment { background-color: #0e7490; } /* cyan-700 */
  .feed-map-basic.feed-map-theme-campfire .feed-map-segment { background-color: #b45309; } /* amber-700 */
  .feed-map-basic.feed-map-theme-forest .feed-map-segment { background-color: #15803d; } /* green-700 */
  .feed-map-basic.feed-map-theme-monochrome .feed-map-segment { background-color: #6b7280; } /* gray-500 */

  .feed-map-segment-current {
    outline-color: #60a5fa;
  }

  .feed-map-viewport-indicator {
    background-color: rgba(0, 0, 0, 0.2);
    border-color: rgba(255, 255, 255, 0.7);
  }

  .feed-map-label {
    color: #9ca3af;
  }

  /* Dark mode ratioed - brighter for visibility */
  .feed-map-segment-ratioed {
    background-color: #f87171 !important; /* red-400 */
  }

  /* === DARK MODE: CAMPFIRE THEME === */
  .feed-map-theme-campfire .feed-map-position-indicator { background-color: #451a03; }
  .feed-map-theme-campfire .feed-map-segment-current { outline-color: #fbbf24 !important; }
  .feed-map-theme-campfire .feed-map-segment-ratioed { background-color: #f87171 !important; }
  .feed-map-segment-heat-1 { background-color: #1e3a5f; }
  .feed-map-segment-heat-2 { background-color: #1e4976; }
  .feed-map-segment-heat-3 { background-color: #1d5a8d; }
  .feed-map-segment-heat-4 { background-color: #1c6ba4; }
  .feed-map-segment-heat-5 { background-color: #1b7cbb; }
  .feed-map-segment-heat-6 { background-color: #1a8dd2; }
  .feed-map-segment-heat-7 { background-color: #199ee9; }
  .feed-map-segment-heat-8 { background-color: #18afff; }

  /* === DARK MODE: OCEAN THEME === */
  .feed-map-theme-ocean .feed-map-position-indicator { background-color: #164e63; }
  .feed-map-theme-ocean .feed-map-segment-current { outline-color: #facc15 !important; }
  .feed-map-theme-ocean .feed-map-segment-ratioed { background-color: #fb923c !important; }
  .feed-map-theme-ocean .feed-map-segment-heat-1 { background-color: #164e63; }
  .feed-map-theme-ocean .feed-map-segment-heat-2 { background-color: #155e75; }
  .feed-map-theme-ocean .feed-map-segment-heat-3 { background-color: #0e7490; }
  .feed-map-theme-ocean .feed-map-segment-heat-4 { background-color: #0891b2; }
  .feed-map-theme-ocean .feed-map-segment-heat-5 { background-color: #06b6d4; }
  .feed-map-theme-ocean .feed-map-segment-heat-6 { background-color: #22d3ee; }
  .feed-map-theme-ocean .feed-map-segment-heat-7 { background-color: #67e8f9; }
  .feed-map-theme-ocean .feed-map-segment-heat-8 { background-color: #a5f3fc; }

  /* === DARK MODE: FOREST THEME === */
  .feed-map-theme-forest .feed-map-position-indicator { background-color: #14532d; }
  .feed-map-theme-forest .feed-map-segment-current { outline-color: #a3e635 !important; }
  .feed-map-theme-forest .feed-map-segment-ratioed { background-color: #fb923c !important; }
  .feed-map-theme-forest .feed-map-segment-heat-1 { background-color: #14532d; }
  .feed-map-theme-forest .feed-map-segment-heat-2 { background-color: #166534; }
  .feed-map-theme-forest .feed-map-segment-heat-3 { background-color: #15803d; }
  .feed-map-theme-forest .feed-map-segment-heat-4 { background-color: #16a34a; }
  .feed-map-theme-forest .feed-map-segment-heat-5 { background-color: #22c55e; }
  .feed-map-theme-forest .feed-map-segment-heat-6 { background-color: #4ade80; }
  .feed-map-theme-forest .feed-map-segment-heat-7 { background-color: #86efac; }
  .feed-map-theme-forest .feed-map-segment-heat-8 { background-color: #bbf7d0; }

  /* === DARK MODE: MONOCHROME THEME === */
  .feed-map-theme-monochrome .feed-map-position-indicator { background-color: #374151; }
  .feed-map-theme-monochrome .feed-map-segment-current { outline-color: #f9fafb !important; }
  .feed-map-theme-monochrome .feed-map-segment-ratioed { background-color: #ef4444 !important; }
  .feed-map-theme-monochrome .feed-map-segment-heat-1 { background-color: #1f2937; }
  .feed-map-theme-monochrome .feed-map-segment-heat-2 { background-color: #374151; }
  .feed-map-theme-monochrome .feed-map-segment-heat-3 { background-color: #4b5563; }
  .feed-map-theme-monochrome .feed-map-segment-heat-4 { background-color: #6b7280; }
  .feed-map-theme-monochrome .feed-map-segment-heat-5 { background-color: #9ca3af; }
  .feed-map-theme-monochrome .feed-map-segment-heat-6 { background-color: #d1d5db; }
  .feed-map-theme-monochrome .feed-map-segment-heat-7 { background-color: #e5e7eb; }
  .feed-map-theme-monochrome .feed-map-segment-heat-8 { background-color: #f3f4f6; }
}

@media (prefers-contrast: more) {
  .feed-map-position-indicator {
    height: 4px;
    background-color: #9ca3af;
  }

  .feed-map-segment-read {
    filter: brightness(0.4);
  }

  .feed-map-segment-current {
    outline: 3px solid #1d4ed8;
    outline-offset: -1px;
  }
}

/* ==========================================================================
   Feed Map Tooltip
   ========================================================================== */

.feed-map-tooltip {
  position: fixed;
  z-index: var(--z-tooltip);
  background: white;
  border: 1px solid #e5e7eb;
  border-radius: 8px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
  padding: 10px 12px;
  max-width: 300px;
  min-width: 200px;
  pointer-events: none;
  opacity: 0;
  transition: opacity 150ms ease;
}

.feed-map-tooltip.visible {
  opacity: 1;
}

.feed-map-tooltip-header {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 12px;
  color: #6b7280;
  margin-bottom: 2px;
}

.feed-map-tooltip-avatar {
  width: 32px;
  height: 32px;
  border-radius: 50%;
  object-fit: cover;
  flex-shrink: 0;
}

.feed-map-tooltip-header-text {
  display: flex;
  flex-direction: column;
}

.feed-map-tooltip-handle {
  color: #9ca3af;
}

.feed-map-tooltip-time {
  color: #9ca3af;
}

.feed-map-tooltip-author {
  font-size: 13px;
  font-weight: 600;
  color: #111827;
  margin-bottom: 6px;
}

.feed-map-tooltip-content {
  font-size: 13px;
  line-height: 1.4;
  color: #374151;
  margin-bottom: 8px;
  word-wrap: break-word;
  overflow-wrap: break-word;
}

.feed-map-tooltip-engagement {
  display: flex;
  align-items: center;
  gap: 12px;
  font-size: 11px;
  color: #6b7280;
  padding-top: 6px;
  border-top: 1px solid #e5e7eb;
}

.feed-map-tooltip-stat {
  display: flex;
  align-items: center;
  gap: 4px;
}

.feed-map-tooltip-icon {
  width: 14px;
  height: 14px;
  opacity: 0.7;
}

.feed-map-tooltip-media-icon {
  width: 14px;
  height: 14px;
  opacity: 0.7;
  margin-left: auto;
}

/* Read post styling - only when visible */
.feed-map-tooltip.visible.feed-map-tooltip-read {
  opacity: 0.85;
}

.feed-map-tooltip.visible.feed-map-tooltip-read .feed-map-tooltip-author,
.feed-map-tooltip.visible.feed-map-tooltip-read .feed-map-tooltip-content {
  color: #6b7280;
}

/* Ratioed post styling */
.feed-map-tooltip.feed-map-tooltip-ratioed .feed-map-tooltip-engagement {
  background-color: #fef2f2;
  margin: 0 -12px -10px -12px;
  padding: 6px 12px 10px 12px;
  border-radius: 0 0 8px 8px;
  border-top: 1px solid #fecaca;
}

/* Dark mode */
@media (prefers-color-scheme: dark) {
  .feed-map-tooltip {
    background: #1f2937;
    border-color: #374151;
    color: #f3f4f6;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
  }

  .feed-map-tooltip-header {
    color: #9ca3af;
  }

  .feed-map-tooltip-handle,
  .feed-map-tooltip-time {
    color: #6b7280;
  }

  .feed-map-tooltip-author {
    color: #f9fafb;
  }

  .feed-map-tooltip-content {
    color: #d1d5db;
  }

  .feed-map-tooltip-engagement {
    color: #9ca3af;
    border-top-color: #374151;
  }

  .feed-map-tooltip-icon,
  .feed-map-tooltip-media-icon {
    filter: invert(1);
  }

  .feed-map-tooltip.feed-map-tooltip-read .feed-map-tooltip-author,
  .feed-map-tooltip.feed-map-tooltip-read .feed-map-tooltip-content {
    color: #9ca3af;
  }

  .feed-map-tooltip.feed-map-tooltip-ratioed .feed-map-tooltip-engagement {
    background-color: #450a0a;
    border-top-color: #7f1d1d;
  }
}

/* ==========================================================================
   Breadcrumb Trail
   ========================================================================== */

.breadcrumb {
  display: flex;
  align-items: center;
  flex-wrap: nowrap;
  flex-shrink: 1;
  gap: 0;
  margin-left: auto;
  padding: 4px 0;
  font-size: 12px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.breadcrumb-item {
  display: flex;
  align-items: center;
}

.breadcrumb-text {
  color: #6b7280;
  overflow: hidden;
  text-overflow: ellipsis;
  max-width: 100px;
}

.breadcrumb-link {
  color: #3b82f6;
  text-decoration: none;
  overflow: hidden;
  text-overflow: ellipsis;
  max-width: 100px;
  transition: color var(--transition-duration, 200ms) ease;
}

.breadcrumb-link:hover {
  color: #2563eb;
  text-decoration: underline;
}

.breadcrumb-link:focus {
  outline: 2px solid var(--focus-ring-color, #0066cc);
  outline-offset: 2px;
  border-radius: 2px;
}

.breadcrumb-separator {
  margin: 0 6px;
  color: #9ca3af;
  flex-shrink: 0;
}

@media (prefers-color-scheme: dark) {
  .breadcrumb-text {
    color: #9ca3af;
  }

  .breadcrumb-link {
    color: #60a5fa;
  }

  .breadcrumb-link:hover {
    color: #93c5fd;
  }

  .breadcrumb-separator {
    color: #6b7280;
  }
}

@media (prefers-contrast: more) {
  .breadcrumb-text {
    color: #374151;
  }

  .breadcrumb-link {
    color: #1d4ed8;
    text-decoration: underline;
  }

  .breadcrumb-separator {
    color: #374151;
  }
}

/* ==========================================================================
   Saved Searches
   ========================================================================== */

.search-wrapper {
  display: flex;
  align-items: center;
  position: relative;
  gap: 4px;
  flex: 0 0 auto;
  margin-left: auto;
  min-width: 150px;
  max-width: 300px;
  z-index: var(--z-toolbar);
}

.saved-searches-btn,
.save-search-btn {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 28px;
  height: 28px;
  padding: 0;
  border: none;
  border-radius: 4px;
  background-color: transparent;
  color: #6b7280;
  cursor: pointer;
  transition: background-color var(--transition-duration, 200ms) ease,
              color var(--transition-duration, 200ms) ease;
}

.saved-searches-btn:hover,
.save-search-btn:hover {
  background-color: #f3f4f6;
  color: #374151;
}

.saved-searches-btn:focus,
.save-search-btn:focus {
  outline: 2px solid var(--focus-ring-color, #0066cc);
  outline-offset: 2px;
}

.save-search-btn-saved {
  color: #22c55e;
  animation: savedPulse var(--animation-duration, 300ms) ease-out;
}

@keyframes savedPulse {
  0%, 100% {
    transform: scale(1);
  }
  50% {
    transform: scale(1.2);
  }
}

/* Autocomplete item styling */
.autocomplete-item-content {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 2px 4px;
  width: 100%;
}

.autocomplete-saved-item {
  justify-content: space-between;
}

.autocomplete-item-icon {
  color: #eab308;
  font-size: 12px;
  flex-shrink: 0;
}

.autocomplete-item-label {
  flex: 1;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.autocomplete-delete-btn {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 18px;
  height: 18px;
  padding: 0;
  border: none;
  border-radius: 4px;
  background-color: transparent;
  color: #9ca3af;
  font-size: 14px;
  cursor: pointer;
  opacity: 0;
  transition: opacity var(--transition-duration, 150ms) ease,
              background-color var(--transition-duration, 150ms) ease;
  flex-shrink: 0;
}

.ui-menu-item:hover .autocomplete-delete-btn,
.ui-state-active .autocomplete-delete-btn {
  opacity: 1;
}

.autocomplete-delete-btn:hover {
  background-color: #fecaca;
  color: #dc2626;
}

@media (prefers-color-scheme: dark) {
  .saved-searches-btn,
  .save-search-btn {
    color: #9ca3af;
  }

  .saved-searches-btn:hover,
  .save-search-btn:hover {
    background-color: #374151;
    color: #e5e7eb;
  }

  .autocomplete-delete-btn {
    color: #6b7280;
  }

  .autocomplete-delete-btn:hover {
    background-color: #7f1d1d;
    color: #fecaca;
  }
}

/* ==========================================================================
   Filter Highlight
   ========================================================================== */

.filter-highlight {
  background-color: #fef08a;
  color: #000;
  border-radius: 2px;
  padding: 0 2px;
}

@media (prefers-color-scheme: dark) {
  .filter-highlight {
    background-color: #ca8a04;
    color: #fef9c3;
  }
}

@media (prefers-contrast: more) {
  .filter-highlight {
    background-color: #facc15;
    outline: 2px solid #000;
    outline-offset: -1px;
  }
}

/* ==========================================================================
   Collapsible Sidecar Sections
   ========================================================================== */

.sidecar-section {
  margin-bottom: 8px;
}

.sidecar-section-toggle {
  display: flex;
  align-items: center;
  width: 100%;
  padding: 8px 10px;
  border: none;
  border-radius: 6px;
  background-color: #f3f4f6;
  color: #374151;
  font-size: 13px;
  font-weight: 600;
  cursor: pointer;
  transition: background-color var(--transition-duration, 200ms) ease;
}

.sidecar-section-toggle:hover {
  background-color: #e5e7eb;
}

.sidecar-section-toggle:focus {
  outline: 2px solid var(--focus-ring-color, #0066cc);
  outline-offset: 2px;
}

.sidecar-section-icon {
  margin-right: 8px;
  font-size: 10px;
  transition: transform var(--transition-duration, 200ms) ease;
}

.sidecar-section-toggle[aria-expanded="false"] .sidecar-section-icon {
  transform: rotate(-90deg);
}

.sidecar-section-title {
  flex: 1;
  text-align: left;
}

.sidecar-section-content {
  overflow: hidden;
}

@media (prefers-color-scheme: dark) {
  .sidecar-section-toggle {
    background-color: #374151;
    color: #e5e7eb;
  }

  .sidecar-section-toggle:hover {
    background-color: #4b5563;
  }
}

@media (prefers-contrast: more) {
  .sidecar-section-toggle {
    border: 2px solid #000;
  }
}

/* ==========================================================================
   Mobile Swipe Gestures
   ========================================================================== */

.swipe-indicator {
  position: absolute;
  top: 50%;
  transform: translateY(-50%);
  width: 48px;
  height: 48px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 50%;
  opacity: 0;
  transition: opacity var(--transition-duration, 200ms) ease,
              transform var(--transition-duration, 200ms) ease;
  z-index: var(--z-raised);
  pointer-events: none;
}

.swipe-indicator-left {
  left: 10px;
  background-color: #22c55e;
  color: white;
}

.swipe-indicator-right {
  right: 10px;
  background-color: #ec4899;
  color: white;
}

.swipe-indicator-active {
  opacity: 1;
  transform: translateY(-50%) scale(1.1);
}

/* Enable on touch devices only */
@media (hover: none) and (pointer: coarse) {
  .swipe-indicator {
    display: flex;
  }
}

@media (hover: hover) and (pointer: fine) {
  .swipe-indicator {
    display: none;
  }
}

/* ==========================================================================
   Mobile Bottom Sheet
   ========================================================================== */

.bottom-sheet-backdrop {
  position: fixed;
  inset: 0;
  background-color: rgba(0, 0, 0, 0);
  z-index: var(--z-modal);
  transition: background-color var(--transition-duration, 200ms) ease;
}

.bottom-sheet-backdrop-visible {
  background-color: rgba(0, 0, 0, 0.5);
}

.bottom-sheet {
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  background-color: white;
  border-radius: 16px 16px 0 0;
  z-index: calc(var(--z-modal) + 1);
  transform: translateY(100%);
  transition: transform var(--transition-duration, 200ms) ease;
  max-height: 80vh;
  overflow-y: auto;
}

.bottom-sheet-visible {
  transform: translateY(0);
}

.bottom-sheet-handle {
  width: 36px;
  height: 4px;
  margin: 12px auto;
  background-color: #d1d5db;
  border-radius: 2px;
}

.bottom-sheet-content {
  padding: 8px 16px 16px;
}

.bottom-sheet-action {
  display: flex;
  align-items: center;
  width: 100%;
  padding: 14px 12px;
  margin-bottom: 4px;
  border: none;
  border-radius: 12px;
  background-color: transparent;
  color: #374151;
  font-size: 16px;
  text-align: left;
  cursor: pointer;
  transition: background-color var(--transition-duration, 200ms) ease;
}

.bottom-sheet-action:hover,
.bottom-sheet-action:active {
  background-color: #f3f4f6;
}

.bottom-sheet-action:focus {
  outline: 2px solid var(--focus-ring-color, #0066cc);
  outline-offset: 2px;
}

.bottom-sheet-action-icon {
  width: 24px;
  height: 24px;
  margin-right: 12px;
  display: flex;
  align-items: center;
  justify-content: center;
  color: #6b7280;
}

.bottom-sheet-action-label {
  flex: 1;
}

.bottom-sheet-cancel {
  display: block;
  width: calc(100% - 32px);
  margin: 8px 16px 16px;
  padding: 14px;
  border: none;
  border-radius: 12px;
  background-color: #f3f4f6;
  color: #374151;
  font-size: 16px;
  font-weight: 600;
  cursor: pointer;
  transition: background-color var(--transition-duration, 200ms) ease;
}

.bottom-sheet-cancel:hover,
.bottom-sheet-cancel:active {
  background-color: #e5e7eb;
}

.bottom-sheet-cancel:focus {
  outline: 2px solid var(--focus-ring-color, #0066cc);
  outline-offset: 2px;
}

/* Safe area for notched devices */
@supports (padding-bottom: env(safe-area-inset-bottom)) {
  .bottom-sheet {
    padding-bottom: env(safe-area-inset-bottom);
  }
}

@media (prefers-color-scheme: dark) {
  .bottom-sheet {
    background-color: #1f2937;
  }

  .bottom-sheet-handle {
    background-color: #4b5563;
  }

  .bottom-sheet-action {
    color: #e5e7eb;
  }

  .bottom-sheet-action:hover,
  .bottom-sheet-action:active {
    background-color: #374151;
  }

  .bottom-sheet-action-icon {
    color: #9ca3af;
  }

  .bottom-sheet-cancel {
    background-color: #374151;
    color: #e5e7eb;
  }

  .bottom-sheet-cancel:hover,
  .bottom-sheet-cancel:active {
    background-color: #4b5563;
  }
}

@media (prefers-contrast: more) {
  .bottom-sheet {
    border: 2px solid black;
    border-bottom: none;
  }

  .bottom-sheet-action {
    border: 1px solid #9ca3af;
  }
}

/* ==========================================================================
   Config Modal
   ========================================================================== */

.config-modal {
  position: fixed;
  inset: 0;
  z-index: calc(var(--z-modal) + 1);
  display: flex;
  align-items: center;
  justify-content: center;
}

.config-modal-backdrop {
  position: absolute;
  inset: 0;
  background-color: rgba(0, 0, 0, 0.5);
}

.config-modal-content {
  position: relative;
  background-color: #ffffff;
  border-radius: 12px;
  box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
  max-width: 800px;
  max-height: 85vh;
  width: 95%;
  display: flex;
  flex-direction: column;
  overflow: hidden;
  animation: overlaySlideUp var(--animation-duration, 200ms) ease-out;
}

.config-modal-hiding .config-modal-content {
  animation: overlaySlideDown var(--animation-duration, 200ms) ease-in;
}

.config-modal-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 16px 20px;
  border-bottom: 1px solid #e5e7eb;
  flex-shrink: 0;
}

.config-modal-header h2 {
  margin: 0;
  font-size: 18px;
  font-weight: 600;
  color: #111827;
}

.config-modal-close {
  background: none;
  border: none;
  font-size: 24px;
  color: #6b7280;
  cursor: pointer;
  padding: 4px 8px;
  line-height: 1;
  border-radius: 4px;
}

.config-modal-close:hover {
  background-color: #f3f4f6;
  color: #111827;
}

.config-modal-body {
  display: flex;
  flex: 1;
  overflow: hidden;
  min-height: 0;
}

/* Tabs navigation */
.config-modal-tabs {
  width: 180px;
  flex-shrink: 0;
  background-color: #f9fafb;
  border-right: 1px solid #e5e7eb;
  padding: 8px;
  overflow-y: auto;
  display: flex;
  flex-direction: column;
  gap: 2px;
}

.config-tab {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 10px 12px;
  border: none;
  background: none;
  border-radius: 6px;
  cursor: pointer;
  text-align: left;
  font-size: 13px;
  color: #4b5563;
  transition: all 150ms ease;
}

.config-tab:hover {
  background-color: #e5e7eb;
}

.config-tab.active {
  background-color: #dbeafe;
  color: #1d4ed8;
  font-weight: 500;
}

.config-tab-icon {
  font-size: 16px;
  width: 20px;
  text-align: center;
}

.config-tab-label {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

/* Panels */
.config-modal-panels {
  flex: 1;
  overflow-y: auto;
  padding: 20px;
}

.config-panel {
  display: none;
}

.config-panel.active {
  display: block;
}

/* Fields */
.config-field {
  display: flex;
  flex-direction: column;
  gap: 4px;
  margin-bottom: 16px;
}

.config-field-label {
  font-size: 13px;
  font-weight: 500;
  color: #374151;
}

.config-field-help {
  font-size: 11px;
  color: #6b7280;
  margin-top: 2px;
}

/* Field wrapper for reset button positioning */
.config-field-wrapper {
  display: flex;
  align-items: flex-start;
  gap: 4px;
}

.config-field-wrapper .config-field {
  flex: 1;
  min-width: 0;
}

.config-field-wrapper.config-field-textarea {
  align-items: stretch;
}

/* Reset button for individual fields */
.config-field-reset {
  flex-shrink: 0;
  width: 24px;
  height: 24px;
  padding: 0;
  border: 1px solid #d1d5db;
  border-radius: 4px;
  background: #f9fafb;
  color: #6b7280;
  font-size: 14px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.15s ease;
  margin-top: 22px; /* Align with input fields that have labels */
}

.config-field-wrapper.config-field-textarea .config-field-reset {
  margin-top: 22px;
  align-self: flex-start;
}

.config-field-reset:hover {
  background: #e5e7eb;
  border-color: #9ca3af;
  color: #374151;
}

.config-field-reset:active {
  background: #d1d5db;
}

.config-field-reset.hidden {
  visibility: hidden;
}

.config-field-conditional.hidden {
  display: none;
}

.config-field input[type="text"],
.config-field input[type="number"],
.config-field input[type="password"],
.config-field select {
  padding: 8px 12px;
  border: 1px solid #d1d5db;
  border-radius: 6px;
  font-size: 13px;
  background-color: #ffffff;
  color: #111827;
  max-width: 300px;
}

.config-field input:focus,
.config-field select:focus,
.config-field textarea:focus {
  outline: none;
  border-color: #3b82f6;
  box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
}

.config-field textarea {
  padding: 8px 12px;
  border: 1px solid #d1d5db;
  border-radius: 6px;
  font-size: 12px;
  font-family: monospace;
  resize: vertical;
  min-height: 60px;
}

.config-field-textarea {
  max-width: 100%;
}

.config-field-textarea textarea {
  width: 100%;
}

/* Checkbox styling - compact inline */
.config-field-checkbox {
  display: inline-flex;
  align-items: center;
  gap: 4px;
  cursor: pointer;
  margin: 0 16px 4px 0;
  position: relative;
}

.config-field-checkbox input[type="checkbox"] {
  width: 13px;
  height: 13px;
  margin: 0;
  cursor: pointer;
  accent-color: #3b82f6;
}

.config-checkbox-label {
  font-size: 11px;
  color: #374151;
  white-space: nowrap;
}

/* Conditional wrapper should be inline for checkboxes */
.config-field-conditional:has(.config-field-checkbox) {
  display: inline;
}

/* Show help as tooltip on hover */
.config-field-checkbox[data-help]:hover::after {
  content: attr(data-help);
  position: absolute;
  bottom: 100%;
  left: 0;
  background: #1f2937;
  color: #fff;
  font-size: 11px;
  padding: 4px 8px;
  border-radius: 4px;
  white-space: nowrap;
  z-index: var(--z-toolbar);
  pointer-events: none;
}

/* Color input */
.config-color-input {
  display: flex;
  gap: 8px;
  align-items: center;
}

.config-range-input {
  display: flex;
  gap: 8px;
  align-items: center;
}

.config-range-input input[type="range"] {
  flex: 1;
  height: 6px;
  cursor: pointer;
}

.config-range-value {
  min-width: 40px;
  text-align: right;
  font-variant-numeric: tabular-nums;
}

.config-color-input input[type="color"] {
  width: 40px;
  height: 32px;
  padding: 2px;
  border: 1px solid #d1d5db;
  border-radius: 4px;
  cursor: pointer;
}

.config-color-text {
  width: 100px !important;
}

/* Footer */
.config-modal-footer {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 16px 20px;
  border-top: 1px solid #e5e7eb;
  background-color: #f9fafb;
  flex-shrink: 0;
}

.config-footer-right {
  display: flex;
  gap: 8px;
}

.config-btn {
  padding: 8px 16px;
  border-radius: 6px;
  font-size: 13px;
  font-weight: 500;
  cursor: pointer;
  transition: all 150ms ease;
}

.config-btn-primary {
  background-color: #3b82f6;
  color: white;
  border: none;
}

.config-btn-primary:hover {
  background-color: #2563eb;
}

.config-btn-secondary {
  background-color: white;
  color: #374151;
  border: 1px solid #d1d5db;
}

.config-btn-secondary:hover {
  background-color: #f3f4f6;
}

#config-reset {
  color: #dc2626;
  border-color: #fecaca;
}

#config-reset:hover {
  background-color: #fef2f2;
}

/* Mobile responsive */
@media (max-width: 640px) {
  .config-modal-content {
    max-height: 100vh;
    height: 100vh;
    border-radius: 0;
  }

  .config-modal-body {
    flex-direction: column;
  }

  .config-modal-tabs {
    width: 100%;
    flex-direction: row;
    overflow-x: auto;
    padding: 8px;
    gap: 4px;
    border-right: none;
    border-bottom: 1px solid #e5e7eb;
  }

  .config-tab {
    flex-direction: column;
    padding: 8px 12px;
    min-width: fit-content;
  }

  .config-tab-label {
    font-size: 11px;
  }

  .config-field input[type="text"],
  .config-field input[type="number"],
  .config-field input[type="password"],
  .config-field select {
    max-width: 100%;
    width: 100%;
  }
}

/* Dark mode support */
@media (prefers-color-scheme: dark) {
  .config-modal-content {
    background-color: #1f2937;
  }

  .config-modal-header {
    border-bottom-color: #374151;
  }

  .config-modal-header h2 {
    color: #f9fafb;
  }

  .config-modal-close {
    color: #9ca3af;
  }

  .config-modal-close:hover {
    background-color: #374151;
    color: #f9fafb;
  }

  .config-modal-tabs {
    background-color: #111827;
    border-right-color: #374151;
  }

  .config-tab {
    color: #d1d5db;
  }

  .config-tab:hover {
    background-color: #374151;
  }

  .config-tab.active {
    background-color: #1e3a5f;
    color: #60a5fa;
  }

  .config-field-label,
  .config-checkbox-label {
    color: #e5e7eb;
  }

  .config-field-help {
    color: #9ca3af;
  }

  .config-field-reset {
    background: #374151;
    border-color: #4b5563;
    color: #9ca3af;
  }

  .config-field-reset:hover {
    background: #4b5563;
    border-color: #6b7280;
    color: #e5e7eb;
  }

  .config-field-reset:active {
    background: #6b7280;
  }

  .config-field input[type="text"],
  .config-field input[type="number"],
  .config-field input[type="password"],
  .config-field select,
  .config-field textarea {
    background-color: #374151;
    border-color: #4b5563;
    color: #f9fafb;
  }

  .config-modal-footer {
    background-color: #111827;
    border-top-color: #374151;
  }

  .config-btn-secondary {
    background-color: #374151;
    border-color: #4b5563;
    color: #e5e7eb;
  }

  .config-btn-secondary:hover {
    background-color: #4b5563;
  }

  #config-reset {
    color: #f87171;
    border-color: #7f1d1d;
  }

  #config-reset:hover {
    background-color: #450a0a;
  }
}

/* ==================== Rule Builder Styles ==================== */

.rules-panel {
  display: flex;
  flex-direction: column;
  height: 100%;
}

.rules-subtabs {
  display: flex;
  gap: 4px;
  margin-bottom: 12px;
  border-bottom: 1px solid #e5e7eb;
  padding-bottom: 8px;
}

.rules-subtab {
  padding: 6px 16px;
  border: 1px solid #d1d5db;
  border-radius: 6px 6px 0 0;
  background: #f9fafb;
  color: #6b7280;
  font-size: 13px;
  cursor: pointer;
  transition: all 0.15s ease;
}

.rules-subtab:hover {
  background: #f3f4f6;
}

.rules-subtab.active {
  background: #ffffff;
  color: #111827;
  border-bottom-color: #ffffff;
  font-weight: 500;
}

.rules-content {
  flex: 1;
  overflow-y: auto;
}

.rules-visual,
.rules-raw {
  display: none;
}

.rules-visual.active,
.rules-raw.active {
  display: block;
}

.rules-raw textarea {
  width: 100%;
  min-height: 300px;
  padding: 12px;
  border: 1px solid #d1d5db;
  border-radius: 6px;
  font-family: monospace;
  font-size: 13px;
  resize: vertical;
}

.rules-options {
  padding: 12px;
}

.rules-options-top {
  border-bottom: 1px solid #e5e7eb;
  margin-bottom: 12px;
}

.rules-options .config-checkbox-label {
  display: flex;
  flex-wrap: wrap;
  align-items: center;
  gap: 8px;
  cursor: pointer;
}

.rules-options .config-checkbox-label span:first-of-type {
  font-weight: 500;
}

.rules-options .config-field-help {
  flex-basis: 100%;
  font-size: 12px;
  color: #6b7280;
  margin-left: 24px;
}

/* Category accordion */
.rules-category {
  margin-bottom: 4px;
}

.rules-category-header {
  display: flex;
  align-items: center;
  gap: 4px;
  padding: 4px 0;
}

.rules-category-toggle {
  background: none;
  border: none;
  padding: 4px;
  cursor: pointer;
  color: #6b7280;
  font-size: 12px;
}

.rules-toggle-icon {
  display: inline-block;
  transition: transform 0.15s ease;
}

.rules-color-picker {
  position: relative;
}

.rules-color-swatch {
  width: 20px;
  height: 20px;
  border: 2px solid #d1d5db;
  border-radius: 4px;
  cursor: pointer;
  padding: 0;
}

.rules-color-swatch:hover {
  border-color: #9ca3af;
}

.rules-color-dropdown {
  display: none;
  position: absolute;
  top: 100%;
  left: 0;
  z-index: 100;
  background: #ffffff;
  border: 1px solid #d1d5db;
  border-radius: 6px;
  padding: 6px;
  margin-top: 4px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
  width: 180px;
  flex-wrap: wrap;
  gap: 4px;
}

.rules-color-dropdown.open {
  display: flex;
}

.rules-color-option {
  width: 20px;
  height: 20px;
  border: 2px solid transparent;
  border-radius: 3px;
  cursor: pointer;
  padding: 0;
}

.rules-color-option:hover {
  border-color: #6b7280;
  transform: scale(1.1);
}

.rules-color-option.selected {
  border-color: #1f2937;
  box-shadow: 0 0 0 2px #ffffff, 0 0 0 4px #3b82f6;
}

.rules-category-name {
  flex: 1;
  padding: 4px 8px;
  border: 1px solid transparent;
  border-radius: 4px;
  font-size: 14px;
  font-weight: 500;
  background: transparent;
}

.rules-category-name:hover {
  border-color: #d1d5db;
}

.rules-category-name:focus {
  outline: none;
  border-color: #3b82f6;
  background: #ffffff;
}

.rules-backing-list {
  margin-left: 8px;
  padding: 2px 6px;
  font-size: 12px;
  border: 1px solid #d1d5db;
  border-radius: 4px;
  background: #f9fafb;
  color: #374151;
  max-width: 140px;
  cursor: pointer;
}

.rules-backing-list:hover {
  border-color: #9ca3af;
}

.rules-backing-list:focus {
  outline: none;
  border-color: #3b82f6;
}

.rules-backing-list:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.rules-category-delete {
  background: none;
  border: none;
  padding: 4px 8px;
  cursor: pointer;
  color: #9ca3af;
  font-size: 14px;
  border-radius: 4px;
}

.rules-category-delete:hover {
  background: #fee2e2;
  color: #dc2626;
}

.rules-category-organize {
  background: none;
  border: none;
  padding: 4px 8px;
  cursor: pointer;
  color: #9ca3af;
  font-size: 14px;
  border-radius: 4px;
}

.rules-category-organize:hover {
  background: #dbeafe;
  color: #2563eb;
}

/* Rules sync UI */
.rules-sync-btn {
  background: none;
  border: 1px solid var(--border-color, #ccc);
  border-radius: 4px;
  padding: 2px 6px;
  cursor: pointer;
  font-size: 14px;
  margin-left: 8px;
}

.rules-sync-btn:hover:not(:disabled) {
  background: var(--hover-bg, #f0f0f0);
}

.rules-sync-btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.rules-sync-menu {
  background: var(--background-color, white);
  border: 1px solid var(--border-color, #ccc);
  border-radius: 8px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
  z-index: 10001;
  min-width: 180px;
}

.sync-menu-item {
  display: block;
  width: 100%;
  padding: 10px 16px;
  text-align: left;
  background: none;
  border: none;
  cursor: pointer;
  font-size: 14px;
}

.sync-menu-item:hover {
  background: var(--hover-bg, #f0f0f0);
}

.sync-menu-item:first-child {
  border-radius: 8px 8px 0 0;
}

.sync-menu-item:last-child {
  border-radius: 0 0 8px 8px;
}

/* Sync dialog overlay */
.sync-dialog-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.5);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 10002;
}

.sync-dialog {
  background: var(--background-color, white);
  border-radius: 12px;
  width: 400px;
  max-width: 90vw;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
}

.sync-dialog-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 16px 20px;
  border-bottom: 1px solid var(--border-color, #eee);
}

.sync-dialog-header h3 {
  margin: 0;
  font-size: 16px;
}

.sync-dialog-close {
  background: none;
  border: none;
  font-size: 24px;
  cursor: pointer;
  padding: 0;
  line-height: 1;
}

.sync-dialog-body {
  padding: 20px;
}

.sync-option {
  margin-bottom: 16px;
}

.sync-option label {
  display: block;
  margin-bottom: 8px;
}

.sync-option input[type="text"],
.sync-option select {
  width: 100%;
  padding: 8px 12px;
  border: 1px solid var(--border-color, #ccc);
  border-radius: 6px;
  font-size: 14px;
  box-sizing: border-box;
}

.sync-preview {
  padding: 12px;
  background: var(--hover-bg, #f5f5f5);
  border-radius: 6px;
  font-size: 14px;
}

.sync-dialog-footer {
  display: flex;
  justify-content: flex-end;
  gap: 12px;
  padding: 16px 20px;
  border-top: 1px solid var(--border-color, #eee);
}

.sync-cancel,
.sync-confirm {
  padding: 8px 16px;
  border-radius: 6px;
  font-size: 14px;
  cursor: pointer;
}

.sync-cancel {
  background: none;
  border: 1px solid var(--border-color, #ccc);
}

.sync-confirm {
  background: var(--accent-color, #0085ff);
  color: white;
  border: none;
}

.sync-confirm:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}

/* Sync toast notification */
.sync-toast {
  position: fixed;
  bottom: 20px;
  left: 50%;
  transform: translateX(-50%);
  background: #333;
  color: white;
  padding: 12px 24px;
  border-radius: 8px;
  z-index: 10003;
  animation: syncToastIn 0.3s ease;
}

.sync-toast-hiding {
  animation: syncToastOut 0.3s ease forwards;
}

@keyframes syncToastIn {
  from { opacity: 0; transform: translateX(-50%) translateY(20px); }
  to { opacity: 1; transform: translateX(-50%) translateY(0); }
}

@keyframes syncToastOut {
  from { opacity: 1; transform: translateX(-50%) translateY(0); }
  to { opacity: 0; transform: translateX(-50%) translateY(20px); }
}

/* Sync menu divider */
.sync-menu-divider {
  margin: 4px 0;
  border: none;
  border-top: 1px solid var(--border-color, #e5e7eb);
}

/* Deduplication dialog styles */
.dedupe-list {
  max-height: 200px;
  overflow-y: auto;
  margin: 12px 0;
  border: 1px solid var(--border-color, #e5e7eb);
  border-radius: 6px;
}

.dedupe-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 8px 12px;
  border-bottom: 1px solid var(--border-color, #e5e7eb);
}

.dedupe-item:last-child {
  border-bottom: none;
}

.dedupe-handle {
  font-family: monospace;
  font-weight: 500;
  color: var(--link-color, #1d4ed8);
}

.dedupe-info {
  font-size: 12px;
  color: var(--secondary-text, #6b7280);
}

.sync-dialog-hint {
  font-size: 12px;
  color: var(--secondary-text, #6b7280);
  margin-top: 12px;
}

.rules-category-drag-handle {
  cursor: grab;
  color: #9ca3af;
  font-size: 14px;
  padding: 4px 2px;
  user-select: none;
  letter-spacing: -2px;
}

.rules-category-drag-handle:hover {
  color: #6b7280;
}

.rules-category-drag-handle:active {
  cursor: grabbing;
}

.rules-category.dragging {
  opacity: 0.5;
}

.rules-category.drag-over {
  background-color: #dbeafe;
  border-radius: 8px;
}

.rules-category-body {
  padding: 4px 0 4px 24px;
}

.rules-category-body.collapsed {
  display: none;
}

/* Rule rows */
.rules-row {
  display: flex;
  align-items: center;
  gap: 6px;
  margin-bottom: 4px;
  transition: opacity 150ms ease, background-color 150ms ease;
}

.rules-row.dragging {
  opacity: 0.5;
}

.rules-row.drag-over {
  background-color: #dbeafe;
  border-radius: 4px;
}

.rules-row-unsaved {
  background-color: #fef3c7;
  border-radius: 4px;
  padding: 2px 4px;
  margin-left: -4px;
  margin-right: -4px;
  position: relative;
}

.rules-row-unsaved::before {
  content: '\u25CF';
  position: absolute;
  left: -12px;
  top: 50%;
  transform: translateY(-50%);
  color: #f59e0b;
  font-size: 8px;
}

/* Dark mode support for unsaved rules */
@media (prefers-color-scheme: dark) {
  .rules-row-unsaved {
    background-color: rgba(245, 158, 11, 0.15);
  }
}

.rules-drag-handle {
  cursor: grab;
  color: #9ca3af;
  font-size: 14px;
  padding: 4px 2px;
  user-select: none;
  letter-spacing: -2px;
}

.rules-drag-handle:hover {
  color: #6b7280;
}

.rules-drag-handle:active {
  cursor: grabbing;
}

.rules-action,
.rules-type {
  padding: 6px 8px;
  border: 1px solid #d1d5db;
  border-radius: 4px;
  font-size: 13px;
  background: #ffffff;
  cursor: pointer;
}

.rules-action {
  width: 80px;
}

.rules-type {
  width: 130px;
}

.rules-value {
  flex: 1;
  padding: 6px 8px;
  border: 1px solid #d1d5db;
  border-radius: 4px;
  font-size: 13px;
  min-width: 0;
}

.rules-value:disabled {
  background: #f3f4f6;
  color: #9ca3af;
}

.rules-delete-rule {
  background: none;
  border: none;
  padding: 4px 8px;
  cursor: pointer;
  color: #9ca3af;
  font-size: 14px;
  border-radius: 4px;
  flex-shrink: 0;
}

.rules-delete-rule:hover {
  background: #fee2e2;
  color: #dc2626;
}

.rules-save-rule {
  background: none;
  border: none;
  padding: 4px 8px;
  cursor: pointer;
  color: #f59e0b;
  font-size: 14px;
  border-radius: 4px;
  flex-shrink: 0;
}

.rules-save-rule:hover {
  background: #fef3c7;
  color: #d97706;
}

/* Add buttons */
.rules-add-rule,
.rules-add-category {
  padding: 8px 16px;
  border: 1px dashed #d1d5db;
  border-radius: 6px;
  background: transparent;
  color: #6b7280;
  font-size: 13px;
  cursor: pointer;
  transition: all 0.15s ease;
}

.rules-add-rule {
  width: 100%;
  margin-top: 4px;
}

.rules-add-category {
  width: 100%;
  margin-top: 8px;
}

.rules-add-rule:hover,
.rules-add-category:hover {
  border-color: #3b82f6;
  color: #3b82f6;
  background: #eff6ff;
}

/* Empty states */
.rules-empty,
.rules-empty-category {
  padding: 24px;
  text-align: center;
  color: #6b7280;
  font-size: 14px;
}

.rules-empty-category {
  padding: 12px;
  font-size: 13px;
  font-style: italic;
}

/* Dark mode for rule builder */
@media (prefers-color-scheme: dark) {
  .rules-subtabs {
    border-bottom-color: #374151;
  }

  .rules-subtab {
    background: #374151;
    border-color: #4b5563;
    color: #9ca3af;
  }

  .rules-subtab:hover {
    background: #4b5563;
  }

  .rules-subtab.active {
    background: #1f2937;
    color: #f9fafb;
    border-bottom-color: #1f2937;
  }

  .rules-raw textarea {
    background: #374151;
    border-color: #4b5563;
    color: #f9fafb;
  }

  .rules-options-top {
    border-bottom-color: #4b5563;
  }

  .rules-options .config-field-help {
    color: #9ca3af;
  }

  .rules-category-header {
    /* no special dark mode styling needed */
  }

  .rules-category-toggle {
    color: #9ca3af;
  }

  .rules-color-swatch {
    border-color: #4b5563;
  }

  .rules-color-swatch:hover {
    border-color: #6b7280;
  }

  .rules-color-dropdown {
    background: #1f2937;
    border-color: #4b5563;
  }

  .rules-color-option.selected {
    border-color: #f9fafb;
    box-shadow: 0 0 0 2px #1f2937, 0 0 0 4px #3b82f6;
  }

  .rules-category-name {
    color: #f9fafb;
  }

  .rules-category-name:hover {
    border-color: #4b5563;
  }

  .rules-category-name:focus {
    border-color: #3b82f6;
    background: #1f2937;
  }

  .rules-backing-list {
    background: #1f2937;
    border-color: #4b5563;
    color: #f9fafb;
  }

  .rules-backing-list:hover {
    border-color: #6b7280;
  }

  .rules-category-delete:hover {
    background: #450a0a;
  }

  .rules-category-body {
    /* no special dark mode styling needed */
  }

  .rules-action,
  .rules-type,
  .rules-value {
    background: #1f2937;
    border-color: #4b5563;
    color: #f9fafb;
  }

  .rules-value:disabled {
    background: #374151;
    color: #6b7280;
  }

  .rules-delete-rule:hover {
    background: #450a0a;
  }

  .rules-save-rule:hover {
    background: #451a03;
  }

  .rules-row.drag-over {
    background-color: #1e3a5f;
  }

  .rules-drag-handle {
    color: #6b7280;
  }

  .rules-drag-handle:hover {
    color: #9ca3af;
  }

  .rules-category-organize {
    color: #6b7280;
  }

  .rules-category-organize:hover {
    background: #1e3a5f;
    color: #60a5fa;
  }

  .rules-category-drag-handle {
    color: #6b7280;
  }

  .rules-category-drag-handle:hover {
    color: #9ca3af;
  }

  .rules-category.drag-over {
    background-color: #1e3a5f;
  }

  .rules-add-rule,
  .rules-add-category {
    border-color: #4b5563;
    color: #9ca3af;
  }

  .rules-add-rule:hover,
  .rules-add-category:hover {
    border-color: #3b82f6;
    color: #60a5fa;
    background: rgba(59, 130, 246, 0.1);
  }

  .rules-empty,
  .rules-empty-category {
    color: #9ca3af;
  }
}

/* Hide right sidebar - target the fixed-position feeds panel */
.bsky-nav-hide-right-sidebar div[style*="position: fixed"][style*="width: 330px"],
.bsky-nav-hide-right-sidebar div[style*="position: fixed"][style*="translateX(300px)"] {
  display: none !important;
}

/* Hide vertical column dividers when right sidebar is hidden */
.bsky-nav-hide-right-sidebar [data-testid="homeScreen"] div[style*="border-left"],
.bsky-nav-hide-right-sidebar [data-testid="homeScreen"] div[style*="border-right"],
.bsky-nav-hide-right-sidebar main div[style*="border-left"],
.bsky-nav-hide-right-sidebar main div[style*="border-right"] {
  border-left: none !important;
  border-right: none !important;
}

/* Broader approach - target column containers */
.bsky-nav-hide-right-sidebar [data-testid="homeScreen"] > div > div {
  border-left: none !important;
  border-right: none !important;
}

.bsky-nav-hide-right-sidebar [data-testid="homeScreen"] > div > div > div {
  border-left: none !important;
  border-right: none !important;
}

/* =============================================================================
   Add to Rules Button (Profile Hover Card)
   ============================================================================= */

.bsky-nav-add-to-rules-btn {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 32px;
  height: 32px;
  margin-left: 8px;
  padding: 0;
  border: none;
  border-radius: 50%;
  background-color: #eff2f6;
  color: #405168;
  cursor: pointer;
  transition: background-color 150ms ease, transform 150ms ease;
}

.bsky-nav-add-to-rules-btn:hover {
  background-color: #dce2eb;
  transform: scale(1.05);
}

.bsky-nav-add-to-rules-btn:active {
  transform: scale(0.95);
}

.bsky-nav-add-to-rules-btn svg {
  pointer-events: none;
}

/* Add to Rules Button (Profile Page) - inline with profile buttons */
.bsky-nav-profile-rules-btn {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 33px;
  height: 33px;
  padding: 0;
  border: none;
  border-radius: 999px;
  background-color: rgb(239, 242, 246);
  color: rgb(64, 81, 104);
  cursor: pointer;
  transition: background-color 150ms ease;
}

.bsky-nav-profile-rules-btn:hover {
  background-color: rgb(220, 226, 235);
}

.bsky-nav-profile-rules-btn:active {
  transform: scale(0.95);
}

.bsky-nav-profile-rules-btn svg {
  pointer-events: none;
}

/* Rules Dropdown */
.bsky-nav-rules-dropdown {
  background: white;
  border: 1px solid #dce2ea;
  border-radius: 12px;
  min-width: 320px;
  overflow: hidden;
  font-family: InterVariable, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
}

.bsky-nav-rules-dropdown-header {
  padding: 12px 14px 8px;
  font-size: 15px;
  font-weight: 600;
  color: #1f2937;
  border-bottom: 1px solid #e5e7eb;
  word-break: break-all;
}

.bsky-nav-rules-dropdown-actions {
  display: flex;
  gap: 8px;
  padding: 10px 14px;
  border-bottom: 1px solid #e5e7eb;
}

.bsky-nav-rules-action-btn {
  flex: 1;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 6px;
  padding: 8px 14px;
  border: 1px solid #d1d5db;
  border-radius: 6px;
  background: white;
  font-size: 14px;
  font-weight: 500;
  color: #4b5563;
  cursor: pointer;
  transition: all 150ms ease;
}

.bsky-nav-rules-action-btn:hover {
  background: #f3f4f6;
}

.bsky-nav-rules-action-btn.selected {
  border-color: #3b82f6;
  background: #eff6ff;
  color: #1d4ed8;
}

.bsky-nav-rules-allow.selected {
  border-color: #22c55e;
  background: #f0fdf4;
  color: #16a34a;
}

.bsky-nav-rules-deny.selected {
  border-color: #ef4444;
  background: #fef2f2;
  color: #dc2626;
}

.bsky-nav-rules-dropdown-categories {
  max-height: 200px;
  overflow-y: auto;
  padding: 8px;
}

.bsky-nav-rules-category-btn {
  display: block;
  width: 100%;
  padding: 10px 14px;
  margin-bottom: 4px;
  border: none;
  border-radius: 6px;
  background: transparent;
  font-size: 15px;
  font-weight: 600;
  text-align: left;
  color: #374151;
  cursor: pointer;
  transition: background-color 150ms ease;
}

.bsky-nav-rules-category-btn:last-child {
  margin-bottom: 0;
}

.bsky-nav-rules-category-btn:hover {
  background: #f3f4f6;
}

.bsky-nav-rules-category-btn.selected {
  background: #dbeafe;
  font-weight: 700;
}

.bsky-nav-rules-no-categories,
.bsky-nav-rules-no-lists {
  padding: 16px 12px;
  font-size: 12px;
  color: #6b7280;
  text-align: center;
  line-height: 1.5;
}

.bsky-nav-rules-dropdown-tabs {
  display: flex;
  border-bottom: 1px solid #e5e7eb;
}

.bsky-nav-rules-tab {
  flex: 1;
  padding: 10px 14px;
  border: none;
  background: transparent;
  font-size: 14px;
  font-weight: 500;
  color: #6b7280;
  cursor: pointer;
  transition: all 150ms ease;
}

.bsky-nav-rules-tab:hover {
  background: #f3f4f6;
}

.bsky-nav-rules-tab.active {
  color: #1d4ed8;
  border-bottom: 2px solid #3b82f6;
  margin-bottom: -1px;
}

.bsky-nav-rules-tab-content {
  display: none;
}

.bsky-nav-rules-tab-content.active {
  display: block;
}

.bsky-nav-rules-dropdown-lists {
  max-height: 200px;
  overflow-y: auto;
  padding: 8px;
}

.bsky-nav-rules-list-btn {
  display: block;
  width: 100%;
  padding: 10px 14px;
  margin-bottom: 4px;
  border: none;
  border-radius: 6px;
  background: transparent;
  font-size: 14px;
  font-weight: 500;
  text-align: left;
  color: #374151;
  cursor: pointer;
  transition: background-color 150ms ease;
}

.bsky-nav-rules-list-btn:last-child {
  margin-bottom: 0;
}

.bsky-nav-rules-list-btn:hover {
  background: #f3f4f6;
}

.bsky-nav-rules-list-btn:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}

.bsky-nav-rules-lists-loading {
  padding: 16px 12px;
  font-size: 12px;
  color: #6b7280;
  text-align: center;
}

.bsky-nav-rules-list-option {
  padding: 8px 14px;
  border-top: 1px solid #e5e7eb;
  background: #f0fdf4;
  font-size: 13px;
}

.bsky-nav-rules-list-option label {
  display: flex;
  align-items: center;
  gap: 8px;
  cursor: pointer;
}

.bsky-nav-rules-list-option input[type="checkbox"] {
  width: 16px;
  height: 16px;
  cursor: pointer;
}

.bsky-nav-rules-list-name {
  font-weight: 500;
}

.bsky-nav-rules-location {
  font-size: 11px;
  opacity: 0.7;
  font-weight: normal;
  margin-left: 4px;
}

.bsky-nav-rules-remove-btn {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.bsky-nav-rules-dropdown-footer {
  display: flex;
  gap: 8px;
  padding: 10px 14px;
  border-top: 1px solid #e5e7eb;
  background: #f9fafb;
}

.bsky-nav-rules-quick-filter {
  flex: 1;
  padding: 6px 10px;
  border: 1px solid #d1d5db;
  border-radius: 6px;
  font-size: 13px;
  outline: none;
  background: white;
  color: #374151;
}

.bsky-nav-rules-quick-filter:focus {
  border-color: #3b82f6;
  box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
}

.bsky-nav-rules-quick-filter::placeholder {
  color: #9ca3af;
  font-size: 12px;
}

.bsky-nav-rules-create-btn {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 28px;
  height: 28px;
  padding: 0;
  border: none;
  border-radius: 6px;
  background: #3b82f6;
  color: white;
  font-size: 18px;
  font-weight: 600;
  cursor: pointer;
  transition: background-color 150ms ease;
}

.bsky-nav-rules-create-btn:hover {
  background: #2563eb;
}

.bsky-nav-rules-cancel-btn {
  flex-shrink: 0;
  padding: 6px 12px;
  border: 1px solid #d1d5db;
  border-radius: 6px;
  background: #f3f4f6;
  color: #374151;
  font-size: 13px;
  font-weight: 500;
  cursor: pointer;
  transition: background-color 150ms ease, border-color 150ms ease;
}

.bsky-nav-rules-cancel-btn:hover {
  background: #e5e7eb;
  border-color: #9ca3af;
}

/* Rule Added Notification */
.bsky-nav-rule-notification {
  position: fixed;
  bottom: 20px;
  left: 50%;
  transform: translateX(-50%) translateY(20px);
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 12px 20px;
  background: #1f2937;
  color: white;
  border-radius: 8px;
  font-size: 14px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
  opacity: 0;
  transition: opacity 300ms ease, transform 300ms ease;
  z-index: 10001;
}

.bsky-nav-rule-notification.visible {
  opacity: 1;
  transform: translateX(-50%) translateY(0);
}

.bsky-nav-rule-notification-icon {
  font-size: 18px;
}

/* =============================================================================
   List-Backed Category Choice Popup
   ============================================================================= */

.bsky-nav-list-choice-popup {
  background: white;
  border-radius: 8px;
  box-shadow: 0 4px 16px rgba(0, 0, 0, 0.15), 0 0 0 1px rgba(0, 0, 0, 0.05);
  padding: 12px;
  min-width: 220px;
  font-family: InterVariable, system-ui, -apple-system, sans-serif;
}

.bsky-nav-list-choice-header {
  font-size: 13px;
  font-weight: 600;
  color: #1f2937;
  margin-bottom: 4px;
}

.bsky-nav-list-choice-info {
  font-size: 11px;
  color: #6b7280;
  margin-bottom: 12px;
}

.bsky-nav-list-choice-buttons {
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.bsky-nav-list-choice-btn {
  padding: 8px 12px;
  border-radius: 6px;
  font-size: 13px;
  font-weight: 500;
  cursor: pointer;
  border: none;
  transition: background 0.15s, transform 0.1s;
}

.bsky-nav-list-choice-btn:active {
  transform: scale(0.98);
}

.bsky-nav-list-choice-btn.primary {
  background: #3b82f6;
  color: white;
}

.bsky-nav-list-choice-btn.primary:hover {
  background: #2563eb;
}

.bsky-nav-list-choice-btn.secondary {
  background: #f3f4f6;
  color: #374151;
}

.bsky-nav-list-choice-btn.secondary:hover {
  background: #e5e7eb;
}

@media (prefers-color-scheme: dark) {
  .bsky-nav-list-choice-popup {
    background: #1f2937;
    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.4), 0 0 0 1px rgba(255, 255, 255, 0.1);
  }

  .bsky-nav-list-choice-header {
    color: #f9fafb;
  }

  .bsky-nav-list-choice-info {
    color: #9ca3af;
  }

  .bsky-nav-list-choice-btn.primary {
    background: #3b82f6;
  }

  .bsky-nav-list-choice-btn.primary:hover {
    background: #2563eb;
  }

  .bsky-nav-list-choice-btn.secondary {
    background: #374151;
    color: #f9fafb;
  }

  .bsky-nav-list-choice-btn.secondary:hover {
    background: #4b5563;
  }
}

/* =============================================================================
   Timeout Popup
   ============================================================================= */

.bsky-nav-timeout-popup {
  background: white;
  border-radius: 8px;
  box-shadow: 0 4px 16px rgba(0, 0, 0, 0.15), 0 0 0 1px rgba(0, 0, 0, 0.05);
  padding: 16px;
  min-width: 240px;
  font-family: InterVariable, system-ui, -apple-system, sans-serif;
}

.bsky-nav-timeout-header {
  font-size: 14px;
  font-weight: 600;
  color: #1f2937;
  margin-bottom: 12px;
}

.bsky-nav-timeout-body {
  margin-bottom: 16px;
}

.bsky-nav-timeout-label {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 13px;
  color: #4b5563;
}

.bsky-nav-timeout-select {
  flex: 1;
  padding: 6px 10px;
  border-radius: 6px;
  border: 1px solid #d1d5db;
  background: white;
  font-size: 13px;
  color: #1f2937;
  cursor: pointer;
}

.bsky-nav-timeout-select:focus {
  outline: none;
  border-color: #3b82f6;
  box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
}

.bsky-nav-timeout-info {
  font-size: 13px;
  color: #6b7280;
  text-align: center;
}

.bsky-nav-timeout-buttons {
  display: flex;
  gap: 8px;
  justify-content: flex-end;
}

.bsky-nav-timeout-btn {
  padding: 8px 16px;
  border-radius: 6px;
  font-size: 13px;
  font-weight: 500;
  cursor: pointer;
  border: none;
  transition: background 0.15s, transform 0.1s;
}

.bsky-nav-timeout-btn:active {
  transform: scale(0.98);
}

.bsky-nav-timeout-btn.cancel {
  background: #f3f4f6;
  color: #4b5563;
}

.bsky-nav-timeout-btn.cancel:hover {
  background: #e5e7eb;
}

.bsky-nav-timeout-btn.confirm {
  background: #ef4444;
  color: white;
}

.bsky-nav-timeout-btn.confirm:hover {
  background: #dc2626;
}

/* Dark mode styles */
@media (prefers-color-scheme: dark) {
  .bsky-nav-timeout-popup {
    background: #1f2937;
    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.4), 0 0 0 1px rgba(255, 255, 255, 0.1);
  }

  .bsky-nav-timeout-header {
    color: #f9fafb;
  }

  .bsky-nav-timeout-label {
    color: #d1d5db;
  }

  .bsky-nav-timeout-select {
    background: #374151;
    border-color: #4b5563;
    color: #f9fafb;
  }

  .bsky-nav-timeout-select:focus {
    border-color: #3b82f6;
  }

  .bsky-nav-timeout-info {
    color: #9ca3af;
  }

  .bsky-nav-timeout-btn.cancel {
    background: #374151;
    color: #f9fafb;
  }

  .bsky-nav-timeout-btn.cancel:hover {
    background: #4b5563;
  }

  .bsky-nav-timeout-btn.confirm {
    background: #dc2626;
  }

  .bsky-nav-timeout-btn.confirm:hover {
    background: #b91c1c;
  }
}

/* =============================================================================
   Timeouts Panel (Config Modal)
   ============================================================================= */

.timeouts-panel {
  padding: 0;
}

.timeouts-active-section {
  margin-top: 24px;
  padding-top: 16px;
  border-top: 1px solid #e5e7eb;
}

.timeouts-section-title {
  font-size: 14px;
  font-weight: 600;
  color: #374151;
  margin: 0 0 12px 0;
}

.timeouts-empty {
  color: #6b7280;
  font-size: 13px;
  padding: 16px;
  text-align: center;
  background: #f9fafb;
  border-radius: 8px;
}

.timeouts-empty kbd {
  display: inline-block;
  padding: 2px 6px;
  font-family: monospace;
  font-size: 12px;
  background: #e5e7eb;
  border-radius: 4px;
  border: 1px solid #d1d5db;
}

.timeouts-list {
  display: flex;
  flex-direction: column;
  gap: 8px;
  margin-bottom: 12px;
}

.timeout-item {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 10px 12px;
  background: #f9fafb;
  border-radius: 8px;
  border: 1px solid #e5e7eb;
}

.timeout-handle {
  font-weight: 500;
  color: #1f2937;
  flex: 1;
}

.timeout-expires {
  font-size: 12px;
  color: #6b7280;
}

.timeout-clear-btn {
  width: 24px;
  height: 24px;
  padding: 0;
  border: none;
  background: transparent;
  color: #9ca3af;
  cursor: pointer;
  border-radius: 4px;
  font-size: 14px;
  transition: background 0.15s, color 0.15s;
}

.timeout-clear-btn:hover {
  background: #fee2e2;
  color: #dc2626;
}

.timeout-clear-all-btn {
  padding: 8px 16px;
  border-radius: 6px;
  font-size: 13px;
  font-weight: 500;
  cursor: pointer;
  border: 1px solid #d1d5db;
  background: white;
  color: #374151;
  transition: background 0.15s;
}

.timeout-clear-all-btn:hover {
  background: #f3f4f6;
}

/* Dark mode styles for timeouts panel */
@media (prefers-color-scheme: dark) {
  .timeouts-active-section {
    border-top-color: #374151;
  }

  .timeouts-section-title {
    color: #f3f4f6;
  }

  .timeouts-empty {
    background: #1f2937;
    color: #9ca3af;
  }

  .timeouts-empty kbd {
    background: #374151;
    border-color: #4b5563;
    color: #f3f4f6;
  }

  .timeout-item {
    background: #1f2937;
    border-color: #374151;
  }

  .timeout-handle {
    color: #f3f4f6;
  }

  .timeout-expires {
    color: #9ca3af;
  }

  .timeout-clear-btn {
    color: #6b7280;
  }

  .timeout-clear-btn:hover {
    background: #7f1d1d;
    color: #fecaca;
  }

  .timeout-clear-all-btn {
    background: #374151;
    border-color: #4b5563;
    color: #f3f4f6;
  }

  .timeout-clear-all-btn:hover {
    background: #4b5563;
  }
}

/* =============================================================================
   Custom Profile Hover Card (for sidecar replies)
   ============================================================================= */

.bsky-nav-profile-card {
  position: fixed;
  z-index: 10000;
  width: 300px;
  background: white;
  border-radius: 12px;
  box-shadow: 0 4px 24px rgba(0, 0, 0, 0.15), 0 0 0 1px rgba(0, 0, 0, 0.05);
  font-family: InterVariable, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
  overflow: hidden;
  animation: bsky-nav-profile-card-fade-in 150ms ease;
}

@keyframes bsky-nav-profile-card-fade-in {
  from {
    opacity: 0;
    transform: translateY(-4px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.bsky-nav-profile-card-banner {
  height: 80px;
  background: linear-gradient(135deg, #0085ff 0%, #00c2ff 100%);
  background-size: cover;
  background-position: center;
}

.bsky-nav-profile-card-content {
  padding: 0 16px 16px;
  margin-top: -32px;
}

.bsky-nav-profile-card-avatar {
  width: 64px;
  height: 64px;
  border-radius: 50%;
  border: 3px solid white;
  background: #e4e9ef;
  object-fit: cover;
}

.bsky-nav-profile-card-names {
  margin-top: 8px;
}

.bsky-nav-profile-card-displayname {
  font-size: 17px;
  font-weight: 600;
  color: #1f2937;
  line-height: 1.3;
  word-break: break-word;
}

.bsky-nav-profile-card-handle {
  font-size: 14px;
  color: #6b7280;
  margin-top: 2px;
}

.bsky-nav-profile-card-handle a {
  color: inherit;
  text-decoration: none;
}

.bsky-nav-profile-card-handle a:hover {
  text-decoration: underline;
}

.bsky-nav-profile-card-bio {
  font-size: 14px;
  color: #374151;
  line-height: 1.4;
  margin-top: 10px;
  max-height: 60px;
  overflow: hidden;
  display: -webkit-box;
  -webkit-line-clamp: 3;
  -webkit-box-orient: vertical;
}

.bsky-nav-profile-card-stats {
  display: flex;
  gap: 16px;
  margin-top: 12px;
  font-size: 14px;
}

.bsky-nav-profile-card-stat {
  display: flex;
  gap: 4px;
}

.bsky-nav-profile-card-stat-value {
  font-weight: 600;
  color: #1f2937;
}

.bsky-nav-profile-card-stat-label {
  color: #6b7280;
}

.bsky-nav-profile-card-actions {
  display: flex;
  gap: 8px;
  margin-top: 12px;
}

.bsky-nav-profile-card-btn {
  flex: 1;
  padding: 8px 12px;
  border: none;
  border-radius: 8px;
  font-size: 13px;
  font-weight: 600;
  cursor: pointer;
  transition: background-color 150ms ease;
}

.bsky-nav-profile-card-btn-primary {
  background: #0085ff;
  color: white;
}

.bsky-nav-profile-card-btn-primary:hover {
  background: #0070db;
}

.bsky-nav-profile-card-btn-secondary {
  background: #eff2f6;
  color: #374151;
}

.bsky-nav-profile-card-btn-secondary:hover {
  background: #dce2eb;
}

.bsky-nav-profile-card-loading {
  padding: 40px 16px;
  text-align: center;
  color: #6b7280;
}

.bsky-nav-profile-card-error {
  padding: 20px 16px;
  text-align: center;
  color: #ef4444;
}

/* Dark mode for profile card */
@media (prefers-color-scheme: dark) {
  .bsky-nav-profile-card {
    background: #1f2937;
    box-shadow: 0 4px 24px rgba(0, 0, 0, 0.4), 0 0 0 1px rgba(255, 255, 255, 0.1);
  }

  .bsky-nav-profile-card-avatar {
    border-color: #1f2937;
    background: #374151;
  }

  .bsky-nav-profile-card-displayname {
    color: #f3f4f6;
  }

  .bsky-nav-profile-card-handle {
    color: #9ca3af;
  }

  .bsky-nav-profile-card-bio {
    color: #d1d5db;
  }

  .bsky-nav-profile-card-stat-value {
    color: #f3f4f6;
  }

  .bsky-nav-profile-card-stat-label {
    color: #9ca3af;
  }

  .bsky-nav-profile-card-btn-secondary {
    background: #374151;
    color: #d1d5db;
  }

  .bsky-nav-profile-card-btn-secondary:hover {
    background: #4b5563;
  }

  .bsky-nav-profile-card-loading {
    color: #9ca3af;
  }
}

/* Dark mode for rules dropdown */
@media (prefers-color-scheme: dark) {
  .bsky-nav-add-to-rules-btn {
    background-color: #374151;
    color: #d1d5db;
  }

  .bsky-nav-add-to-rules-btn:hover {
    background-color: #4b5563;
  }

  .bsky-nav-rules-dropdown {
    background: #1f2937;
    border-color: #374151;
  }

  .bsky-nav-rules-dropdown-header {
    color: #f3f4f6;
    border-bottom-color: #374151;
  }

  .bsky-nav-rules-dropdown-actions {
    border-bottom-color: #374151;
  }

  .bsky-nav-rules-action-btn {
    background: #374151;
    border-color: #4b5563;
    color: #d1d5db;
  }

  .bsky-nav-rules-action-btn:hover {
    background: #4b5563;
  }

  .bsky-nav-rules-action-btn.selected {
    background: rgba(59, 130, 246, 0.2);
    border-color: #3b82f6;
    color: #60a5fa;
  }

  .bsky-nav-rules-allow.selected {
    background: rgba(34, 197, 94, 0.2);
    border-color: #22c55e;
    color: #4ade80;
  }

  .bsky-nav-rules-deny.selected {
    background: rgba(239, 68, 68, 0.2);
    border-color: #ef4444;
    color: #f87171;
  }

  .bsky-nav-rules-category-btn {
    text-shadow:
      -1px -1px 0 rgba(0, 0, 0, 0.7),
      1px -1px 0 rgba(0, 0, 0, 0.7),
      -1px 1px 0 rgba(0, 0, 0, 0.7),
      1px 1px 0 rgba(0, 0, 0, 0.7),
      0 0 3px rgba(0, 0, 0, 0.8);
  }

  .bsky-nav-rules-category-btn:hover {
    background: #374151;
  }

  .bsky-nav-rules-category-btn.selected {
    background: #1e3a5f;
  }

  .bsky-nav-rules-no-categories,
  .bsky-nav-rules-no-lists,
  .bsky-nav-rules-lists-loading {
    color: #9ca3af;
  }

  .bsky-nav-rules-dropdown-tabs {
    border-bottom-color: #374151;
  }

  .bsky-nav-rules-tab {
    color: #9ca3af;
  }

  .bsky-nav-rules-tab:hover {
    background: #374151;
  }

  .bsky-nav-rules-tab.active {
    color: #60a5fa;
    border-bottom-color: #3b82f6;
  }

  .bsky-nav-rules-list-btn {
    color: #d1d5db;
  }

  .bsky-nav-rules-list-btn:hover {
    background: #374151;
  }

  .bsky-nav-rules-list-option {
    background: #064e3b;
    border-top-color: #374151;
    color: #d1fae5;
  }

  .bsky-nav-rules-dropdown-footer {
    background: #111827;
    border-top-color: #374151;
  }

  .bsky-nav-rules-quick-filter {
    background: #374151;
    border-color: #4b5563;
    color: #f3f4f6;
  }

  .bsky-nav-rules-quick-filter:focus {
    border-color: #3b82f6;
  }

  .bsky-nav-rules-quick-filter::placeholder {
    color: #9ca3af;
  }

  .bsky-nav-rules-cancel-btn {
    background: #374151;
    border-color: #4b5563;
    color: #d1d5db;
  }

  .bsky-nav-rules-cancel-btn:hover {
    background: #4b5563;
    border-color: #6b7280;
  }

  .bsky-nav-rule-notification {
    background: #374151;
  }
}

/* Toast Notifications */
.bsky-nav-toast-container {
  position: fixed;
  z-index: 999999;
  display: flex;
  flex-direction: column;
  gap: 10px;
  pointer-events: none;
  max-width: 380px;
}

.bsky-nav-toast-container.top-right {
  top: 70px;
  right: 10px;
}

.bsky-nav-toast-container.top-left {
  top: 70px;
  left: 10px;
}

.bsky-nav-toast-container.bottom-right {
  bottom: 100px;
  right: 10px;
}

.bsky-nav-toast-container.bottom-left {
  bottom: 100px;
  left: 10px;
}

.bsky-nav-toast {
  display: flex;
  align-items: flex-start;
  gap: 12px;
  padding: 12px 16px;
  background: #ffffff;
  border-radius: 12px;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15), 0 0 0 1px rgba(0, 0, 0, 0.05);
  opacity: 0;
  transform: translateX(100%);
  transition: opacity 300ms ease, transform 300ms ease;
  pointer-events: auto;
  cursor: pointer;
  max-width: 100%;
}

.bsky-nav-toast-container.top-left .bsky-nav-toast {
  transform: translateX(-100%);
}

.bsky-nav-toast-container.bottom-right .bsky-nav-toast,
.bsky-nav-toast-container.bottom-left .bsky-nav-toast {
  transform: translateY(100%);
}

.bsky-nav-toast.visible {
  opacity: 1;
  transform: translate(0, 0);
}

.bsky-nav-toast:hover {
  background: #f9fafb;
}

.bsky-nav-toast-icon {
  flex-shrink: 0;
  width: 28px;
  height: 28px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 50%;
}

.bsky-nav-toast-icon.like {
  background: rgba(236, 72, 153, 0.15);
  color: #ec4899;
}

.bsky-nav-toast-icon.repost {
  background: rgba(34, 197, 94, 0.15);
  color: #22c55e;
}

.bsky-nav-toast-icon.reply {
  background: rgba(59, 130, 246, 0.15);
  color: #3b82f6;
}

.bsky-nav-toast-icon.follow {
  background: rgba(139, 92, 246, 0.15);
  color: #8b5cf6;
}

.bsky-nav-toast-icon.mention {
  background: rgba(245, 158, 11, 0.15);
  color: #f59e0b;
}

.bsky-nav-toast-icon.quote {
  background: rgba(20, 184, 166, 0.15);
  color: #14b8a6;
}

.bsky-nav-toast-content {
  flex: 1;
  min-width: 0;
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.bsky-nav-toast-header {
  display: flex;
  align-items: center;
  gap: 8px;
}

.bsky-nav-toast-avatar {
  width: 24px;
  height: 24px;
  border-radius: 50%;
  flex-shrink: 0;
  background: #e5e7eb;
  object-fit: cover;
}

.bsky-nav-toast-author {
  font-weight: 600;
  font-size: 14px;
  color: #111827;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.bsky-nav-toast-handle {
  font-size: 13px;
  color: #6b7280;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.bsky-nav-toast-action {
  font-size: 14px;
  color: #6b7280;
}

.bsky-nav-toast-preview {
  font-size: 13px;
  color: #6b7280;
  line-height: 1.4;
  display: -webkit-box;
  -webkit-line-clamp: 2;
  -webkit-box-orient: vertical;
  overflow: hidden;
}

.bsky-nav-toast-time {
  font-size: 12px;
  color: #9ca3af;
}

.bsky-nav-toast-close {
  flex-shrink: 0;
  width: 20px;
  height: 20px;
  border: none;
  background: transparent;
  color: #9ca3af;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 4px;
  font-size: 16px;
  line-height: 1;
  padding: 0;
  margin: -4px -4px -4px 0;
}

.bsky-nav-toast-close:hover {
  background: #f3f4f6;
  color: #6b7280;
}

/* Dark mode for toasts */
@media (prefers-color-scheme: dark) {
  .bsky-nav-toast {
    background: #1f2937;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4), 0 0 0 1px rgba(255, 255, 255, 0.1);
  }

  .bsky-nav-toast:hover {
    background: #374151;
  }

  .bsky-nav-toast-author {
    color: #f9fafb;
  }

  .bsky-nav-toast-handle {
    color: #9ca3af;
  }

  .bsky-nav-toast-action {
    color: #9ca3af;
  }

  .bsky-nav-toast-preview {
    color: #9ca3af;
  }

  .bsky-nav-toast-time {
    color: #6b7280;
  }

  .bsky-nav-toast-close {
    color: #6b7280;
  }

  .bsky-nav-toast-close:hover {
    background: #4b5563;
    color: #9ca3af;
  }
}

/* ==========================================================================
   Action Feedback Indicator
   Brief visual feedback when post actions are triggered off-screen
   ========================================================================== */

.bsky-nav-action-feedback {
  position: fixed;
  bottom: 60px;
  left: 50%;
  transform: translateX(-50%) scale(0.8);
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 12px;
  background: rgba(255, 255, 255, 0.95);
  border-radius: 50%;
  z-index: 10000;
  opacity: 0;
  transition: opacity 0.15s ease, transform 0.15s ease;
  pointer-events: none;
  box-shadow: 0 2px 12px rgba(0, 0, 0, 0.2);
}

.bsky-nav-action-feedback.visible {
  opacity: 1;
  transform: translateX(-50%) scale(1);
}

.bsky-nav-action-feedback svg {
  display: block;
}

/* Dark mode */
@media (prefers-color-scheme: dark) {
  .bsky-nav-action-feedback {
    background: rgba(30, 30, 30, 0.95);
  }
}

/* Menu feedback - shows menu options at bottom of screen */
.bsky-nav-menu-feedback {
  position: fixed;
  bottom: 60px;
  left: 50%;
  transform: translateX(-50%) translateY(20px);
  z-index: 10000;
  opacity: 0;
  transition: opacity 0.15s ease, transform 0.15s ease;
  pointer-events: auto;
}

.bsky-nav-menu-feedback.visible {
  opacity: 1;
  transform: translateX(-50%) translateY(0);
}

.bsky-nav-menu-feedback-menu {
  background: #fff;
  border-radius: 8px;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
  overflow: hidden;
  min-width: 200px;
}

.bsky-nav-menu-feedback-menu [role="menuitem"] {
  cursor: pointer;
  padding: 12px 16px;
}

.bsky-nav-menu-feedback-menu [role="menuitem"]:hover,
.bsky-nav-menu-feedback-menu .bsky-nav-menu-item-selected {
  background: rgba(0, 0, 0, 0.08);
}

@media (prefers-color-scheme: dark) {
  .bsky-nav-menu-feedback-menu {
    background: #1a1a1a;
  }
  .bsky-nav-menu-feedback-menu [role="menuitem"]:hover,
  .bsky-nav-menu-feedback-menu .bsky-nav-menu-item-selected {
    background: rgba(255, 255, 255, 0.12);
  }
}

/* ==========================================================================
   Global UIManager Toolbar and Status Bar
   These styles apply to the persistent toolbar/status bar shown on all pages
   ========================================================================== */

/* Global toolbar - positioned within main content area */
.bsky-navigator-global-toolbar {
  display: flex;
  flex-direction: column;
  position: sticky;
  top: 0;
  width: 100%;
  background-color: #ffffff;
  border-bottom: 1px solid rgb(192, 192, 192);
  z-index: var(--z-toolbar);
  overflow: visible;
}

/* Global status bar - fixed at bottom of viewport */
.bsky-navigator-global-statusbar {
  display: flex;
  flex-wrap: wrap;
  width: 100%;
  min-height: 32px;
  position: fixed;
  left: 0;
  right: 0;
  z-index: var(--z-raised);
  align-items: center;
  background-color: #ffffff;
  bottom: 0;
  font-size: 1em;
  padding: 1px;
  border-top: 1px solid rgb(192, 192, 192);
  overflow: clip;
}

/* Mobile status bar positioning - above mobile nav */
@media only screen and (max-width: 800px) {
  .bsky-navigator-global-statusbar {
    bottom: 58px;
  }
}

/* Dark mode support for global UI elements */
@media (prefers-color-scheme: dark) {
  .bsky-navigator-global-toolbar {
    background-color: #29333d;
  }

  .bsky-navigator-global-statusbar {
    background-color: #29333d;
  }
}

/* Global status bar section styling (mirrors #statusBarLeft/Center/Right) */
.global-statusbar-left {
  display: flex;
  flex: 1;
  text-align: left;
  padding: 1px;
}

.global-statusbar-center {
  display: flex;
  flex: 1 1 auto;
  text-align: center;
  justify-content: center;
  padding: 1px;
}

.global-statusbar-right {
  display: flex;
  flex: 1;
  text-align: right;
  justify-content: flex-end;
  padding: 1px;
}

/* Global info indicator styling */
.global-info-indicator {
  display: flex;
  justify-content: center;
}

.global-info-indicator-text {
  font-size: 0.9em;
  color: #374151;
}

@media (prefers-color-scheme: dark) {
  .global-info-indicator-text {
    color: #9ca3af;
  }
}
`;
  const sidecarTemplatesHtml = '<script id="sidecar-replies-template" type="text/x-handlebars-template">\n  {{#if this.postId}}\n  <div id="sidecar-replies-{{postId}}" class="sidecar-replies">\n  {{#if parent}}\n  <div class="sidecar-section sidecar-parent-section">\n    <button class="sidecar-section-toggle" aria-expanded="true" aria-controls="sidecar-parent-content-{{postId}}">\n      <span class="sidecar-section-icon">\u25BC</span>\n      <span class="sidecar-section-title">Parent</span>\n    </button>\n    <div id="sidecar-parent-content-{{postId}}" class="sidecar-section-content">\n      <div class="sidecar-parent">\n        <div class="sidecar-parent-indicator">\u2199\uFE0F</div>\n        {{> postTemplate parent}}\n      </div>\n    </div>\n  </div>\n  {{/if}}\n  {{#if replies.length}}\n  <div class="sidecar-section sidecar-replies-section">\n    <button class="sidecar-section-toggle" aria-expanded="true" aria-controls="sidecar-replies-content-{{postId}}">\n      <span class="sidecar-section-icon">\u25BC</span>\n      <span class="sidecar-section-title">Replies ({{replies.length}})</span>\n    </button>\n    <div id="sidecar-replies-content-{{postId}}" class="sidecar-section-content">\n      {{#each replies}}\n      {{> postTemplate this}}\n      {{/each}}\n    </div>\n  </div>\n  {{/if}}\n  </div>\n  {{else}}\n  <div class="sidecar-replies-empty sidecar-replies">\n  </div>\n  {{/if}}\n<\/script>\n\n<script id="sidecar-post-template" type="text/x-handlebars-template">\n  {{#if postId}}\n  <div id="sidecar-post-{{postId}}" class="sidecar-post">\n  <div class="sidecar-post-user-info">\n  <img id="avatar-{{postId}}" class="sidecar-post-avatar" src="{{avatar}}" alt="User Avatar" loading="lazy">\n  <div class="sidecar-post-author">\n  <a href="https://bsky.app/profile/{{handle}}">\n  <div class="sidecar-post-username">{{displayName}}</div>\n  </a>\n  <a href="https://bsky.app/profile/{{handle}}">\n  <div class="sidecar-post-handle">@{{handle}}</div>\n  </a>\n  </div>\n  </div>\n  {{> bodyTemplate this}}\n  {{> footerTemplate this}}\n  </div>\n  {{else}}\n  <div class="sidecar-post-empty" class="sidecar-post">\n  </div>\n  {{/if}}\n<\/script>\n\n<script id="sidecar-footer-template" type="text/x-handlebars-template">\n  <div class="sidecar-post-footer">\n  <div class="sidecar-post-timestamp">\n  <a href="{{postUrl}}">\n  {{timestamp}}\n  </a>\n  </div>\n  {{> postCountsTemplate this}}\n  </div>\n<\/script>\n\n<script id="sidecar-post-counts-template" type="text/x-handlebars-template">\n\n  <div class="sidecar-post-counts">\n  <div class="sidecar-count sidecar-count-replies">\n  <div class="sidecar-count-icon sidecar-reply-button">{{{replySvg}}}</div>\n  <div class="sidecar-count-label sidecar-count-label-replies">{{replyCount}}</div>\n  </div>\n\n  <div class="sidecar-count sidecar-count-reposts">\n  <div class="sidecar-count-icon sidecar-repost-button">{{{repostSvg}}}</div>\n  <div class="sidecar-count-label sidecar-count-label-reposts">{{repostCount}}</div>\n  </div>\n\n  <div class="sidecar-count sidecar-count-likes">\n  <div class="sidecar-count-icon sidecar-like-button">{{{likeSvg}}}</div>\n  <div class="sidecar-count-label sidecar-count-label-likes">{{likeCount}}</div>\n  </div>\n\n  </div>\n<\/script>\n\n\n<script id="sidecar-body-template" type="text/x-handlebars-template">\n<div class="sidecar-post-body">\n<div class="sidecar-post-content">{{{content}}}</div>\n  {{#if embed}}\n  {{#each embed.images}}\n  {{> imageTemplate this}}\n  {{/each}}\n  {{#if embed.media.images}}\n  {{#each embed.media.images}}\n  {{> imageTemplate this}}\n  {{/each}}\n  {{/if}}\n  {{/if}}\n  {{#if quotedPost}}\n  {{> quoteTemplate quotedPost}}\n  {{/if}}\n  {{#if externalLink}}\n  {{> externalTemplate externalLink}}\n  {{/if}}\n</div>\n<\/script>\n\n<script id="sidecar-embed-image-template" type="text/x-handlebars-template">\n        <button aria-label="{{#if alt}}{{alt}}{{else}}Image{{/if}}" role="button" tabindex="0" class="css-175oi2r r-1loqt21 r-1otgn73" style="flex: 1 1 0%; overflow: hidden; background-color: rgb(241, 243, 245);" type="button"><div data-expoimage="true" class="css-175oi2r" style="overflow: hidden; flex: 1 1 0%;"><div><img alt="{{#if alt}}{{alt}}{{else}}Image{{/if}}" src="{{thumb}}" loading="lazy" style="object-position: left 50% top 50%; width: 100%; height: 100%; object-fit: cover; transition-duration: 0ms; transition-timing-function: linear;" fetchpriority="auto" title="{{alt}}"></div></div><div class="css-175oi2r" style="position: absolute; inset: 0px; border-radius: 12px 0px 0px 12px; border-width: 1px; border-color: rgb(212, 219, 226); opacity: 0.6; pointer-events: none;"></div></button>\n<\/script>\n\n<script id="sidecar-embed-quote-template" type="text/x-handlebars-template">\n<div class="sidecar-embed-quote" style="border: 1px solid rgb(212, 219, 226); border-radius: 12px; padding: 12px; margin-top: 8px;">\n  <div class="sidecar-quote-author" style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">\n    {{#if avatar}}\n    <img class="sidecar-quote-avatar" src="{{avatar}}" alt="User Avatar" style="width: 20px; height: 20px; border-radius: 50%;" loading="lazy">\n    {{/if}}\n    <a href="https://bsky.app/profile/{{handle}}" style="text-decoration: none;">\n      <span class="sidecar-quote-displayname" style="font-weight: 600;">{{displayName}}</span>\n      <span class="sidecar-quote-handle" style="color: rgb(112, 127, 140);">@{{handle}}</span>\n    </a>\n  </div>\n  <div class="sidecar-quote-content">{{{text}}}</div>\n  {{#if images}}\n  <div class="sidecar-quote-images" style="margin-top: 8px;">\n    {{#each images}}\n    <img src="{{this.thumb}}" alt="Embedded image" style="max-width: 100%; border-radius: 8px;" loading="lazy">\n    {{/each}}\n  </div>\n  {{/if}}\n</div>\n<\/script>\n\n<script id="sidecar-embed-external-template" type="text/x-handlebars-template">\n<a href="{{uri}}" target="_blank" rel="noopener noreferrer" style="text-decoration: none; color: inherit;">\n  <div class="sidecar-embed-external" style="border: 1px solid rgb(212, 219, 226); border-radius: 12px; margin-top: 8px; overflow: hidden;">\n    {{#if thumb}}\n    <div class="sidecar-external-thumb" style="width: 100%; max-height: 200px; overflow: hidden;">\n      <img src="{{thumb}}" alt="{{title}}" style="width: 100%; object-fit: cover;" loading="lazy">\n    </div>\n    {{/if}}\n    <div class="sidecar-external-info" style="padding: 12px;">\n      <div class="sidecar-external-domain" style="font-size: 12px; color: rgb(112, 127, 140); margin-bottom: 4px;">{{domain}}</div>\n      <div class="sidecar-external-title" style="font-weight: 600; margin-bottom: 4px;">{{title}}</div>\n      {{#if description}}\n      <div class="sidecar-external-description" style="font-size: 14px; color: rgb(66, 87, 108); line-height: 1.3;">{{description}}</div>\n      {{/if}}\n    </div>\n  </div>\n</a>\n<\/script>\n\n<script id="sidecar-skeleton-template" type="text/x-handlebars-template">\n<div class="sidecar-replies sidecar-skeleton" role="status" aria-label="Loading replies">\n  <div class="skeleton-post">\n    <div class="skeleton-header">\n      <div class="skeleton-avatar skeleton-shimmer"></div>\n      <div class="skeleton-author">\n        <div class="skeleton-line skeleton-line-short skeleton-shimmer"></div>\n        <div class="skeleton-line skeleton-line-medium skeleton-shimmer"></div>\n      </div>\n    </div>\n    <div class="skeleton-body">\n      <div class="skeleton-line skeleton-line-full skeleton-shimmer"></div>\n      <div class="skeleton-line skeleton-line-full skeleton-shimmer"></div>\n      <div class="skeleton-line skeleton-line-medium skeleton-shimmer"></div>\n    </div>\n  </div>\n  <div class="skeleton-post">\n    <div class="skeleton-header">\n      <div class="skeleton-avatar skeleton-shimmer"></div>\n      <div class="skeleton-author">\n        <div class="skeleton-line skeleton-line-short skeleton-shimmer"></div>\n        <div class="skeleton-line skeleton-line-medium skeleton-shimmer"></div>\n      </div>\n    </div>\n    <div class="skeleton-body">\n      <div class="skeleton-line skeleton-line-full skeleton-shimmer"></div>\n      <div class="skeleton-line skeleton-line-medium skeleton-shimmer"></div>\n    </div>\n  </div>\n  <span class="sr-only">Loading replies...</span>\n</div>\n<\/script>\n';
  const SHORTCUTS = {
    "Global Navigation": {
      contexts: null,
      // Show in all contexts
      shortcuts: [
        { keys: ["Alt+H"], description: "Home" },
        { keys: ["Alt+E"], description: "Explore (Search)" },
        { keys: ["Alt+S"], description: "Saved" },
        { keys: ["Alt+N"], description: "Notifications" },
        { keys: ["Alt+M"], description: "Messages" },
        { keys: ["Alt+F"], description: "Feeds" },
        { keys: ["Alt+L"], description: "Lists" },
        { keys: ["Alt+P"], description: "Profile" },
        { keys: ["Alt+,"], description: "Settings" },
        { keys: ["Alt+."], description: "Extension preferences" }
      ]
    },
    Navigation: {
      contexts: null,
      // Show in all contexts
      shortcuts: [
        { keys: ["j"], description: "Next item (mark read)" },
        { keys: ["k"], description: "Previous item (mark read)" },
        { keys: ["\u2193"], description: "Next item" },
        { keys: ["\u2191"], description: "Previous item" },
        { keys: ["J"], description: "Mark thread read, next post" },
        { keys: ["K"], description: "Mark thread read, previous post" },
        { keys: ["PgDn"], description: "Page down (multiple items)" },
        { keys: ["PgUp"], description: "Page up (multiple items)" },
        { keys: ["Home"], description: "Go to first item" },
        { keys: ["End"], description: "Go to last item" },
        { keys: ["g", "g"], description: "Go to first item (vim)" },
        { keys: ["G"], description: "Go to last item (vim)" },
        { keys: ["h"], description: "Go back" },
        { keys: ["\u2190", "\u2192"], description: "Toggle focus (post/replies)" }
      ]
    },
    "Post Actions": {
      contexts: ["feed", "post", "profile"],
      // Show on pages with posts
      shortcuts: [
        { keys: ["o", "Enter"], description: "Open post" },
        { keys: ["O"], description: "Open inner post" },
        { keys: ["l"], description: "Like/Unlike" },
        { keys: ["p"], description: "Repost menu" },
        { keys: ["P"], description: "Repost immediately" },
        { keys: ["r"], description: "Reply" },
        { keys: ["f"], description: "Follow author" },
        { keys: ["F"], description: "Unfollow author" },
        { keys: ["+"], description: "Add author to rules" },
        { keys: ["-"], description: "Remove author from rules" },
        { keys: ["!"], description: "Timeout author" },
        { keys: ["s"], description: "Save/Unsave post" },
        { keys: ["S"], description: "Share menu" },
        { keys: ["i"], description: "Open first link" },
        { keys: ["m"], description: "Toggle media/video" },
        { keys: ["c"], description: "Screenshot to clipboard" },
        { keys: ["v"], description: "Full-screen post view" },
        { keys: ["V"], description: "Reader mode (thread)" },
        { keys: ["t"], description: "Toggle thread context" },
        { keys: ["a"], description: "Show author hover card" },
        { keys: ["A"], description: "Open author profile" }
      ]
    },
    "Feed Controls": {
      contexts: ["feed", "profile"],
      // Feed and profile pages have feed controls
      shortcuts: [
        { keys: ["/"], description: "Focus search" },
        { keys: ["u"], description: "Load newer posts" },
        { keys: ["U"], description: "Load older posts" },
        { keys: [":"], description: "Toggle sort order" },
        { keys: ['"'], description: "Toggle hide read" },
        { keys: [","], description: "Refresh items" },
        { keys: ["."], description: "Toggle read status" }
      ]
    },
    "Quick Filters": {
      contexts: ["feed", "profile"],
      // Filters apply to feeds
      shortcuts: [
        { keys: ["Alt+1-9"], description: "Apply filter rule" },
        { keys: ["Alt+Shift+1-9"], description: "Negate filter rule" },
        { keys: ["Alt+0"], description: "Clear filter" }
      ]
    },
    "Profile Actions": {
      contexts: ["profile"],
      // Only on profile pages
      shortcuts: [
        { keys: ["f"], description: "Follow" },
        { keys: ["F"], description: "Unfollow" },
        { keys: ["L"], description: "Add to list" },
        { keys: ["M"], description: "Mute" },
        { keys: ["B"], description: "Block" },
        { keys: ["R"], description: "Report" }
      ]
    },
    Other: {
      contexts: null,
      // Show in all contexts
      shortcuts: [
        { keys: [";"], description: "Expand sidecar" },
        { keys: ["x"], description: "Dismiss oldest toast" },
        { keys: ["1-9"], description: "Switch to tab" },
        { keys: ["?"], description: "Show/hide this help" },
        { keys: ["Esc"], description: "Close overlay" }
      ]
    }
  };
  const CONTEXT_NAMES = {
    feed: "Feed",
    post: "Post",
    profile: "Profile"
  };
  let instance$1 = null;
  class ShortcutOverlay {
    constructor(config2) {
      if (instance$1) {
        instance$1.config = config2;
        return instance$1;
      }
      this.config = config2;
      this.isVisible = false;
      this.overlayEl = null;
      this.previousActiveElement = null;
      this.ignoreNextQuestionMark = false;
      this.currentContext = null;
      instance$1 = this;
    }
    /**
     * Toggle overlay visibility
     * @param {string} context - The current handler context ('feed', 'post', 'profile')
     */
    toggle(context) {
      if (this.isVisible) {
        this.hide();
      } else {
        this.show(context);
      }
    }
    /**
     * Show the overlay
     * @param {string} context - The current handler context
     */
    show(context) {
      if (this.isVisible) return;
      this.currentContext = context;
      this.previousActiveElement = document.activeElement;
      this.isVisible = true;
      this.overlayEl = this.createOverlay();
      document.body.appendChild(this.overlayEl);
      const firstFocusable = this.overlayEl.querySelector(".shortcut-overlay-close");
      if (firstFocusable) {
        firstFocusable.focus();
      }
      announceToScreenReader$2("Keyboard shortcuts dialog opened. Press Escape to close.");
      this.ignoreNextQuestionMark = true;
      this.escapeHandler = (e) => {
        if (this.ignoreNextQuestionMark && e.key === "?") {
          this.ignoreNextQuestionMark = false;
          return;
        }
        this.ignoreNextQuestionMark = false;
        if (e.key === "Escape" || e.key === "?") {
          e.preventDefault();
          e.stopPropagation();
          this.hide();
        }
      };
      document.addEventListener("keydown", this.escapeHandler, true);
    }
    /**
     * Hide the overlay
     */
    hide() {
      if (!this.isVisible || !this.overlayEl) return;
      const animDuration = getAnimationDuration$1(200, this.config);
      this.overlayEl.classList.add("shortcut-overlay-hiding");
      setTimeout(() => {
        if (this.overlayEl && this.overlayEl.parentNode) {
          this.overlayEl.parentNode.removeChild(this.overlayEl);
        }
        this.overlayEl = null;
        this.isVisible = false;
        this.currentContext = null;
        if (this.previousActiveElement) {
          this.previousActiveElement.focus();
        }
      }, animDuration);
      document.removeEventListener("keydown", this.escapeHandler);
      announceToScreenReader$2("Keyboard shortcuts dialog closed.");
    }
    /**
     * Create the overlay DOM element
     */
    createOverlay() {
      const overlay = document.createElement("div");
      overlay.className = "shortcut-overlay";
      overlay.setAttribute("role", "dialog");
      overlay.setAttribute("aria-modal", "true");
      overlay.setAttribute("aria-labelledby", "shortcut-overlay-title");
      const contextName = CONTEXT_NAMES[this.currentContext] || "Page";
      const title = `Keyboard Shortcuts \u2014 ${contextName}`;
      overlay.innerHTML = `
      <div class="shortcut-overlay-backdrop"></div>
      <div class="shortcut-overlay-content">
        <div class="shortcut-overlay-header">
          <h2 id="shortcut-overlay-title">${title}</h2>
          <button class="shortcut-overlay-close" aria-label="Close">\xD7</button>
        </div>
        <div class="shortcut-overlay-body">
          ${this.renderCategories()}
        </div>
        <div class="shortcut-overlay-footer">
          Press <kbd>?</kbd> or <kbd>Esc</kbd> to close
        </div>
      </div>
    `;
      overlay.querySelector(".shortcut-overlay-backdrop").addEventListener("click", () => this.hide());
      overlay.querySelector(".shortcut-overlay-close").addEventListener("click", () => this.hide());
      return overlay;
    }
    /**
     * Check if a category should be shown for the current context
     */
    shouldShowCategory(category) {
      const contexts = category.contexts;
      if (!contexts) return true;
      return contexts.includes(this.currentContext);
    }
    /**
     * Render all shortcut categories for the current context
     */
    renderCategories() {
      return Object.entries(SHORTCUTS).filter(([, category]) => this.shouldShowCategory(category)).map(([name, category]) => `
        <div class="shortcut-category">
          <h3 class="shortcut-category-title">${name}</h3>
          <dl class="shortcut-list">
            ${category.shortcuts.map((s) => this.renderShortcut(s)).join("")}
          </dl>
        </div>
      `).join("");
    }
    /**
     * Render a single shortcut
     */
    renderShortcut({ keys, description }) {
      const keyHtml = keys.map((key) => `<kbd>${this.escapeHtml(key)}</kbd>`).join(" ");
      return `
      <div class="shortcut-item">
        <dt class="shortcut-keys">${keyHtml}</dt>
        <dd class="shortcut-desc">${this.escapeHtml(description)}</dd>
      </div>
    `;
    }
    /**
     * Escape HTML special characters
     */
    escapeHtml(text) {
      const div = document.createElement("div");
      div.textContent = text;
      return div.innerHTML;
    }
  }
  class Handler {
    constructor(name, config2, state2, api) {
      this.name = name;
      this.config = config2;
      this.state = state2;
      this.api = api;
      this.items = [];
      this.handleInput = this.handleInput.bind(this);
      this.shortcutOverlay = new ShortcutOverlay(config2);
    }
    activate() {
      this.bindKeys();
    }
    deactivate() {
      this.unbindKeys();
    }
    isActive() {
      return true;
    }
    bindKeys() {
      document.addEventListener("keydown", this.handleInput, true);
    }
    unbindKeys() {
      document.removeEventListener("keydown", this.handleInput, true);
    }
    handleInput(event) {
      if (isUserTyping()) {
        return;
      }
      if (isModalOpen()) {
        return;
      }
      if (event.altKey && !event.metaKey) {
        if (event.code === "KeyH") {
          event.preventDefault();
          $("nav a[aria-label='Home']")[0].click();
        } else if (event.code === "KeyE") {
          event.preventDefault();
          $("nav a[aria-label='Explore']")[0].click();
        } else if (event.code === "KeyS") {
          event.preventDefault();
          $("nav a[aria-label='Saved']")[0].click();
        } else if (event.code === "KeyN") {
          event.preventDefault();
          $("nav a[aria-label='Notifications']")[0].click();
        } else if (event.code === "KeyM") {
          event.preventDefault();
          $("nav a[aria-label='Chat']")[0].click();
        } else if (event.code === "KeyF") {
          event.preventDefault();
          $("nav a[aria-label='Feeds']")[0].click();
        } else if (event.code === "KeyL") {
          event.preventDefault();
          $("nav a[aria-label='Lists']")[0].click();
        } else if (event.code === "KeyP") {
          event.preventDefault();
          $("nav a[aria-label='Profile']")[0].click();
        } else if (event.code === "Comma") {
          event.preventDefault();
          $("nav a[aria-label='Settings']")[0].click();
        } else if (event.code === "Period") {
          event.preventDefault();
          this.config.open();
        } else if (event.code === "Enter" && $(".config-modal").is(":visible")) {
          event.preventDefault();
        }
      } else if (!event.altKey && !event.metaKey) {
        if (event.code == "Escape" && $(".config-modal").is(":visible")) {
          event.preventDefault();
          this.config.close();
        } else if (event.key === "?") {
          event.preventDefault();
          this.shortcutOverlay.toggle(this.name);
        }
      }
    }
  }
  const millisecondsInWeek = 6048e5;
  const millisecondsInDay = 864e5;
  const constructFromSymbol = Symbol.for("constructDateFrom");
  function constructFrom(date, value) {
    if (typeof date === "function") return date(value);
    if (date && typeof date === "object" && constructFromSymbol in date)
      return date[constructFromSymbol](value);
    if (date instanceof Date) return new date.constructor(value);
    return new Date(value);
  }
  function toDate(argument, context) {
    return constructFrom(context || argument, argument);
  }
  let defaultOptions = {};
  function getDefaultOptions() {
    return defaultOptions;
  }
  function startOfWeek(date, options) {
    const defaultOptions2 = getDefaultOptions();
    const weekStartsOn = options?.weekStartsOn ?? options?.locale?.options?.weekStartsOn ?? defaultOptions2.weekStartsOn ?? defaultOptions2.locale?.options?.weekStartsOn ?? 0;
    const _date = toDate(date, options?.in);
    const day = _date.getDay();
    const diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
    _date.setDate(_date.getDate() - diff);
    _date.setHours(0, 0, 0, 0);
    return _date;
  }
  function startOfISOWeek(date, options) {
    return startOfWeek(date, { ...options, weekStartsOn: 1 });
  }
  function getISOWeekYear(date, options) {
    const _date = toDate(date, options?.in);
    const year = _date.getFullYear();
    const fourthOfJanuaryOfNextYear = constructFrom(_date, 0);
    fourthOfJanuaryOfNextYear.setFullYear(year + 1, 0, 4);
    fourthOfJanuaryOfNextYear.setHours(0, 0, 0, 0);
    const startOfNextYear = startOfISOWeek(fourthOfJanuaryOfNextYear);
    const fourthOfJanuaryOfThisYear = constructFrom(_date, 0);
    fourthOfJanuaryOfThisYear.setFullYear(year, 0, 4);
    fourthOfJanuaryOfThisYear.setHours(0, 0, 0, 0);
    const startOfThisYear = startOfISOWeek(fourthOfJanuaryOfThisYear);
    if (_date.getTime() >= startOfNextYear.getTime()) {
      return year + 1;
    } else if (_date.getTime() >= startOfThisYear.getTime()) {
      return year;
    } else {
      return year - 1;
    }
  }
  function getTimezoneOffsetInMilliseconds(date) {
    const _date = toDate(date);
    const utcDate = new Date(
      Date.UTC(
        _date.getFullYear(),
        _date.getMonth(),
        _date.getDate(),
        _date.getHours(),
        _date.getMinutes(),
        _date.getSeconds(),
        _date.getMilliseconds()
      )
    );
    utcDate.setUTCFullYear(_date.getFullYear());
    return +date - +utcDate;
  }
  function normalizeDates(context, ...dates) {
    const normalize = constructFrom.bind(
      null,
      dates.find((date) => typeof date === "object")
    );
    return dates.map(normalize);
  }
  function startOfDay(date, options) {
    const _date = toDate(date, options?.in);
    _date.setHours(0, 0, 0, 0);
    return _date;
  }
  function differenceInCalendarDays(laterDate, earlierDate, options) {
    const [laterDate_, earlierDate_] = normalizeDates(
      options?.in,
      laterDate,
      earlierDate
    );
    const laterStartOfDay = startOfDay(laterDate_);
    const earlierStartOfDay = startOfDay(earlierDate_);
    const laterTimestamp = +laterStartOfDay - getTimezoneOffsetInMilliseconds(laterStartOfDay);
    const earlierTimestamp = +earlierStartOfDay - getTimezoneOffsetInMilliseconds(earlierStartOfDay);
    return Math.round((laterTimestamp - earlierTimestamp) / millisecondsInDay);
  }
  function startOfISOWeekYear(date, options) {
    const year = getISOWeekYear(date, options);
    const fourthOfJanuary = constructFrom(date, 0);
    fourthOfJanuary.setFullYear(year, 0, 4);
    fourthOfJanuary.setHours(0, 0, 0, 0);
    return startOfISOWeek(fourthOfJanuary);
  }
  function isDate(value) {
    return value instanceof Date || typeof value === "object" && Object.prototype.toString.call(value) === "[object Date]";
  }
  function isValid(date) {
    return !(!isDate(date) && typeof date !== "number" || isNaN(+toDate(date)));
  }
  function startOfYear(date, options) {
    const date_ = toDate(date, options?.in);
    date_.setFullYear(date_.getFullYear(), 0, 1);
    date_.setHours(0, 0, 0, 0);
    return date_;
  }
  const formatDistanceLocale = {
    lessThanXSeconds: {
      one: "less than a second",
      other: "less than {{count}} seconds"
    },
    xSeconds: {
      one: "1 second",
      other: "{{count}} seconds"
    },
    halfAMinute: "half a minute",
    lessThanXMinutes: {
      one: "less than a minute",
      other: "less than {{count}} minutes"
    },
    xMinutes: {
      one: "1 minute",
      other: "{{count}} minutes"
    },
    aboutXHours: {
      one: "about 1 hour",
      other: "about {{count}} hours"
    },
    xHours: {
      one: "1 hour",
      other: "{{count}} hours"
    },
    xDays: {
      one: "1 day",
      other: "{{count}} days"
    },
    aboutXWeeks: {
      one: "about 1 week",
      other: "about {{count}} weeks"
    },
    xWeeks: {
      one: "1 week",
      other: "{{count}} weeks"
    },
    aboutXMonths: {
      one: "about 1 month",
      other: "about {{count}} months"
    },
    xMonths: {
      one: "1 month",
      other: "{{count}} months"
    },
    aboutXYears: {
      one: "about 1 year",
      other: "about {{count}} years"
    },
    xYears: {
      one: "1 year",
      other: "{{count}} years"
    },
    overXYears: {
      one: "over 1 year",
      other: "over {{count}} years"
    },
    almostXYears: {
      one: "almost 1 year",
      other: "almost {{count}} years"
    }
  };
  const formatDistance = (token, count, options) => {
    let result;
    const tokenValue = formatDistanceLocale[token];
    if (typeof tokenValue === "string") {
      result = tokenValue;
    } else if (count === 1) {
      result = tokenValue.one;
    } else {
      result = tokenValue.other.replace("{{count}}", count.toString());
    }
    if (options?.addSuffix) {
      if (options.comparison && options.comparison > 0) {
        return "in " + result;
      } else {
        return result + " ago";
      }
    }
    return result;
  };
  function buildFormatLongFn(args) {
    return (options = {}) => {
      const width = options.width ? String(options.width) : args.defaultWidth;
      const format2 = args.formats[width] || args.formats[args.defaultWidth];
      return format2;
    };
  }
  const dateFormats = {
    full: "EEEE, MMMM do, y",
    long: "MMMM do, y",
    medium: "MMM d, y",
    short: "MM/dd/yyyy"
  };
  const timeFormats = {
    full: "h:mm:ss a zzzz",
    long: "h:mm:ss a z",
    medium: "h:mm:ss a",
    short: "h:mm a"
  };
  const dateTimeFormats = {
    full: "{{date}} 'at' {{time}}",
    long: "{{date}} 'at' {{time}}",
    medium: "{{date}}, {{time}}",
    short: "{{date}}, {{time}}"
  };
  const formatLong = {
    date: buildFormatLongFn({
      formats: dateFormats,
      defaultWidth: "full"
    }),
    time: buildFormatLongFn({
      formats: timeFormats,
      defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
      formats: dateTimeFormats,
      defaultWidth: "full"
    })
  };
  const formatRelativeLocale = {
    lastWeek: "'last' eeee 'at' p",
    yesterday: "'yesterday at' p",
    today: "'today at' p",
    tomorrow: "'tomorrow at' p",
    nextWeek: "eeee 'at' p",
    other: "P"
  };
  const formatRelative = (token, _date, _baseDate, _options) => formatRelativeLocale[token];
  function buildLocalizeFn(args) {
    return (value, options) => {
      const context = options?.context ? String(options.context) : "standalone";
      let valuesArray;
      if (context === "formatting" && args.formattingValues) {
        const defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
        const width = options?.width ? String(options.width) : defaultWidth;
        valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
      } else {
        const defaultWidth = args.defaultWidth;
        const width = options?.width ? String(options.width) : args.defaultWidth;
        valuesArray = args.values[width] || args.values[defaultWidth];
      }
      const index = args.argumentCallback ? args.argumentCallback(value) : value;
      return valuesArray[index];
    };
  }
  const eraValues = {
    narrow: ["B", "A"],
    abbreviated: ["BC", "AD"],
    wide: ["Before Christ", "Anno Domini"]
  };
  const quarterValues = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["Q1", "Q2", "Q3", "Q4"],
    wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
  };
  const monthValues = {
    narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
    abbreviated: [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ],
    wide: [
      "January",
      "February",
      "March",
      "April",
      "May",
      "June",
      "July",
      "August",
      "September",
      "October",
      "November",
      "December"
    ]
  };
  const dayValues = {
    narrow: ["S", "M", "T", "W", "T", "F", "S"],
    short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
    abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    wide: [
      "Sunday",
      "Monday",
      "Tuesday",
      "Wednesday",
      "Thursday",
      "Friday",
      "Saturday"
    ]
  };
  const dayPeriodValues = {
    narrow: {
      am: "a",
      pm: "p",
      midnight: "mi",
      noon: "n",
      morning: "morning",
      afternoon: "afternoon",
      evening: "evening",
      night: "night"
    },
    abbreviated: {
      am: "AM",
      pm: "PM",
      midnight: "midnight",
      noon: "noon",
      morning: "morning",
      afternoon: "afternoon",
      evening: "evening",
      night: "night"
    },
    wide: {
      am: "a.m.",
      pm: "p.m.",
      midnight: "midnight",
      noon: "noon",
      morning: "morning",
      afternoon: "afternoon",
      evening: "evening",
      night: "night"
    }
  };
  const formattingDayPeriodValues = {
    narrow: {
      am: "a",
      pm: "p",
      midnight: "mi",
      noon: "n",
      morning: "in the morning",
      afternoon: "in the afternoon",
      evening: "in the evening",
      night: "at night"
    },
    abbreviated: {
      am: "AM",
      pm: "PM",
      midnight: "midnight",
      noon: "noon",
      morning: "in the morning",
      afternoon: "in the afternoon",
      evening: "in the evening",
      night: "at night"
    },
    wide: {
      am: "a.m.",
      pm: "p.m.",
      midnight: "midnight",
      noon: "noon",
      morning: "in the morning",
      afternoon: "in the afternoon",
      evening: "in the evening",
      night: "at night"
    }
  };
  const ordinalNumber = (dirtyNumber, _options) => {
    const number = Number(dirtyNumber);
    const rem100 = number % 100;
    if (rem100 > 20 || rem100 < 10) {
      switch (rem100 % 10) {
        case 1:
          return number + "st";
        case 2:
          return number + "nd";
        case 3:
          return number + "rd";
      }
    }
    return number + "th";
  };
  const localize = {
    ordinalNumber,
    era: buildLocalizeFn({
      values: eraValues,
      defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
      values: quarterValues,
      defaultWidth: "wide",
      argumentCallback: (quarter) => quarter - 1
    }),
    month: buildLocalizeFn({
      values: monthValues,
      defaultWidth: "wide"
    }),
    day: buildLocalizeFn({
      values: dayValues,
      defaultWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
      values: dayPeriodValues,
      defaultWidth: "wide",
      formattingValues: formattingDayPeriodValues,
      defaultFormattingWidth: "wide"
    })
  };
  function buildMatchFn(args) {
    return (string2, options = {}) => {
      const width = options.width;
      const matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
      const matchResult = string2.match(matchPattern);
      if (!matchResult) {
        return null;
      }
      const matchedString = matchResult[0];
      const parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
      const key = Array.isArray(parsePatterns) ? findIndex(parsePatterns, (pattern) => pattern.test(matchedString)) : (
        // [TODO] -- I challenge you to fix the type
        findKey(parsePatterns, (pattern) => pattern.test(matchedString))
      );
      let value;
      value = args.valueCallback ? args.valueCallback(key) : key;
      value = options.valueCallback ? (
        // [TODO] -- I challenge you to fix the type
        options.valueCallback(value)
      ) : value;
      const rest = string2.slice(matchedString.length);
      return { value, rest };
    };
  }
  function findKey(object, predicate2) {
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key) && predicate2(object[key])) {
        return key;
      }
    }
    return void 0;
  }
  function findIndex(array, predicate2) {
    for (let key = 0; key < array.length; key++) {
      if (predicate2(array[key])) {
        return key;
      }
    }
    return void 0;
  }
  function buildMatchPatternFn(args) {
    return (string2, options = {}) => {
      const matchResult = string2.match(args.matchPattern);
      if (!matchResult) return null;
      const matchedString = matchResult[0];
      const parseResult = string2.match(args.parsePattern);
      if (!parseResult) return null;
      let value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
      value = options.valueCallback ? options.valueCallback(value) : value;
      const rest = string2.slice(matchedString.length);
      return { value, rest };
    };
  }
  const matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
  const parseOrdinalNumberPattern = /\d+/i;
  const matchEraPatterns = {
    narrow: /^(b|a)/i,
    abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
    wide: /^(before christ|before common era|anno domini|common era)/i
  };
  const parseEraPatterns = {
    any: [/^b/i, /^(a|c)/i]
  };
  const matchQuarterPatterns = {
    narrow: /^[1234]/i,
    abbreviated: /^q[1234]/i,
    wide: /^[1234](th|st|nd|rd)? quarter/i
  };
  const parseQuarterPatterns = {
    any: [/1/i, /2/i, /3/i, /4/i]
  };
  const matchMonthPatterns = {
    narrow: /^[jfmasond]/i,
    abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
    wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
  };
  const parseMonthPatterns = {
    narrow: [
      /^j/i,
      /^f/i,
      /^m/i,
      /^a/i,
      /^m/i,
      /^j/i,
      /^j/i,
      /^a/i,
      /^s/i,
      /^o/i,
      /^n/i,
      /^d/i
    ],
    any: [
      /^ja/i,
      /^f/i,
      /^mar/i,
      /^ap/i,
      /^may/i,
      /^jun/i,
      /^jul/i,
      /^au/i,
      /^s/i,
      /^o/i,
      /^n/i,
      /^d/i
    ]
  };
  const matchDayPatterns = {
    narrow: /^[smtwf]/i,
    short: /^(su|mo|tu|we|th|fr|sa)/i,
    abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
    wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
  };
  const parseDayPatterns = {
    narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
    any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
  };
  const matchDayPeriodPatterns = {
    narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
    any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
  };
  const parseDayPeriodPatterns = {
    any: {
      am: /^a/i,
      pm: /^p/i,
      midnight: /^mi/i,
      noon: /^no/i,
      morning: /morning/i,
      afternoon: /afternoon/i,
      evening: /evening/i,
      night: /night/i
    }
  };
  const match = {
    ordinalNumber: buildMatchPatternFn({
      matchPattern: matchOrdinalNumberPattern,
      parsePattern: parseOrdinalNumberPattern,
      valueCallback: (value) => parseInt(value, 10)
    }),
    era: buildMatchFn({
      matchPatterns: matchEraPatterns,
      defaultMatchWidth: "wide",
      parsePatterns: parseEraPatterns,
      defaultParseWidth: "any"
    }),
    quarter: buildMatchFn({
      matchPatterns: matchQuarterPatterns,
      defaultMatchWidth: "wide",
      parsePatterns: parseQuarterPatterns,
      defaultParseWidth: "any",
      valueCallback: (index) => index + 1
    }),
    month: buildMatchFn({
      matchPatterns: matchMonthPatterns,
      defaultMatchWidth: "wide",
      parsePatterns: parseMonthPatterns,
      defaultParseWidth: "any"
    }),
    day: buildMatchFn({
      matchPatterns: matchDayPatterns,
      defaultMatchWidth: "wide",
      parsePatterns: parseDayPatterns,
      defaultParseWidth: "any"
    }),
    dayPeriod: buildMatchFn({
      matchPatterns: matchDayPeriodPatterns,
      defaultMatchWidth: "any",
      parsePatterns: parseDayPeriodPatterns,
      defaultParseWidth: "any"
    })
  };
  const enUS = {
    code: "en-US",
    formatDistance,
    formatLong,
    formatRelative,
    localize,
    match,
    options: {
      weekStartsOn: 0,
      firstWeekContainsDate: 1
    }
  };
  function getDayOfYear(date, options) {
    const _date = toDate(date, options?.in);
    const diff = differenceInCalendarDays(_date, startOfYear(_date));
    const dayOfYear = diff + 1;
    return dayOfYear;
  }
  function getISOWeek(date, options) {
    const _date = toDate(date, options?.in);
    const diff = +startOfISOWeek(_date) - +startOfISOWeekYear(_date);
    return Math.round(diff / millisecondsInWeek) + 1;
  }
  function getWeekYear(date, options) {
    const _date = toDate(date, options?.in);
    const year = _date.getFullYear();
    const defaultOptions2 = getDefaultOptions();
    const firstWeekContainsDate = options?.firstWeekContainsDate ?? options?.locale?.options?.firstWeekContainsDate ?? defaultOptions2.firstWeekContainsDate ?? defaultOptions2.locale?.options?.firstWeekContainsDate ?? 1;
    const firstWeekOfNextYear = constructFrom(options?.in || date, 0);
    firstWeekOfNextYear.setFullYear(year + 1, 0, firstWeekContainsDate);
    firstWeekOfNextYear.setHours(0, 0, 0, 0);
    const startOfNextYear = startOfWeek(firstWeekOfNextYear, options);
    const firstWeekOfThisYear = constructFrom(options?.in || date, 0);
    firstWeekOfThisYear.setFullYear(year, 0, firstWeekContainsDate);
    firstWeekOfThisYear.setHours(0, 0, 0, 0);
    const startOfThisYear = startOfWeek(firstWeekOfThisYear, options);
    if (+_date >= +startOfNextYear) {
      return year + 1;
    } else if (+_date >= +startOfThisYear) {
      return year;
    } else {
      return year - 1;
    }
  }
  function startOfWeekYear(date, options) {
    const defaultOptions2 = getDefaultOptions();
    const firstWeekContainsDate = options?.firstWeekContainsDate ?? options?.locale?.options?.firstWeekContainsDate ?? defaultOptions2.firstWeekContainsDate ?? defaultOptions2.locale?.options?.firstWeekContainsDate ?? 1;
    const year = getWeekYear(date, options);
    const firstWeek = constructFrom(options?.in || date, 0);
    firstWeek.setFullYear(year, 0, firstWeekContainsDate);
    firstWeek.setHours(0, 0, 0, 0);
    const _date = startOfWeek(firstWeek, options);
    return _date;
  }
  function getWeek(date, options) {
    const _date = toDate(date, options?.in);
    const diff = +startOfWeek(_date, options) - +startOfWeekYear(_date, options);
    return Math.round(diff / millisecondsInWeek) + 1;
  }
  function addLeadingZeros(number, targetLength) {
    const sign = number < 0 ? "-" : "";
    const output = Math.abs(number).toString().padStart(targetLength, "0");
    return sign + output;
  }
  const lightFormatters = {
    // Year
    y(date, token) {
      const signedYear = date.getFullYear();
      const year = signedYear > 0 ? signedYear : 1 - signedYear;
      return addLeadingZeros(token === "yy" ? year % 100 : year, token.length);
    },
    // Month
    M(date, token) {
      const month = date.getMonth();
      return token === "M" ? String(month + 1) : addLeadingZeros(month + 1, 2);
    },
    // Day of the month
    d(date, token) {
      return addLeadingZeros(date.getDate(), token.length);
    },
    // AM or PM
    a(date, token) {
      const dayPeriodEnumValue = date.getHours() / 12 >= 1 ? "pm" : "am";
      switch (token) {
        case "a":
        case "aa":
          return dayPeriodEnumValue.toUpperCase();
        case "aaa":
          return dayPeriodEnumValue;
        case "aaaaa":
          return dayPeriodEnumValue[0];
        case "aaaa":
        default:
          return dayPeriodEnumValue === "am" ? "a.m." : "p.m.";
      }
    },
    // Hour [1-12]
    h(date, token) {
      return addLeadingZeros(date.getHours() % 12 || 12, token.length);
    },
    // Hour [0-23]
    H(date, token) {
      return addLeadingZeros(date.getHours(), token.length);
    },
    // Minute
    m(date, token) {
      return addLeadingZeros(date.getMinutes(), token.length);
    },
    // Second
    s(date, token) {
      return addLeadingZeros(date.getSeconds(), token.length);
    },
    // Fraction of second
    S(date, token) {
      const numberOfDigits = token.length;
      const milliseconds = date.getMilliseconds();
      const fractionalSeconds = Math.trunc(
        milliseconds * Math.pow(10, numberOfDigits - 3)
      );
      return addLeadingZeros(fractionalSeconds, token.length);
    }
  };
  const dayPeriodEnum = {
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  };
  const formatters = {
    // Era
    G: function(date, token, localize2) {
      const era = date.getFullYear() > 0 ? 1 : 0;
      switch (token) {
        // AD, BC
        case "G":
        case "GG":
        case "GGG":
          return localize2.era(era, { width: "abbreviated" });
        // A, B
        case "GGGGG":
          return localize2.era(era, { width: "narrow" });
        // Anno Domini, Before Christ
        case "GGGG":
        default:
          return localize2.era(era, { width: "wide" });
      }
    },
    // Year
    y: function(date, token, localize2) {
      if (token === "yo") {
        const signedYear = date.getFullYear();
        const year = signedYear > 0 ? signedYear : 1 - signedYear;
        return localize2.ordinalNumber(year, { unit: "year" });
      }
      return lightFormatters.y(date, token);
    },
    // Local week-numbering year
    Y: function(date, token, localize2, options) {
      const signedWeekYear = getWeekYear(date, options);
      const weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear;
      if (token === "YY") {
        const twoDigitYear = weekYear % 100;
        return addLeadingZeros(twoDigitYear, 2);
      }
      if (token === "Yo") {
        return localize2.ordinalNumber(weekYear, { unit: "year" });
      }
      return addLeadingZeros(weekYear, token.length);
    },
    // ISO week-numbering year
    R: function(date, token) {
      const isoWeekYear = getISOWeekYear(date);
      return addLeadingZeros(isoWeekYear, token.length);
    },
    // Extended year. This is a single number designating the year of this calendar system.
    // The main difference between `y` and `u` localizers are B.C. years:
    // | Year | `y` | `u` |
    // |------|-----|-----|
    // | AC 1 |   1 |   1 |
    // | BC 1 |   1 |   0 |
    // | BC 2 |   2 |  -1 |
    // Also `yy` always returns the last two digits of a year,
    // while `uu` pads single digit years to 2 characters and returns other years unchanged.
    u: function(date, token) {
      const year = date.getFullYear();
      return addLeadingZeros(year, token.length);
    },
    // Quarter
    Q: function(date, token, localize2) {
      const quarter = Math.ceil((date.getMonth() + 1) / 3);
      switch (token) {
        // 1, 2, 3, 4
        case "Q":
          return String(quarter);
        // 01, 02, 03, 04
        case "QQ":
          return addLeadingZeros(quarter, 2);
        // 1st, 2nd, 3rd, 4th
        case "Qo":
          return localize2.ordinalNumber(quarter, { unit: "quarter" });
        // Q1, Q2, Q3, Q4
        case "QQQ":
          return localize2.quarter(quarter, {
            width: "abbreviated",
            context: "formatting"
          });
        // 1, 2, 3, 4 (narrow quarter; could be not numerical)
        case "QQQQQ":
          return localize2.quarter(quarter, {
            width: "narrow",
            context: "formatting"
          });
        // 1st quarter, 2nd quarter, ...
        case "QQQQ":
        default:
          return localize2.quarter(quarter, {
            width: "wide",
            context: "formatting"
          });
      }
    },
    // Stand-alone quarter
    q: function(date, token, localize2) {
      const quarter = Math.ceil((date.getMonth() + 1) / 3);
      switch (token) {
        // 1, 2, 3, 4
        case "q":
          return String(quarter);
        // 01, 02, 03, 04
        case "qq":
          return addLeadingZeros(quarter, 2);
        // 1st, 2nd, 3rd, 4th
        case "qo":
          return localize2.ordinalNumber(quarter, { unit: "quarter" });
        // Q1, Q2, Q3, Q4
        case "qqq":
          return localize2.quarter(quarter, {
            width: "abbreviated",
            context: "standalone"
          });
        // 1, 2, 3, 4 (narrow quarter; could be not numerical)
        case "qqqqq":
          return localize2.quarter(quarter, {
            width: "narrow",
            context: "standalone"
          });
        // 1st quarter, 2nd quarter, ...
        case "qqqq":
        default:
          return localize2.quarter(quarter, {
            width: "wide",
            context: "standalone"
          });
      }
    },
    // Month
    M: function(date, token, localize2) {
      const month = date.getMonth();
      switch (token) {
        case "M":
        case "MM":
          return lightFormatters.M(date, token);
        // 1st, 2nd, ..., 12th
        case "Mo":
          return localize2.ordinalNumber(month + 1, { unit: "month" });
        // Jan, Feb, ..., Dec
        case "MMM":
          return localize2.month(month, {
            width: "abbreviated",
            context: "formatting"
          });
        // J, F, ..., D
        case "MMMMM":
          return localize2.month(month, {
            width: "narrow",
            context: "formatting"
          });
        // January, February, ..., December
        case "MMMM":
        default:
          return localize2.month(month, { width: "wide", context: "formatting" });
      }
    },
    // Stand-alone month
    L: function(date, token, localize2) {
      const month = date.getMonth();
      switch (token) {
        // 1, 2, ..., 12
        case "L":
          return String(month + 1);
        // 01, 02, ..., 12
        case "LL":
          return addLeadingZeros(month + 1, 2);
        // 1st, 2nd, ..., 12th
        case "Lo":
          return localize2.ordinalNumber(month + 1, { unit: "month" });
        // Jan, Feb, ..., Dec
        case "LLL":
          return localize2.month(month, {
            width: "abbreviated",
            context: "standalone"
          });
        // J, F, ..., D
        case "LLLLL":
          return localize2.month(month, {
            width: "narrow",
            context: "standalone"
          });
        // January, February, ..., December
        case "LLLL":
        default:
          return localize2.month(month, { width: "wide", context: "standalone" });
      }
    },
    // Local week of year
    w: function(date, token, localize2, options) {
      const week = getWeek(date, options);
      if (token === "wo") {
        return localize2.ordinalNumber(week, { unit: "week" });
      }
      return addLeadingZeros(week, token.length);
    },
    // ISO week of year
    I: function(date, token, localize2) {
      const isoWeek = getISOWeek(date);
      if (token === "Io") {
        return localize2.ordinalNumber(isoWeek, { unit: "week" });
      }
      return addLeadingZeros(isoWeek, token.length);
    },
    // Day of the month
    d: function(date, token, localize2) {
      if (token === "do") {
        return localize2.ordinalNumber(date.getDate(), { unit: "date" });
      }
      return lightFormatters.d(date, token);
    },
    // Day of year
    D: function(date, token, localize2) {
      const dayOfYear = getDayOfYear(date);
      if (token === "Do") {
        return localize2.ordinalNumber(dayOfYear, { unit: "dayOfYear" });
      }
      return addLeadingZeros(dayOfYear, token.length);
    },
    // Day of week
    E: function(date, token, localize2) {
      const dayOfWeek = date.getDay();
      switch (token) {
        // Tue
        case "E":
        case "EE":
        case "EEE":
          return localize2.day(dayOfWeek, {
            width: "abbreviated",
            context: "formatting"
          });
        // T
        case "EEEEE":
          return localize2.day(dayOfWeek, {
            width: "narrow",
            context: "formatting"
          });
        // Tu
        case "EEEEEE":
          return localize2.day(dayOfWeek, {
            width: "short",
            context: "formatting"
          });
        // Tuesday
        case "EEEE":
        default:
          return localize2.day(dayOfWeek, {
            width: "wide",
            context: "formatting"
          });
      }
    },
    // Local day of week
    e: function(date, token, localize2, options) {
      const dayOfWeek = date.getDay();
      const localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
      switch (token) {
        // Numerical value (Nth day of week with current locale or weekStartsOn)
        case "e":
          return String(localDayOfWeek);
        // Padded numerical value
        case "ee":
          return addLeadingZeros(localDayOfWeek, 2);
        // 1st, 2nd, ..., 7th
        case "eo":
          return localize2.ordinalNumber(localDayOfWeek, { unit: "day" });
        case "eee":
          return localize2.day(dayOfWeek, {
            width: "abbreviated",
            context: "formatting"
          });
        // T
        case "eeeee":
          return localize2.day(dayOfWeek, {
            width: "narrow",
            context: "formatting"
          });
        // Tu
        case "eeeeee":
          return localize2.day(dayOfWeek, {
            width: "short",
            context: "formatting"
          });
        // Tuesday
        case "eeee":
        default:
          return localize2.day(dayOfWeek, {
            width: "wide",
            context: "formatting"
          });
      }
    },
    // Stand-alone local day of week
    c: function(date, token, localize2, options) {
      const dayOfWeek = date.getDay();
      const localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
      switch (token) {
        // Numerical value (same as in `e`)
        case "c":
          return String(localDayOfWeek);
        // Padded numerical value
        case "cc":
          return addLeadingZeros(localDayOfWeek, token.length);
        // 1st, 2nd, ..., 7th
        case "co":
          return localize2.ordinalNumber(localDayOfWeek, { unit: "day" });
        case "ccc":
          return localize2.day(dayOfWeek, {
            width: "abbreviated",
            context: "standalone"
          });
        // T
        case "ccccc":
          return localize2.day(dayOfWeek, {
            width: "narrow",
            context: "standalone"
          });
        // Tu
        case "cccccc":
          return localize2.day(dayOfWeek, {
            width: "short",
            context: "standalone"
          });
        // Tuesday
        case "cccc":
        default:
          return localize2.day(dayOfWeek, {
            width: "wide",
            context: "standalone"
          });
      }
    },
    // ISO day of week
    i: function(date, token, localize2) {
      const dayOfWeek = date.getDay();
      const isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;
      switch (token) {
        // 2
        case "i":
          return String(isoDayOfWeek);
        // 02
        case "ii":
          return addLeadingZeros(isoDayOfWeek, token.length);
        // 2nd
        case "io":
          return localize2.ordinalNumber(isoDayOfWeek, { unit: "day" });
        // Tue
        case "iii":
          return localize2.day(dayOfWeek, {
            width: "abbreviated",
            context: "formatting"
          });
        // T
        case "iiiii":
          return localize2.day(dayOfWeek, {
            width: "narrow",
            context: "formatting"
          });
        // Tu
        case "iiiiii":
          return localize2.day(dayOfWeek, {
            width: "short",
            context: "formatting"
          });
        // Tuesday
        case "iiii":
        default:
          return localize2.day(dayOfWeek, {
            width: "wide",
            context: "formatting"
          });
      }
    },
    // AM or PM
    a: function(date, token, localize2) {
      const hours = date.getHours();
      const dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
      switch (token) {
        case "a":
        case "aa":
          return localize2.dayPeriod(dayPeriodEnumValue, {
            width: "abbreviated",
            context: "formatting"
          });
        case "aaa":
          return localize2.dayPeriod(dayPeriodEnumValue, {
            width: "abbreviated",
            context: "formatting"
          }).toLowerCase();
        case "aaaaa":
          return localize2.dayPeriod(dayPeriodEnumValue, {
            width: "narrow",
            context: "formatting"
          });
        case "aaaa":
        default:
          return localize2.dayPeriod(dayPeriodEnumValue, {
            width: "wide",
            context: "formatting"
          });
      }
    },
    // AM, PM, midnight, noon
    b: function(date, token, localize2) {
      const hours = date.getHours();
      let dayPeriodEnumValue;
      if (hours === 12) {
        dayPeriodEnumValue = dayPeriodEnum.noon;
      } else if (hours === 0) {
        dayPeriodEnumValue = dayPeriodEnum.midnight;
      } else {
        dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
      }
      switch (token) {
        case "b":
        case "bb":
          return localize2.dayPeriod(dayPeriodEnumValue, {
            width: "abbreviated",
            context: "formatting"
          });
        case "bbb":
          return localize2.dayPeriod(dayPeriodEnumValue, {
            width: "abbreviated",
            context: "formatting"
          }).toLowerCase();
        case "bbbbb":
          return localize2.dayPeriod(dayPeriodEnumValue, {
            width: "narrow",
            context: "formatting"
          });
        case "bbbb":
        default:
          return localize2.dayPeriod(dayPeriodEnumValue, {
            width: "wide",
            context: "formatting"
          });
      }
    },
    // in the morning, in the afternoon, in the evening, at night
    B: function(date, token, localize2) {
      const hours = date.getHours();
      let dayPeriodEnumValue;
      if (hours >= 17) {
        dayPeriodEnumValue = dayPeriodEnum.evening;
      } else if (hours >= 12) {
        dayPeriodEnumValue = dayPeriodEnum.afternoon;
      } else if (hours >= 4) {
        dayPeriodEnumValue = dayPeriodEnum.morning;
      } else {
        dayPeriodEnumValue = dayPeriodEnum.night;
      }
      switch (token) {
        case "B":
        case "BB":
        case "BBB":
          return localize2.dayPeriod(dayPeriodEnumValue, {
            width: "abbreviated",
            context: "formatting"
          });
        case "BBBBB":
          return localize2.dayPeriod(dayPeriodEnumValue, {
            width: "narrow",
            context: "formatting"
          });
        case "BBBB":
        default:
          return localize2.dayPeriod(dayPeriodEnumValue, {
            width: "wide",
            context: "formatting"
          });
      }
    },
    // Hour [1-12]
    h: function(date, token, localize2) {
      if (token === "ho") {
        let hours = date.getHours() % 12;
        if (hours === 0) hours = 12;
        return localize2.ordinalNumber(hours, { unit: "hour" });
      }
      return lightFormatters.h(date, token);
    },
    // Hour [0-23]
    H: function(date, token, localize2) {
      if (token === "Ho") {
        return localize2.ordinalNumber(date.getHours(), { unit: "hour" });
      }
      return lightFormatters.H(date, token);
    },
    // Hour [0-11]
    K: function(date, token, localize2) {
      const hours = date.getHours() % 12;
      if (token === "Ko") {
        return localize2.ordinalNumber(hours, { unit: "hour" });
      }
      return addLeadingZeros(hours, token.length);
    },
    // Hour [1-24]
    k: function(date, token, localize2) {
      let hours = date.getHours();
      if (hours === 0) hours = 24;
      if (token === "ko") {
        return localize2.ordinalNumber(hours, { unit: "hour" });
      }
      return addLeadingZeros(hours, token.length);
    },
    // Minute
    m: function(date, token, localize2) {
      if (token === "mo") {
        return localize2.ordinalNumber(date.getMinutes(), { unit: "minute" });
      }
      return lightFormatters.m(date, token);
    },
    // Second
    s: function(date, token, localize2) {
      if (token === "so") {
        return localize2.ordinalNumber(date.getSeconds(), { unit: "second" });
      }
      return lightFormatters.s(date, token);
    },
    // Fraction of second
    S: function(date, token) {
      return lightFormatters.S(date, token);
    },
    // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
    X: function(date, token, _localize) {
      const timezoneOffset = date.getTimezoneOffset();
      if (timezoneOffset === 0) {
        return "Z";
      }
      switch (token) {
        // Hours and optional minutes
        case "X":
          return formatTimezoneWithOptionalMinutes(timezoneOffset);
        // Hours, minutes and optional seconds without `:` delimiter
        // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
        // so this token always has the same output as `XX`
        case "XXXX":
        case "XX":
          return formatTimezone(timezoneOffset);
        // Hours, minutes and optional seconds with `:` delimiter
        // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
        // so this token always has the same output as `XXX`
        case "XXXXX":
        case "XXX":
        // Hours and minutes with `:` delimiter
        default:
          return formatTimezone(timezoneOffset, ":");
      }
    },
    // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
    x: function(date, token, _localize) {
      const timezoneOffset = date.getTimezoneOffset();
      switch (token) {
        // Hours and optional minutes
        case "x":
          return formatTimezoneWithOptionalMinutes(timezoneOffset);
        // Hours, minutes and optional seconds without `:` delimiter
        // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
        // so this token always has the same output as `xx`
        case "xxxx":
        case "xx":
          return formatTimezone(timezoneOffset);
        // Hours, minutes and optional seconds with `:` delimiter
        // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
        // so this token always has the same output as `xxx`
        case "xxxxx":
        case "xxx":
        // Hours and minutes with `:` delimiter
        default:
          return formatTimezone(timezoneOffset, ":");
      }
    },
    // Timezone (GMT)
    O: function(date, token, _localize) {
      const timezoneOffset = date.getTimezoneOffset();
      switch (token) {
        // Short
        case "O":
        case "OO":
        case "OOO":
          return "GMT" + formatTimezoneShort(timezoneOffset, ":");
        // Long
        case "OOOO":
        default:
          return "GMT" + formatTimezone(timezoneOffset, ":");
      }
    },
    // Timezone (specific non-location)
    z: function(date, token, _localize) {
      const timezoneOffset = date.getTimezoneOffset();
      switch (token) {
        // Short
        case "z":
        case "zz":
        case "zzz":
          return "GMT" + formatTimezoneShort(timezoneOffset, ":");
        // Long
        case "zzzz":
        default:
          return "GMT" + formatTimezone(timezoneOffset, ":");
      }
    },
    // Seconds timestamp
    t: function(date, token, _localize) {
      const timestamp = Math.trunc(+date / 1e3);
      return addLeadingZeros(timestamp, token.length);
    },
    // Milliseconds timestamp
    T: function(date, token, _localize) {
      return addLeadingZeros(+date, token.length);
    }
  };
  function formatTimezoneShort(offset, delimiter = "") {
    const sign = offset > 0 ? "-" : "+";
    const absOffset = Math.abs(offset);
    const hours = Math.trunc(absOffset / 60);
    const minutes = absOffset % 60;
    if (minutes === 0) {
      return sign + String(hours);
    }
    return sign + String(hours) + delimiter + addLeadingZeros(minutes, 2);
  }
  function formatTimezoneWithOptionalMinutes(offset, delimiter) {
    if (offset % 60 === 0) {
      const sign = offset > 0 ? "-" : "+";
      return sign + addLeadingZeros(Math.abs(offset) / 60, 2);
    }
    return formatTimezone(offset, delimiter);
  }
  function formatTimezone(offset, delimiter = "") {
    const sign = offset > 0 ? "-" : "+";
    const absOffset = Math.abs(offset);
    const hours = addLeadingZeros(Math.trunc(absOffset / 60), 2);
    const minutes = addLeadingZeros(absOffset % 60, 2);
    return sign + hours + delimiter + minutes;
  }
  const dateLongFormatter = (pattern, formatLong2) => {
    switch (pattern) {
      case "P":
        return formatLong2.date({ width: "short" });
      case "PP":
        return formatLong2.date({ width: "medium" });
      case "PPP":
        return formatLong2.date({ width: "long" });
      case "PPPP":
      default:
        return formatLong2.date({ width: "full" });
    }
  };
  const timeLongFormatter = (pattern, formatLong2) => {
    switch (pattern) {
      case "p":
        return formatLong2.time({ width: "short" });
      case "pp":
        return formatLong2.time({ width: "medium" });
      case "ppp":
        return formatLong2.time({ width: "long" });
      case "pppp":
      default:
        return formatLong2.time({ width: "full" });
    }
  };
  const dateTimeLongFormatter = (pattern, formatLong2) => {
    const matchResult = pattern.match(/(P+)(p+)?/) || [];
    const datePattern = matchResult[1];
    const timePattern = matchResult[2];
    if (!timePattern) {
      return dateLongFormatter(pattern, formatLong2);
    }
    let dateTimeFormat;
    switch (datePattern) {
      case "P":
        dateTimeFormat = formatLong2.dateTime({ width: "short" });
        break;
      case "PP":
        dateTimeFormat = formatLong2.dateTime({ width: "medium" });
        break;
      case "PPP":
        dateTimeFormat = formatLong2.dateTime({ width: "long" });
        break;
      case "PPPP":
      default:
        dateTimeFormat = formatLong2.dateTime({ width: "full" });
        break;
    }
    return dateTimeFormat.replace("{{date}}", dateLongFormatter(datePattern, formatLong2)).replace("{{time}}", timeLongFormatter(timePattern, formatLong2));
  };
  const longFormatters = {
    p: timeLongFormatter,
    P: dateTimeLongFormatter
  };
  const dayOfYearTokenRE = /^D+$/;
  const weekYearTokenRE = /^Y+$/;
  const throwTokens = ["D", "DD", "YY", "YYYY"];
  function isProtectedDayOfYearToken(token) {
    return dayOfYearTokenRE.test(token);
  }
  function isProtectedWeekYearToken(token) {
    return weekYearTokenRE.test(token);
  }
  function warnOrThrowProtectedError(token, format2, input) {
    const _message = message(token, format2, input);
    console.warn(_message);
    if (throwTokens.includes(token)) throw new RangeError(_message);
  }
  function message(token, format2, input) {
    const subject = token[0] === "Y" ? "years" : "days of the month";
    return `Use \`${token.toLowerCase()}\` instead of \`${token}\` (in \`${format2}\`) for formatting ${subject} to the input \`${input}\`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md`;
  }
  const formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
  const longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
  const escapedStringRegExp = /^'([^]*?)'?$/;
  const doubleQuoteRegExp = /''/g;
  const unescapedLatinCharacterRegExp = /[a-zA-Z]/;
  function format(date, formatStr, options) {
    const defaultOptions2 = getDefaultOptions();
    const locale = defaultOptions2.locale ?? enUS;
    const firstWeekContainsDate = defaultOptions2.firstWeekContainsDate ?? defaultOptions2.locale?.options?.firstWeekContainsDate ?? 1;
    const weekStartsOn = defaultOptions2.weekStartsOn ?? defaultOptions2.locale?.options?.weekStartsOn ?? 0;
    const originalDate = toDate(date, options?.in);
    if (!isValid(originalDate)) {
      throw new RangeError("Invalid time value");
    }
    let parts = formatStr.match(longFormattingTokensRegExp).map((substring) => {
      const firstCharacter = substring[0];
      if (firstCharacter === "p" || firstCharacter === "P") {
        const longFormatter = longFormatters[firstCharacter];
        return longFormatter(substring, locale.formatLong);
      }
      return substring;
    }).join("").match(formattingTokensRegExp).map((substring) => {
      if (substring === "''") {
        return { isToken: false, value: "'" };
      }
      const firstCharacter = substring[0];
      if (firstCharacter === "'") {
        return { isToken: false, value: cleanEscapedString(substring) };
      }
      if (formatters[firstCharacter]) {
        return { isToken: true, value: substring };
      }
      if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
        throw new RangeError(
          "Format string contains an unescaped latin alphabet character `" + firstCharacter + "`"
        );
      }
      return { isToken: false, value: substring };
    });
    if (locale.localize.preprocessor) {
      parts = locale.localize.preprocessor(originalDate, parts);
    }
    const formatterOptions = {
      firstWeekContainsDate,
      weekStartsOn,
      locale
    };
    return parts.map((part) => {
      if (!part.isToken) return part.value;
      const token = part.value;
      if (isProtectedWeekYearToken(token) || isProtectedDayOfYearToken(token)) {
        warnOrThrowProtectedError(token, formatStr, String(date));
      }
      const formatter = formatters[token[0]];
      return formatter(originalDate, token, locale.localize, formatterOptions);
    }).join("");
  }
  function cleanEscapedString(input) {
    const matched = input.match(escapedStringRegExp);
    if (!matched) {
      return input;
    }
    return matched[1].replace(doubleQuoteRegExp, "'");
  }
  var handlebars = { exports: {} };
  var handlebars_runtime = { exports: {} };
  var base$1 = {};
  var utils = {};
  var hasRequiredUtils;
  function requireUtils() {
    if (hasRequiredUtils) return utils;
    hasRequiredUtils = 1;
    utils.__esModule = true;
    utils.extend = extend;
    utils.indexOf = indexOf;
    utils.escapeExpression = escapeExpression;
    utils.isEmpty = isEmpty;
    utils.createFrame = createFrame;
    utils.blockParams = blockParams;
    utils.appendContextPath = appendContextPath;
    var escape = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#x27;",
      "`": "&#x60;",
      "=": "&#x3D;"
    };
    var badChars = /[&<>"'`=]/g, possible = /[&<>"'`=]/;
    function escapeChar(chr) {
      return escape[chr];
    }
    function extend(obj) {
      for (var i = 1; i < arguments.length; i++) {
        for (var key in arguments[i]) {
          if (Object.prototype.hasOwnProperty.call(arguments[i], key)) {
            obj[key] = arguments[i][key];
          }
        }
      }
      return obj;
    }
    var toString2 = Object.prototype.toString;
    utils.toString = toString2;
    var isFunction = function isFunction2(value) {
      return typeof value === "function";
    };
    if (isFunction(/x/)) {
      utils.isFunction = isFunction = function(value) {
        return typeof value === "function" && toString2.call(value) === "[object Function]";
      };
    }
    utils.isFunction = isFunction;
    var isArray = Array.isArray || function(value) {
      return value && typeof value === "object" ? toString2.call(value) === "[object Array]" : false;
    };
    utils.isArray = isArray;
    function indexOf(array, value) {
      for (var i = 0, len = array.length; i < len; i++) {
        if (array[i] === value) {
          return i;
        }
      }
      return -1;
    }
    function escapeExpression(string2) {
      if (typeof string2 !== "string") {
        if (string2 && string2.toHTML) {
          return string2.toHTML();
        } else if (string2 == null) {
          return "";
        } else if (!string2) {
          return string2 + "";
        }
        string2 = "" + string2;
      }
      if (!possible.test(string2)) {
        return string2;
      }
      return string2.replace(badChars, escapeChar);
    }
    function isEmpty(value) {
      if (!value && value !== 0) {
        return true;
      } else if (isArray(value) && value.length === 0) {
        return true;
      } else {
        return false;
      }
    }
    function createFrame(object) {
      var frame = extend({}, object);
      frame._parent = object;
      return frame;
    }
    function blockParams(params, ids) {
      params.path = ids;
      return params;
    }
    function appendContextPath(contextPath, id) {
      return (contextPath ? contextPath + "." : "") + id;
    }
    return utils;
  }
  var exception = { exports: {} };
  var hasRequiredException;
  function requireException() {
    if (hasRequiredException) return exception.exports;
    hasRequiredException = 1;
    (function(module, exports$1) {
      exports$1.__esModule = true;
      var errorProps = ["description", "fileName", "lineNumber", "endLineNumber", "message", "name", "number", "stack"];
      function Exception(message2, node) {
        var loc = node && node.loc, line = void 0, endLineNumber = void 0, column = void 0, endColumn = void 0;
        if (loc) {
          line = loc.start.line;
          endLineNumber = loc.end.line;
          column = loc.start.column;
          endColumn = loc.end.column;
          message2 += " - " + line + ":" + column;
        }
        var tmp = Error.prototype.constructor.call(this, message2);
        for (var idx = 0; idx < errorProps.length; idx++) {
          this[errorProps[idx]] = tmp[errorProps[idx]];
        }
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, Exception);
        }
        try {
          if (loc) {
            this.lineNumber = line;
            this.endLineNumber = endLineNumber;
            if (Object.defineProperty) {
              Object.defineProperty(this, "column", {
                value: column,
                enumerable: true
              });
              Object.defineProperty(this, "endColumn", {
                value: endColumn,
                enumerable: true
              });
            } else {
              this.column = column;
              this.endColumn = endColumn;
            }
          }
        } catch (nop) {
        }
      }
      Exception.prototype = new Error();
      exports$1["default"] = Exception;
      module.exports = exports$1["default"];
    })(exception, exception.exports);
    return exception.exports;
  }
  var helpers$1 = {};
  var blockHelperMissing = { exports: {} };
  var hasRequiredBlockHelperMissing;
  function requireBlockHelperMissing() {
    if (hasRequiredBlockHelperMissing) return blockHelperMissing.exports;
    hasRequiredBlockHelperMissing = 1;
    (function(module, exports$1) {
      exports$1.__esModule = true;
      var _utils = requireUtils();
      exports$1["default"] = function(instance2) {
        instance2.registerHelper("blockHelperMissing", function(context, options) {
          var inverse = options.inverse, fn = options.fn;
          if (context === true) {
            return fn(this);
          } else if (context === false || context == null) {
            return inverse(this);
          } else if (_utils.isArray(context)) {
            if (context.length > 0) {
              if (options.ids) {
                options.ids = [options.name];
              }
              return instance2.helpers.each(context, options);
            } else {
              return inverse(this);
            }
          } else {
            if (options.data && options.ids) {
              var data = _utils.createFrame(options.data);
              data.contextPath = _utils.appendContextPath(options.data.contextPath, options.name);
              options = { data };
            }
            return fn(context, options);
          }
        });
      };
      module.exports = exports$1["default"];
    })(blockHelperMissing, blockHelperMissing.exports);
    return blockHelperMissing.exports;
  }
  var each = { exports: {} };
  var hasRequiredEach;
  function requireEach() {
    if (hasRequiredEach) return each.exports;
    hasRequiredEach = 1;
    (function(module, exports$1) {
      exports$1.__esModule = true;
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var _utils = requireUtils();
      var _exception = requireException();
      var _exception2 = _interopRequireDefault(_exception);
      exports$1["default"] = function(instance2) {
        instance2.registerHelper("each", function(context, options) {
          if (!options) {
            throw new _exception2["default"]("Must pass iterator to #each");
          }
          var fn = options.fn, inverse = options.inverse, i = 0, ret = "", data = void 0, contextPath = void 0;
          if (options.data && options.ids) {
            contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]) + ".";
          }
          if (_utils.isFunction(context)) {
            context = context.call(this);
          }
          if (options.data) {
            data = _utils.createFrame(options.data);
          }
          function execIteration(field, index, last) {
            if (data) {
              data.key = field;
              data.index = index;
              data.first = index === 0;
              data.last = !!last;
              if (contextPath) {
                data.contextPath = contextPath + field;
              }
            }
            ret = ret + fn(context[field], {
              data,
              blockParams: _utils.blockParams([context[field], field], [contextPath + field, null])
            });
          }
          if (context && typeof context === "object") {
            if (_utils.isArray(context)) {
              for (var j = context.length; i < j; i++) {
                if (i in context) {
                  execIteration(i, i, i === context.length - 1);
                }
              }
            } else if (typeof Symbol === "function" && context[Symbol.iterator]) {
              var newContext = [];
              var iterator = context[Symbol.iterator]();
              for (var it = iterator.next(); !it.done; it = iterator.next()) {
                newContext.push(it.value);
              }
              context = newContext;
              for (var j = context.length; i < j; i++) {
                execIteration(i, i, i === context.length - 1);
              }
            } else {
              (function() {
                var priorKey = void 0;
                Object.keys(context).forEach(function(key) {
                  if (priorKey !== void 0) {
                    execIteration(priorKey, i - 1);
                  }
                  priorKey = key;
                  i++;
                });
                if (priorKey !== void 0) {
                  execIteration(priorKey, i - 1, true);
                }
              })();
            }
          }
          if (i === 0) {
            ret = inverse(this);
          }
          return ret;
        });
      };
      module.exports = exports$1["default"];
    })(each, each.exports);
    return each.exports;
  }
  var helperMissing = { exports: {} };
  var hasRequiredHelperMissing;
  function requireHelperMissing() {
    if (hasRequiredHelperMissing) return helperMissing.exports;
    hasRequiredHelperMissing = 1;
    (function(module, exports$1) {
      exports$1.__esModule = true;
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var _exception = requireException();
      var _exception2 = _interopRequireDefault(_exception);
      exports$1["default"] = function(instance2) {
        instance2.registerHelper("helperMissing", function() {
          if (arguments.length === 1) {
            return void 0;
          } else {
            throw new _exception2["default"]('Missing helper: "' + arguments[arguments.length - 1].name + '"');
          }
        });
      };
      module.exports = exports$1["default"];
    })(helperMissing, helperMissing.exports);
    return helperMissing.exports;
  }
  var _if = { exports: {} };
  var hasRequired_if;
  function require_if() {
    if (hasRequired_if) return _if.exports;
    hasRequired_if = 1;
    (function(module, exports$1) {
      exports$1.__esModule = true;
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var _utils = requireUtils();
      var _exception = requireException();
      var _exception2 = _interopRequireDefault(_exception);
      exports$1["default"] = function(instance2) {
        instance2.registerHelper("if", function(conditional, options) {
          if (arguments.length != 2) {
            throw new _exception2["default"]("#if requires exactly one argument");
          }
          if (_utils.isFunction(conditional)) {
            conditional = conditional.call(this);
          }
          if (!options.hash.includeZero && !conditional || _utils.isEmpty(conditional)) {
            return options.inverse(this);
          } else {
            return options.fn(this);
          }
        });
        instance2.registerHelper("unless", function(conditional, options) {
          if (arguments.length != 2) {
            throw new _exception2["default"]("#unless requires exactly one argument");
          }
          return instance2.helpers["if"].call(this, conditional, {
            fn: options.inverse,
            inverse: options.fn,
            hash: options.hash
          });
        });
      };
      module.exports = exports$1["default"];
    })(_if, _if.exports);
    return _if.exports;
  }
  var log = { exports: {} };
  var hasRequiredLog;
  function requireLog() {
    if (hasRequiredLog) return log.exports;
    hasRequiredLog = 1;
    (function(module, exports$1) {
      exports$1.__esModule = true;
      exports$1["default"] = function(instance2) {
        instance2.registerHelper("log", function() {
          var args = [void 0], options = arguments[arguments.length - 1];
          for (var i = 0; i < arguments.length - 1; i++) {
            args.push(arguments[i]);
          }
          var level = 1;
          if (options.hash.level != null) {
            level = options.hash.level;
          } else if (options.data && options.data.level != null) {
            level = options.data.level;
          }
          args[0] = level;
          instance2.log.apply(instance2, args);
        });
      };
      module.exports = exports$1["default"];
    })(log, log.exports);
    return log.exports;
  }
  var lookup = { exports: {} };
  var hasRequiredLookup;
  function requireLookup() {
    if (hasRequiredLookup) return lookup.exports;
    hasRequiredLookup = 1;
    (function(module, exports$1) {
      exports$1.__esModule = true;
      exports$1["default"] = function(instance2) {
        instance2.registerHelper("lookup", function(obj, field, options) {
          if (!obj) {
            return obj;
          }
          return options.lookupProperty(obj, field);
        });
      };
      module.exports = exports$1["default"];
    })(lookup, lookup.exports);
    return lookup.exports;
  }
  var _with = { exports: {} };
  var hasRequired_with;
  function require_with() {
    if (hasRequired_with) return _with.exports;
    hasRequired_with = 1;
    (function(module, exports$1) {
      exports$1.__esModule = true;
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var _utils = requireUtils();
      var _exception = requireException();
      var _exception2 = _interopRequireDefault(_exception);
      exports$1["default"] = function(instance2) {
        instance2.registerHelper("with", function(context, options) {
          if (arguments.length != 2) {
            throw new _exception2["default"]("#with requires exactly one argument");
          }
          if (_utils.isFunction(context)) {
            context = context.call(this);
          }
          var fn = options.fn;
          if (!_utils.isEmpty(context)) {
            var data = options.data;
            if (options.data && options.ids) {
              data = _utils.createFrame(options.data);
              data.contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]);
            }
            return fn(context, {
              data,
              blockParams: _utils.blockParams([context], [data && data.contextPath])
            });
          } else {
            return options.inverse(this);
          }
        });
      };
      module.exports = exports$1["default"];
    })(_with, _with.exports);
    return _with.exports;
  }
  var hasRequiredHelpers$1;
  function requireHelpers$1() {
    if (hasRequiredHelpers$1) return helpers$1;
    hasRequiredHelpers$1 = 1;
    helpers$1.__esModule = true;
    helpers$1.registerDefaultHelpers = registerDefaultHelpers;
    helpers$1.moveHelperToHooks = moveHelperToHooks;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var _helpersBlockHelperMissing = requireBlockHelperMissing();
    var _helpersBlockHelperMissing2 = _interopRequireDefault(_helpersBlockHelperMissing);
    var _helpersEach = requireEach();
    var _helpersEach2 = _interopRequireDefault(_helpersEach);
    var _helpersHelperMissing = requireHelperMissing();
    var _helpersHelperMissing2 = _interopRequireDefault(_helpersHelperMissing);
    var _helpersIf = require_if();
    var _helpersIf2 = _interopRequireDefault(_helpersIf);
    var _helpersLog = requireLog();
    var _helpersLog2 = _interopRequireDefault(_helpersLog);
    var _helpersLookup = requireLookup();
    var _helpersLookup2 = _interopRequireDefault(_helpersLookup);
    var _helpersWith = require_with();
    var _helpersWith2 = _interopRequireDefault(_helpersWith);
    function registerDefaultHelpers(instance2) {
      _helpersBlockHelperMissing2["default"](instance2);
      _helpersEach2["default"](instance2);
      _helpersHelperMissing2["default"](instance2);
      _helpersIf2["default"](instance2);
      _helpersLog2["default"](instance2);
      _helpersLookup2["default"](instance2);
      _helpersWith2["default"](instance2);
    }
    function moveHelperToHooks(instance2, helperName, keepHelper) {
      if (instance2.helpers[helperName]) {
        instance2.hooks[helperName] = instance2.helpers[helperName];
        if (!keepHelper) {
          delete instance2.helpers[helperName];
        }
      }
    }
    return helpers$1;
  }
  var decorators = {};
  var inline = { exports: {} };
  var hasRequiredInline;
  function requireInline() {
    if (hasRequiredInline) return inline.exports;
    hasRequiredInline = 1;
    (function(module, exports$1) {
      exports$1.__esModule = true;
      var _utils = requireUtils();
      exports$1["default"] = function(instance2) {
        instance2.registerDecorator("inline", function(fn, props, container, options) {
          var ret = fn;
          if (!props.partials) {
            props.partials = {};
            ret = function(context, options2) {
              var original = container.partials;
              container.partials = _utils.extend({}, original, props.partials);
              var ret2 = fn(context, options2);
              container.partials = original;
              return ret2;
            };
          }
          props.partials[options.args[0]] = options.fn;
          return ret;
        });
      };
      module.exports = exports$1["default"];
    })(inline, inline.exports);
    return inline.exports;
  }
  var hasRequiredDecorators;
  function requireDecorators() {
    if (hasRequiredDecorators) return decorators;
    hasRequiredDecorators = 1;
    decorators.__esModule = true;
    decorators.registerDefaultDecorators = registerDefaultDecorators;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var _decoratorsInline = requireInline();
    var _decoratorsInline2 = _interopRequireDefault(_decoratorsInline);
    function registerDefaultDecorators(instance2) {
      _decoratorsInline2["default"](instance2);
    }
    return decorators;
  }
  var logger = { exports: {} };
  var hasRequiredLogger;
  function requireLogger() {
    if (hasRequiredLogger) return logger.exports;
    hasRequiredLogger = 1;
    (function(module, exports$1) {
      exports$1.__esModule = true;
      var _utils = requireUtils();
      var logger2 = {
        methodMap: ["debug", "info", "warn", "error"],
        level: "info",
        // Maps a given level value to the `methodMap` indexes above.
        lookupLevel: function lookupLevel(level) {
          if (typeof level === "string") {
            var levelMap = _utils.indexOf(logger2.methodMap, level.toLowerCase());
            if (levelMap >= 0) {
              level = levelMap;
            } else {
              level = parseInt(level, 10);
            }
          }
          return level;
        },
        // Can be overridden in the host environment
        log: function log2(level) {
          level = logger2.lookupLevel(level);
          if (typeof console !== "undefined" && logger2.lookupLevel(logger2.level) <= level) {
            var method = logger2.methodMap[level];
            if (!console[method]) {
              method = "log";
            }
            for (var _len = arguments.length, message2 = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              message2[_key - 1] = arguments[_key];
            }
            console[method].apply(console, message2);
          }
        }
      };
      exports$1["default"] = logger2;
      module.exports = exports$1["default"];
    })(logger, logger.exports);
    return logger.exports;
  }
  var protoAccess = {};
  var createNewLookupObject = {};
  var hasRequiredCreateNewLookupObject;
  function requireCreateNewLookupObject() {
    if (hasRequiredCreateNewLookupObject) return createNewLookupObject;
    hasRequiredCreateNewLookupObject = 1;
    createNewLookupObject.__esModule = true;
    createNewLookupObject.createNewLookupObject = createNewLookupObject$1;
    var _utils = requireUtils();
    function createNewLookupObject$1() {
      for (var _len = arguments.length, sources = Array(_len), _key = 0; _key < _len; _key++) {
        sources[_key] = arguments[_key];
      }
      return _utils.extend.apply(void 0, [/* @__PURE__ */ Object.create(null)].concat(sources));
    }
    return createNewLookupObject;
  }
  var hasRequiredProtoAccess;
  function requireProtoAccess() {
    if (hasRequiredProtoAccess) return protoAccess;
    hasRequiredProtoAccess = 1;
    protoAccess.__esModule = true;
    protoAccess.createProtoAccessControl = createProtoAccessControl;
    protoAccess.resultIsAllowed = resultIsAllowed;
    protoAccess.resetLoggedProperties = resetLoggedProperties;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var _createNewLookupObject = requireCreateNewLookupObject();
    var _logger = requireLogger();
    var _logger2 = _interopRequireDefault(_logger);
    var loggedProperties = /* @__PURE__ */ Object.create(null);
    function createProtoAccessControl(runtimeOptions) {
      var defaultMethodWhiteList = /* @__PURE__ */ Object.create(null);
      defaultMethodWhiteList["constructor"] = false;
      defaultMethodWhiteList["__defineGetter__"] = false;
      defaultMethodWhiteList["__defineSetter__"] = false;
      defaultMethodWhiteList["__lookupGetter__"] = false;
      var defaultPropertyWhiteList = /* @__PURE__ */ Object.create(null);
      defaultPropertyWhiteList["__proto__"] = false;
      return {
        properties: {
          whitelist: _createNewLookupObject.createNewLookupObject(defaultPropertyWhiteList, runtimeOptions.allowedProtoProperties),
          defaultValue: runtimeOptions.allowProtoPropertiesByDefault
        },
        methods: {
          whitelist: _createNewLookupObject.createNewLookupObject(defaultMethodWhiteList, runtimeOptions.allowedProtoMethods),
          defaultValue: runtimeOptions.allowProtoMethodsByDefault
        }
      };
    }
    function resultIsAllowed(result, protoAccessControl, propertyName) {
      if (typeof result === "function") {
        return checkWhiteList(protoAccessControl.methods, propertyName);
      } else {
        return checkWhiteList(protoAccessControl.properties, propertyName);
      }
    }
    function checkWhiteList(protoAccessControlForType, propertyName) {
      if (protoAccessControlForType.whitelist[propertyName] !== void 0) {
        return protoAccessControlForType.whitelist[propertyName] === true;
      }
      if (protoAccessControlForType.defaultValue !== void 0) {
        return protoAccessControlForType.defaultValue;
      }
      logUnexpecedPropertyAccessOnce(propertyName);
      return false;
    }
    function logUnexpecedPropertyAccessOnce(propertyName) {
      if (loggedProperties[propertyName] !== true) {
        loggedProperties[propertyName] = true;
        _logger2["default"].log("error", 'Handlebars: Access has been denied to resolve the property "' + propertyName + '" because it is not an "own property" of its parent.\nYou can add a runtime option to disable the check or this warning:\nSee https://handlebarsjs.com/api-reference/runtime-options.html#options-to-control-prototype-access for details');
      }
    }
    function resetLoggedProperties() {
      Object.keys(loggedProperties).forEach(function(propertyName) {
        delete loggedProperties[propertyName];
      });
    }
    return protoAccess;
  }
  var hasRequiredBase$1;
  function requireBase$1() {
    if (hasRequiredBase$1) return base$1;
    hasRequiredBase$1 = 1;
    base$1.__esModule = true;
    base$1.HandlebarsEnvironment = HandlebarsEnvironment;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var _utils = requireUtils();
    var _exception = requireException();
    var _exception2 = _interopRequireDefault(_exception);
    var _helpers = requireHelpers$1();
    var _decorators = requireDecorators();
    var _logger = requireLogger();
    var _logger2 = _interopRequireDefault(_logger);
    var _internalProtoAccess = requireProtoAccess();
    var VERSION = "4.7.8";
    base$1.VERSION = VERSION;
    var COMPILER_REVISION = 8;
    base$1.COMPILER_REVISION = COMPILER_REVISION;
    var LAST_COMPATIBLE_COMPILER_REVISION = 7;
    base$1.LAST_COMPATIBLE_COMPILER_REVISION = LAST_COMPATIBLE_COMPILER_REVISION;
    var REVISION_CHANGES = {
      1: "<= 1.0.rc.2",
      // 1.0.rc.2 is actually rev2 but doesn't report it
      2: "== 1.0.0-rc.3",
      3: "== 1.0.0-rc.4",
      4: "== 1.x.x",
      5: "== 2.0.0-alpha.x",
      6: ">= 2.0.0-beta.1",
      7: ">= 4.0.0 <4.3.0",
      8: ">= 4.3.0"
    };
    base$1.REVISION_CHANGES = REVISION_CHANGES;
    var objectType = "[object Object]";
    function HandlebarsEnvironment(helpers2, partials, decorators2) {
      this.helpers = helpers2 || {};
      this.partials = partials || {};
      this.decorators = decorators2 || {};
      _helpers.registerDefaultHelpers(this);
      _decorators.registerDefaultDecorators(this);
    }
    HandlebarsEnvironment.prototype = {
      constructor: HandlebarsEnvironment,
      logger: _logger2["default"],
      log: _logger2["default"].log,
      registerHelper: function registerHelper(name, fn) {
        if (_utils.toString.call(name) === objectType) {
          if (fn) {
            throw new _exception2["default"]("Arg not supported with multiple helpers");
          }
          _utils.extend(this.helpers, name);
        } else {
          this.helpers[name] = fn;
        }
      },
      unregisterHelper: function unregisterHelper(name) {
        delete this.helpers[name];
      },
      registerPartial: function registerPartial(name, partial) {
        if (_utils.toString.call(name) === objectType) {
          _utils.extend(this.partials, name);
        } else {
          if (typeof partial === "undefined") {
            throw new _exception2["default"]('Attempting to register a partial called "' + name + '" as undefined');
          }
          this.partials[name] = partial;
        }
      },
      unregisterPartial: function unregisterPartial(name) {
        delete this.partials[name];
      },
      registerDecorator: function registerDecorator(name, fn) {
        if (_utils.toString.call(name) === objectType) {
          if (fn) {
            throw new _exception2["default"]("Arg not supported with multiple decorators");
          }
          _utils.extend(this.decorators, name);
        } else {
          this.decorators[name] = fn;
        }
      },
      unregisterDecorator: function unregisterDecorator(name) {
        delete this.decorators[name];
      },
      /**
       * Reset the memory of illegal property accesses that have already been logged.
       * @deprecated should only be used in handlebars test-cases
       */
      resetLoggedPropertyAccesses: function resetLoggedPropertyAccesses() {
        _internalProtoAccess.resetLoggedProperties();
      }
    };
    var log2 = _logger2["default"].log;
    base$1.log = log2;
    base$1.createFrame = _utils.createFrame;
    base$1.logger = _logger2["default"];
    return base$1;
  }
  var safeString = { exports: {} };
  var hasRequiredSafeString;
  function requireSafeString() {
    if (hasRequiredSafeString) return safeString.exports;
    hasRequiredSafeString = 1;
    (function(module, exports$1) {
      exports$1.__esModule = true;
      function SafeString(string2) {
        this.string = string2;
      }
      SafeString.prototype.toString = SafeString.prototype.toHTML = function() {
        return "" + this.string;
      };
      exports$1["default"] = SafeString;
      module.exports = exports$1["default"];
    })(safeString, safeString.exports);
    return safeString.exports;
  }
  var runtime = {};
  var wrapHelper = {};
  var hasRequiredWrapHelper;
  function requireWrapHelper() {
    if (hasRequiredWrapHelper) return wrapHelper;
    hasRequiredWrapHelper = 1;
    wrapHelper.__esModule = true;
    wrapHelper.wrapHelper = wrapHelper$1;
    function wrapHelper$1(helper, transformOptionsFn) {
      if (typeof helper !== "function") {
        return helper;
      }
      var wrapper = function wrapper2() {
        var options = arguments[arguments.length - 1];
        arguments[arguments.length - 1] = transformOptionsFn(options);
        return helper.apply(this, arguments);
      };
      return wrapper;
    }
    return wrapHelper;
  }
  var hasRequiredRuntime;
  function requireRuntime() {
    if (hasRequiredRuntime) return runtime;
    hasRequiredRuntime = 1;
    runtime.__esModule = true;
    runtime.checkRevision = checkRevision;
    runtime.template = template;
    runtime.wrapProgram = wrapProgram;
    runtime.resolvePartial = resolvePartial;
    runtime.invokePartial = invokePartial;
    runtime.noop = noop;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
          }
        }
        newObj["default"] = obj;
        return newObj;
      }
    }
    var _utils = requireUtils();
    var Utils = _interopRequireWildcard(_utils);
    var _exception = requireException();
    var _exception2 = _interopRequireDefault(_exception);
    var _base = requireBase$1();
    var _helpers = requireHelpers$1();
    var _internalWrapHelper = requireWrapHelper();
    var _internalProtoAccess = requireProtoAccess();
    function checkRevision(compilerInfo) {
      var compilerRevision = compilerInfo && compilerInfo[0] || 1, currentRevision = _base.COMPILER_REVISION;
      if (compilerRevision >= _base.LAST_COMPATIBLE_COMPILER_REVISION && compilerRevision <= _base.COMPILER_REVISION) {
        return;
      }
      if (compilerRevision < _base.LAST_COMPATIBLE_COMPILER_REVISION) {
        var runtimeVersions = _base.REVISION_CHANGES[currentRevision], compilerVersions = _base.REVISION_CHANGES[compilerRevision];
        throw new _exception2["default"]("Template was precompiled with an older version of Handlebars than the current runtime. Please update your precompiler to a newer version (" + runtimeVersions + ") or downgrade your runtime to an older version (" + compilerVersions + ").");
      } else {
        throw new _exception2["default"]("Template was precompiled with a newer version of Handlebars than the current runtime. Please update your runtime to a newer version (" + compilerInfo[1] + ").");
      }
    }
    function template(templateSpec, env) {
      if (!env) {
        throw new _exception2["default"]("No environment passed to template");
      }
      if (!templateSpec || !templateSpec.main) {
        throw new _exception2["default"]("Unknown template object: " + typeof templateSpec);
      }
      templateSpec.main.decorator = templateSpec.main_d;
      env.VM.checkRevision(templateSpec.compiler);
      var templateWasPrecompiledWithCompilerV7 = templateSpec.compiler && templateSpec.compiler[0] === 7;
      function invokePartialWrapper(partial, context, options) {
        if (options.hash) {
          context = Utils.extend({}, context, options.hash);
          if (options.ids) {
            options.ids[0] = true;
          }
        }
        partial = env.VM.resolvePartial.call(this, partial, context, options);
        var extendedOptions = Utils.extend({}, options, {
          hooks: this.hooks,
          protoAccessControl: this.protoAccessControl
        });
        var result = env.VM.invokePartial.call(this, partial, context, extendedOptions);
        if (result == null && env.compile) {
          options.partials[options.name] = env.compile(partial, templateSpec.compilerOptions, env);
          result = options.partials[options.name](context, extendedOptions);
        }
        if (result != null) {
          if (options.indent) {
            var lines = result.split("\n");
            for (var i = 0, l = lines.length; i < l; i++) {
              if (!lines[i] && i + 1 === l) {
                break;
              }
              lines[i] = options.indent + lines[i];
            }
            result = lines.join("\n");
          }
          return result;
        } else {
          throw new _exception2["default"]("The partial " + options.name + " could not be compiled when running in runtime-only mode");
        }
      }
      var container = {
        strict: function strict(obj, name, loc) {
          if (!obj || !(name in obj)) {
            throw new _exception2["default"]('"' + name + '" not defined in ' + obj, {
              loc
            });
          }
          return container.lookupProperty(obj, name);
        },
        lookupProperty: function lookupProperty(parent, propertyName) {
          var result = parent[propertyName];
          if (result == null) {
            return result;
          }
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return result;
          }
          if (_internalProtoAccess.resultIsAllowed(result, container.protoAccessControl, propertyName)) {
            return result;
          }
          return void 0;
        },
        lookup: function lookup2(depths, name) {
          var len = depths.length;
          for (var i = 0; i < len; i++) {
            var result = depths[i] && container.lookupProperty(depths[i], name);
            if (result != null) {
              return depths[i][name];
            }
          }
        },
        lambda: function lambda(current, context) {
          return typeof current === "function" ? current.call(context) : current;
        },
        escapeExpression: Utils.escapeExpression,
        invokePartial: invokePartialWrapper,
        fn: function fn(i) {
          var ret2 = templateSpec[i];
          ret2.decorator = templateSpec[i + "_d"];
          return ret2;
        },
        programs: [],
        program: function program(i, data, declaredBlockParams, blockParams, depths) {
          var programWrapper = this.programs[i], fn = this.fn(i);
          if (data || depths || blockParams || declaredBlockParams) {
            programWrapper = wrapProgram(this, i, fn, data, declaredBlockParams, blockParams, depths);
          } else if (!programWrapper) {
            programWrapper = this.programs[i] = wrapProgram(this, i, fn);
          }
          return programWrapper;
        },
        data: function data(value, depth) {
          while (value && depth--) {
            value = value._parent;
          }
          return value;
        },
        mergeIfNeeded: function mergeIfNeeded(param, common) {
          var obj = param || common;
          if (param && common && param !== common) {
            obj = Utils.extend({}, common, param);
          }
          return obj;
        },
        // An empty object to use as replacement for null-contexts
        nullContext: Object.seal({}),
        noop: env.VM.noop,
        compilerInfo: templateSpec.compiler
      };
      function ret(context) {
        var options = arguments.length <= 1 || arguments[1] === void 0 ? {} : arguments[1];
        var data = options.data;
        ret._setup(options);
        if (!options.partial && templateSpec.useData) {
          data = initData(context, data);
        }
        var depths = void 0, blockParams = templateSpec.useBlockParams ? [] : void 0;
        if (templateSpec.useDepths) {
          if (options.depths) {
            depths = context != options.depths[0] ? [context].concat(options.depths) : options.depths;
          } else {
            depths = [context];
          }
        }
        function main(context2) {
          return "" + templateSpec.main(container, context2, container.helpers, container.partials, data, blockParams, depths);
        }
        main = executeDecorators(templateSpec.main, main, container, options.depths || [], data, blockParams);
        return main(context, options);
      }
      ret.isTop = true;
      ret._setup = function(options) {
        if (!options.partial) {
          var mergedHelpers = Utils.extend({}, env.helpers, options.helpers);
          wrapHelpersToPassLookupProperty(mergedHelpers, container);
          container.helpers = mergedHelpers;
          if (templateSpec.usePartial) {
            container.partials = container.mergeIfNeeded(options.partials, env.partials);
          }
          if (templateSpec.usePartial || templateSpec.useDecorators) {
            container.decorators = Utils.extend({}, env.decorators, options.decorators);
          }
          container.hooks = {};
          container.protoAccessControl = _internalProtoAccess.createProtoAccessControl(options);
          var keepHelperInHelpers = options.allowCallsToHelperMissing || templateWasPrecompiledWithCompilerV7;
          _helpers.moveHelperToHooks(container, "helperMissing", keepHelperInHelpers);
          _helpers.moveHelperToHooks(container, "blockHelperMissing", keepHelperInHelpers);
        } else {
          container.protoAccessControl = options.protoAccessControl;
          container.helpers = options.helpers;
          container.partials = options.partials;
          container.decorators = options.decorators;
          container.hooks = options.hooks;
        }
      };
      ret._child = function(i, data, blockParams, depths) {
        if (templateSpec.useBlockParams && !blockParams) {
          throw new _exception2["default"]("must pass block params");
        }
        if (templateSpec.useDepths && !depths) {
          throw new _exception2["default"]("must pass parent depths");
        }
        return wrapProgram(container, i, templateSpec[i], data, 0, blockParams, depths);
      };
      return ret;
    }
    function wrapProgram(container, i, fn, data, declaredBlockParams, blockParams, depths) {
      function prog(context) {
        var options = arguments.length <= 1 || arguments[1] === void 0 ? {} : arguments[1];
        var currentDepths = depths;
        if (depths && context != depths[0] && !(context === container.nullContext && depths[0] === null)) {
          currentDepths = [context].concat(depths);
        }
        return fn(container, context, container.helpers, container.partials, options.data || data, blockParams && [options.blockParams].concat(blockParams), currentDepths);
      }
      prog = executeDecorators(fn, prog, container, depths, data, blockParams);
      prog.program = i;
      prog.depth = depths ? depths.length : 0;
      prog.blockParams = declaredBlockParams || 0;
      return prog;
    }
    function resolvePartial(partial, context, options) {
      if (!partial) {
        if (options.name === "@partial-block") {
          partial = options.data["partial-block"];
        } else {
          partial = options.partials[options.name];
        }
      } else if (!partial.call && !options.name) {
        options.name = partial;
        partial = options.partials[partial];
      }
      return partial;
    }
    function invokePartial(partial, context, options) {
      var currentPartialBlock = options.data && options.data["partial-block"];
      options.partial = true;
      if (options.ids) {
        options.data.contextPath = options.ids[0] || options.data.contextPath;
      }
      var partialBlock = void 0;
      if (options.fn && options.fn !== noop) {
        (function() {
          options.data = _base.createFrame(options.data);
          var fn = options.fn;
          partialBlock = options.data["partial-block"] = function partialBlockWrapper(context2) {
            var options2 = arguments.length <= 1 || arguments[1] === void 0 ? {} : arguments[1];
            options2.data = _base.createFrame(options2.data);
            options2.data["partial-block"] = currentPartialBlock;
            return fn(context2, options2);
          };
          if (fn.partials) {
            options.partials = Utils.extend({}, options.partials, fn.partials);
          }
        })();
      }
      if (partial === void 0 && partialBlock) {
        partial = partialBlock;
      }
      if (partial === void 0) {
        throw new _exception2["default"]("The partial " + options.name + " could not be found");
      } else if (partial instanceof Function) {
        return partial(context, options);
      }
    }
    function noop() {
      return "";
    }
    function initData(context, data) {
      if (!data || !("root" in data)) {
        data = data ? _base.createFrame(data) : {};
        data.root = context;
      }
      return data;
    }
    function executeDecorators(fn, prog, container, depths, data, blockParams) {
      if (fn.decorator) {
        var props = {};
        prog = fn.decorator(prog, props, container, depths && depths[0], data, blockParams, depths);
        Utils.extend(prog, props);
      }
      return prog;
    }
    function wrapHelpersToPassLookupProperty(mergedHelpers, container) {
      Object.keys(mergedHelpers).forEach(function(helperName) {
        var helper = mergedHelpers[helperName];
        mergedHelpers[helperName] = passLookupPropertyOption(helper, container);
      });
    }
    function passLookupPropertyOption(helper, container) {
      var lookupProperty = container.lookupProperty;
      return _internalWrapHelper.wrapHelper(helper, function(options) {
        return Utils.extend({ lookupProperty }, options);
      });
    }
    return runtime;
  }
  var noConflict = { exports: {} };
  var hasRequiredNoConflict;
  function requireNoConflict() {
    if (hasRequiredNoConflict) return noConflict.exports;
    hasRequiredNoConflict = 1;
    (function(module, exports$1) {
      exports$1.__esModule = true;
      exports$1["default"] = function(Handlebars2) {
        (function() {
          if (typeof globalThis === "object") return;
          Object.prototype.__defineGetter__("__magic__", function() {
            return this;
          });
          __magic__.globalThis = __magic__;
          delete Object.prototype.__magic__;
        })();
        var $Handlebars = globalThis.Handlebars;
        Handlebars2.noConflict = function() {
          if (globalThis.Handlebars === Handlebars2) {
            globalThis.Handlebars = $Handlebars;
          }
          return Handlebars2;
        };
      };
      module.exports = exports$1["default"];
    })(noConflict, noConflict.exports);
    return noConflict.exports;
  }
  var hasRequiredHandlebars_runtime;
  function requireHandlebars_runtime() {
    if (hasRequiredHandlebars_runtime) return handlebars_runtime.exports;
    hasRequiredHandlebars_runtime = 1;
    (function(module, exports$1) {
      exports$1.__esModule = true;
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _interopRequireWildcard(obj) {
        if (obj && obj.__esModule) {
          return obj;
        } else {
          var newObj = {};
          if (obj != null) {
            for (var key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
            }
          }
          newObj["default"] = obj;
          return newObj;
        }
      }
      var _handlebarsBase = requireBase$1();
      var base3 = _interopRequireWildcard(_handlebarsBase);
      var _handlebarsSafeString = requireSafeString();
      var _handlebarsSafeString2 = _interopRequireDefault(_handlebarsSafeString);
      var _handlebarsException = requireException();
      var _handlebarsException2 = _interopRequireDefault(_handlebarsException);
      var _handlebarsUtils = requireUtils();
      var Utils = _interopRequireWildcard(_handlebarsUtils);
      var _handlebarsRuntime = requireRuntime();
      var runtime2 = _interopRequireWildcard(_handlebarsRuntime);
      var _handlebarsNoConflict = requireNoConflict();
      var _handlebarsNoConflict2 = _interopRequireDefault(_handlebarsNoConflict);
      function create2() {
        var hb = new base3.HandlebarsEnvironment();
        Utils.extend(hb, base3);
        hb.SafeString = _handlebarsSafeString2["default"];
        hb.Exception = _handlebarsException2["default"];
        hb.Utils = Utils;
        hb.escapeExpression = Utils.escapeExpression;
        hb.VM = runtime2;
        hb.template = function(spec) {
          return runtime2.template(spec, hb);
        };
        return hb;
      }
      var inst = create2();
      inst.create = create2;
      _handlebarsNoConflict2["default"](inst);
      inst["default"] = inst;
      exports$1["default"] = inst;
      module.exports = exports$1["default"];
    })(handlebars_runtime, handlebars_runtime.exports);
    return handlebars_runtime.exports;
  }
  var ast = { exports: {} };
  var hasRequiredAst;
  function requireAst() {
    if (hasRequiredAst) return ast.exports;
    hasRequiredAst = 1;
    (function(module, exports$1) {
      exports$1.__esModule = true;
      var AST = {
        // Public API used to evaluate derived attributes regarding AST nodes
        helpers: {
          // a mustache is definitely a helper if:
          // * it is an eligible helper, and
          // * it has at least one parameter or hash segment
          helperExpression: function helperExpression(node) {
            return node.type === "SubExpression" || (node.type === "MustacheStatement" || node.type === "BlockStatement") && !!(node.params && node.params.length || node.hash);
          },
          scopedId: function scopedId(path) {
            return /^\.|this\b/.test(path.original);
          },
          // an ID is simple if it only has one part, and that part is not
          // `..` or `this`.
          simpleId: function simpleId(path) {
            return path.parts.length === 1 && !AST.helpers.scopedId(path) && !path.depth;
          }
        }
      };
      exports$1["default"] = AST;
      module.exports = exports$1["default"];
    })(ast, ast.exports);
    return ast.exports;
  }
  var base = {};
  var parser = { exports: {} };
  var hasRequiredParser;
  function requireParser() {
    if (hasRequiredParser) return parser.exports;
    hasRequiredParser = 1;
    (function(module, exports$1) {
      exports$1.__esModule = true;
      var handlebars2 = (function() {
        var parser2 = {
          trace: function trace() {
          },
          yy: {},
          symbols_: { "error": 2, "root": 3, "program": 4, "EOF": 5, "program_repetition0": 6, "statement": 7, "mustache": 8, "block": 9, "rawBlock": 10, "partial": 11, "partialBlock": 12, "content": 13, "COMMENT": 14, "CONTENT": 15, "openRawBlock": 16, "rawBlock_repetition0": 17, "END_RAW_BLOCK": 18, "OPEN_RAW_BLOCK": 19, "helperName": 20, "openRawBlock_repetition0": 21, "openRawBlock_option0": 22, "CLOSE_RAW_BLOCK": 23, "openBlock": 24, "block_option0": 25, "closeBlock": 26, "openInverse": 27, "block_option1": 28, "OPEN_BLOCK": 29, "openBlock_repetition0": 30, "openBlock_option0": 31, "openBlock_option1": 32, "CLOSE": 33, "OPEN_INVERSE": 34, "openInverse_repetition0": 35, "openInverse_option0": 36, "openInverse_option1": 37, "openInverseChain": 38, "OPEN_INVERSE_CHAIN": 39, "openInverseChain_repetition0": 40, "openInverseChain_option0": 41, "openInverseChain_option1": 42, "inverseAndProgram": 43, "INVERSE": 44, "inverseChain": 45, "inverseChain_option0": 46, "OPEN_ENDBLOCK": 47, "OPEN": 48, "mustache_repetition0": 49, "mustache_option0": 50, "OPEN_UNESCAPED": 51, "mustache_repetition1": 52, "mustache_option1": 53, "CLOSE_UNESCAPED": 54, "OPEN_PARTIAL": 55, "partialName": 56, "partial_repetition0": 57, "partial_option0": 58, "openPartialBlock": 59, "OPEN_PARTIAL_BLOCK": 60, "openPartialBlock_repetition0": 61, "openPartialBlock_option0": 62, "param": 63, "sexpr": 64, "OPEN_SEXPR": 65, "sexpr_repetition0": 66, "sexpr_option0": 67, "CLOSE_SEXPR": 68, "hash": 69, "hash_repetition_plus0": 70, "hashSegment": 71, "ID": 72, "EQUALS": 73, "blockParams": 74, "OPEN_BLOCK_PARAMS": 75, "blockParams_repetition_plus0": 76, "CLOSE_BLOCK_PARAMS": 77, "path": 78, "dataName": 79, "STRING": 80, "NUMBER": 81, "BOOLEAN": 82, "UNDEFINED": 83, "NULL": 84, "DATA": 85, "pathSegments": 86, "SEP": 87, "$accept": 0, "$end": 1 },
          terminals_: { 2: "error", 5: "EOF", 14: "COMMENT", 15: "CONTENT", 18: "END_RAW_BLOCK", 19: "OPEN_RAW_BLOCK", 23: "CLOSE_RAW_BLOCK", 29: "OPEN_BLOCK", 33: "CLOSE", 34: "OPEN_INVERSE", 39: "OPEN_INVERSE_CHAIN", 44: "INVERSE", 47: "OPEN_ENDBLOCK", 48: "OPEN", 51: "OPEN_UNESCAPED", 54: "CLOSE_UNESCAPED", 55: "OPEN_PARTIAL", 60: "OPEN_PARTIAL_BLOCK", 65: "OPEN_SEXPR", 68: "CLOSE_SEXPR", 72: "ID", 73: "EQUALS", 75: "OPEN_BLOCK_PARAMS", 77: "CLOSE_BLOCK_PARAMS", 80: "STRING", 81: "NUMBER", 82: "BOOLEAN", 83: "UNDEFINED", 84: "NULL", 85: "DATA", 87: "SEP" },
          productions_: [0, [3, 2], [4, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [13, 1], [10, 3], [16, 5], [9, 4], [9, 4], [24, 6], [27, 6], [38, 6], [43, 2], [45, 3], [45, 1], [26, 3], [8, 5], [8, 5], [11, 5], [12, 3], [59, 5], [63, 1], [63, 1], [64, 5], [69, 1], [71, 3], [74, 3], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [56, 1], [56, 1], [79, 2], [78, 1], [86, 3], [86, 1], [6, 0], [6, 2], [17, 0], [17, 2], [21, 0], [21, 2], [22, 0], [22, 1], [25, 0], [25, 1], [28, 0], [28, 1], [30, 0], [30, 2], [31, 0], [31, 1], [32, 0], [32, 1], [35, 0], [35, 2], [36, 0], [36, 1], [37, 0], [37, 1], [40, 0], [40, 2], [41, 0], [41, 1], [42, 0], [42, 1], [46, 0], [46, 1], [49, 0], [49, 2], [50, 0], [50, 1], [52, 0], [52, 2], [53, 0], [53, 1], [57, 0], [57, 2], [58, 0], [58, 1], [61, 0], [61, 2], [62, 0], [62, 1], [66, 0], [66, 2], [67, 0], [67, 1], [70, 1], [70, 2], [76, 1], [76, 2]],
          performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {
            var $0 = $$.length - 1;
            switch (yystate) {
              case 1:
                return $$[$0 - 1];
              case 2:
                this.$ = yy.prepareProgram($$[$0]);
                break;
              case 3:
                this.$ = $$[$0];
                break;
              case 4:
                this.$ = $$[$0];
                break;
              case 5:
                this.$ = $$[$0];
                break;
              case 6:
                this.$ = $$[$0];
                break;
              case 7:
                this.$ = $$[$0];
                break;
              case 8:
                this.$ = $$[$0];
                break;
              case 9:
                this.$ = {
                  type: "CommentStatement",
                  value: yy.stripComment($$[$0]),
                  strip: yy.stripFlags($$[$0], $$[$0]),
                  loc: yy.locInfo(this._$)
                };
                break;
              case 10:
                this.$ = {
                  type: "ContentStatement",
                  original: $$[$0],
                  value: $$[$0],
                  loc: yy.locInfo(this._$)
                };
                break;
              case 11:
                this.$ = yy.prepareRawBlock($$[$0 - 2], $$[$0 - 1], $$[$0], this._$);
                break;
              case 12:
                this.$ = { path: $$[$0 - 3], params: $$[$0 - 2], hash: $$[$0 - 1] };
                break;
              case 13:
                this.$ = yy.prepareBlock($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0], false, this._$);
                break;
              case 14:
                this.$ = yy.prepareBlock($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0], true, this._$);
                break;
              case 15:
                this.$ = { open: $$[$0 - 5], path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };
                break;
              case 16:
                this.$ = { path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };
                break;
              case 17:
                this.$ = { path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };
                break;
              case 18:
                this.$ = { strip: yy.stripFlags($$[$0 - 1], $$[$0 - 1]), program: $$[$0] };
                break;
              case 19:
                var inverse = yy.prepareBlock($$[$0 - 2], $$[$0 - 1], $$[$0], $$[$0], false, this._$), program = yy.prepareProgram([inverse], $$[$0 - 1].loc);
                program.chained = true;
                this.$ = { strip: $$[$0 - 2].strip, program, chain: true };
                break;
              case 20:
                this.$ = $$[$0];
                break;
              case 21:
                this.$ = { path: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 2], $$[$0]) };
                break;
              case 22:
                this.$ = yy.prepareMustache($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0 - 4], yy.stripFlags($$[$0 - 4], $$[$0]), this._$);
                break;
              case 23:
                this.$ = yy.prepareMustache($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0 - 4], yy.stripFlags($$[$0 - 4], $$[$0]), this._$);
                break;
              case 24:
                this.$ = {
                  type: "PartialStatement",
                  name: $$[$0 - 3],
                  params: $$[$0 - 2],
                  hash: $$[$0 - 1],
                  indent: "",
                  strip: yy.stripFlags($$[$0 - 4], $$[$0]),
                  loc: yy.locInfo(this._$)
                };
                break;
              case 25:
                this.$ = yy.preparePartialBlock($$[$0 - 2], $$[$0 - 1], $$[$0], this._$);
                break;
              case 26:
                this.$ = { path: $$[$0 - 3], params: $$[$0 - 2], hash: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 4], $$[$0]) };
                break;
              case 27:
                this.$ = $$[$0];
                break;
              case 28:
                this.$ = $$[$0];
                break;
              case 29:
                this.$ = {
                  type: "SubExpression",
                  path: $$[$0 - 3],
                  params: $$[$0 - 2],
                  hash: $$[$0 - 1],
                  loc: yy.locInfo(this._$)
                };
                break;
              case 30:
                this.$ = { type: "Hash", pairs: $$[$0], loc: yy.locInfo(this._$) };
                break;
              case 31:
                this.$ = { type: "HashPair", key: yy.id($$[$0 - 2]), value: $$[$0], loc: yy.locInfo(this._$) };
                break;
              case 32:
                this.$ = yy.id($$[$0 - 1]);
                break;
              case 33:
                this.$ = $$[$0];
                break;
              case 34:
                this.$ = $$[$0];
                break;
              case 35:
                this.$ = { type: "StringLiteral", value: $$[$0], original: $$[$0], loc: yy.locInfo(this._$) };
                break;
              case 36:
                this.$ = { type: "NumberLiteral", value: Number($$[$0]), original: Number($$[$0]), loc: yy.locInfo(this._$) };
                break;
              case 37:
                this.$ = { type: "BooleanLiteral", value: $$[$0] === "true", original: $$[$0] === "true", loc: yy.locInfo(this._$) };
                break;
              case 38:
                this.$ = { type: "UndefinedLiteral", original: void 0, value: void 0, loc: yy.locInfo(this._$) };
                break;
              case 39:
                this.$ = { type: "NullLiteral", original: null, value: null, loc: yy.locInfo(this._$) };
                break;
              case 40:
                this.$ = $$[$0];
                break;
              case 41:
                this.$ = $$[$0];
                break;
              case 42:
                this.$ = yy.preparePath(true, $$[$0], this._$);
                break;
              case 43:
                this.$ = yy.preparePath(false, $$[$0], this._$);
                break;
              case 44:
                $$[$0 - 2].push({ part: yy.id($$[$0]), original: $$[$0], separator: $$[$0 - 1] });
                this.$ = $$[$0 - 2];
                break;
              case 45:
                this.$ = [{ part: yy.id($$[$0]), original: $$[$0] }];
                break;
              case 46:
                this.$ = [];
                break;
              case 47:
                $$[$0 - 1].push($$[$0]);
                break;
              case 48:
                this.$ = [];
                break;
              case 49:
                $$[$0 - 1].push($$[$0]);
                break;
              case 50:
                this.$ = [];
                break;
              case 51:
                $$[$0 - 1].push($$[$0]);
                break;
              case 58:
                this.$ = [];
                break;
              case 59:
                $$[$0 - 1].push($$[$0]);
                break;
              case 64:
                this.$ = [];
                break;
              case 65:
                $$[$0 - 1].push($$[$0]);
                break;
              case 70:
                this.$ = [];
                break;
              case 71:
                $$[$0 - 1].push($$[$0]);
                break;
              case 78:
                this.$ = [];
                break;
              case 79:
                $$[$0 - 1].push($$[$0]);
                break;
              case 82:
                this.$ = [];
                break;
              case 83:
                $$[$0 - 1].push($$[$0]);
                break;
              case 86:
                this.$ = [];
                break;
              case 87:
                $$[$0 - 1].push($$[$0]);
                break;
              case 90:
                this.$ = [];
                break;
              case 91:
                $$[$0 - 1].push($$[$0]);
                break;
              case 94:
                this.$ = [];
                break;
              case 95:
                $$[$0 - 1].push($$[$0]);
                break;
              case 98:
                this.$ = [$$[$0]];
                break;
              case 99:
                $$[$0 - 1].push($$[$0]);
                break;
              case 100:
                this.$ = [$$[$0]];
                break;
              case 101:
                $$[$0 - 1].push($$[$0]);
                break;
            }
          },
          table: [{ 3: 1, 4: 2, 5: [2, 46], 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 1: [3] }, { 5: [1, 4] }, { 5: [2, 2], 7: 5, 8: 6, 9: 7, 10: 8, 11: 9, 12: 10, 13: 11, 14: [1, 12], 15: [1, 20], 16: 17, 19: [1, 23], 24: 15, 27: 16, 29: [1, 21], 34: [1, 22], 39: [2, 2], 44: [2, 2], 47: [2, 2], 48: [1, 13], 51: [1, 14], 55: [1, 18], 59: 19, 60: [1, 24] }, { 1: [2, 1] }, { 5: [2, 47], 14: [2, 47], 15: [2, 47], 19: [2, 47], 29: [2, 47], 34: [2, 47], 39: [2, 47], 44: [2, 47], 47: [2, 47], 48: [2, 47], 51: [2, 47], 55: [2, 47], 60: [2, 47] }, { 5: [2, 3], 14: [2, 3], 15: [2, 3], 19: [2, 3], 29: [2, 3], 34: [2, 3], 39: [2, 3], 44: [2, 3], 47: [2, 3], 48: [2, 3], 51: [2, 3], 55: [2, 3], 60: [2, 3] }, { 5: [2, 4], 14: [2, 4], 15: [2, 4], 19: [2, 4], 29: [2, 4], 34: [2, 4], 39: [2, 4], 44: [2, 4], 47: [2, 4], 48: [2, 4], 51: [2, 4], 55: [2, 4], 60: [2, 4] }, { 5: [2, 5], 14: [2, 5], 15: [2, 5], 19: [2, 5], 29: [2, 5], 34: [2, 5], 39: [2, 5], 44: [2, 5], 47: [2, 5], 48: [2, 5], 51: [2, 5], 55: [2, 5], 60: [2, 5] }, { 5: [2, 6], 14: [2, 6], 15: [2, 6], 19: [2, 6], 29: [2, 6], 34: [2, 6], 39: [2, 6], 44: [2, 6], 47: [2, 6], 48: [2, 6], 51: [2, 6], 55: [2, 6], 60: [2, 6] }, { 5: [2, 7], 14: [2, 7], 15: [2, 7], 19: [2, 7], 29: [2, 7], 34: [2, 7], 39: [2, 7], 44: [2, 7], 47: [2, 7], 48: [2, 7], 51: [2, 7], 55: [2, 7], 60: [2, 7] }, { 5: [2, 8], 14: [2, 8], 15: [2, 8], 19: [2, 8], 29: [2, 8], 34: [2, 8], 39: [2, 8], 44: [2, 8], 47: [2, 8], 48: [2, 8], 51: [2, 8], 55: [2, 8], 60: [2, 8] }, { 5: [2, 9], 14: [2, 9], 15: [2, 9], 19: [2, 9], 29: [2, 9], 34: [2, 9], 39: [2, 9], 44: [2, 9], 47: [2, 9], 48: [2, 9], 51: [2, 9], 55: [2, 9], 60: [2, 9] }, { 20: 25, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 36, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 37, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 39: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 4: 38, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 15: [2, 48], 17: 39, 18: [2, 48] }, { 20: 41, 56: 40, 64: 42, 65: [1, 43], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 44, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 5: [2, 10], 14: [2, 10], 15: [2, 10], 18: [2, 10], 19: [2, 10], 29: [2, 10], 34: [2, 10], 39: [2, 10], 44: [2, 10], 47: [2, 10], 48: [2, 10], 51: [2, 10], 55: [2, 10], 60: [2, 10] }, { 20: 45, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 46, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 47, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 41, 56: 48, 64: 42, 65: [1, 43], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [2, 78], 49: 49, 65: [2, 78], 72: [2, 78], 80: [2, 78], 81: [2, 78], 82: [2, 78], 83: [2, 78], 84: [2, 78], 85: [2, 78] }, { 23: [2, 33], 33: [2, 33], 54: [2, 33], 65: [2, 33], 68: [2, 33], 72: [2, 33], 75: [2, 33], 80: [2, 33], 81: [2, 33], 82: [2, 33], 83: [2, 33], 84: [2, 33], 85: [2, 33] }, { 23: [2, 34], 33: [2, 34], 54: [2, 34], 65: [2, 34], 68: [2, 34], 72: [2, 34], 75: [2, 34], 80: [2, 34], 81: [2, 34], 82: [2, 34], 83: [2, 34], 84: [2, 34], 85: [2, 34] }, { 23: [2, 35], 33: [2, 35], 54: [2, 35], 65: [2, 35], 68: [2, 35], 72: [2, 35], 75: [2, 35], 80: [2, 35], 81: [2, 35], 82: [2, 35], 83: [2, 35], 84: [2, 35], 85: [2, 35] }, { 23: [2, 36], 33: [2, 36], 54: [2, 36], 65: [2, 36], 68: [2, 36], 72: [2, 36], 75: [2, 36], 80: [2, 36], 81: [2, 36], 82: [2, 36], 83: [2, 36], 84: [2, 36], 85: [2, 36] }, { 23: [2, 37], 33: [2, 37], 54: [2, 37], 65: [2, 37], 68: [2, 37], 72: [2, 37], 75: [2, 37], 80: [2, 37], 81: [2, 37], 82: [2, 37], 83: [2, 37], 84: [2, 37], 85: [2, 37] }, { 23: [2, 38], 33: [2, 38], 54: [2, 38], 65: [2, 38], 68: [2, 38], 72: [2, 38], 75: [2, 38], 80: [2, 38], 81: [2, 38], 82: [2, 38], 83: [2, 38], 84: [2, 38], 85: [2, 38] }, { 23: [2, 39], 33: [2, 39], 54: [2, 39], 65: [2, 39], 68: [2, 39], 72: [2, 39], 75: [2, 39], 80: [2, 39], 81: [2, 39], 82: [2, 39], 83: [2, 39], 84: [2, 39], 85: [2, 39] }, { 23: [2, 43], 33: [2, 43], 54: [2, 43], 65: [2, 43], 68: [2, 43], 72: [2, 43], 75: [2, 43], 80: [2, 43], 81: [2, 43], 82: [2, 43], 83: [2, 43], 84: [2, 43], 85: [2, 43], 87: [1, 50] }, { 72: [1, 35], 86: 51 }, { 23: [2, 45], 33: [2, 45], 54: [2, 45], 65: [2, 45], 68: [2, 45], 72: [2, 45], 75: [2, 45], 80: [2, 45], 81: [2, 45], 82: [2, 45], 83: [2, 45], 84: [2, 45], 85: [2, 45], 87: [2, 45] }, { 52: 52, 54: [2, 82], 65: [2, 82], 72: [2, 82], 80: [2, 82], 81: [2, 82], 82: [2, 82], 83: [2, 82], 84: [2, 82], 85: [2, 82] }, { 25: 53, 38: 55, 39: [1, 57], 43: 56, 44: [1, 58], 45: 54, 47: [2, 54] }, { 28: 59, 43: 60, 44: [1, 58], 47: [2, 56] }, { 13: 62, 15: [1, 20], 18: [1, 61] }, { 33: [2, 86], 57: 63, 65: [2, 86], 72: [2, 86], 80: [2, 86], 81: [2, 86], 82: [2, 86], 83: [2, 86], 84: [2, 86], 85: [2, 86] }, { 33: [2, 40], 65: [2, 40], 72: [2, 40], 80: [2, 40], 81: [2, 40], 82: [2, 40], 83: [2, 40], 84: [2, 40], 85: [2, 40] }, { 33: [2, 41], 65: [2, 41], 72: [2, 41], 80: [2, 41], 81: [2, 41], 82: [2, 41], 83: [2, 41], 84: [2, 41], 85: [2, 41] }, { 20: 64, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 26: 65, 47: [1, 66] }, { 30: 67, 33: [2, 58], 65: [2, 58], 72: [2, 58], 75: [2, 58], 80: [2, 58], 81: [2, 58], 82: [2, 58], 83: [2, 58], 84: [2, 58], 85: [2, 58] }, { 33: [2, 64], 35: 68, 65: [2, 64], 72: [2, 64], 75: [2, 64], 80: [2, 64], 81: [2, 64], 82: [2, 64], 83: [2, 64], 84: [2, 64], 85: [2, 64] }, { 21: 69, 23: [2, 50], 65: [2, 50], 72: [2, 50], 80: [2, 50], 81: [2, 50], 82: [2, 50], 83: [2, 50], 84: [2, 50], 85: [2, 50] }, { 33: [2, 90], 61: 70, 65: [2, 90], 72: [2, 90], 80: [2, 90], 81: [2, 90], 82: [2, 90], 83: [2, 90], 84: [2, 90], 85: [2, 90] }, { 20: 74, 33: [2, 80], 50: 71, 63: 72, 64: 75, 65: [1, 43], 69: 73, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 72: [1, 79] }, { 23: [2, 42], 33: [2, 42], 54: [2, 42], 65: [2, 42], 68: [2, 42], 72: [2, 42], 75: [2, 42], 80: [2, 42], 81: [2, 42], 82: [2, 42], 83: [2, 42], 84: [2, 42], 85: [2, 42], 87: [1, 50] }, { 20: 74, 53: 80, 54: [2, 84], 63: 81, 64: 75, 65: [1, 43], 69: 82, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 26: 83, 47: [1, 66] }, { 47: [2, 55] }, { 4: 84, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 39: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 47: [2, 20] }, { 20: 85, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 86, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 26: 87, 47: [1, 66] }, { 47: [2, 57] }, { 5: [2, 11], 14: [2, 11], 15: [2, 11], 19: [2, 11], 29: [2, 11], 34: [2, 11], 39: [2, 11], 44: [2, 11], 47: [2, 11], 48: [2, 11], 51: [2, 11], 55: [2, 11], 60: [2, 11] }, { 15: [2, 49], 18: [2, 49] }, { 20: 74, 33: [2, 88], 58: 88, 63: 89, 64: 75, 65: [1, 43], 69: 90, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 65: [2, 94], 66: 91, 68: [2, 94], 72: [2, 94], 80: [2, 94], 81: [2, 94], 82: [2, 94], 83: [2, 94], 84: [2, 94], 85: [2, 94] }, { 5: [2, 25], 14: [2, 25], 15: [2, 25], 19: [2, 25], 29: [2, 25], 34: [2, 25], 39: [2, 25], 44: [2, 25], 47: [2, 25], 48: [2, 25], 51: [2, 25], 55: [2, 25], 60: [2, 25] }, { 20: 92, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 74, 31: 93, 33: [2, 60], 63: 94, 64: 75, 65: [1, 43], 69: 95, 70: 76, 71: 77, 72: [1, 78], 75: [2, 60], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 74, 33: [2, 66], 36: 96, 63: 97, 64: 75, 65: [1, 43], 69: 98, 70: 76, 71: 77, 72: [1, 78], 75: [2, 66], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 74, 22: 99, 23: [2, 52], 63: 100, 64: 75, 65: [1, 43], 69: 101, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 74, 33: [2, 92], 62: 102, 63: 103, 64: 75, 65: [1, 43], 69: 104, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [1, 105] }, { 33: [2, 79], 65: [2, 79], 72: [2, 79], 80: [2, 79], 81: [2, 79], 82: [2, 79], 83: [2, 79], 84: [2, 79], 85: [2, 79] }, { 33: [2, 81] }, { 23: [2, 27], 33: [2, 27], 54: [2, 27], 65: [2, 27], 68: [2, 27], 72: [2, 27], 75: [2, 27], 80: [2, 27], 81: [2, 27], 82: [2, 27], 83: [2, 27], 84: [2, 27], 85: [2, 27] }, { 23: [2, 28], 33: [2, 28], 54: [2, 28], 65: [2, 28], 68: [2, 28], 72: [2, 28], 75: [2, 28], 80: [2, 28], 81: [2, 28], 82: [2, 28], 83: [2, 28], 84: [2, 28], 85: [2, 28] }, { 23: [2, 30], 33: [2, 30], 54: [2, 30], 68: [2, 30], 71: 106, 72: [1, 107], 75: [2, 30] }, { 23: [2, 98], 33: [2, 98], 54: [2, 98], 68: [2, 98], 72: [2, 98], 75: [2, 98] }, { 23: [2, 45], 33: [2, 45], 54: [2, 45], 65: [2, 45], 68: [2, 45], 72: [2, 45], 73: [1, 108], 75: [2, 45], 80: [2, 45], 81: [2, 45], 82: [2, 45], 83: [2, 45], 84: [2, 45], 85: [2, 45], 87: [2, 45] }, { 23: [2, 44], 33: [2, 44], 54: [2, 44], 65: [2, 44], 68: [2, 44], 72: [2, 44], 75: [2, 44], 80: [2, 44], 81: [2, 44], 82: [2, 44], 83: [2, 44], 84: [2, 44], 85: [2, 44], 87: [2, 44] }, { 54: [1, 109] }, { 54: [2, 83], 65: [2, 83], 72: [2, 83], 80: [2, 83], 81: [2, 83], 82: [2, 83], 83: [2, 83], 84: [2, 83], 85: [2, 83] }, { 54: [2, 85] }, { 5: [2, 13], 14: [2, 13], 15: [2, 13], 19: [2, 13], 29: [2, 13], 34: [2, 13], 39: [2, 13], 44: [2, 13], 47: [2, 13], 48: [2, 13], 51: [2, 13], 55: [2, 13], 60: [2, 13] }, { 38: 55, 39: [1, 57], 43: 56, 44: [1, 58], 45: 111, 46: 110, 47: [2, 76] }, { 33: [2, 70], 40: 112, 65: [2, 70], 72: [2, 70], 75: [2, 70], 80: [2, 70], 81: [2, 70], 82: [2, 70], 83: [2, 70], 84: [2, 70], 85: [2, 70] }, { 47: [2, 18] }, { 5: [2, 14], 14: [2, 14], 15: [2, 14], 19: [2, 14], 29: [2, 14], 34: [2, 14], 39: [2, 14], 44: [2, 14], 47: [2, 14], 48: [2, 14], 51: [2, 14], 55: [2, 14], 60: [2, 14] }, { 33: [1, 113] }, { 33: [2, 87], 65: [2, 87], 72: [2, 87], 80: [2, 87], 81: [2, 87], 82: [2, 87], 83: [2, 87], 84: [2, 87], 85: [2, 87] }, { 33: [2, 89] }, { 20: 74, 63: 115, 64: 75, 65: [1, 43], 67: 114, 68: [2, 96], 69: 116, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [1, 117] }, { 32: 118, 33: [2, 62], 74: 119, 75: [1, 120] }, { 33: [2, 59], 65: [2, 59], 72: [2, 59], 75: [2, 59], 80: [2, 59], 81: [2, 59], 82: [2, 59], 83: [2, 59], 84: [2, 59], 85: [2, 59] }, { 33: [2, 61], 75: [2, 61] }, { 33: [2, 68], 37: 121, 74: 122, 75: [1, 120] }, { 33: [2, 65], 65: [2, 65], 72: [2, 65], 75: [2, 65], 80: [2, 65], 81: [2, 65], 82: [2, 65], 83: [2, 65], 84: [2, 65], 85: [2, 65] }, { 33: [2, 67], 75: [2, 67] }, { 23: [1, 123] }, { 23: [2, 51], 65: [2, 51], 72: [2, 51], 80: [2, 51], 81: [2, 51], 82: [2, 51], 83: [2, 51], 84: [2, 51], 85: [2, 51] }, { 23: [2, 53] }, { 33: [1, 124] }, { 33: [2, 91], 65: [2, 91], 72: [2, 91], 80: [2, 91], 81: [2, 91], 82: [2, 91], 83: [2, 91], 84: [2, 91], 85: [2, 91] }, { 33: [2, 93] }, { 5: [2, 22], 14: [2, 22], 15: [2, 22], 19: [2, 22], 29: [2, 22], 34: [2, 22], 39: [2, 22], 44: [2, 22], 47: [2, 22], 48: [2, 22], 51: [2, 22], 55: [2, 22], 60: [2, 22] }, { 23: [2, 99], 33: [2, 99], 54: [2, 99], 68: [2, 99], 72: [2, 99], 75: [2, 99] }, { 73: [1, 108] }, { 20: 74, 63: 125, 64: 75, 65: [1, 43], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 5: [2, 23], 14: [2, 23], 15: [2, 23], 19: [2, 23], 29: [2, 23], 34: [2, 23], 39: [2, 23], 44: [2, 23], 47: [2, 23], 48: [2, 23], 51: [2, 23], 55: [2, 23], 60: [2, 23] }, { 47: [2, 19] }, { 47: [2, 77] }, { 20: 74, 33: [2, 72], 41: 126, 63: 127, 64: 75, 65: [1, 43], 69: 128, 70: 76, 71: 77, 72: [1, 78], 75: [2, 72], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 5: [2, 24], 14: [2, 24], 15: [2, 24], 19: [2, 24], 29: [2, 24], 34: [2, 24], 39: [2, 24], 44: [2, 24], 47: [2, 24], 48: [2, 24], 51: [2, 24], 55: [2, 24], 60: [2, 24] }, { 68: [1, 129] }, { 65: [2, 95], 68: [2, 95], 72: [2, 95], 80: [2, 95], 81: [2, 95], 82: [2, 95], 83: [2, 95], 84: [2, 95], 85: [2, 95] }, { 68: [2, 97] }, { 5: [2, 21], 14: [2, 21], 15: [2, 21], 19: [2, 21], 29: [2, 21], 34: [2, 21], 39: [2, 21], 44: [2, 21], 47: [2, 21], 48: [2, 21], 51: [2, 21], 55: [2, 21], 60: [2, 21] }, { 33: [1, 130] }, { 33: [2, 63] }, { 72: [1, 132], 76: 131 }, { 33: [1, 133] }, { 33: [2, 69] }, { 15: [2, 12], 18: [2, 12] }, { 14: [2, 26], 15: [2, 26], 19: [2, 26], 29: [2, 26], 34: [2, 26], 47: [2, 26], 48: [2, 26], 51: [2, 26], 55: [2, 26], 60: [2, 26] }, { 23: [2, 31], 33: [2, 31], 54: [2, 31], 68: [2, 31], 72: [2, 31], 75: [2, 31] }, { 33: [2, 74], 42: 134, 74: 135, 75: [1, 120] }, { 33: [2, 71], 65: [2, 71], 72: [2, 71], 75: [2, 71], 80: [2, 71], 81: [2, 71], 82: [2, 71], 83: [2, 71], 84: [2, 71], 85: [2, 71] }, { 33: [2, 73], 75: [2, 73] }, { 23: [2, 29], 33: [2, 29], 54: [2, 29], 65: [2, 29], 68: [2, 29], 72: [2, 29], 75: [2, 29], 80: [2, 29], 81: [2, 29], 82: [2, 29], 83: [2, 29], 84: [2, 29], 85: [2, 29] }, { 14: [2, 15], 15: [2, 15], 19: [2, 15], 29: [2, 15], 34: [2, 15], 39: [2, 15], 44: [2, 15], 47: [2, 15], 48: [2, 15], 51: [2, 15], 55: [2, 15], 60: [2, 15] }, { 72: [1, 137], 77: [1, 136] }, { 72: [2, 100], 77: [2, 100] }, { 14: [2, 16], 15: [2, 16], 19: [2, 16], 29: [2, 16], 34: [2, 16], 44: [2, 16], 47: [2, 16], 48: [2, 16], 51: [2, 16], 55: [2, 16], 60: [2, 16] }, { 33: [1, 138] }, { 33: [2, 75] }, { 33: [2, 32] }, { 72: [2, 101], 77: [2, 101] }, { 14: [2, 17], 15: [2, 17], 19: [2, 17], 29: [2, 17], 34: [2, 17], 39: [2, 17], 44: [2, 17], 47: [2, 17], 48: [2, 17], 51: [2, 17], 55: [2, 17], 60: [2, 17] }],
          defaultActions: { 4: [2, 1], 54: [2, 55], 56: [2, 20], 60: [2, 57], 73: [2, 81], 82: [2, 85], 86: [2, 18], 90: [2, 89], 101: [2, 53], 104: [2, 93], 110: [2, 19], 111: [2, 77], 116: [2, 97], 119: [2, 63], 122: [2, 69], 135: [2, 75], 136: [2, 32] },
          parseError: function parseError(str, hash) {
            throw new Error(str);
          },
          parse: function parse(input) {
            var self = this, stack = [0], vstack = [null], lstack = [], table = this.table, yytext = "", yylineno = 0, yyleng = 0;
            this.lexer.setInput(input);
            this.lexer.yy = this.yy;
            this.yy.lexer = this.lexer;
            this.yy.parser = this;
            if (typeof this.lexer.yylloc == "undefined") this.lexer.yylloc = {};
            var yyloc = this.lexer.yylloc;
            lstack.push(yyloc);
            var ranges = this.lexer.options && this.lexer.options.ranges;
            if (typeof this.yy.parseError === "function") this.parseError = this.yy.parseError;
            function lex() {
              var token;
              token = self.lexer.lex() || 1;
              if (typeof token !== "number") {
                token = self.symbols_[token] || token;
              }
              return token;
            }
            var symbol, state2, action, r, yyval = {}, p, len, newState, expected;
            while (true) {
              state2 = stack[stack.length - 1];
              if (this.defaultActions[state2]) {
                action = this.defaultActions[state2];
              } else {
                if (symbol === null || typeof symbol == "undefined") {
                  symbol = lex();
                }
                action = table[state2] && table[state2][symbol];
              }
              if (typeof action === "undefined" || !action.length || !action[0]) {
                var errStr = "";
                {
                  expected = [];
                  for (p in table[state2]) if (this.terminals_[p] && p > 2) {
                    expected.push("'" + this.terminals_[p] + "'");
                  }
                  if (this.lexer.showPosition) {
                    errStr = "Parse error on line " + (yylineno + 1) + ":\n" + this.lexer.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol] || symbol) + "'";
                  } else {
                    errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol == 1 ? "end of input" : "'" + (this.terminals_[symbol] || symbol) + "'");
                  }
                  this.parseError(errStr, { text: this.lexer.match, token: this.terminals_[symbol] || symbol, line: this.lexer.yylineno, loc: yyloc, expected });
                }
              }
              if (action[0] instanceof Array && action.length > 1) {
                throw new Error("Parse Error: multiple actions possible at state: " + state2 + ", token: " + symbol);
              }
              switch (action[0]) {
                case 1:
                  stack.push(symbol);
                  vstack.push(this.lexer.yytext);
                  lstack.push(this.lexer.yylloc);
                  stack.push(action[1]);
                  symbol = null;
                  {
                    yyleng = this.lexer.yyleng;
                    yytext = this.lexer.yytext;
                    yylineno = this.lexer.yylineno;
                    yyloc = this.lexer.yylloc;
                  }
                  break;
                case 2:
                  len = this.productions_[action[1]][1];
                  yyval.$ = vstack[vstack.length - len];
                  yyval._$ = { first_line: lstack[lstack.length - (len || 1)].first_line, last_line: lstack[lstack.length - 1].last_line, first_column: lstack[lstack.length - (len || 1)].first_column, last_column: lstack[lstack.length - 1].last_column };
                  if (ranges) {
                    yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];
                  }
                  r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);
                  if (typeof r !== "undefined") {
                    return r;
                  }
                  if (len) {
                    stack = stack.slice(0, -1 * len * 2);
                    vstack = vstack.slice(0, -1 * len);
                    lstack = lstack.slice(0, -1 * len);
                  }
                  stack.push(this.productions_[action[1]][0]);
                  vstack.push(yyval.$);
                  lstack.push(yyval._$);
                  newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
                  stack.push(newState);
                  break;
                case 3:
                  return true;
              }
            }
            return true;
          }
        };
        var lexer = (function() {
          var lexer2 = {
            EOF: 1,
            parseError: function parseError(str, hash) {
              if (this.yy.parser) {
                this.yy.parser.parseError(str, hash);
              } else {
                throw new Error(str);
              }
            },
            setInput: function setInput(input) {
              this._input = input;
              this._more = this._less = this.done = false;
              this.yylineno = this.yyleng = 0;
              this.yytext = this.matched = this.match = "";
              this.conditionStack = ["INITIAL"];
              this.yylloc = { first_line: 1, first_column: 0, last_line: 1, last_column: 0 };
              if (this.options.ranges) this.yylloc.range = [0, 0];
              this.offset = 0;
              return this;
            },
            input: function input() {
              var ch = this._input[0];
              this.yytext += ch;
              this.yyleng++;
              this.offset++;
              this.match += ch;
              this.matched += ch;
              var lines = ch.match(/(?:\r\n?|\n).*/g);
              if (lines) {
                this.yylineno++;
                this.yylloc.last_line++;
              } else {
                this.yylloc.last_column++;
              }
              if (this.options.ranges) this.yylloc.range[1]++;
              this._input = this._input.slice(1);
              return ch;
            },
            unput: function unput(ch) {
              var len = ch.length;
              var lines = ch.split(/(?:\r\n?|\n)/g);
              this._input = ch + this._input;
              this.yytext = this.yytext.substr(0, this.yytext.length - len - 1);
              this.offset -= len;
              var oldLines = this.match.split(/(?:\r\n?|\n)/g);
              this.match = this.match.substr(0, this.match.length - 1);
              this.matched = this.matched.substr(0, this.matched.length - 1);
              if (lines.length - 1) this.yylineno -= lines.length - 1;
              var r = this.yylloc.range;
              this.yylloc = {
                first_line: this.yylloc.first_line,
                last_line: this.yylineno + 1,
                first_column: this.yylloc.first_column,
                last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
              };
              if (this.options.ranges) {
                this.yylloc.range = [r[0], r[0] + this.yyleng - len];
              }
              return this;
            },
            more: function more() {
              this._more = true;
              return this;
            },
            less: function less(n) {
              this.unput(this.match.slice(n));
            },
            pastInput: function pastInput() {
              var past = this.matched.substr(0, this.matched.length - this.match.length);
              return (past.length > 20 ? "..." : "") + past.substr(-20).replace(/\n/g, "");
            },
            upcomingInput: function upcomingInput() {
              var next = this.match;
              if (next.length < 20) {
                next += this._input.substr(0, 20 - next.length);
              }
              return (next.substr(0, 20) + (next.length > 20 ? "..." : "")).replace(/\n/g, "");
            },
            showPosition: function showPosition() {
              var pre = this.pastInput();
              var c = new Array(pre.length + 1).join("-");
              return pre + this.upcomingInput() + "\n" + c + "^";
            },
            next: function next() {
              if (this.done) {
                return this.EOF;
              }
              if (!this._input) this.done = true;
              var token, match2, tempMatch, index, lines;
              if (!this._more) {
                this.yytext = "";
                this.match = "";
              }
              var rules = this._currentRules();
              for (var i = 0; i < rules.length; i++) {
                tempMatch = this._input.match(this.rules[rules[i]]);
                if (tempMatch && (!match2 || tempMatch[0].length > match2[0].length)) {
                  match2 = tempMatch;
                  index = i;
                  if (!this.options.flex) break;
                }
              }
              if (match2) {
                lines = match2[0].match(/(?:\r\n?|\n).*/g);
                if (lines) this.yylineno += lines.length;
                this.yylloc = {
                  first_line: this.yylloc.last_line,
                  last_line: this.yylineno + 1,
                  first_column: this.yylloc.last_column,
                  last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match2[0].length
                };
                this.yytext += match2[0];
                this.match += match2[0];
                this.matches = match2;
                this.yyleng = this.yytext.length;
                if (this.options.ranges) {
                  this.yylloc.range = [this.offset, this.offset += this.yyleng];
                }
                this._more = false;
                this._input = this._input.slice(match2[0].length);
                this.matched += match2[0];
                token = this.performAction.call(this, this.yy, this, rules[index], this.conditionStack[this.conditionStack.length - 1]);
                if (this.done && this._input) this.done = false;
                if (token) return token;
                else return;
              }
              if (this._input === "") {
                return this.EOF;
              } else {
                return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". Unrecognized text.\n" + this.showPosition(), { text: "", token: null, line: this.yylineno });
              }
            },
            lex: function lex() {
              var r = this.next();
              if (typeof r !== "undefined") {
                return r;
              } else {
                return this.lex();
              }
            },
            begin: function begin(condition) {
              this.conditionStack.push(condition);
            },
            popState: function popState() {
              return this.conditionStack.pop();
            },
            _currentRules: function _currentRules() {
              return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
            },
            topState: function topState() {
              return this.conditionStack[this.conditionStack.length - 2];
            },
            pushState: function begin(condition) {
              this.begin(condition);
            }
          };
          lexer2.options = {};
          lexer2.performAction = function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
            function strip(start, end) {
              return yy_.yytext = yy_.yytext.substring(start, yy_.yyleng - end + start);
            }
            switch ($avoiding_name_collisions) {
              case 0:
                if (yy_.yytext.slice(-2) === "\\\\") {
                  strip(0, 1);
                  this.begin("mu");
                } else if (yy_.yytext.slice(-1) === "\\") {
                  strip(0, 1);
                  this.begin("emu");
                } else {
                  this.begin("mu");
                }
                if (yy_.yytext) return 15;
                break;
              case 1:
                return 15;
              case 2:
                this.popState();
                return 15;
              case 3:
                this.begin("raw");
                return 15;
              case 4:
                this.popState();
                if (this.conditionStack[this.conditionStack.length - 1] === "raw") {
                  return 15;
                } else {
                  strip(5, 9);
                  return "END_RAW_BLOCK";
                }
              case 5:
                return 15;
              case 6:
                this.popState();
                return 14;
              case 7:
                return 65;
              case 8:
                return 68;
              case 9:
                return 19;
              case 10:
                this.popState();
                this.begin("raw");
                return 23;
              case 11:
                return 55;
              case 12:
                return 60;
              case 13:
                return 29;
              case 14:
                return 47;
              case 15:
                this.popState();
                return 44;
              case 16:
                this.popState();
                return 44;
              case 17:
                return 34;
              case 18:
                return 39;
              case 19:
                return 51;
              case 20:
                return 48;
              case 21:
                this.unput(yy_.yytext);
                this.popState();
                this.begin("com");
                break;
              case 22:
                this.popState();
                return 14;
              case 23:
                return 48;
              case 24:
                return 73;
              case 25:
                return 72;
              case 26:
                return 72;
              case 27:
                return 87;
              case 28:
                break;
              case 29:
                this.popState();
                return 54;
              case 30:
                this.popState();
                return 33;
              case 31:
                yy_.yytext = strip(1, 2).replace(/\\"/g, '"');
                return 80;
              case 32:
                yy_.yytext = strip(1, 2).replace(/\\'/g, "'");
                return 80;
              case 33:
                return 85;
              case 34:
                return 82;
              case 35:
                return 82;
              case 36:
                return 83;
              case 37:
                return 84;
              case 38:
                return 81;
              case 39:
                return 75;
              case 40:
                return 77;
              case 41:
                return 72;
              case 42:
                yy_.yytext = yy_.yytext.replace(/\\([\\\]])/g, "$1");
                return 72;
              case 43:
                return "INVALID";
              case 44:
                return 5;
            }
          };
          lexer2.rules = [/^(?:[^\x00]*?(?=(\{\{)))/, /^(?:[^\x00]+)/, /^(?:[^\x00]{2,}?(?=(\{\{|\\\{\{|\\\\\{\{|$)))/, /^(?:\{\{\{\{(?=[^/]))/, /^(?:\{\{\{\{\/[^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=[=}\s\/.])\}\}\}\})/, /^(?:[^\x00]+?(?=(\{\{\{\{)))/, /^(?:[\s\S]*?--(~)?\}\})/, /^(?:\()/, /^(?:\))/, /^(?:\{\{\{\{)/, /^(?:\}\}\}\})/, /^(?:\{\{(~)?>)/, /^(?:\{\{(~)?#>)/, /^(?:\{\{(~)?#\*?)/, /^(?:\{\{(~)?\/)/, /^(?:\{\{(~)?\^\s*(~)?\}\})/, /^(?:\{\{(~)?\s*else\s*(~)?\}\})/, /^(?:\{\{(~)?\^)/, /^(?:\{\{(~)?\s*else\b)/, /^(?:\{\{(~)?\{)/, /^(?:\{\{(~)?&)/, /^(?:\{\{(~)?!--)/, /^(?:\{\{(~)?![\s\S]*?\}\})/, /^(?:\{\{(~)?\*?)/, /^(?:=)/, /^(?:\.\.)/, /^(?:\.(?=([=~}\s\/.)|])))/, /^(?:[\/.])/, /^(?:\s+)/, /^(?:\}(~)?\}\})/, /^(?:(~)?\}\})/, /^(?:"(\\["]|[^"])*")/, /^(?:'(\\[']|[^'])*')/, /^(?:@)/, /^(?:true(?=([~}\s)])))/, /^(?:false(?=([~}\s)])))/, /^(?:undefined(?=([~}\s)])))/, /^(?:null(?=([~}\s)])))/, /^(?:-?[0-9]+(?:\.[0-9]+)?(?=([~}\s)])))/, /^(?:as\s+\|)/, /^(?:\|)/, /^(?:([^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=([=~}\s\/.)|]))))/, /^(?:\[(\\\]|[^\]])*\])/, /^(?:.)/, /^(?:$)/];
          lexer2.conditions = { "mu": { "rules": [7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44], "inclusive": false }, "emu": { "rules": [2], "inclusive": false }, "com": { "rules": [6], "inclusive": false }, "raw": { "rules": [3, 4, 5], "inclusive": false }, "INITIAL": { "rules": [0, 1, 44], "inclusive": true } };
          return lexer2;
        })();
        parser2.lexer = lexer;
        function Parser() {
          this.yy = {};
        }
        Parser.prototype = parser2;
        parser2.Parser = Parser;
        return new Parser();
      })();
      exports$1["default"] = handlebars2;
      module.exports = exports$1["default"];
    })(parser, parser.exports);
    return parser.exports;
  }
  var whitespaceControl = { exports: {} };
  var visitor = { exports: {} };
  var hasRequiredVisitor;
  function requireVisitor() {
    if (hasRequiredVisitor) return visitor.exports;
    hasRequiredVisitor = 1;
    (function(module, exports$1) {
      exports$1.__esModule = true;
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var _exception = requireException();
      var _exception2 = _interopRequireDefault(_exception);
      function Visitor() {
        this.parents = [];
      }
      Visitor.prototype = {
        constructor: Visitor,
        mutating: false,
        // Visits a given value. If mutating, will replace the value if necessary.
        acceptKey: function acceptKey(node, name) {
          var value = this.accept(node[name]);
          if (this.mutating) {
            if (value && !Visitor.prototype[value.type]) {
              throw new _exception2["default"]('Unexpected node type "' + value.type + '" found when accepting ' + name + " on " + node.type);
            }
            node[name] = value;
          }
        },
        // Performs an accept operation with added sanity check to ensure
        // required keys are not removed.
        acceptRequired: function acceptRequired(node, name) {
          this.acceptKey(node, name);
          if (!node[name]) {
            throw new _exception2["default"](node.type + " requires " + name);
          }
        },
        // Traverses a given array. If mutating, empty respnses will be removed
        // for child elements.
        acceptArray: function acceptArray(array) {
          for (var i = 0, l = array.length; i < l; i++) {
            this.acceptKey(array, i);
            if (!array[i]) {
              array.splice(i, 1);
              i--;
              l--;
            }
          }
        },
        accept: function accept(object) {
          if (!object) {
            return;
          }
          if (!this[object.type]) {
            throw new _exception2["default"]("Unknown type: " + object.type, object);
          }
          if (this.current) {
            this.parents.unshift(this.current);
          }
          this.current = object;
          var ret = this[object.type](object);
          this.current = this.parents.shift();
          if (!this.mutating || ret) {
            return ret;
          } else if (ret !== false) {
            return object;
          }
        },
        Program: function Program(program) {
          this.acceptArray(program.body);
        },
        MustacheStatement: visitSubExpression,
        Decorator: visitSubExpression,
        BlockStatement: visitBlock,
        DecoratorBlock: visitBlock,
        PartialStatement: visitPartial,
        PartialBlockStatement: function PartialBlockStatement(partial) {
          visitPartial.call(this, partial);
          this.acceptKey(partial, "program");
        },
        ContentStatement: function ContentStatement() {
        },
        CommentStatement: function CommentStatement() {
        },
        SubExpression: visitSubExpression,
        PathExpression: function PathExpression() {
        },
        StringLiteral: function StringLiteral() {
        },
        NumberLiteral: function NumberLiteral() {
        },
        BooleanLiteral: function BooleanLiteral() {
        },
        UndefinedLiteral: function UndefinedLiteral() {
        },
        NullLiteral: function NullLiteral() {
        },
        Hash: function Hash(hash) {
          this.acceptArray(hash.pairs);
        },
        HashPair: function HashPair(pair) {
          this.acceptRequired(pair, "value");
        }
      };
      function visitSubExpression(mustache) {
        this.acceptRequired(mustache, "path");
        this.acceptArray(mustache.params);
        this.acceptKey(mustache, "hash");
      }
      function visitBlock(block2) {
        visitSubExpression.call(this, block2);
        this.acceptKey(block2, "program");
        this.acceptKey(block2, "inverse");
      }
      function visitPartial(partial) {
        this.acceptRequired(partial, "name");
        this.acceptArray(partial.params);
        this.acceptKey(partial, "hash");
      }
      exports$1["default"] = Visitor;
      module.exports = exports$1["default"];
    })(visitor, visitor.exports);
    return visitor.exports;
  }
  var hasRequiredWhitespaceControl;
  function requireWhitespaceControl() {
    if (hasRequiredWhitespaceControl) return whitespaceControl.exports;
    hasRequiredWhitespaceControl = 1;
    (function(module, exports$1) {
      exports$1.__esModule = true;
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var _visitor = requireVisitor();
      var _visitor2 = _interopRequireDefault(_visitor);
      function WhitespaceControl() {
        var options = arguments.length <= 0 || arguments[0] === void 0 ? {} : arguments[0];
        this.options = options;
      }
      WhitespaceControl.prototype = new _visitor2["default"]();
      WhitespaceControl.prototype.Program = function(program) {
        var doStandalone = !this.options.ignoreStandalone;
        var isRoot = !this.isRootSeen;
        this.isRootSeen = true;
        var body = program.body;
        for (var i = 0, l = body.length; i < l; i++) {
          var current = body[i], strip = this.accept(current);
          if (!strip) {
            continue;
          }
          var _isPrevWhitespace = isPrevWhitespace(body, i, isRoot), _isNextWhitespace = isNextWhitespace(body, i, isRoot), openStandalone = strip.openStandalone && _isPrevWhitespace, closeStandalone = strip.closeStandalone && _isNextWhitespace, inlineStandalone = strip.inlineStandalone && _isPrevWhitespace && _isNextWhitespace;
          if (strip.close) {
            omitRight(body, i, true);
          }
          if (strip.open) {
            omitLeft(body, i, true);
          }
          if (doStandalone && inlineStandalone) {
            omitRight(body, i);
            if (omitLeft(body, i)) {
              if (current.type === "PartialStatement") {
                current.indent = /([ \t]+$)/.exec(body[i - 1].original)[1];
              }
            }
          }
          if (doStandalone && openStandalone) {
            omitRight((current.program || current.inverse).body);
            omitLeft(body, i);
          }
          if (doStandalone && closeStandalone) {
            omitRight(body, i);
            omitLeft((current.inverse || current.program).body);
          }
        }
        return program;
      };
      WhitespaceControl.prototype.BlockStatement = WhitespaceControl.prototype.DecoratorBlock = WhitespaceControl.prototype.PartialBlockStatement = function(block2) {
        this.accept(block2.program);
        this.accept(block2.inverse);
        var program = block2.program || block2.inverse, inverse = block2.program && block2.inverse, firstInverse = inverse, lastInverse = inverse;
        if (inverse && inverse.chained) {
          firstInverse = inverse.body[0].program;
          while (lastInverse.chained) {
            lastInverse = lastInverse.body[lastInverse.body.length - 1].program;
          }
        }
        var strip = {
          open: block2.openStrip.open,
          close: block2.closeStrip.close,
          // Determine the standalone candiacy. Basically flag our content as being possibly standalone
          // so our parent can determine if we actually are standalone
          openStandalone: isNextWhitespace(program.body),
          closeStandalone: isPrevWhitespace((firstInverse || program).body)
        };
        if (block2.openStrip.close) {
          omitRight(program.body, null, true);
        }
        if (inverse) {
          var inverseStrip = block2.inverseStrip;
          if (inverseStrip.open) {
            omitLeft(program.body, null, true);
          }
          if (inverseStrip.close) {
            omitRight(firstInverse.body, null, true);
          }
          if (block2.closeStrip.open) {
            omitLeft(lastInverse.body, null, true);
          }
          if (!this.options.ignoreStandalone && isPrevWhitespace(program.body) && isNextWhitespace(firstInverse.body)) {
            omitLeft(program.body);
            omitRight(firstInverse.body);
          }
        } else if (block2.closeStrip.open) {
          omitLeft(program.body, null, true);
        }
        return strip;
      };
      WhitespaceControl.prototype.Decorator = WhitespaceControl.prototype.MustacheStatement = function(mustache) {
        return mustache.strip;
      };
      WhitespaceControl.prototype.PartialStatement = WhitespaceControl.prototype.CommentStatement = function(node) {
        var strip = node.strip || {};
        return {
          inlineStandalone: true,
          open: strip.open,
          close: strip.close
        };
      };
      function isPrevWhitespace(body, i, isRoot) {
        if (i === void 0) {
          i = body.length;
        }
        var prev = body[i - 1], sibling = body[i - 2];
        if (!prev) {
          return isRoot;
        }
        if (prev.type === "ContentStatement") {
          return (sibling || !isRoot ? /\r?\n\s*?$/ : /(^|\r?\n)\s*?$/).test(prev.original);
        }
      }
      function isNextWhitespace(body, i, isRoot) {
        if (i === void 0) {
          i = -1;
        }
        var next = body[i + 1], sibling = body[i + 2];
        if (!next) {
          return isRoot;
        }
        if (next.type === "ContentStatement") {
          return (sibling || !isRoot ? /^\s*?\r?\n/ : /^\s*?(\r?\n|$)/).test(next.original);
        }
      }
      function omitRight(body, i, multiple) {
        var current = body[i == null ? 0 : i + 1];
        if (!current || current.type !== "ContentStatement" || !multiple && current.rightStripped) {
          return;
        }
        var original = current.value;
        current.value = current.value.replace(multiple ? /^\s+/ : /^[ \t]*\r?\n?/, "");
        current.rightStripped = current.value !== original;
      }
      function omitLeft(body, i, multiple) {
        var current = body[i == null ? body.length - 1 : i - 1];
        if (!current || current.type !== "ContentStatement" || !multiple && current.leftStripped) {
          return;
        }
        var original = current.value;
        current.value = current.value.replace(multiple ? /\s+$/ : /[ \t]+$/, "");
        current.leftStripped = current.value !== original;
        return current.leftStripped;
      }
      exports$1["default"] = WhitespaceControl;
      module.exports = exports$1["default"];
    })(whitespaceControl, whitespaceControl.exports);
    return whitespaceControl.exports;
  }
  var helpers = {};
  var hasRequiredHelpers;
  function requireHelpers() {
    if (hasRequiredHelpers) return helpers;
    hasRequiredHelpers = 1;
    helpers.__esModule = true;
    helpers.SourceLocation = SourceLocation;
    helpers.id = id;
    helpers.stripFlags = stripFlags;
    helpers.stripComment = stripComment;
    helpers.preparePath = preparePath;
    helpers.prepareMustache = prepareMustache;
    helpers.prepareRawBlock = prepareRawBlock;
    helpers.prepareBlock = prepareBlock;
    helpers.prepareProgram = prepareProgram;
    helpers.preparePartialBlock = preparePartialBlock;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var _exception = requireException();
    var _exception2 = _interopRequireDefault(_exception);
    function validateClose(open, close) {
      close = close.path ? close.path.original : close;
      if (open.path.original !== close) {
        var errorNode = { loc: open.path.loc };
        throw new _exception2["default"](open.path.original + " doesn't match " + close, errorNode);
      }
    }
    function SourceLocation(source, locInfo) {
      this.source = source;
      this.start = {
        line: locInfo.first_line,
        column: locInfo.first_column
      };
      this.end = {
        line: locInfo.last_line,
        column: locInfo.last_column
      };
    }
    function id(token) {
      if (/^\[.*\]$/.test(token)) {
        return token.substring(1, token.length - 1);
      } else {
        return token;
      }
    }
    function stripFlags(open, close) {
      return {
        open: open.charAt(2) === "~",
        close: close.charAt(close.length - 3) === "~"
      };
    }
    function stripComment(comment) {
      return comment.replace(/^\{\{~?!-?-?/, "").replace(/-?-?~?\}\}$/, "");
    }
    function preparePath(data, parts, loc) {
      loc = this.locInfo(loc);
      var original = data ? "@" : "", dig = [], depth = 0;
      for (var i = 0, l = parts.length; i < l; i++) {
        var part = parts[i].part, isLiteral = parts[i].original !== part;
        original += (parts[i].separator || "") + part;
        if (!isLiteral && (part === ".." || part === "." || part === "this")) {
          if (dig.length > 0) {
            throw new _exception2["default"]("Invalid path: " + original, { loc });
          } else if (part === "..") {
            depth++;
          }
        } else {
          dig.push(part);
        }
      }
      return {
        type: "PathExpression",
        data,
        depth,
        parts: dig,
        original,
        loc
      };
    }
    function prepareMustache(path, params, hash, open, strip, locInfo) {
      var escapeFlag = open.charAt(3) || open.charAt(2), escaped = escapeFlag !== "{" && escapeFlag !== "&";
      var decorator = /\*/.test(open);
      return {
        type: decorator ? "Decorator" : "MustacheStatement",
        path,
        params,
        hash,
        escaped,
        strip,
        loc: this.locInfo(locInfo)
      };
    }
    function prepareRawBlock(openRawBlock, contents, close, locInfo) {
      validateClose(openRawBlock, close);
      locInfo = this.locInfo(locInfo);
      var program = {
        type: "Program",
        body: contents,
        strip: {},
        loc: locInfo
      };
      return {
        type: "BlockStatement",
        path: openRawBlock.path,
        params: openRawBlock.params,
        hash: openRawBlock.hash,
        program,
        openStrip: {},
        inverseStrip: {},
        closeStrip: {},
        loc: locInfo
      };
    }
    function prepareBlock(openBlock, program, inverseAndProgram, close, inverted, locInfo) {
      if (close && close.path) {
        validateClose(openBlock, close);
      }
      var decorator = /\*/.test(openBlock.open);
      program.blockParams = openBlock.blockParams;
      var inverse = void 0, inverseStrip = void 0;
      if (inverseAndProgram) {
        if (decorator) {
          throw new _exception2["default"]("Unexpected inverse block on decorator", inverseAndProgram);
        }
        if (inverseAndProgram.chain) {
          inverseAndProgram.program.body[0].closeStrip = close.strip;
        }
        inverseStrip = inverseAndProgram.strip;
        inverse = inverseAndProgram.program;
      }
      if (inverted) {
        inverted = inverse;
        inverse = program;
        program = inverted;
      }
      return {
        type: decorator ? "DecoratorBlock" : "BlockStatement",
        path: openBlock.path,
        params: openBlock.params,
        hash: openBlock.hash,
        program,
        inverse,
        openStrip: openBlock.strip,
        inverseStrip,
        closeStrip: close && close.strip,
        loc: this.locInfo(locInfo)
      };
    }
    function prepareProgram(statements, loc) {
      if (!loc && statements.length) {
        var firstLoc = statements[0].loc, lastLoc = statements[statements.length - 1].loc;
        if (firstLoc && lastLoc) {
          loc = {
            source: firstLoc.source,
            start: {
              line: firstLoc.start.line,
              column: firstLoc.start.column
            },
            end: {
              line: lastLoc.end.line,
              column: lastLoc.end.column
            }
          };
        }
      }
      return {
        type: "Program",
        body: statements,
        strip: {},
        loc
      };
    }
    function preparePartialBlock(open, program, close, locInfo) {
      validateClose(open, close);
      return {
        type: "PartialBlockStatement",
        name: open.path,
        params: open.params,
        hash: open.hash,
        program,
        openStrip: open.strip,
        closeStrip: close && close.strip,
        loc: this.locInfo(locInfo)
      };
    }
    return helpers;
  }
  var hasRequiredBase;
  function requireBase() {
    if (hasRequiredBase) return base;
    hasRequiredBase = 1;
    base.__esModule = true;
    base.parseWithoutProcessing = parseWithoutProcessing;
    base.parse = parse;
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
          }
        }
        newObj["default"] = obj;
        return newObj;
      }
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var _parser = requireParser();
    var _parser2 = _interopRequireDefault(_parser);
    var _whitespaceControl = requireWhitespaceControl();
    var _whitespaceControl2 = _interopRequireDefault(_whitespaceControl);
    var _helpers = requireHelpers();
    var Helpers = _interopRequireWildcard(_helpers);
    var _utils = requireUtils();
    base.parser = _parser2["default"];
    var yy = {};
    _utils.extend(yy, Helpers);
    function parseWithoutProcessing(input, options) {
      if (input.type === "Program") {
        return input;
      }
      _parser2["default"].yy = yy;
      yy.locInfo = function(locInfo) {
        return new yy.SourceLocation(options && options.srcName, locInfo);
      };
      var ast2 = _parser2["default"].parse(input);
      return ast2;
    }
    function parse(input, options) {
      var ast2 = parseWithoutProcessing(input, options);
      var strip = new _whitespaceControl2["default"](options);
      return strip.accept(ast2);
    }
    return base;
  }
  var compiler = {};
  var hasRequiredCompiler;
  function requireCompiler() {
    if (hasRequiredCompiler) return compiler;
    hasRequiredCompiler = 1;
    compiler.__esModule = true;
    compiler.Compiler = Compiler;
    compiler.precompile = precompile;
    compiler.compile = compile;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var _exception = requireException();
    var _exception2 = _interopRequireDefault(_exception);
    var _utils = requireUtils();
    var _ast = requireAst();
    var _ast2 = _interopRequireDefault(_ast);
    var slice = [].slice;
    function Compiler() {
    }
    Compiler.prototype = {
      compiler: Compiler,
      equals: function equals2(other) {
        var len = this.opcodes.length;
        if (other.opcodes.length !== len) {
          return false;
        }
        for (var i = 0; i < len; i++) {
          var opcode = this.opcodes[i], otherOpcode = other.opcodes[i];
          if (opcode.opcode !== otherOpcode.opcode || !argEquals(opcode.args, otherOpcode.args)) {
            return false;
          }
        }
        len = this.children.length;
        for (var i = 0; i < len; i++) {
          if (!this.children[i].equals(other.children[i])) {
            return false;
          }
        }
        return true;
      },
      guid: 0,
      compile: function compile2(program, options) {
        this.sourceNode = [];
        this.opcodes = [];
        this.children = [];
        this.options = options;
        this.stringParams = options.stringParams;
        this.trackIds = options.trackIds;
        options.blockParams = options.blockParams || [];
        options.knownHelpers = _utils.extend(/* @__PURE__ */ Object.create(null), {
          helperMissing: true,
          blockHelperMissing: true,
          each: true,
          "if": true,
          unless: true,
          "with": true,
          log: true,
          lookup: true
        }, options.knownHelpers);
        return this.accept(program);
      },
      compileProgram: function compileProgram(program) {
        var childCompiler = new this.compiler(), result = childCompiler.compile(program, this.options), guid = this.guid++;
        this.usePartial = this.usePartial || result.usePartial;
        this.children[guid] = result;
        this.useDepths = this.useDepths || result.useDepths;
        return guid;
      },
      accept: function accept(node) {
        if (!this[node.type]) {
          throw new _exception2["default"]("Unknown type: " + node.type, node);
        }
        this.sourceNode.unshift(node);
        var ret = this[node.type](node);
        this.sourceNode.shift();
        return ret;
      },
      Program: function Program(program) {
        this.options.blockParams.unshift(program.blockParams);
        var body = program.body, bodyLength = body.length;
        for (var i = 0; i < bodyLength; i++) {
          this.accept(body[i]);
        }
        this.options.blockParams.shift();
        this.isSimple = bodyLength === 1;
        this.blockParams = program.blockParams ? program.blockParams.length : 0;
        return this;
      },
      BlockStatement: function BlockStatement(block2) {
        transformLiteralToPath(block2);
        var program = block2.program, inverse = block2.inverse;
        program = program && this.compileProgram(program);
        inverse = inverse && this.compileProgram(inverse);
        var type = this.classifySexpr(block2);
        if (type === "helper") {
          this.helperSexpr(block2, program, inverse);
        } else if (type === "simple") {
          this.simpleSexpr(block2);
          this.opcode("pushProgram", program);
          this.opcode("pushProgram", inverse);
          this.opcode("emptyHash");
          this.opcode("blockValue", block2.path.original);
        } else {
          this.ambiguousSexpr(block2, program, inverse);
          this.opcode("pushProgram", program);
          this.opcode("pushProgram", inverse);
          this.opcode("emptyHash");
          this.opcode("ambiguousBlockValue");
        }
        this.opcode("append");
      },
      DecoratorBlock: function DecoratorBlock(decorator) {
        var program = decorator.program && this.compileProgram(decorator.program);
        var params = this.setupFullMustacheParams(decorator, program, void 0), path = decorator.path;
        this.useDecorators = true;
        this.opcode("registerDecorator", params.length, path.original);
      },
      PartialStatement: function PartialStatement(partial) {
        this.usePartial = true;
        var program = partial.program;
        if (program) {
          program = this.compileProgram(partial.program);
        }
        var params = partial.params;
        if (params.length > 1) {
          throw new _exception2["default"]("Unsupported number of partial arguments: " + params.length, partial);
        } else if (!params.length) {
          if (this.options.explicitPartialContext) {
            this.opcode("pushLiteral", "undefined");
          } else {
            params.push({ type: "PathExpression", parts: [], depth: 0 });
          }
        }
        var partialName = partial.name.original, isDynamic = partial.name.type === "SubExpression";
        if (isDynamic) {
          this.accept(partial.name);
        }
        this.setupFullMustacheParams(partial, program, void 0, true);
        var indent = partial.indent || "";
        if (this.options.preventIndent && indent) {
          this.opcode("appendContent", indent);
          indent = "";
        }
        this.opcode("invokePartial", isDynamic, partialName, indent);
        this.opcode("append");
      },
      PartialBlockStatement: function PartialBlockStatement(partialBlock) {
        this.PartialStatement(partialBlock);
      },
      MustacheStatement: function MustacheStatement(mustache) {
        this.SubExpression(mustache);
        if (mustache.escaped && !this.options.noEscape) {
          this.opcode("appendEscaped");
        } else {
          this.opcode("append");
        }
      },
      Decorator: function Decorator(decorator) {
        this.DecoratorBlock(decorator);
      },
      ContentStatement: function ContentStatement(content) {
        if (content.value) {
          this.opcode("appendContent", content.value);
        }
      },
      CommentStatement: function CommentStatement() {
      },
      SubExpression: function SubExpression(sexpr) {
        transformLiteralToPath(sexpr);
        var type = this.classifySexpr(sexpr);
        if (type === "simple") {
          this.simpleSexpr(sexpr);
        } else if (type === "helper") {
          this.helperSexpr(sexpr);
        } else {
          this.ambiguousSexpr(sexpr);
        }
      },
      ambiguousSexpr: function ambiguousSexpr(sexpr, program, inverse) {
        var path = sexpr.path, name = path.parts[0], isBlock = program != null || inverse != null;
        this.opcode("getContext", path.depth);
        this.opcode("pushProgram", program);
        this.opcode("pushProgram", inverse);
        path.strict = true;
        this.accept(path);
        this.opcode("invokeAmbiguous", name, isBlock);
      },
      simpleSexpr: function simpleSexpr(sexpr) {
        var path = sexpr.path;
        path.strict = true;
        this.accept(path);
        this.opcode("resolvePossibleLambda");
      },
      helperSexpr: function helperSexpr(sexpr, program, inverse) {
        var params = this.setupFullMustacheParams(sexpr, program, inverse), path = sexpr.path, name = path.parts[0];
        if (this.options.knownHelpers[name]) {
          this.opcode("invokeKnownHelper", params.length, name);
        } else if (this.options.knownHelpersOnly) {
          throw new _exception2["default"]("You specified knownHelpersOnly, but used the unknown helper " + name, sexpr);
        } else {
          path.strict = true;
          path.falsy = true;
          this.accept(path);
          this.opcode("invokeHelper", params.length, path.original, _ast2["default"].helpers.simpleId(path));
        }
      },
      PathExpression: function PathExpression(path) {
        this.addDepth(path.depth);
        this.opcode("getContext", path.depth);
        var name = path.parts[0], scoped = _ast2["default"].helpers.scopedId(path), blockParamId = !path.depth && !scoped && this.blockParamIndex(name);
        if (blockParamId) {
          this.opcode("lookupBlockParam", blockParamId, path.parts);
        } else if (!name) {
          this.opcode("pushContext");
        } else if (path.data) {
          this.options.data = true;
          this.opcode("lookupData", path.depth, path.parts, path.strict);
        } else {
          this.opcode("lookupOnContext", path.parts, path.falsy, path.strict, scoped);
        }
      },
      StringLiteral: function StringLiteral(string2) {
        this.opcode("pushString", string2.value);
      },
      NumberLiteral: function NumberLiteral(number) {
        this.opcode("pushLiteral", number.value);
      },
      BooleanLiteral: function BooleanLiteral(bool) {
        this.opcode("pushLiteral", bool.value);
      },
      UndefinedLiteral: function UndefinedLiteral() {
        this.opcode("pushLiteral", "undefined");
      },
      NullLiteral: function NullLiteral() {
        this.opcode("pushLiteral", "null");
      },
      Hash: function Hash(hash) {
        var pairs = hash.pairs, i = 0, l = pairs.length;
        this.opcode("pushHash");
        for (; i < l; i++) {
          this.pushParam(pairs[i].value);
        }
        while (i--) {
          this.opcode("assignToHash", pairs[i].key);
        }
        this.opcode("popHash");
      },
      // HELPERS
      opcode: function opcode(name) {
        this.opcodes.push({
          opcode: name,
          args: slice.call(arguments, 1),
          loc: this.sourceNode[0].loc
        });
      },
      addDepth: function addDepth(depth) {
        if (!depth) {
          return;
        }
        this.useDepths = true;
      },
      classifySexpr: function classifySexpr(sexpr) {
        var isSimple = _ast2["default"].helpers.simpleId(sexpr.path);
        var isBlockParam = isSimple && !!this.blockParamIndex(sexpr.path.parts[0]);
        var isHelper = !isBlockParam && _ast2["default"].helpers.helperExpression(sexpr);
        var isEligible = !isBlockParam && (isHelper || isSimple);
        if (isEligible && !isHelper) {
          var _name = sexpr.path.parts[0], options = this.options;
          if (options.knownHelpers[_name]) {
            isHelper = true;
          } else if (options.knownHelpersOnly) {
            isEligible = false;
          }
        }
        if (isHelper) {
          return "helper";
        } else if (isEligible) {
          return "ambiguous";
        } else {
          return "simple";
        }
      },
      pushParams: function pushParams(params) {
        for (var i = 0, l = params.length; i < l; i++) {
          this.pushParam(params[i]);
        }
      },
      pushParam: function pushParam(val) {
        var value = val.value != null ? val.value : val.original || "";
        if (this.stringParams) {
          if (value.replace) {
            value = value.replace(/^(\.?\.\/)*/g, "").replace(/\//g, ".");
          }
          if (val.depth) {
            this.addDepth(val.depth);
          }
          this.opcode("getContext", val.depth || 0);
          this.opcode("pushStringParam", value, val.type);
          if (val.type === "SubExpression") {
            this.accept(val);
          }
        } else {
          if (this.trackIds) {
            var blockParamIndex = void 0;
            if (val.parts && !_ast2["default"].helpers.scopedId(val) && !val.depth) {
              blockParamIndex = this.blockParamIndex(val.parts[0]);
            }
            if (blockParamIndex) {
              var blockParamChild = val.parts.slice(1).join(".");
              this.opcode("pushId", "BlockParam", blockParamIndex, blockParamChild);
            } else {
              value = val.original || value;
              if (value.replace) {
                value = value.replace(/^this(?:\.|$)/, "").replace(/^\.\//, "").replace(/^\.$/, "");
              }
              this.opcode("pushId", val.type, value);
            }
          }
          this.accept(val);
        }
      },
      setupFullMustacheParams: function setupFullMustacheParams(sexpr, program, inverse, omitEmpty) {
        var params = sexpr.params;
        this.pushParams(params);
        this.opcode("pushProgram", program);
        this.opcode("pushProgram", inverse);
        if (sexpr.hash) {
          this.accept(sexpr.hash);
        } else {
          this.opcode("emptyHash", omitEmpty);
        }
        return params;
      },
      blockParamIndex: function blockParamIndex(name) {
        for (var depth = 0, len = this.options.blockParams.length; depth < len; depth++) {
          var blockParams = this.options.blockParams[depth], param = blockParams && _utils.indexOf(blockParams, name);
          if (blockParams && param >= 0) {
            return [depth, param];
          }
        }
      }
    };
    function precompile(input, options, env) {
      if (input == null || typeof input !== "string" && input.type !== "Program") {
        throw new _exception2["default"]("You must pass a string or Handlebars AST to Handlebars.precompile. You passed " + input);
      }
      options = options || {};
      if (!("data" in options)) {
        options.data = true;
      }
      if (options.compat) {
        options.useDepths = true;
      }
      var ast2 = env.parse(input, options), environment = new env.Compiler().compile(ast2, options);
      return new env.JavaScriptCompiler().compile(environment, options);
    }
    function compile(input, options, env) {
      if (options === void 0) options = {};
      if (input == null || typeof input !== "string" && input.type !== "Program") {
        throw new _exception2["default"]("You must pass a string or Handlebars AST to Handlebars.compile. You passed " + input);
      }
      options = _utils.extend({}, options);
      if (!("data" in options)) {
        options.data = true;
      }
      if (options.compat) {
        options.useDepths = true;
      }
      var compiled = void 0;
      function compileInput() {
        var ast2 = env.parse(input, options), environment = new env.Compiler().compile(ast2, options), templateSpec = new env.JavaScriptCompiler().compile(environment, options, void 0, true);
        return env.template(templateSpec);
      }
      function ret(context, execOptions) {
        if (!compiled) {
          compiled = compileInput();
        }
        return compiled.call(this, context, execOptions);
      }
      ret._setup = function(setupOptions) {
        if (!compiled) {
          compiled = compileInput();
        }
        return compiled._setup(setupOptions);
      };
      ret._child = function(i, data, blockParams, depths) {
        if (!compiled) {
          compiled = compileInput();
        }
        return compiled._child(i, data, blockParams, depths);
      };
      return ret;
    }
    function argEquals(a, b) {
      if (a === b) {
        return true;
      }
      if (_utils.isArray(a) && _utils.isArray(b) && a.length === b.length) {
        for (var i = 0; i < a.length; i++) {
          if (!argEquals(a[i], b[i])) {
            return false;
          }
        }
        return true;
      }
    }
    function transformLiteralToPath(sexpr) {
      if (!sexpr.path.parts) {
        var literal = sexpr.path;
        sexpr.path = {
          type: "PathExpression",
          data: false,
          depth: 0,
          parts: [literal.original + ""],
          original: literal.original + "",
          loc: literal.loc
        };
      }
    }
    return compiler;
  }
  var javascriptCompiler = { exports: {} };
  var codeGen = { exports: {} };
  var sourceMap = {};
  var sourceMapGenerator = {};
  var base64Vlq = {};
  var base64 = {};
  var hasRequiredBase64;
  function requireBase64() {
    if (hasRequiredBase64) return base64;
    hasRequiredBase64 = 1;
    var intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
    base64.encode = function(number) {
      if (0 <= number && number < intToCharMap.length) {
        return intToCharMap[number];
      }
      throw new TypeError("Must be between 0 and 63: " + number);
    };
    base64.decode = function(charCode) {
      var bigA = 65;
      var bigZ = 90;
      var littleA = 97;
      var littleZ = 122;
      var zero = 48;
      var nine = 57;
      var plus = 43;
      var slash = 47;
      var littleOffset = 26;
      var numberOffset = 52;
      if (bigA <= charCode && charCode <= bigZ) {
        return charCode - bigA;
      }
      if (littleA <= charCode && charCode <= littleZ) {
        return charCode - littleA + littleOffset;
      }
      if (zero <= charCode && charCode <= nine) {
        return charCode - zero + numberOffset;
      }
      if (charCode == plus) {
        return 62;
      }
      if (charCode == slash) {
        return 63;
      }
      return -1;
    };
    return base64;
  }
  var hasRequiredBase64Vlq;
  function requireBase64Vlq() {
    if (hasRequiredBase64Vlq) return base64Vlq;
    hasRequiredBase64Vlq = 1;
    var base642 = requireBase64();
    var VLQ_BASE_SHIFT = 5;
    var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
    var VLQ_BASE_MASK = VLQ_BASE - 1;
    var VLQ_CONTINUATION_BIT = VLQ_BASE;
    function toVLQSigned(aValue) {
      return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
    }
    function fromVLQSigned(aValue) {
      var isNegative = (aValue & 1) === 1;
      var shifted = aValue >> 1;
      return isNegative ? -shifted : shifted;
    }
    base64Vlq.encode = function base64VLQ_encode(aValue) {
      var encoded = "";
      var digit;
      var vlq = toVLQSigned(aValue);
      do {
        digit = vlq & VLQ_BASE_MASK;
        vlq >>>= VLQ_BASE_SHIFT;
        if (vlq > 0) {
          digit |= VLQ_CONTINUATION_BIT;
        }
        encoded += base642.encode(digit);
      } while (vlq > 0);
      return encoded;
    };
    base64Vlq.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
      var strLen = aStr.length;
      var result = 0;
      var shift = 0;
      var continuation, digit;
      do {
        if (aIndex >= strLen) {
          throw new Error("Expected more digits in base 64 VLQ value.");
        }
        digit = base642.decode(aStr.charCodeAt(aIndex++));
        if (digit === -1) {
          throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
        }
        continuation = !!(digit & VLQ_CONTINUATION_BIT);
        digit &= VLQ_BASE_MASK;
        result = result + (digit << shift);
        shift += VLQ_BASE_SHIFT;
      } while (continuation);
      aOutParam.value = fromVLQSigned(result);
      aOutParam.rest = aIndex;
    };
    return base64Vlq;
  }
  var util = {};
  var hasRequiredUtil;
  function requireUtil() {
    if (hasRequiredUtil) return util;
    hasRequiredUtil = 1;
    (function(exports$1) {
      function getArg(aArgs, aName, aDefaultValue) {
        if (aName in aArgs) {
          return aArgs[aName];
        } else if (arguments.length === 3) {
          return aDefaultValue;
        } else {
          throw new Error('"' + aName + '" is a required argument.');
        }
      }
      exports$1.getArg = getArg;
      var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
      var dataUrlRegexp = /^data:.+\,.+$/;
      function urlParse(aUrl) {
        var match2 = aUrl.match(urlRegexp);
        if (!match2) {
          return null;
        }
        return {
          scheme: match2[1],
          auth: match2[2],
          host: match2[3],
          port: match2[4],
          path: match2[5]
        };
      }
      exports$1.urlParse = urlParse;
      function urlGenerate(aParsedUrl) {
        var url = "";
        if (aParsedUrl.scheme) {
          url += aParsedUrl.scheme + ":";
        }
        url += "//";
        if (aParsedUrl.auth) {
          url += aParsedUrl.auth + "@";
        }
        if (aParsedUrl.host) {
          url += aParsedUrl.host;
        }
        if (aParsedUrl.port) {
          url += ":" + aParsedUrl.port;
        }
        if (aParsedUrl.path) {
          url += aParsedUrl.path;
        }
        return url;
      }
      exports$1.urlGenerate = urlGenerate;
      function normalize(aPath) {
        var path = aPath;
        var url = urlParse(aPath);
        if (url) {
          if (!url.path) {
            return aPath;
          }
          path = url.path;
        }
        var isAbsolute = exports$1.isAbsolute(path);
        var parts = path.split(/\/+/);
        for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
          part = parts[i];
          if (part === ".") {
            parts.splice(i, 1);
          } else if (part === "..") {
            up++;
          } else if (up > 0) {
            if (part === "") {
              parts.splice(i + 1, up);
              up = 0;
            } else {
              parts.splice(i, 2);
              up--;
            }
          }
        }
        path = parts.join("/");
        if (path === "") {
          path = isAbsolute ? "/" : ".";
        }
        if (url) {
          url.path = path;
          return urlGenerate(url);
        }
        return path;
      }
      exports$1.normalize = normalize;
      function join(aRoot, aPath) {
        if (aRoot === "") {
          aRoot = ".";
        }
        if (aPath === "") {
          aPath = ".";
        }
        var aPathUrl = urlParse(aPath);
        var aRootUrl = urlParse(aRoot);
        if (aRootUrl) {
          aRoot = aRootUrl.path || "/";
        }
        if (aPathUrl && !aPathUrl.scheme) {
          if (aRootUrl) {
            aPathUrl.scheme = aRootUrl.scheme;
          }
          return urlGenerate(aPathUrl);
        }
        if (aPathUrl || aPath.match(dataUrlRegexp)) {
          return aPath;
        }
        if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
          aRootUrl.host = aPath;
          return urlGenerate(aRootUrl);
        }
        var joined = aPath.charAt(0) === "/" ? aPath : normalize(aRoot.replace(/\/+$/, "") + "/" + aPath);
        if (aRootUrl) {
          aRootUrl.path = joined;
          return urlGenerate(aRootUrl);
        }
        return joined;
      }
      exports$1.join = join;
      exports$1.isAbsolute = function(aPath) {
        return aPath.charAt(0) === "/" || urlRegexp.test(aPath);
      };
      function relative(aRoot, aPath) {
        if (aRoot === "") {
          aRoot = ".";
        }
        aRoot = aRoot.replace(/\/$/, "");
        var level = 0;
        while (aPath.indexOf(aRoot + "/") !== 0) {
          var index = aRoot.lastIndexOf("/");
          if (index < 0) {
            return aPath;
          }
          aRoot = aRoot.slice(0, index);
          if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
            return aPath;
          }
          ++level;
        }
        return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
      }
      exports$1.relative = relative;
      var supportsNullProto = (function() {
        var obj = /* @__PURE__ */ Object.create(null);
        return !("__proto__" in obj);
      })();
      function identity2(s) {
        return s;
      }
      function toSetString(aStr) {
        if (isProtoString(aStr)) {
          return "$" + aStr;
        }
        return aStr;
      }
      exports$1.toSetString = supportsNullProto ? identity2 : toSetString;
      function fromSetString(aStr) {
        if (isProtoString(aStr)) {
          return aStr.slice(1);
        }
        return aStr;
      }
      exports$1.fromSetString = supportsNullProto ? identity2 : fromSetString;
      function isProtoString(s) {
        if (!s) {
          return false;
        }
        var length2 = s.length;
        if (length2 < 9) {
          return false;
        }
        if (s.charCodeAt(length2 - 1) !== 95 || s.charCodeAt(length2 - 2) !== 95 || s.charCodeAt(length2 - 3) !== 111 || s.charCodeAt(length2 - 4) !== 116 || s.charCodeAt(length2 - 5) !== 111 || s.charCodeAt(length2 - 6) !== 114 || s.charCodeAt(length2 - 7) !== 112 || s.charCodeAt(length2 - 8) !== 95 || s.charCodeAt(length2 - 9) !== 95) {
          return false;
        }
        for (var i = length2 - 10; i >= 0; i--) {
          if (s.charCodeAt(i) !== 36) {
            return false;
          }
        }
        return true;
      }
      function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
        var cmp = strcmp(mappingA.source, mappingB.source);
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalLine - mappingB.originalLine;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalColumn - mappingB.originalColumn;
        if (cmp !== 0 || onlyCompareOriginal) {
          return cmp;
        }
        cmp = mappingA.generatedColumn - mappingB.generatedColumn;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.generatedLine - mappingB.generatedLine;
        if (cmp !== 0) {
          return cmp;
        }
        return strcmp(mappingA.name, mappingB.name);
      }
      exports$1.compareByOriginalPositions = compareByOriginalPositions;
      function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
        var cmp = mappingA.generatedLine - mappingB.generatedLine;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.generatedColumn - mappingB.generatedColumn;
        if (cmp !== 0 || onlyCompareGenerated) {
          return cmp;
        }
        cmp = strcmp(mappingA.source, mappingB.source);
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalLine - mappingB.originalLine;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalColumn - mappingB.originalColumn;
        if (cmp !== 0) {
          return cmp;
        }
        return strcmp(mappingA.name, mappingB.name);
      }
      exports$1.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
      function strcmp(aStr1, aStr2) {
        if (aStr1 === aStr2) {
          return 0;
        }
        if (aStr1 === null) {
          return 1;
        }
        if (aStr2 === null) {
          return -1;
        }
        if (aStr1 > aStr2) {
          return 1;
        }
        return -1;
      }
      function compareByGeneratedPositionsInflated(mappingA, mappingB) {
        var cmp = mappingA.generatedLine - mappingB.generatedLine;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.generatedColumn - mappingB.generatedColumn;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = strcmp(mappingA.source, mappingB.source);
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalLine - mappingB.originalLine;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalColumn - mappingB.originalColumn;
        if (cmp !== 0) {
          return cmp;
        }
        return strcmp(mappingA.name, mappingB.name);
      }
      exports$1.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
      function parseSourceMapInput(str) {
        return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ""));
      }
      exports$1.parseSourceMapInput = parseSourceMapInput;
      function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
        sourceURL = sourceURL || "";
        if (sourceRoot) {
          if (sourceRoot[sourceRoot.length - 1] !== "/" && sourceURL[0] !== "/") {
            sourceRoot += "/";
          }
          sourceURL = sourceRoot + sourceURL;
        }
        if (sourceMapURL) {
          var parsed = urlParse(sourceMapURL);
          if (!parsed) {
            throw new Error("sourceMapURL could not be parsed");
          }
          if (parsed.path) {
            var index = parsed.path.lastIndexOf("/");
            if (index >= 0) {
              parsed.path = parsed.path.substring(0, index + 1);
            }
          }
          sourceURL = join(urlGenerate(parsed), sourceURL);
        }
        return normalize(sourceURL);
      }
      exports$1.computeSourceURL = computeSourceURL;
    })(util);
    return util;
  }
  var arraySet = {};
  var hasRequiredArraySet;
  function requireArraySet() {
    if (hasRequiredArraySet) return arraySet;
    hasRequiredArraySet = 1;
    var util2 = requireUtil();
    var has = Object.prototype.hasOwnProperty;
    var hasNativeMap = typeof Map !== "undefined";
    function ArraySet() {
      this._array = [];
      this._set = hasNativeMap ? /* @__PURE__ */ new Map() : /* @__PURE__ */ Object.create(null);
    }
    ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
      var set = new ArraySet();
      for (var i = 0, len = aArray.length; i < len; i++) {
        set.add(aArray[i], aAllowDuplicates);
      }
      return set;
    };
    ArraySet.prototype.size = function ArraySet_size() {
      return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
    };
    ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
      var sStr = hasNativeMap ? aStr : util2.toSetString(aStr);
      var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
      var idx = this._array.length;
      if (!isDuplicate || aAllowDuplicates) {
        this._array.push(aStr);
      }
      if (!isDuplicate) {
        if (hasNativeMap) {
          this._set.set(aStr, idx);
        } else {
          this._set[sStr] = idx;
        }
      }
    };
    ArraySet.prototype.has = function ArraySet_has(aStr) {
      if (hasNativeMap) {
        return this._set.has(aStr);
      } else {
        var sStr = util2.toSetString(aStr);
        return has.call(this._set, sStr);
      }
    };
    ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
      if (hasNativeMap) {
        var idx = this._set.get(aStr);
        if (idx >= 0) {
          return idx;
        }
      } else {
        var sStr = util2.toSetString(aStr);
        if (has.call(this._set, sStr)) {
          return this._set[sStr];
        }
      }
      throw new Error('"' + aStr + '" is not in the set.');
    };
    ArraySet.prototype.at = function ArraySet_at(aIdx) {
      if (aIdx >= 0 && aIdx < this._array.length) {
        return this._array[aIdx];
      }
      throw new Error("No element indexed by " + aIdx);
    };
    ArraySet.prototype.toArray = function ArraySet_toArray() {
      return this._array.slice();
    };
    arraySet.ArraySet = ArraySet;
    return arraySet;
  }
  var mappingList = {};
  var hasRequiredMappingList;
  function requireMappingList() {
    if (hasRequiredMappingList) return mappingList;
    hasRequiredMappingList = 1;
    var util2 = requireUtil();
    function generatedPositionAfter(mappingA, mappingB) {
      var lineA = mappingA.generatedLine;
      var lineB = mappingB.generatedLine;
      var columnA = mappingA.generatedColumn;
      var columnB = mappingB.generatedColumn;
      return lineB > lineA || lineB == lineA && columnB >= columnA || util2.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
    }
    function MappingList() {
      this._array = [];
      this._sorted = true;
      this._last = { generatedLine: -1, generatedColumn: 0 };
    }
    MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
      this._array.forEach(aCallback, aThisArg);
    };
    MappingList.prototype.add = function MappingList_add(aMapping) {
      if (generatedPositionAfter(this._last, aMapping)) {
        this._last = aMapping;
        this._array.push(aMapping);
      } else {
        this._sorted = false;
        this._array.push(aMapping);
      }
    };
    MappingList.prototype.toArray = function MappingList_toArray() {
      if (!this._sorted) {
        this._array.sort(util2.compareByGeneratedPositionsInflated);
        this._sorted = true;
      }
      return this._array;
    };
    mappingList.MappingList = MappingList;
    return mappingList;
  }
  var hasRequiredSourceMapGenerator;
  function requireSourceMapGenerator() {
    if (hasRequiredSourceMapGenerator) return sourceMapGenerator;
    hasRequiredSourceMapGenerator = 1;
    var base64VLQ = requireBase64Vlq();
    var util2 = requireUtil();
    var ArraySet = requireArraySet().ArraySet;
    var MappingList = requireMappingList().MappingList;
    function SourceMapGenerator(aArgs) {
      if (!aArgs) {
        aArgs = {};
      }
      this._file = util2.getArg(aArgs, "file", null);
      this._sourceRoot = util2.getArg(aArgs, "sourceRoot", null);
      this._skipValidation = util2.getArg(aArgs, "skipValidation", false);
      this._sources = new ArraySet();
      this._names = new ArraySet();
      this._mappings = new MappingList();
      this._sourcesContents = null;
    }
    SourceMapGenerator.prototype._version = 3;
    SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
      var sourceRoot = aSourceMapConsumer.sourceRoot;
      var generator2 = new SourceMapGenerator({
        file: aSourceMapConsumer.file,
        sourceRoot
      });
      aSourceMapConsumer.eachMapping(function(mapping) {
        var newMapping = {
          generated: {
            line: mapping.generatedLine,
            column: mapping.generatedColumn
          }
        };
        if (mapping.source != null) {
          newMapping.source = mapping.source;
          if (sourceRoot != null) {
            newMapping.source = util2.relative(sourceRoot, newMapping.source);
          }
          newMapping.original = {
            line: mapping.originalLine,
            column: mapping.originalColumn
          };
          if (mapping.name != null) {
            newMapping.name = mapping.name;
          }
        }
        generator2.addMapping(newMapping);
      });
      aSourceMapConsumer.sources.forEach(function(sourceFile) {
        var sourceRelative = sourceFile;
        if (sourceRoot !== null) {
          sourceRelative = util2.relative(sourceRoot, sourceFile);
        }
        if (!generator2._sources.has(sourceRelative)) {
          generator2._sources.add(sourceRelative);
        }
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          generator2.setSourceContent(sourceFile, content);
        }
      });
      return generator2;
    };
    SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
      var generated = util2.getArg(aArgs, "generated");
      var original = util2.getArg(aArgs, "original", null);
      var source = util2.getArg(aArgs, "source", null);
      var name = util2.getArg(aArgs, "name", null);
      if (!this._skipValidation) {
        this._validateMapping(generated, original, source, name);
      }
      if (source != null) {
        source = String(source);
        if (!this._sources.has(source)) {
          this._sources.add(source);
        }
      }
      if (name != null) {
        name = String(name);
        if (!this._names.has(name)) {
          this._names.add(name);
        }
      }
      this._mappings.add({
        generatedLine: generated.line,
        generatedColumn: generated.column,
        originalLine: original != null && original.line,
        originalColumn: original != null && original.column,
        source,
        name
      });
    };
    SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
      var source = aSourceFile;
      if (this._sourceRoot != null) {
        source = util2.relative(this._sourceRoot, source);
      }
      if (aSourceContent != null) {
        if (!this._sourcesContents) {
          this._sourcesContents = /* @__PURE__ */ Object.create(null);
        }
        this._sourcesContents[util2.toSetString(source)] = aSourceContent;
      } else if (this._sourcesContents) {
        delete this._sourcesContents[util2.toSetString(source)];
        if (Object.keys(this._sourcesContents).length === 0) {
          this._sourcesContents = null;
        }
      }
    };
    SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
      var sourceFile = aSourceFile;
      if (aSourceFile == null) {
        if (aSourceMapConsumer.file == null) {
          throw new Error(
            `SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`
          );
        }
        sourceFile = aSourceMapConsumer.file;
      }
      var sourceRoot = this._sourceRoot;
      if (sourceRoot != null) {
        sourceFile = util2.relative(sourceRoot, sourceFile);
      }
      var newSources = new ArraySet();
      var newNames = new ArraySet();
      this._mappings.unsortedForEach(function(mapping) {
        if (mapping.source === sourceFile && mapping.originalLine != null) {
          var original = aSourceMapConsumer.originalPositionFor({
            line: mapping.originalLine,
            column: mapping.originalColumn
          });
          if (original.source != null) {
            mapping.source = original.source;
            if (aSourceMapPath != null) {
              mapping.source = util2.join(aSourceMapPath, mapping.source);
            }
            if (sourceRoot != null) {
              mapping.source = util2.relative(sourceRoot, mapping.source);
            }
            mapping.originalLine = original.line;
            mapping.originalColumn = original.column;
            if (original.name != null) {
              mapping.name = original.name;
            }
          }
        }
        var source = mapping.source;
        if (source != null && !newSources.has(source)) {
          newSources.add(source);
        }
        var name = mapping.name;
        if (name != null && !newNames.has(name)) {
          newNames.add(name);
        }
      }, this);
      this._sources = newSources;
      this._names = newNames;
      aSourceMapConsumer.sources.forEach(function(sourceFile2) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile2);
        if (content != null) {
          if (aSourceMapPath != null) {
            sourceFile2 = util2.join(aSourceMapPath, sourceFile2);
          }
          if (sourceRoot != null) {
            sourceFile2 = util2.relative(sourceRoot, sourceFile2);
          }
          this.setSourceContent(sourceFile2, content);
        }
      }, this);
    };
    SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
      if (aOriginal && typeof aOriginal.line !== "number" && typeof aOriginal.column !== "number") {
        throw new Error(
          "original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values."
        );
      }
      if (aGenerated && "line" in aGenerated && "column" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
        return;
      } else if (aGenerated && "line" in aGenerated && "column" in aGenerated && aOriginal && "line" in aOriginal && "column" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
        return;
      } else {
        throw new Error("Invalid mapping: " + JSON.stringify({
          generated: aGenerated,
          source: aSource,
          original: aOriginal,
          name: aName
        }));
      }
    };
    SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
      var previousGeneratedColumn = 0;
      var previousGeneratedLine = 1;
      var previousOriginalColumn = 0;
      var previousOriginalLine = 0;
      var previousName = 0;
      var previousSource = 0;
      var result = "";
      var next;
      var mapping;
      var nameIdx;
      var sourceIdx;
      var mappings = this._mappings.toArray();
      for (var i = 0, len = mappings.length; i < len; i++) {
        mapping = mappings[i];
        next = "";
        if (mapping.generatedLine !== previousGeneratedLine) {
          previousGeneratedColumn = 0;
          while (mapping.generatedLine !== previousGeneratedLine) {
            next += ";";
            previousGeneratedLine++;
          }
        } else {
          if (i > 0) {
            if (!util2.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
              continue;
            }
            next += ",";
          }
        }
        next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
        previousGeneratedColumn = mapping.generatedColumn;
        if (mapping.source != null) {
          sourceIdx = this._sources.indexOf(mapping.source);
          next += base64VLQ.encode(sourceIdx - previousSource);
          previousSource = sourceIdx;
          next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
          previousOriginalLine = mapping.originalLine - 1;
          next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
          previousOriginalColumn = mapping.originalColumn;
          if (mapping.name != null) {
            nameIdx = this._names.indexOf(mapping.name);
            next += base64VLQ.encode(nameIdx - previousName);
            previousName = nameIdx;
          }
        }
        result += next;
      }
      return result;
    };
    SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
      return aSources.map(function(source) {
        if (!this._sourcesContents) {
          return null;
        }
        if (aSourceRoot != null) {
          source = util2.relative(aSourceRoot, source);
        }
        var key = util2.toSetString(source);
        return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
      }, this);
    };
    SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
      var map = {
        version: this._version,
        sources: this._sources.toArray(),
        names: this._names.toArray(),
        mappings: this._serializeMappings()
      };
      if (this._file != null) {
        map.file = this._file;
      }
      if (this._sourceRoot != null) {
        map.sourceRoot = this._sourceRoot;
      }
      if (this._sourcesContents) {
        map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
      }
      return map;
    };
    SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
      return JSON.stringify(this.toJSON());
    };
    sourceMapGenerator.SourceMapGenerator = SourceMapGenerator;
    return sourceMapGenerator;
  }
  var sourceMapConsumer = {};
  var binarySearch = {};
  var hasRequiredBinarySearch;
  function requireBinarySearch() {
    if (hasRequiredBinarySearch) return binarySearch;
    hasRequiredBinarySearch = 1;
    (function(exports$1) {
      exports$1.GREATEST_LOWER_BOUND = 1;
      exports$1.LEAST_UPPER_BOUND = 2;
      function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
        var mid = Math.floor((aHigh - aLow) / 2) + aLow;
        var cmp = aCompare(aNeedle, aHaystack[mid], true);
        if (cmp === 0) {
          return mid;
        } else if (cmp > 0) {
          if (aHigh - mid > 1) {
            return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
          }
          if (aBias == exports$1.LEAST_UPPER_BOUND) {
            return aHigh < aHaystack.length ? aHigh : -1;
          } else {
            return mid;
          }
        } else {
          if (mid - aLow > 1) {
            return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
          }
          if (aBias == exports$1.LEAST_UPPER_BOUND) {
            return mid;
          } else {
            return aLow < 0 ? -1 : aLow;
          }
        }
      }
      exports$1.search = function search(aNeedle, aHaystack, aCompare, aBias) {
        if (aHaystack.length === 0) {
          return -1;
        }
        var index = recursiveSearch(
          -1,
          aHaystack.length,
          aNeedle,
          aHaystack,
          aCompare,
          aBias || exports$1.GREATEST_LOWER_BOUND
        );
        if (index < 0) {
          return -1;
        }
        while (index - 1 >= 0) {
          if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
            break;
          }
          --index;
        }
        return index;
      };
    })(binarySearch);
    return binarySearch;
  }
  var quickSort = {};
  var hasRequiredQuickSort;
  function requireQuickSort() {
    if (hasRequiredQuickSort) return quickSort;
    hasRequiredQuickSort = 1;
    function swap(ary, x, y) {
      var temp = ary[x];
      ary[x] = ary[y];
      ary[y] = temp;
    }
    function randomIntInRange(low, high) {
      return Math.round(low + Math.random() * (high - low));
    }
    function doQuickSort(ary, comparator, p, r) {
      if (p < r) {
        var pivotIndex = randomIntInRange(p, r);
        var i = p - 1;
        swap(ary, pivotIndex, r);
        var pivot = ary[r];
        for (var j = p; j < r; j++) {
          if (comparator(ary[j], pivot) <= 0) {
            i += 1;
            swap(ary, i, j);
          }
        }
        swap(ary, i + 1, j);
        var q = i + 1;
        doQuickSort(ary, comparator, p, q - 1);
        doQuickSort(ary, comparator, q + 1, r);
      }
    }
    quickSort.quickSort = function(ary, comparator) {
      doQuickSort(ary, comparator, 0, ary.length - 1);
    };
    return quickSort;
  }
  var hasRequiredSourceMapConsumer;
  function requireSourceMapConsumer() {
    if (hasRequiredSourceMapConsumer) return sourceMapConsumer;
    hasRequiredSourceMapConsumer = 1;
    var util2 = requireUtil();
    var binarySearch2 = requireBinarySearch();
    var ArraySet = requireArraySet().ArraySet;
    var base64VLQ = requireBase64Vlq();
    var quickSort2 = requireQuickSort().quickSort;
    function SourceMapConsumer(aSourceMap, aSourceMapURL) {
      var sourceMap2 = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap2 = util2.parseSourceMapInput(aSourceMap);
      }
      return sourceMap2.sections != null ? new IndexedSourceMapConsumer(sourceMap2, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap2, aSourceMapURL);
    }
    SourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {
      return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
    };
    SourceMapConsumer.prototype._version = 3;
    SourceMapConsumer.prototype.__generatedMappings = null;
    Object.defineProperty(SourceMapConsumer.prototype, "_generatedMappings", {
      configurable: true,
      enumerable: true,
      get: function() {
        if (!this.__generatedMappings) {
          this._parseMappings(this._mappings, this.sourceRoot);
        }
        return this.__generatedMappings;
      }
    });
    SourceMapConsumer.prototype.__originalMappings = null;
    Object.defineProperty(SourceMapConsumer.prototype, "_originalMappings", {
      configurable: true,
      enumerable: true,
      get: function() {
        if (!this.__originalMappings) {
          this._parseMappings(this._mappings, this.sourceRoot);
        }
        return this.__originalMappings;
      }
    });
    SourceMapConsumer.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
      var c = aStr.charAt(index);
      return c === ";" || c === ",";
    };
    SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      throw new Error("Subclasses must implement _parseMappings");
    };
    SourceMapConsumer.GENERATED_ORDER = 1;
    SourceMapConsumer.ORIGINAL_ORDER = 2;
    SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
    SourceMapConsumer.LEAST_UPPER_BOUND = 2;
    SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
      var context = aContext || null;
      var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
      var mappings;
      switch (order) {
        case SourceMapConsumer.GENERATED_ORDER:
          mappings = this._generatedMappings;
          break;
        case SourceMapConsumer.ORIGINAL_ORDER:
          mappings = this._originalMappings;
          break;
        default:
          throw new Error("Unknown order of iteration.");
      }
      var sourceRoot = this.sourceRoot;
      mappings.map(function(mapping) {
        var source = mapping.source === null ? null : this._sources.at(mapping.source);
        source = util2.computeSourceURL(sourceRoot, source, this._sourceMapURL);
        return {
          source,
          generatedLine: mapping.generatedLine,
          generatedColumn: mapping.generatedColumn,
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: mapping.name === null ? null : this._names.at(mapping.name)
        };
      }, this).forEach(aCallback, context);
    };
    SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
      var line = util2.getArg(aArgs, "line");
      var needle = {
        source: util2.getArg(aArgs, "source"),
        originalLine: line,
        originalColumn: util2.getArg(aArgs, "column", 0)
      };
      needle.source = this._findSourceIndex(needle.source);
      if (needle.source < 0) {
        return [];
      }
      var mappings = [];
      var index = this._findMapping(
        needle,
        this._originalMappings,
        "originalLine",
        "originalColumn",
        util2.compareByOriginalPositions,
        binarySearch2.LEAST_UPPER_BOUND
      );
      if (index >= 0) {
        var mapping = this._originalMappings[index];
        if (aArgs.column === void 0) {
          var originalLine = mapping.originalLine;
          while (mapping && mapping.originalLine === originalLine) {
            mappings.push({
              line: util2.getArg(mapping, "generatedLine", null),
              column: util2.getArg(mapping, "generatedColumn", null),
              lastColumn: util2.getArg(mapping, "lastGeneratedColumn", null)
            });
            mapping = this._originalMappings[++index];
          }
        } else {
          var originalColumn = mapping.originalColumn;
          while (mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn) {
            mappings.push({
              line: util2.getArg(mapping, "generatedLine", null),
              column: util2.getArg(mapping, "generatedColumn", null),
              lastColumn: util2.getArg(mapping, "lastGeneratedColumn", null)
            });
            mapping = this._originalMappings[++index];
          }
        }
      }
      return mappings;
    };
    sourceMapConsumer.SourceMapConsumer = SourceMapConsumer;
    function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
      var sourceMap2 = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap2 = util2.parseSourceMapInput(aSourceMap);
      }
      var version2 = util2.getArg(sourceMap2, "version");
      var sources = util2.getArg(sourceMap2, "sources");
      var names = util2.getArg(sourceMap2, "names", []);
      var sourceRoot = util2.getArg(sourceMap2, "sourceRoot", null);
      var sourcesContent = util2.getArg(sourceMap2, "sourcesContent", null);
      var mappings = util2.getArg(sourceMap2, "mappings");
      var file = util2.getArg(sourceMap2, "file", null);
      if (version2 != this._version) {
        throw new Error("Unsupported version: " + version2);
      }
      if (sourceRoot) {
        sourceRoot = util2.normalize(sourceRoot);
      }
      sources = sources.map(String).map(util2.normalize).map(function(source) {
        return sourceRoot && util2.isAbsolute(sourceRoot) && util2.isAbsolute(source) ? util2.relative(sourceRoot, source) : source;
      });
      this._names = ArraySet.fromArray(names.map(String), true);
      this._sources = ArraySet.fromArray(sources, true);
      this._absoluteSources = this._sources.toArray().map(function(s) {
        return util2.computeSourceURL(sourceRoot, s, aSourceMapURL);
      });
      this.sourceRoot = sourceRoot;
      this.sourcesContent = sourcesContent;
      this._mappings = mappings;
      this._sourceMapURL = aSourceMapURL;
      this.file = file;
    }
    BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
    BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
    BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
      var relativeSource = aSource;
      if (this.sourceRoot != null) {
        relativeSource = util2.relative(this.sourceRoot, relativeSource);
      }
      if (this._sources.has(relativeSource)) {
        return this._sources.indexOf(relativeSource);
      }
      var i;
      for (i = 0; i < this._absoluteSources.length; ++i) {
        if (this._absoluteSources[i] == aSource) {
          return i;
        }
      }
      return -1;
    };
    BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
      var smc = Object.create(BasicSourceMapConsumer.prototype);
      var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
      var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
      smc.sourceRoot = aSourceMap._sourceRoot;
      smc.sourcesContent = aSourceMap._generateSourcesContent(
        smc._sources.toArray(),
        smc.sourceRoot
      );
      smc.file = aSourceMap._file;
      smc._sourceMapURL = aSourceMapURL;
      smc._absoluteSources = smc._sources.toArray().map(function(s) {
        return util2.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
      });
      var generatedMappings = aSourceMap._mappings.toArray().slice();
      var destGeneratedMappings = smc.__generatedMappings = [];
      var destOriginalMappings = smc.__originalMappings = [];
      for (var i = 0, length2 = generatedMappings.length; i < length2; i++) {
        var srcMapping = generatedMappings[i];
        var destMapping = new Mapping();
        destMapping.generatedLine = srcMapping.generatedLine;
        destMapping.generatedColumn = srcMapping.generatedColumn;
        if (srcMapping.source) {
          destMapping.source = sources.indexOf(srcMapping.source);
          destMapping.originalLine = srcMapping.originalLine;
          destMapping.originalColumn = srcMapping.originalColumn;
          if (srcMapping.name) {
            destMapping.name = names.indexOf(srcMapping.name);
          }
          destOriginalMappings.push(destMapping);
        }
        destGeneratedMappings.push(destMapping);
      }
      quickSort2(smc.__originalMappings, util2.compareByOriginalPositions);
      return smc;
    };
    BasicSourceMapConsumer.prototype._version = 3;
    Object.defineProperty(BasicSourceMapConsumer.prototype, "sources", {
      get: function() {
        return this._absoluteSources.slice();
      }
    });
    function Mapping() {
      this.generatedLine = 0;
      this.generatedColumn = 0;
      this.source = null;
      this.originalLine = null;
      this.originalColumn = null;
      this.name = null;
    }
    BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      var generatedLine = 1;
      var previousGeneratedColumn = 0;
      var previousOriginalLine = 0;
      var previousOriginalColumn = 0;
      var previousSource = 0;
      var previousName = 0;
      var length2 = aStr.length;
      var index = 0;
      var cachedSegments = {};
      var temp = {};
      var originalMappings = [];
      var generatedMappings = [];
      var mapping, str, segment, end, value;
      while (index < length2) {
        if (aStr.charAt(index) === ";") {
          generatedLine++;
          index++;
          previousGeneratedColumn = 0;
        } else if (aStr.charAt(index) === ",") {
          index++;
        } else {
          mapping = new Mapping();
          mapping.generatedLine = generatedLine;
          for (end = index; end < length2; end++) {
            if (this._charIsMappingSeparator(aStr, end)) {
              break;
            }
          }
          str = aStr.slice(index, end);
          segment = cachedSegments[str];
          if (segment) {
            index += str.length;
          } else {
            segment = [];
            while (index < end) {
              base64VLQ.decode(aStr, index, temp);
              value = temp.value;
              index = temp.rest;
              segment.push(value);
            }
            if (segment.length === 2) {
              throw new Error("Found a source, but no line and column");
            }
            if (segment.length === 3) {
              throw new Error("Found a source and line, but no column");
            }
            cachedSegments[str] = segment;
          }
          mapping.generatedColumn = previousGeneratedColumn + segment[0];
          previousGeneratedColumn = mapping.generatedColumn;
          if (segment.length > 1) {
            mapping.source = previousSource + segment[1];
            previousSource += segment[1];
            mapping.originalLine = previousOriginalLine + segment[2];
            previousOriginalLine = mapping.originalLine;
            mapping.originalLine += 1;
            mapping.originalColumn = previousOriginalColumn + segment[3];
            previousOriginalColumn = mapping.originalColumn;
            if (segment.length > 4) {
              mapping.name = previousName + segment[4];
              previousName += segment[4];
            }
          }
          generatedMappings.push(mapping);
          if (typeof mapping.originalLine === "number") {
            originalMappings.push(mapping);
          }
        }
      }
      quickSort2(generatedMappings, util2.compareByGeneratedPositionsDeflated);
      this.__generatedMappings = generatedMappings;
      quickSort2(originalMappings, util2.compareByOriginalPositions);
      this.__originalMappings = originalMappings;
    };
    BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
      if (aNeedle[aLineName] <= 0) {
        throw new TypeError("Line must be greater than or equal to 1, got " + aNeedle[aLineName]);
      }
      if (aNeedle[aColumnName] < 0) {
        throw new TypeError("Column must be greater than or equal to 0, got " + aNeedle[aColumnName]);
      }
      return binarySearch2.search(aNeedle, aMappings, aComparator, aBias);
    };
    BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
      for (var index = 0; index < this._generatedMappings.length; ++index) {
        var mapping = this._generatedMappings[index];
        if (index + 1 < this._generatedMappings.length) {
          var nextMapping = this._generatedMappings[index + 1];
          if (mapping.generatedLine === nextMapping.generatedLine) {
            mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
            continue;
          }
        }
        mapping.lastGeneratedColumn = Infinity;
      }
    };
    BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util2.getArg(aArgs, "line"),
        generatedColumn: util2.getArg(aArgs, "column")
      };
      var index = this._findMapping(
        needle,
        this._generatedMappings,
        "generatedLine",
        "generatedColumn",
        util2.compareByGeneratedPositionsDeflated,
        util2.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND)
      );
      if (index >= 0) {
        var mapping = this._generatedMappings[index];
        if (mapping.generatedLine === needle.generatedLine) {
          var source = util2.getArg(mapping, "source", null);
          if (source !== null) {
            source = this._sources.at(source);
            source = util2.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
          }
          var name = util2.getArg(mapping, "name", null);
          if (name !== null) {
            name = this._names.at(name);
          }
          return {
            source,
            line: util2.getArg(mapping, "originalLine", null),
            column: util2.getArg(mapping, "originalColumn", null),
            name
          };
        }
      }
      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    };
    BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
      if (!this.sourcesContent) {
        return false;
      }
      return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(sc) {
        return sc == null;
      });
    };
    BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
      if (!this.sourcesContent) {
        return null;
      }
      var index = this._findSourceIndex(aSource);
      if (index >= 0) {
        return this.sourcesContent[index];
      }
      var relativeSource = aSource;
      if (this.sourceRoot != null) {
        relativeSource = util2.relative(this.sourceRoot, relativeSource);
      }
      var url;
      if (this.sourceRoot != null && (url = util2.urlParse(this.sourceRoot))) {
        var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
        if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) {
          return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
        }
        if ((!url.path || url.path == "/") && this._sources.has("/" + relativeSource)) {
          return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
        }
      }
      if (nullOnMissing) {
        return null;
      } else {
        throw new Error('"' + relativeSource + '" is not in the SourceMap.');
      }
    };
    BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
      var source = util2.getArg(aArgs, "source");
      source = this._findSourceIndex(source);
      if (source < 0) {
        return {
          line: null,
          column: null,
          lastColumn: null
        };
      }
      var needle = {
        source,
        originalLine: util2.getArg(aArgs, "line"),
        originalColumn: util2.getArg(aArgs, "column")
      };
      var index = this._findMapping(
        needle,
        this._originalMappings,
        "originalLine",
        "originalColumn",
        util2.compareByOriginalPositions,
        util2.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND)
      );
      if (index >= 0) {
        var mapping = this._originalMappings[index];
        if (mapping.source === needle.source) {
          return {
            line: util2.getArg(mapping, "generatedLine", null),
            column: util2.getArg(mapping, "generatedColumn", null),
            lastColumn: util2.getArg(mapping, "lastGeneratedColumn", null)
          };
        }
      }
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    };
    sourceMapConsumer.BasicSourceMapConsumer = BasicSourceMapConsumer;
    function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
      var sourceMap2 = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap2 = util2.parseSourceMapInput(aSourceMap);
      }
      var version2 = util2.getArg(sourceMap2, "version");
      var sections = util2.getArg(sourceMap2, "sections");
      if (version2 != this._version) {
        throw new Error("Unsupported version: " + version2);
      }
      this._sources = new ArraySet();
      this._names = new ArraySet();
      var lastOffset = {
        line: -1,
        column: 0
      };
      this._sections = sections.map(function(s) {
        if (s.url) {
          throw new Error("Support for url field in sections not implemented.");
        }
        var offset = util2.getArg(s, "offset");
        var offsetLine = util2.getArg(offset, "line");
        var offsetColumn = util2.getArg(offset, "column");
        if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {
          throw new Error("Section offsets must be ordered and non-overlapping.");
        }
        lastOffset = offset;
        return {
          generatedOffset: {
            // The offset fields are 0-based, but we use 1-based indices when
            // encoding/decoding from VLQ.
            generatedLine: offsetLine + 1,
            generatedColumn: offsetColumn + 1
          },
          consumer: new SourceMapConsumer(util2.getArg(s, "map"), aSourceMapURL)
        };
      });
    }
    IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
    IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
    IndexedSourceMapConsumer.prototype._version = 3;
    Object.defineProperty(IndexedSourceMapConsumer.prototype, "sources", {
      get: function() {
        var sources = [];
        for (var i = 0; i < this._sections.length; i++) {
          for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
            sources.push(this._sections[i].consumer.sources[j]);
          }
        }
        return sources;
      }
    });
    IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util2.getArg(aArgs, "line"),
        generatedColumn: util2.getArg(aArgs, "column")
      };
      var sectionIndex = binarySearch2.search(
        needle,
        this._sections,
        function(needle2, section2) {
          var cmp = needle2.generatedLine - section2.generatedOffset.generatedLine;
          if (cmp) {
            return cmp;
          }
          return needle2.generatedColumn - section2.generatedOffset.generatedColumn;
        }
      );
      var section = this._sections[sectionIndex];
      if (!section) {
        return {
          source: null,
          line: null,
          column: null,
          name: null
        };
      }
      return section.consumer.originalPositionFor({
        line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
        column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
        bias: aArgs.bias
      });
    };
    IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
      return this._sections.every(function(s) {
        return s.consumer.hasContentsOfAllSources();
      });
    };
    IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];
        var content = section.consumer.sourceContentFor(aSource, true);
        if (content) {
          return content;
        }
      }
      if (nullOnMissing) {
        return null;
      } else {
        throw new Error('"' + aSource + '" is not in the SourceMap.');
      }
    };
    IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];
        if (section.consumer._findSourceIndex(util2.getArg(aArgs, "source")) === -1) {
          continue;
        }
        var generatedPosition = section.consumer.generatedPositionFor(aArgs);
        if (generatedPosition) {
          var ret = {
            line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
            column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
          };
          return ret;
        }
      }
      return {
        line: null,
        column: null
      };
    };
    IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      this.__generatedMappings = [];
      this.__originalMappings = [];
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];
        var sectionMappings = section.consumer._generatedMappings;
        for (var j = 0; j < sectionMappings.length; j++) {
          var mapping = sectionMappings[j];
          var source = section.consumer._sources.at(mapping.source);
          source = util2.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
          this._sources.add(source);
          source = this._sources.indexOf(source);
          var name = null;
          if (mapping.name) {
            name = section.consumer._names.at(mapping.name);
            this._names.add(name);
            name = this._names.indexOf(name);
          }
          var adjustedMapping = {
            source,
            generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
            generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
            originalLine: mapping.originalLine,
            originalColumn: mapping.originalColumn,
            name
          };
          this.__generatedMappings.push(adjustedMapping);
          if (typeof adjustedMapping.originalLine === "number") {
            this.__originalMappings.push(adjustedMapping);
          }
        }
      }
      quickSort2(this.__generatedMappings, util2.compareByGeneratedPositionsDeflated);
      quickSort2(this.__originalMappings, util2.compareByOriginalPositions);
    };
    sourceMapConsumer.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
    return sourceMapConsumer;
  }
  var sourceNode = {};
  var hasRequiredSourceNode;
  function requireSourceNode() {
    if (hasRequiredSourceNode) return sourceNode;
    hasRequiredSourceNode = 1;
    var SourceMapGenerator = requireSourceMapGenerator().SourceMapGenerator;
    var util2 = requireUtil();
    var REGEX_NEWLINE = /(\r?\n)/;
    var NEWLINE_CODE = 10;
    var isSourceNode = "$$$isSourceNode$$$";
    function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
      this.children = [];
      this.sourceContents = {};
      this.line = aLine == null ? null : aLine;
      this.column = aColumn == null ? null : aColumn;
      this.source = aSource == null ? null : aSource;
      this.name = aName == null ? null : aName;
      this[isSourceNode] = true;
      if (aChunks != null) this.add(aChunks);
    }
    SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
      var node = new SourceNode();
      var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
      var remainingLinesIndex = 0;
      var shiftNextLine = function() {
        var lineContents = getNextLine();
        var newLine = getNextLine() || "";
        return lineContents + newLine;
        function getNextLine() {
          return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : void 0;
        }
      };
      var lastGeneratedLine = 1, lastGeneratedColumn = 0;
      var lastMapping = null;
      aSourceMapConsumer.eachMapping(function(mapping) {
        if (lastMapping !== null) {
          if (lastGeneratedLine < mapping.generatedLine) {
            addMappingWithCode(lastMapping, shiftNextLine());
            lastGeneratedLine++;
            lastGeneratedColumn = 0;
          } else {
            var nextLine = remainingLines[remainingLinesIndex] || "";
            var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
            remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
            lastGeneratedColumn = mapping.generatedColumn;
            addMappingWithCode(lastMapping, code);
            lastMapping = mapping;
            return;
          }
        }
        while (lastGeneratedLine < mapping.generatedLine) {
          node.add(shiftNextLine());
          lastGeneratedLine++;
        }
        if (lastGeneratedColumn < mapping.generatedColumn) {
          var nextLine = remainingLines[remainingLinesIndex] || "";
          node.add(nextLine.substr(0, mapping.generatedColumn));
          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
        }
        lastMapping = mapping;
      }, this);
      if (remainingLinesIndex < remainingLines.length) {
        if (lastMapping) {
          addMappingWithCode(lastMapping, shiftNextLine());
        }
        node.add(remainingLines.splice(remainingLinesIndex).join(""));
      }
      aSourceMapConsumer.sources.forEach(function(sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          if (aRelativePath != null) {
            sourceFile = util2.join(aRelativePath, sourceFile);
          }
          node.setSourceContent(sourceFile, content);
        }
      });
      return node;
      function addMappingWithCode(mapping, code) {
        if (mapping === null || mapping.source === void 0) {
          node.add(code);
        } else {
          var source = aRelativePath ? util2.join(aRelativePath, mapping.source) : mapping.source;
          node.add(new SourceNode(
            mapping.originalLine,
            mapping.originalColumn,
            source,
            code,
            mapping.name
          ));
        }
      }
    };
    SourceNode.prototype.add = function SourceNode_add(aChunk) {
      if (Array.isArray(aChunk)) {
        aChunk.forEach(function(chunk) {
          this.add(chunk);
        }, this);
      } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
        if (aChunk) {
          this.children.push(aChunk);
        }
      } else {
        throw new TypeError(
          "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
        );
      }
      return this;
    };
    SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
      if (Array.isArray(aChunk)) {
        for (var i = aChunk.length - 1; i >= 0; i--) {
          this.prepend(aChunk[i]);
        }
      } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
        this.children.unshift(aChunk);
      } else {
        throw new TypeError(
          "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
        );
      }
      return this;
    };
    SourceNode.prototype.walk = function SourceNode_walk(aFn) {
      var chunk;
      for (var i = 0, len = this.children.length; i < len; i++) {
        chunk = this.children[i];
        if (chunk[isSourceNode]) {
          chunk.walk(aFn);
        } else {
          if (chunk !== "") {
            aFn(chunk, {
              source: this.source,
              line: this.line,
              column: this.column,
              name: this.name
            });
          }
        }
      }
    };
    SourceNode.prototype.join = function SourceNode_join(aSep) {
      var newChildren;
      var i;
      var len = this.children.length;
      if (len > 0) {
        newChildren = [];
        for (i = 0; i < len - 1; i++) {
          newChildren.push(this.children[i]);
          newChildren.push(aSep);
        }
        newChildren.push(this.children[i]);
        this.children = newChildren;
      }
      return this;
    };
    SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
      var lastChild = this.children[this.children.length - 1];
      if (lastChild[isSourceNode]) {
        lastChild.replaceRight(aPattern, aReplacement);
      } else if (typeof lastChild === "string") {
        this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
      } else {
        this.children.push("".replace(aPattern, aReplacement));
      }
      return this;
    };
    SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
      this.sourceContents[util2.toSetString(aSourceFile)] = aSourceContent;
    };
    SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
      for (var i = 0, len = this.children.length; i < len; i++) {
        if (this.children[i][isSourceNode]) {
          this.children[i].walkSourceContents(aFn);
        }
      }
      var sources = Object.keys(this.sourceContents);
      for (var i = 0, len = sources.length; i < len; i++) {
        aFn(util2.fromSetString(sources[i]), this.sourceContents[sources[i]]);
      }
    };
    SourceNode.prototype.toString = function SourceNode_toString() {
      var str = "";
      this.walk(function(chunk) {
        str += chunk;
      });
      return str;
    };
    SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
      var generated = {
        code: "",
        line: 1,
        column: 0
      };
      var map = new SourceMapGenerator(aArgs);
      var sourceMappingActive = false;
      var lastOriginalSource = null;
      var lastOriginalLine = null;
      var lastOriginalColumn = null;
      var lastOriginalName = null;
      this.walk(function(chunk, original) {
        generated.code += chunk;
        if (original.source !== null && original.line !== null && original.column !== null) {
          if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
            map.addMapping({
              source: original.source,
              original: {
                line: original.line,
                column: original.column
              },
              generated: {
                line: generated.line,
                column: generated.column
              },
              name: original.name
            });
          }
          lastOriginalSource = original.source;
          lastOriginalLine = original.line;
          lastOriginalColumn = original.column;
          lastOriginalName = original.name;
          sourceMappingActive = true;
        } else if (sourceMappingActive) {
          map.addMapping({
            generated: {
              line: generated.line,
              column: generated.column
            }
          });
          lastOriginalSource = null;
          sourceMappingActive = false;
        }
        for (var idx = 0, length2 = chunk.length; idx < length2; idx++) {
          if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
            generated.line++;
            generated.column = 0;
            if (idx + 1 === length2) {
              lastOriginalSource = null;
              sourceMappingActive = false;
            } else if (sourceMappingActive) {
              map.addMapping({
                source: original.source,
                original: {
                  line: original.line,
                  column: original.column
                },
                generated: {
                  line: generated.line,
                  column: generated.column
                },
                name: original.name
              });
            }
          } else {
            generated.column++;
          }
        }
      });
      this.walkSourceContents(function(sourceFile, sourceContent) {
        map.setSourceContent(sourceFile, sourceContent);
      });
      return { code: generated.code, map };
    };
    sourceNode.SourceNode = SourceNode;
    return sourceNode;
  }
  var hasRequiredSourceMap;
  function requireSourceMap() {
    if (hasRequiredSourceMap) return sourceMap;
    hasRequiredSourceMap = 1;
    sourceMap.SourceMapGenerator = requireSourceMapGenerator().SourceMapGenerator;
    sourceMap.SourceMapConsumer = requireSourceMapConsumer().SourceMapConsumer;
    sourceMap.SourceNode = requireSourceNode().SourceNode;
    return sourceMap;
  }
  var hasRequiredCodeGen;
  function requireCodeGen() {
    if (hasRequiredCodeGen) return codeGen.exports;
    hasRequiredCodeGen = 1;
    (function(module, exports$1) {
      exports$1.__esModule = true;
      var _utils = requireUtils();
      var SourceNode = void 0;
      try {
        if (true) {
          var SourceMap = requireSourceMap();
          SourceNode = SourceMap.SourceNode;
        }
      } catch (err) {
      }
      if (!SourceNode) {
        SourceNode = function(line, column, srcFile, chunks) {
          this.src = "";
          if (chunks) {
            this.add(chunks);
          }
        };
        SourceNode.prototype = {
          add: function add(chunks) {
            if (_utils.isArray(chunks)) {
              chunks = chunks.join("");
            }
            this.src += chunks;
          },
          prepend: function prepend(chunks) {
            if (_utils.isArray(chunks)) {
              chunks = chunks.join("");
            }
            this.src = chunks + this.src;
          },
          toStringWithSourceMap: function toStringWithSourceMap() {
            return { code: this.toString() };
          },
          toString: function toString2() {
            return this.src;
          }
        };
      }
      function castChunk(chunk, codeGen2, loc) {
        if (_utils.isArray(chunk)) {
          var ret = [];
          for (var i = 0, len = chunk.length; i < len; i++) {
            ret.push(codeGen2.wrap(chunk[i], loc));
          }
          return ret;
        } else if (typeof chunk === "boolean" || typeof chunk === "number") {
          return chunk + "";
        }
        return chunk;
      }
      function CodeGen(srcFile) {
        this.srcFile = srcFile;
        this.source = [];
      }
      CodeGen.prototype = {
        isEmpty: function isEmpty() {
          return !this.source.length;
        },
        prepend: function prepend(source, loc) {
          this.source.unshift(this.wrap(source, loc));
        },
        push: function push(source, loc) {
          this.source.push(this.wrap(source, loc));
        },
        merge: function merge() {
          var source = this.empty();
          this.each(function(line) {
            source.add(["  ", line, "\n"]);
          });
          return source;
        },
        each: function each2(iter) {
          for (var i = 0, len = this.source.length; i < len; i++) {
            iter(this.source[i]);
          }
        },
        empty: function empty() {
          var loc = this.currentLocation || { start: {} };
          return new SourceNode(loc.start.line, loc.start.column, this.srcFile);
        },
        wrap: function wrap(chunk) {
          var loc = arguments.length <= 1 || arguments[1] === void 0 ? this.currentLocation || { start: {} } : arguments[1];
          if (chunk instanceof SourceNode) {
            return chunk;
          }
          chunk = castChunk(chunk, this, loc);
          return new SourceNode(loc.start.line, loc.start.column, this.srcFile, chunk);
        },
        functionCall: function functionCall(fn, type, params) {
          params = this.generateList(params);
          return this.wrap([fn, type ? "." + type + "(" : "(", params, ")"]);
        },
        quotedString: function quotedString(str) {
          return '"' + (str + "").replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029") + '"';
        },
        objectLiteral: function objectLiteral(obj) {
          var _this = this;
          var pairs = [];
          Object.keys(obj).forEach(function(key) {
            var value = castChunk(obj[key], _this);
            if (value !== "undefined") {
              pairs.push([_this.quotedString(key), ":", value]);
            }
          });
          var ret = this.generateList(pairs);
          ret.prepend("{");
          ret.add("}");
          return ret;
        },
        generateList: function generateList(entries) {
          var ret = this.empty();
          for (var i = 0, len = entries.length; i < len; i++) {
            if (i) {
              ret.add(",");
            }
            ret.add(castChunk(entries[i], this));
          }
          return ret;
        },
        generateArray: function generateArray(entries) {
          var ret = this.generateList(entries);
          ret.prepend("[");
          ret.add("]");
          return ret;
        }
      };
      exports$1["default"] = CodeGen;
      module.exports = exports$1["default"];
    })(codeGen, codeGen.exports);
    return codeGen.exports;
  }
  var hasRequiredJavascriptCompiler;
  function requireJavascriptCompiler() {
    if (hasRequiredJavascriptCompiler) return javascriptCompiler.exports;
    hasRequiredJavascriptCompiler = 1;
    (function(module, exports$1) {
      exports$1.__esModule = true;
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var _base = requireBase$1();
      var _exception = requireException();
      var _exception2 = _interopRequireDefault(_exception);
      var _utils = requireUtils();
      var _codeGen = requireCodeGen();
      var _codeGen2 = _interopRequireDefault(_codeGen);
      function Literal(value) {
        this.value = value;
      }
      function JavaScriptCompiler() {
      }
      JavaScriptCompiler.prototype = {
        // PUBLIC API: You can override these methods in a subclass to provide
        // alternative compiled forms for name lookup and buffering semantics
        nameLookup: function nameLookup(parent, name) {
          return this.internalNameLookup(parent, name);
        },
        depthedLookup: function depthedLookup(name) {
          return [this.aliasable("container.lookup"), "(depths, ", JSON.stringify(name), ")"];
        },
        compilerInfo: function compilerInfo() {
          var revision = _base.COMPILER_REVISION, versions = _base.REVISION_CHANGES[revision];
          return [revision, versions];
        },
        appendToBuffer: function appendToBuffer(source, location, explicit) {
          if (!_utils.isArray(source)) {
            source = [source];
          }
          source = this.source.wrap(source, location);
          if (this.environment.isSimple) {
            return ["return ", source, ";"];
          } else if (explicit) {
            return ["buffer += ", source, ";"];
          } else {
            source.appendToBuffer = true;
            return source;
          }
        },
        initializeBuffer: function initializeBuffer() {
          return this.quotedString("");
        },
        // END PUBLIC API
        internalNameLookup: function internalNameLookup(parent, name) {
          this.lookupPropertyFunctionIsUsed = true;
          return ["lookupProperty(", parent, ",", JSON.stringify(name), ")"];
        },
        lookupPropertyFunctionIsUsed: false,
        compile: function compile(environment, options, context, asObject) {
          this.environment = environment;
          this.options = options;
          this.stringParams = this.options.stringParams;
          this.trackIds = this.options.trackIds;
          this.precompile = !asObject;
          this.name = this.environment.name;
          this.isChild = !!context;
          this.context = context || {
            decorators: [],
            programs: [],
            environments: []
          };
          this.preamble();
          this.stackSlot = 0;
          this.stackVars = [];
          this.aliases = {};
          this.registers = { list: [] };
          this.hashes = [];
          this.compileStack = [];
          this.inlineStack = [];
          this.blockParams = [];
          this.compileChildren(environment, options);
          this.useDepths = this.useDepths || environment.useDepths || environment.useDecorators || this.options.compat;
          this.useBlockParams = this.useBlockParams || environment.useBlockParams;
          var opcodes = environment.opcodes, opcode = void 0, firstLoc = void 0, i = void 0, l = void 0;
          for (i = 0, l = opcodes.length; i < l; i++) {
            opcode = opcodes[i];
            this.source.currentLocation = opcode.loc;
            firstLoc = firstLoc || opcode.loc;
            this[opcode.opcode].apply(this, opcode.args);
          }
          this.source.currentLocation = firstLoc;
          this.pushSource("");
          if (this.stackSlot || this.inlineStack.length || this.compileStack.length) {
            throw new _exception2["default"]("Compile completed with content left on stack");
          }
          if (!this.decorators.isEmpty()) {
            this.useDecorators = true;
            this.decorators.prepend(["var decorators = container.decorators, ", this.lookupPropertyFunctionVarDeclaration(), ";\n"]);
            this.decorators.push("return fn;");
            if (asObject) {
              this.decorators = Function.apply(this, ["fn", "props", "container", "depth0", "data", "blockParams", "depths", this.decorators.merge()]);
            } else {
              this.decorators.prepend("function(fn, props, container, depth0, data, blockParams, depths) {\n");
              this.decorators.push("}\n");
              this.decorators = this.decorators.merge();
            }
          } else {
            this.decorators = void 0;
          }
          var fn = this.createFunctionContext(asObject);
          if (!this.isChild) {
            var ret = {
              compiler: this.compilerInfo(),
              main: fn
            };
            if (this.decorators) {
              ret.main_d = this.decorators;
              ret.useDecorators = true;
            }
            var _context = this.context;
            var programs = _context.programs;
            var decorators2 = _context.decorators;
            for (i = 0, l = programs.length; i < l; i++) {
              if (programs[i]) {
                ret[i] = programs[i];
                if (decorators2[i]) {
                  ret[i + "_d"] = decorators2[i];
                  ret.useDecorators = true;
                }
              }
            }
            if (this.environment.usePartial) {
              ret.usePartial = true;
            }
            if (this.options.data) {
              ret.useData = true;
            }
            if (this.useDepths) {
              ret.useDepths = true;
            }
            if (this.useBlockParams) {
              ret.useBlockParams = true;
            }
            if (this.options.compat) {
              ret.compat = true;
            }
            if (!asObject) {
              ret.compiler = JSON.stringify(ret.compiler);
              this.source.currentLocation = { start: { line: 1, column: 0 } };
              ret = this.objectLiteral(ret);
              if (options.srcName) {
                ret = ret.toStringWithSourceMap({ file: options.destName });
                ret.map = ret.map && ret.map.toString();
              } else {
                ret = ret.toString();
              }
            } else {
              ret.compilerOptions = this.options;
            }
            return ret;
          } else {
            return fn;
          }
        },
        preamble: function preamble() {
          this.lastContext = 0;
          this.source = new _codeGen2["default"](this.options.srcName);
          this.decorators = new _codeGen2["default"](this.options.srcName);
        },
        createFunctionContext: function createFunctionContext(asObject) {
          var _this = this;
          var varDeclarations = "";
          var locals = this.stackVars.concat(this.registers.list);
          if (locals.length > 0) {
            varDeclarations += ", " + locals.join(", ");
          }
          var aliasCount = 0;
          Object.keys(this.aliases).forEach(function(alias) {
            var node = _this.aliases[alias];
            if (node.children && node.referenceCount > 1) {
              varDeclarations += ", alias" + ++aliasCount + "=" + alias;
              node.children[0] = "alias" + aliasCount;
            }
          });
          if (this.lookupPropertyFunctionIsUsed) {
            varDeclarations += ", " + this.lookupPropertyFunctionVarDeclaration();
          }
          var params = ["container", "depth0", "helpers", "partials", "data"];
          if (this.useBlockParams || this.useDepths) {
            params.push("blockParams");
          }
          if (this.useDepths) {
            params.push("depths");
          }
          var source = this.mergeSource(varDeclarations);
          if (asObject) {
            params.push(source);
            return Function.apply(this, params);
          } else {
            return this.source.wrap(["function(", params.join(","), ") {\n  ", source, "}"]);
          }
        },
        mergeSource: function mergeSource(varDeclarations) {
          var isSimple = this.environment.isSimple, appendOnly = !this.forceBuffer, appendFirst = void 0, sourceSeen = void 0, bufferStart = void 0, bufferEnd = void 0;
          this.source.each(function(line) {
            if (line.appendToBuffer) {
              if (bufferStart) {
                line.prepend("  + ");
              } else {
                bufferStart = line;
              }
              bufferEnd = line;
            } else {
              if (bufferStart) {
                if (!sourceSeen) {
                  appendFirst = true;
                } else {
                  bufferStart.prepend("buffer += ");
                }
                bufferEnd.add(";");
                bufferStart = bufferEnd = void 0;
              }
              sourceSeen = true;
              if (!isSimple) {
                appendOnly = false;
              }
            }
          });
          if (appendOnly) {
            if (bufferStart) {
              bufferStart.prepend("return ");
              bufferEnd.add(";");
            } else if (!sourceSeen) {
              this.source.push('return "";');
            }
          } else {
            varDeclarations += ", buffer = " + (appendFirst ? "" : this.initializeBuffer());
            if (bufferStart) {
              bufferStart.prepend("return buffer + ");
              bufferEnd.add(";");
            } else {
              this.source.push("return buffer;");
            }
          }
          if (varDeclarations) {
            this.source.prepend("var " + varDeclarations.substring(2) + (appendFirst ? "" : ";\n"));
          }
          return this.source.merge();
        },
        lookupPropertyFunctionVarDeclaration: function lookupPropertyFunctionVarDeclaration() {
          return "\n      lookupProperty = container.lookupProperty || function(parent, propertyName) {\n        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {\n          return parent[propertyName];\n        }\n        return undefined\n    }\n    ".trim();
        },
        // [blockValue]
        //
        // On stack, before: hash, inverse, program, value
        // On stack, after: return value of blockHelperMissing
        //
        // The purpose of this opcode is to take a block of the form
        // `{{#this.foo}}...{{/this.foo}}`, resolve the value of `foo`, and
        // replace it on the stack with the result of properly
        // invoking blockHelperMissing.
        blockValue: function blockValue(name) {
          var blockHelperMissing2 = this.aliasable("container.hooks.blockHelperMissing"), params = [this.contextName(0)];
          this.setupHelperArgs(name, 0, params);
          var blockName = this.popStack();
          params.splice(1, 0, blockName);
          this.push(this.source.functionCall(blockHelperMissing2, "call", params));
        },
        // [ambiguousBlockValue]
        //
        // On stack, before: hash, inverse, program, value
        // Compiler value, before: lastHelper=value of last found helper, if any
        // On stack, after, if no lastHelper: same as [blockValue]
        // On stack, after, if lastHelper: value
        ambiguousBlockValue: function ambiguousBlockValue() {
          var blockHelperMissing2 = this.aliasable("container.hooks.blockHelperMissing"), params = [this.contextName(0)];
          this.setupHelperArgs("", 0, params, true);
          this.flushInline();
          var current = this.topStack();
          params.splice(1, 0, current);
          this.pushSource(["if (!", this.lastHelper, ") { ", current, " = ", this.source.functionCall(blockHelperMissing2, "call", params), "}"]);
        },
        // [appendContent]
        //
        // On stack, before: ...
        // On stack, after: ...
        //
        // Appends the string value of `content` to the current buffer
        appendContent: function appendContent(content) {
          if (this.pendingContent) {
            content = this.pendingContent + content;
          } else {
            this.pendingLocation = this.source.currentLocation;
          }
          this.pendingContent = content;
        },
        // [append]
        //
        // On stack, before: value, ...
        // On stack, after: ...
        //
        // Coerces `value` to a String and appends it to the current buffer.
        //
        // If `value` is truthy, or 0, it is coerced into a string and appended
        // Otherwise, the empty string is appended
        append: function append() {
          if (this.isInline()) {
            this.replaceStack(function(current) {
              return [" != null ? ", current, ' : ""'];
            });
            this.pushSource(this.appendToBuffer(this.popStack()));
          } else {
            var local = this.popStack();
            this.pushSource(["if (", local, " != null) { ", this.appendToBuffer(local, void 0, true), " }"]);
            if (this.environment.isSimple) {
              this.pushSource(["else { ", this.appendToBuffer("''", void 0, true), " }"]);
            }
          }
        },
        // [appendEscaped]
        //
        // On stack, before: value, ...
        // On stack, after: ...
        //
        // Escape `value` and append it to the buffer
        appendEscaped: function appendEscaped() {
          this.pushSource(this.appendToBuffer([this.aliasable("container.escapeExpression"), "(", this.popStack(), ")"]));
        },
        // [getContext]
        //
        // On stack, before: ...
        // On stack, after: ...
        // Compiler value, after: lastContext=depth
        //
        // Set the value of the `lastContext` compiler value to the depth
        getContext: function getContext(depth) {
          this.lastContext = depth;
        },
        // [pushContext]
        //
        // On stack, before: ...
        // On stack, after: currentContext, ...
        //
        // Pushes the value of the current context onto the stack.
        pushContext: function pushContext() {
          this.pushStackLiteral(this.contextName(this.lastContext));
        },
        // [lookupOnContext]
        //
        // On stack, before: ...
        // On stack, after: currentContext[name], ...
        //
        // Looks up the value of `name` on the current context and pushes
        // it onto the stack.
        lookupOnContext: function lookupOnContext(parts, falsy, strict, scoped) {
          var i = 0;
          if (!scoped && this.options.compat && !this.lastContext) {
            this.push(this.depthedLookup(parts[i++]));
          } else {
            this.pushContext();
          }
          this.resolvePath("context", parts, i, falsy, strict);
        },
        // [lookupBlockParam]
        //
        // On stack, before: ...
        // On stack, after: blockParam[name], ...
        //
        // Looks up the value of `parts` on the given block param and pushes
        // it onto the stack.
        lookupBlockParam: function lookupBlockParam(blockParamId, parts) {
          this.useBlockParams = true;
          this.push(["blockParams[", blockParamId[0], "][", blockParamId[1], "]"]);
          this.resolvePath("context", parts, 1);
        },
        // [lookupData]
        //
        // On stack, before: ...
        // On stack, after: data, ...
        //
        // Push the data lookup operator
        lookupData: function lookupData(depth, parts, strict) {
          if (!depth) {
            this.pushStackLiteral("data");
          } else {
            this.pushStackLiteral("container.data(data, " + depth + ")");
          }
          this.resolvePath("data", parts, 0, true, strict);
        },
        resolvePath: function resolvePath(type, parts, i, falsy, strict) {
          var _this2 = this;
          if (this.options.strict || this.options.assumeObjects) {
            this.push(strictLookup(this.options.strict && strict, this, parts, i, type));
            return;
          }
          var len = parts.length;
          for (; i < len; i++) {
            this.replaceStack(function(current) {
              var lookup2 = _this2.nameLookup(current, parts[i], type);
              if (!falsy) {
                return [" != null ? ", lookup2, " : ", current];
              } else {
                return [" && ", lookup2];
              }
            });
          }
        },
        // [resolvePossibleLambda]
        //
        // On stack, before: value, ...
        // On stack, after: resolved value, ...
        //
        // If the `value` is a lambda, replace it on the stack by
        // the return value of the lambda
        resolvePossibleLambda: function resolvePossibleLambda() {
          this.push([this.aliasable("container.lambda"), "(", this.popStack(), ", ", this.contextName(0), ")"]);
        },
        // [pushStringParam]
        //
        // On stack, before: ...
        // On stack, after: string, currentContext, ...
        //
        // This opcode is designed for use in string mode, which
        // provides the string value of a parameter along with its
        // depth rather than resolving it immediately.
        pushStringParam: function pushStringParam(string2, type) {
          this.pushContext();
          this.pushString(type);
          if (type !== "SubExpression") {
            if (typeof string2 === "string") {
              this.pushString(string2);
            } else {
              this.pushStackLiteral(string2);
            }
          }
        },
        emptyHash: function emptyHash(omitEmpty) {
          if (this.trackIds) {
            this.push("{}");
          }
          if (this.stringParams) {
            this.push("{}");
            this.push("{}");
          }
          this.pushStackLiteral(omitEmpty ? "undefined" : "{}");
        },
        pushHash: function pushHash() {
          if (this.hash) {
            this.hashes.push(this.hash);
          }
          this.hash = { values: {}, types: [], contexts: [], ids: [] };
        },
        popHash: function popHash() {
          var hash = this.hash;
          this.hash = this.hashes.pop();
          if (this.trackIds) {
            this.push(this.objectLiteral(hash.ids));
          }
          if (this.stringParams) {
            this.push(this.objectLiteral(hash.contexts));
            this.push(this.objectLiteral(hash.types));
          }
          this.push(this.objectLiteral(hash.values));
        },
        // [pushString]
        //
        // On stack, before: ...
        // On stack, after: quotedString(string), ...
        //
        // Push a quoted version of `string` onto the stack
        pushString: function pushString(string2) {
          this.pushStackLiteral(this.quotedString(string2));
        },
        // [pushLiteral]
        //
        // On stack, before: ...
        // On stack, after: value, ...
        //
        // Pushes a value onto the stack. This operation prevents
        // the compiler from creating a temporary variable to hold
        // it.
        pushLiteral: function pushLiteral(value) {
          this.pushStackLiteral(value);
        },
        // [pushProgram]
        //
        // On stack, before: ...
        // On stack, after: program(guid), ...
        //
        // Push a program expression onto the stack. This takes
        // a compile-time guid and converts it into a runtime-accessible
        // expression.
        pushProgram: function pushProgram(guid) {
          if (guid != null) {
            this.pushStackLiteral(this.programExpression(guid));
          } else {
            this.pushStackLiteral(null);
          }
        },
        // [registerDecorator]
        //
        // On stack, before: hash, program, params..., ...
        // On stack, after: ...
        //
        // Pops off the decorator's parameters, invokes the decorator,
        // and inserts the decorator into the decorators list.
        registerDecorator: function registerDecorator(paramSize, name) {
          var foundDecorator = this.nameLookup("decorators", name, "decorator"), options = this.setupHelperArgs(name, paramSize);
          this.decorators.push(["fn = ", this.decorators.functionCall(foundDecorator, "", ["fn", "props", "container", options]), " || fn;"]);
        },
        // [invokeHelper]
        //
        // On stack, before: hash, inverse, program, params..., ...
        // On stack, after: result of helper invocation
        //
        // Pops off the helper's parameters, invokes the helper,
        // and pushes the helper's return value onto the stack.
        //
        // If the helper is not found, `helperMissing` is called.
        invokeHelper: function invokeHelper(paramSize, name, isSimple) {
          var nonHelper = this.popStack(), helper = this.setupHelper(paramSize, name);
          var possibleFunctionCalls = [];
          if (isSimple) {
            possibleFunctionCalls.push(helper.name);
          }
          possibleFunctionCalls.push(nonHelper);
          if (!this.options.strict) {
            possibleFunctionCalls.push(this.aliasable("container.hooks.helperMissing"));
          }
          var functionLookupCode = ["(", this.itemsSeparatedBy(possibleFunctionCalls, "||"), ")"];
          var functionCall = this.source.functionCall(functionLookupCode, "call", helper.callParams);
          this.push(functionCall);
        },
        itemsSeparatedBy: function itemsSeparatedBy(items, separator) {
          var result = [];
          result.push(items[0]);
          for (var i = 1; i < items.length; i++) {
            result.push(separator, items[i]);
          }
          return result;
        },
        // [invokeKnownHelper]
        //
        // On stack, before: hash, inverse, program, params..., ...
        // On stack, after: result of helper invocation
        //
        // This operation is used when the helper is known to exist,
        // so a `helperMissing` fallback is not required.
        invokeKnownHelper: function invokeKnownHelper(paramSize, name) {
          var helper = this.setupHelper(paramSize, name);
          this.push(this.source.functionCall(helper.name, "call", helper.callParams));
        },
        // [invokeAmbiguous]
        //
        // On stack, before: hash, inverse, program, params..., ...
        // On stack, after: result of disambiguation
        //
        // This operation is used when an expression like `{{foo}}`
        // is provided, but we don't know at compile-time whether it
        // is a helper or a path.
        //
        // This operation emits more code than the other options,
        // and can be avoided by passing the `knownHelpers` and
        // `knownHelpersOnly` flags at compile-time.
        invokeAmbiguous: function invokeAmbiguous(name, helperCall) {
          this.useRegister("helper");
          var nonHelper = this.popStack();
          this.emptyHash();
          var helper = this.setupHelper(0, name, helperCall);
          var helperName = this.lastHelper = this.nameLookup("helpers", name, "helper");
          var lookup2 = ["(", "(helper = ", helperName, " || ", nonHelper, ")"];
          if (!this.options.strict) {
            lookup2[0] = "(helper = ";
            lookup2.push(" != null ? helper : ", this.aliasable("container.hooks.helperMissing"));
          }
          this.push(["(", lookup2, helper.paramsInit ? ["),(", helper.paramsInit] : [], "),", "(typeof helper === ", this.aliasable('"function"'), " ? ", this.source.functionCall("helper", "call", helper.callParams), " : helper))"]);
        },
        // [invokePartial]
        //
        // On stack, before: context, ...
        // On stack after: result of partial invocation
        //
        // This operation pops off a context, invokes a partial with that context,
        // and pushes the result of the invocation back.
        invokePartial: function invokePartial(isDynamic, name, indent) {
          var params = [], options = this.setupParams(name, 1, params);
          if (isDynamic) {
            name = this.popStack();
            delete options.name;
          }
          if (indent) {
            options.indent = JSON.stringify(indent);
          }
          options.helpers = "helpers";
          options.partials = "partials";
          options.decorators = "container.decorators";
          if (!isDynamic) {
            params.unshift(this.nameLookup("partials", name, "partial"));
          } else {
            params.unshift(name);
          }
          if (this.options.compat) {
            options.depths = "depths";
          }
          options = this.objectLiteral(options);
          params.push(options);
          this.push(this.source.functionCall("container.invokePartial", "", params));
        },
        // [assignToHash]
        //
        // On stack, before: value, ..., hash, ...
        // On stack, after: ..., hash, ...
        //
        // Pops a value off the stack and assigns it to the current hash
        assignToHash: function assignToHash(key) {
          var value = this.popStack(), context = void 0, type = void 0, id = void 0;
          if (this.trackIds) {
            id = this.popStack();
          }
          if (this.stringParams) {
            type = this.popStack();
            context = this.popStack();
          }
          var hash = this.hash;
          if (context) {
            hash.contexts[key] = context;
          }
          if (type) {
            hash.types[key] = type;
          }
          if (id) {
            hash.ids[key] = id;
          }
          hash.values[key] = value;
        },
        pushId: function pushId(type, name, child) {
          if (type === "BlockParam") {
            this.pushStackLiteral("blockParams[" + name[0] + "].path[" + name[1] + "]" + (child ? " + " + JSON.stringify("." + child) : ""));
          } else if (type === "PathExpression") {
            this.pushString(name);
          } else if (type === "SubExpression") {
            this.pushStackLiteral("true");
          } else {
            this.pushStackLiteral("null");
          }
        },
        // HELPERS
        compiler: JavaScriptCompiler,
        compileChildren: function compileChildren(environment, options) {
          var children = environment.children, child = void 0, compiler2 = void 0;
          for (var i = 0, l = children.length; i < l; i++) {
            child = children[i];
            compiler2 = new this.compiler();
            var existing = this.matchExistingProgram(child);
            if (existing == null) {
              this.context.programs.push("");
              var index = this.context.programs.length;
              child.index = index;
              child.name = "program" + index;
              this.context.programs[index] = compiler2.compile(child, options, this.context, !this.precompile);
              this.context.decorators[index] = compiler2.decorators;
              this.context.environments[index] = child;
              this.useDepths = this.useDepths || compiler2.useDepths;
              this.useBlockParams = this.useBlockParams || compiler2.useBlockParams;
              child.useDepths = this.useDepths;
              child.useBlockParams = this.useBlockParams;
            } else {
              child.index = existing.index;
              child.name = "program" + existing.index;
              this.useDepths = this.useDepths || existing.useDepths;
              this.useBlockParams = this.useBlockParams || existing.useBlockParams;
            }
          }
        },
        matchExistingProgram: function matchExistingProgram(child) {
          for (var i = 0, len = this.context.environments.length; i < len; i++) {
            var environment = this.context.environments[i];
            if (environment && environment.equals(child)) {
              return environment;
            }
          }
        },
        programExpression: function programExpression(guid) {
          var child = this.environment.children[guid], programParams = [child.index, "data", child.blockParams];
          if (this.useBlockParams || this.useDepths) {
            programParams.push("blockParams");
          }
          if (this.useDepths) {
            programParams.push("depths");
          }
          return "container.program(" + programParams.join(", ") + ")";
        },
        useRegister: function useRegister(name) {
          if (!this.registers[name]) {
            this.registers[name] = true;
            this.registers.list.push(name);
          }
        },
        push: function push(expr) {
          if (!(expr instanceof Literal)) {
            expr = this.source.wrap(expr);
          }
          this.inlineStack.push(expr);
          return expr;
        },
        pushStackLiteral: function pushStackLiteral(item) {
          this.push(new Literal(item));
        },
        pushSource: function pushSource(source) {
          if (this.pendingContent) {
            this.source.push(this.appendToBuffer(this.source.quotedString(this.pendingContent), this.pendingLocation));
            this.pendingContent = void 0;
          }
          if (source) {
            this.source.push(source);
          }
        },
        replaceStack: function replaceStack(callback) {
          var prefix = ["("], stack = void 0, createdStack = void 0, usedLiteral = void 0;
          if (!this.isInline()) {
            throw new _exception2["default"]("replaceStack on non-inline");
          }
          var top = this.popStack(true);
          if (top instanceof Literal) {
            stack = [top.value];
            prefix = ["(", stack];
            usedLiteral = true;
          } else {
            createdStack = true;
            var _name = this.incrStack();
            prefix = ["((", this.push(_name), " = ", top, ")"];
            stack = this.topStack();
          }
          var item = callback.call(this, stack);
          if (!usedLiteral) {
            this.popStack();
          }
          if (createdStack) {
            this.stackSlot--;
          }
          this.push(prefix.concat(item, ")"));
        },
        incrStack: function incrStack() {
          this.stackSlot++;
          if (this.stackSlot > this.stackVars.length) {
            this.stackVars.push("stack" + this.stackSlot);
          }
          return this.topStackName();
        },
        topStackName: function topStackName() {
          return "stack" + this.stackSlot;
        },
        flushInline: function flushInline() {
          var inlineStack = this.inlineStack;
          this.inlineStack = [];
          for (var i = 0, len = inlineStack.length; i < len; i++) {
            var entry = inlineStack[i];
            if (entry instanceof Literal) {
              this.compileStack.push(entry);
            } else {
              var stack = this.incrStack();
              this.pushSource([stack, " = ", entry, ";"]);
              this.compileStack.push(stack);
            }
          }
        },
        isInline: function isInline() {
          return this.inlineStack.length;
        },
        popStack: function popStack(wrapped) {
          var inline2 = this.isInline(), item = (inline2 ? this.inlineStack : this.compileStack).pop();
          if (!wrapped && item instanceof Literal) {
            return item.value;
          } else {
            if (!inline2) {
              if (!this.stackSlot) {
                throw new _exception2["default"]("Invalid stack pop");
              }
              this.stackSlot--;
            }
            return item;
          }
        },
        topStack: function topStack() {
          var stack = this.isInline() ? this.inlineStack : this.compileStack, item = stack[stack.length - 1];
          if (item instanceof Literal) {
            return item.value;
          } else {
            return item;
          }
        },
        contextName: function contextName(context) {
          if (this.useDepths && context) {
            return "depths[" + context + "]";
          } else {
            return "depth" + context;
          }
        },
        quotedString: function quotedString(str) {
          return this.source.quotedString(str);
        },
        objectLiteral: function objectLiteral(obj) {
          return this.source.objectLiteral(obj);
        },
        aliasable: function aliasable(name) {
          var ret = this.aliases[name];
          if (ret) {
            ret.referenceCount++;
            return ret;
          }
          ret = this.aliases[name] = this.source.wrap(name);
          ret.aliasable = true;
          ret.referenceCount = 1;
          return ret;
        },
        setupHelper: function setupHelper(paramSize, name, blockHelper) {
          var params = [], paramsInit = this.setupHelperArgs(name, paramSize, params, blockHelper);
          var foundHelper = this.nameLookup("helpers", name, "helper"), callContext = this.aliasable(this.contextName(0) + " != null ? " + this.contextName(0) + " : (container.nullContext || {})");
          return {
            params,
            paramsInit,
            name: foundHelper,
            callParams: [callContext].concat(params)
          };
        },
        setupParams: function setupParams(helper, paramSize, params) {
          var options = {}, contexts = [], types2 = [], ids = [], objectArgs = !params, param = void 0;
          if (objectArgs) {
            params = [];
          }
          options.name = this.quotedString(helper);
          options.hash = this.popStack();
          if (this.trackIds) {
            options.hashIds = this.popStack();
          }
          if (this.stringParams) {
            options.hashTypes = this.popStack();
            options.hashContexts = this.popStack();
          }
          var inverse = this.popStack(), program = this.popStack();
          if (program || inverse) {
            options.fn = program || "container.noop";
            options.inverse = inverse || "container.noop";
          }
          var i = paramSize;
          while (i--) {
            param = this.popStack();
            params[i] = param;
            if (this.trackIds) {
              ids[i] = this.popStack();
            }
            if (this.stringParams) {
              types2[i] = this.popStack();
              contexts[i] = this.popStack();
            }
          }
          if (objectArgs) {
            options.args = this.source.generateArray(params);
          }
          if (this.trackIds) {
            options.ids = this.source.generateArray(ids);
          }
          if (this.stringParams) {
            options.types = this.source.generateArray(types2);
            options.contexts = this.source.generateArray(contexts);
          }
          if (this.options.data) {
            options.data = "data";
          }
          if (this.useBlockParams) {
            options.blockParams = "blockParams";
          }
          return options;
        },
        setupHelperArgs: function setupHelperArgs(helper, paramSize, params, useRegister) {
          var options = this.setupParams(helper, paramSize, params);
          options.loc = JSON.stringify(this.source.currentLocation);
          options = this.objectLiteral(options);
          if (useRegister) {
            this.useRegister("options");
            params.push("options");
            return ["options=", options];
          } else if (params) {
            params.push(options);
            return "";
          } else {
            return options;
          }
        }
      };
      (function() {
        var reservedWords = "break else new var case finally return void catch for switch while continue function this with default if throw delete in try do instanceof typeof abstract enum int short boolean export interface static byte extends long super char final native synchronized class float package throws const goto private transient debugger implements protected volatile double import public let yield await null true false".split(" ");
        var compilerWords = JavaScriptCompiler.RESERVED_WORDS = {};
        for (var i = 0, l = reservedWords.length; i < l; i++) {
          compilerWords[reservedWords[i]] = true;
        }
      })();
      JavaScriptCompiler.isValidJavaScriptVariableName = function(name) {
        return !JavaScriptCompiler.RESERVED_WORDS[name] && /^[a-zA-Z_$][0-9a-zA-Z_$]*$/.test(name);
      };
      function strictLookup(requireTerminal, compiler2, parts, i, type) {
        var stack = compiler2.popStack(), len = parts.length;
        if (requireTerminal) {
          len--;
        }
        for (; i < len; i++) {
          stack = compiler2.nameLookup(stack, parts[i], type);
        }
        if (requireTerminal) {
          return [compiler2.aliasable("container.strict"), "(", stack, ", ", compiler2.quotedString(parts[i]), ", ", JSON.stringify(compiler2.source.currentLocation), " )"];
        } else {
          return stack;
        }
      }
      exports$1["default"] = JavaScriptCompiler;
      module.exports = exports$1["default"];
    })(javascriptCompiler, javascriptCompiler.exports);
    return javascriptCompiler.exports;
  }
  var hasRequiredHandlebars;
  function requireHandlebars() {
    if (hasRequiredHandlebars) return handlebars.exports;
    hasRequiredHandlebars = 1;
    (function(module, exports$1) {
      exports$1.__esModule = true;
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var _handlebarsRuntime = requireHandlebars_runtime();
      var _handlebarsRuntime2 = _interopRequireDefault(_handlebarsRuntime);
      var _handlebarsCompilerAst = requireAst();
      var _handlebarsCompilerAst2 = _interopRequireDefault(_handlebarsCompilerAst);
      var _handlebarsCompilerBase = requireBase();
      var _handlebarsCompilerCompiler = requireCompiler();
      var _handlebarsCompilerJavascriptCompiler = requireJavascriptCompiler();
      var _handlebarsCompilerJavascriptCompiler2 = _interopRequireDefault(_handlebarsCompilerJavascriptCompiler);
      var _handlebarsCompilerVisitor = requireVisitor();
      var _handlebarsCompilerVisitor2 = _interopRequireDefault(_handlebarsCompilerVisitor);
      var _handlebarsNoConflict = requireNoConflict();
      var _handlebarsNoConflict2 = _interopRequireDefault(_handlebarsNoConflict);
      var _create = _handlebarsRuntime2["default"].create;
      function create2() {
        var hb = _create();
        hb.compile = function(input, options) {
          return _handlebarsCompilerCompiler.compile(input, options, hb);
        };
        hb.precompile = function(input, options) {
          return _handlebarsCompilerCompiler.precompile(input, options, hb);
        };
        hb.AST = _handlebarsCompilerAst2["default"];
        hb.Compiler = _handlebarsCompilerCompiler.Compiler;
        hb.JavaScriptCompiler = _handlebarsCompilerJavascriptCompiler2["default"];
        hb.Parser = _handlebarsCompilerBase.parser;
        hb.parse = _handlebarsCompilerBase.parse;
        hb.parseWithoutProcessing = _handlebarsCompilerBase.parseWithoutProcessing;
        return hb;
      }
      var inst = create2();
      inst.create = create2;
      _handlebarsNoConflict2["default"](inst);
      inst.Visitor = _handlebarsCompilerVisitor2["default"];
      inst["default"] = inst;
      exports$1["default"] = inst;
      module.exports = exports$1["default"];
    })(handlebars, handlebars.exports);
    return handlebars.exports;
  }
  var handlebarsExports = requireHandlebars();
  const Handlebars = /* @__PURE__ */ getDefaultExportFromCjs(handlebarsExports);
  function resolveUrl(url, baseUrl) {
    if (url.match(/^[a-z]+:\/\//i)) {
      return url;
    }
    if (url.match(/^\/\//)) {
      return window.location.protocol + url;
    }
    if (url.match(/^[a-z]+:/i)) {
      return url;
    }
    const doc = document.implementation.createHTMLDocument();
    const base3 = doc.createElement("base");
    const a = doc.createElement("a");
    doc.head.appendChild(base3);
    doc.body.appendChild(a);
    if (baseUrl) {
      base3.href = baseUrl;
    }
    a.href = url;
    return a.href;
  }
  const uuid = /* @__PURE__ */ (() => {
    let counter = 0;
    const random = () => (
      // eslint-disable-next-line no-bitwise
      `0000${(Math.random() * 36 ** 4 << 0).toString(36)}`.slice(-4)
    );
    return () => {
      counter += 1;
      return `u${random()}${counter}`;
    };
  })();
  function toArray(arrayLike) {
    const arr = [];
    for (let i = 0, l = arrayLike.length; i < l; i++) {
      arr.push(arrayLike[i]);
    }
    return arr;
  }
  let styleProps = null;
  function getStyleProperties(options = {}) {
    if (styleProps) {
      return styleProps;
    }
    if (options.includeStyleProperties) {
      styleProps = options.includeStyleProperties;
      return styleProps;
    }
    styleProps = toArray(window.getComputedStyle(document.documentElement));
    return styleProps;
  }
  function px(node, styleProperty) {
    const win = node.ownerDocument.defaultView || window;
    const val = win.getComputedStyle(node).getPropertyValue(styleProperty);
    return val ? parseFloat(val.replace("px", "")) : 0;
  }
  function getNodeWidth(node) {
    const leftBorder = px(node, "border-left-width");
    const rightBorder = px(node, "border-right-width");
    return node.clientWidth + leftBorder + rightBorder;
  }
  function getNodeHeight(node) {
    const topBorder = px(node, "border-top-width");
    const bottomBorder = px(node, "border-bottom-width");
    return node.clientHeight + topBorder + bottomBorder;
  }
  function getImageSize(targetNode, options = {}) {
    const width = options.width || getNodeWidth(targetNode);
    const height = options.height || getNodeHeight(targetNode);
    return { width, height };
  }
  function getPixelRatio() {
    let ratio;
    let FINAL_PROCESS;
    try {
      FINAL_PROCESS = process;
    } catch (e) {
    }
    const val = FINAL_PROCESS && FINAL_PROCESS.env ? FINAL_PROCESS.env.devicePixelRatio : null;
    if (val) {
      ratio = parseInt(val, 10);
      if (Number.isNaN(ratio)) {
        ratio = 1;
      }
    }
    return ratio || window.devicePixelRatio || 1;
  }
  const canvasDimensionLimit = 16384;
  function checkCanvasDimensions(canvas) {
    if (canvas.width > canvasDimensionLimit || canvas.height > canvasDimensionLimit) {
      if (canvas.width > canvasDimensionLimit && canvas.height > canvasDimensionLimit) {
        if (canvas.width > canvas.height) {
          canvas.height *= canvasDimensionLimit / canvas.width;
          canvas.width = canvasDimensionLimit;
        } else {
          canvas.width *= canvasDimensionLimit / canvas.height;
          canvas.height = canvasDimensionLimit;
        }
      } else if (canvas.width > canvasDimensionLimit) {
        canvas.height *= canvasDimensionLimit / canvas.width;
        canvas.width = canvasDimensionLimit;
      } else {
        canvas.width *= canvasDimensionLimit / canvas.height;
        canvas.height = canvasDimensionLimit;
      }
    }
  }
  function canvasToBlob(canvas, options = {}) {
    if (canvas.toBlob) {
      return new Promise((resolve) => {
        canvas.toBlob(resolve, options.type ? options.type : "image/png", options.quality ? options.quality : 1);
      });
    }
    return new Promise((resolve) => {
      const binaryString = window.atob(canvas.toDataURL(options.type ? options.type : void 0, options.quality ? options.quality : void 0).split(",")[1]);
      const len = binaryString.length;
      const binaryArray = new Uint8Array(len);
      for (let i = 0; i < len; i += 1) {
        binaryArray[i] = binaryString.charCodeAt(i);
      }
      resolve(new Blob([binaryArray], {
        type: options.type ? options.type : "image/png"
      }));
    });
  }
  function createImage(url) {
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.onload = () => {
        img.decode().then(() => {
          requestAnimationFrame(() => resolve(img));
        });
      };
      img.onerror = reject;
      img.crossOrigin = "anonymous";
      img.decoding = "async";
      img.src = url;
    });
  }
  async function svgToDataURL(svg) {
    return Promise.resolve().then(() => new XMLSerializer().serializeToString(svg)).then(encodeURIComponent).then((html) => `data:image/svg+xml;charset=utf-8,${html}`);
  }
  async function nodeToDataURL(node, width, height) {
    const xmlns = "http://www.w3.org/2000/svg";
    const svg = document.createElementNS(xmlns, "svg");
    const foreignObject = document.createElementNS(xmlns, "foreignObject");
    svg.setAttribute("width", `${width}`);
    svg.setAttribute("height", `${height}`);
    svg.setAttribute("viewBox", `0 0 ${width} ${height}`);
    foreignObject.setAttribute("width", "100%");
    foreignObject.setAttribute("height", "100%");
    foreignObject.setAttribute("x", "0");
    foreignObject.setAttribute("y", "0");
    foreignObject.setAttribute("externalResourcesRequired", "true");
    svg.appendChild(foreignObject);
    foreignObject.appendChild(node);
    return svgToDataURL(svg);
  }
  const isInstanceOfElement = (node, instance2) => {
    if (node instanceof instance2)
      return true;
    const nodePrototype = Object.getPrototypeOf(node);
    if (nodePrototype === null)
      return false;
    return nodePrototype.constructor.name === instance2.name || isInstanceOfElement(nodePrototype, instance2);
  };
  function formatCSSText(style2) {
    const content = style2.getPropertyValue("content");
    return `${style2.cssText} content: '${content.replace(/'|"/g, "")}';`;
  }
  function formatCSSProperties(style2, options) {
    return getStyleProperties(options).map((name) => {
      const value = style2.getPropertyValue(name);
      const priority = style2.getPropertyPriority(name);
      return `${name}: ${value}${priority ? " !important" : ""};`;
    }).join(" ");
  }
  function getPseudoElementStyle(className, pseudo, style2, options) {
    const selector = `.${className}:${pseudo}`;
    const cssText = style2.cssText ? formatCSSText(style2) : formatCSSProperties(style2, options);
    return document.createTextNode(`${selector}{${cssText}}`);
  }
  function clonePseudoElement(nativeNode, clonedNode, pseudo, options) {
    const style2 = window.getComputedStyle(nativeNode, pseudo);
    const content = style2.getPropertyValue("content");
    if (content === "" || content === "none") {
      return;
    }
    const className = uuid();
    try {
      clonedNode.className = `${clonedNode.className} ${className}`;
    } catch (err) {
      return;
    }
    const styleElement = document.createElement("style");
    styleElement.appendChild(getPseudoElementStyle(className, pseudo, style2, options));
    clonedNode.appendChild(styleElement);
  }
  function clonePseudoElements(nativeNode, clonedNode, options) {
    clonePseudoElement(nativeNode, clonedNode, ":before", options);
    clonePseudoElement(nativeNode, clonedNode, ":after", options);
  }
  const WOFF = "application/font-woff";
  const JPEG = "image/jpeg";
  const mimes = {
    woff: WOFF,
    woff2: WOFF,
    ttf: "application/font-truetype",
    eot: "application/vnd.ms-fontobject",
    png: "image/png",
    jpg: JPEG,
    jpeg: JPEG,
    gif: "image/gif",
    tiff: "image/tiff",
    svg: "image/svg+xml",
    webp: "image/webp"
  };
  function getExtension(url) {
    const match2 = /\.([^./]*?)$/g.exec(url);
    return match2 ? match2[1] : "";
  }
  function getMimeType(url) {
    const extension = getExtension(url).toLowerCase();
    return mimes[extension] || "";
  }
  function getContentFromDataUrl(dataURL) {
    return dataURL.split(/,/)[1];
  }
  function isDataUrl(url) {
    return url.search(/^(data:)/) !== -1;
  }
  function makeDataUrl(content, mimeType) {
    return `data:${mimeType};base64,${content}`;
  }
  async function fetchAsDataURL(url, init, process2) {
    const res = await fetch(url, init);
    if (res.status === 404) {
      throw new Error(`Resource "${res.url}" not found`);
    }
    const blob2 = await res.blob();
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onerror = reject;
      reader.onloadend = () => {
        try {
          resolve(process2({ res, result: reader.result }));
        } catch (error) {
          reject(error);
        }
      };
      reader.readAsDataURL(blob2);
    });
  }
  const cache = {};
  function getCacheKey(url, contentType, includeQueryParams) {
    let key = url.replace(/\?.*/, "");
    if (includeQueryParams) {
      key = url;
    }
    if (/ttf|otf|eot|woff2?/i.test(key)) {
      key = key.replace(/.*\//, "");
    }
    return contentType ? `[${contentType}]${key}` : key;
  }
  async function resourceToDataURL(resourceUrl, contentType, options) {
    const cacheKey = getCacheKey(resourceUrl, contentType, options.includeQueryParams);
    if (cache[cacheKey] != null) {
      return cache[cacheKey];
    }
    if (options.cacheBust) {
      resourceUrl += (/\?/.test(resourceUrl) ? "&" : "?") + (/* @__PURE__ */ new Date()).getTime();
    }
    let dataURL;
    try {
      const content = await fetchAsDataURL(resourceUrl, options.fetchRequestInit, ({ res, result }) => {
        if (!contentType) {
          contentType = res.headers.get("Content-Type") || "";
        }
        return getContentFromDataUrl(result);
      });
      dataURL = makeDataUrl(content, contentType);
    } catch (error) {
      dataURL = options.imagePlaceholder || "";
      let msg = `Failed to fetch resource: ${resourceUrl}`;
      if (error) {
        msg = typeof error === "string" ? error : error.message;
      }
      if (msg) {
        console.warn(msg);
      }
    }
    cache[cacheKey] = dataURL;
    return dataURL;
  }
  async function cloneCanvasElement(canvas) {
    const dataURL = canvas.toDataURL();
    if (dataURL === "data:,") {
      return canvas.cloneNode(false);
    }
    return createImage(dataURL);
  }
  async function cloneVideoElement(video2, options) {
    if (video2.currentSrc) {
      const canvas = document.createElement("canvas");
      const ctx = canvas.getContext("2d");
      canvas.width = video2.clientWidth;
      canvas.height = video2.clientHeight;
      ctx === null || ctx === void 0 ? void 0 : ctx.drawImage(video2, 0, 0, canvas.width, canvas.height);
      const dataURL2 = canvas.toDataURL();
      return createImage(dataURL2);
    }
    const poster = video2.poster;
    const contentType = getMimeType(poster);
    const dataURL = await resourceToDataURL(poster, contentType, options);
    return createImage(dataURL);
  }
  async function cloneIFrameElement(iframe, options) {
    var _a;
    try {
      if ((_a = iframe === null || iframe === void 0 ? void 0 : iframe.contentDocument) === null || _a === void 0 ? void 0 : _a.body) {
        return await cloneNode(iframe.contentDocument.body, options, true);
      }
    } catch (_b) {
    }
    return iframe.cloneNode(false);
  }
  async function cloneSingleNode(node, options) {
    if (isInstanceOfElement(node, HTMLCanvasElement)) {
      return cloneCanvasElement(node);
    }
    if (isInstanceOfElement(node, HTMLVideoElement)) {
      return cloneVideoElement(node, options);
    }
    if (isInstanceOfElement(node, HTMLIFrameElement)) {
      return cloneIFrameElement(node, options);
    }
    return node.cloneNode(isSVGElement(node));
  }
  const isSlotElement = (node) => node.tagName != null && node.tagName.toUpperCase() === "SLOT";
  const isSVGElement = (node) => node.tagName != null && node.tagName.toUpperCase() === "SVG";
  async function cloneChildren(nativeNode, clonedNode, options) {
    var _a, _b;
    if (isSVGElement(clonedNode)) {
      return clonedNode;
    }
    let children = [];
    if (isSlotElement(nativeNode) && nativeNode.assignedNodes) {
      children = toArray(nativeNode.assignedNodes());
    } else if (isInstanceOfElement(nativeNode, HTMLIFrameElement) && ((_a = nativeNode.contentDocument) === null || _a === void 0 ? void 0 : _a.body)) {
      children = toArray(nativeNode.contentDocument.body.childNodes);
    } else {
      children = toArray(((_b = nativeNode.shadowRoot) !== null && _b !== void 0 ? _b : nativeNode).childNodes);
    }
    if (children.length === 0 || isInstanceOfElement(nativeNode, HTMLVideoElement)) {
      return clonedNode;
    }
    await children.reduce((deferred, child) => deferred.then(() => cloneNode(child, options)).then((clonedChild) => {
      if (clonedChild) {
        clonedNode.appendChild(clonedChild);
      }
    }), Promise.resolve());
    return clonedNode;
  }
  function cloneCSSStyle(nativeNode, clonedNode, options) {
    const targetStyle = clonedNode.style;
    if (!targetStyle) {
      return;
    }
    const sourceStyle = window.getComputedStyle(nativeNode);
    if (sourceStyle.cssText) {
      targetStyle.cssText = sourceStyle.cssText;
      targetStyle.transformOrigin = sourceStyle.transformOrigin;
    } else {
      getStyleProperties(options).forEach((name) => {
        let value = sourceStyle.getPropertyValue(name);
        if (name === "font-size" && value.endsWith("px")) {
          const reducedFont = Math.floor(parseFloat(value.substring(0, value.length - 2))) - 0.1;
          value = `${reducedFont}px`;
        }
        if (isInstanceOfElement(nativeNode, HTMLIFrameElement) && name === "display" && value === "inline") {
          value = "block";
        }
        if (name === "d" && clonedNode.getAttribute("d")) {
          value = `path(${clonedNode.getAttribute("d")})`;
        }
        targetStyle.setProperty(name, value, sourceStyle.getPropertyPriority(name));
      });
    }
  }
  function cloneInputValue(nativeNode, clonedNode) {
    if (isInstanceOfElement(nativeNode, HTMLTextAreaElement)) {
      clonedNode.innerHTML = nativeNode.value;
    }
    if (isInstanceOfElement(nativeNode, HTMLInputElement)) {
      clonedNode.setAttribute("value", nativeNode.value);
    }
  }
  function cloneSelectValue(nativeNode, clonedNode) {
    if (isInstanceOfElement(nativeNode, HTMLSelectElement)) {
      const clonedSelect = clonedNode;
      const selectedOption = Array.from(clonedSelect.children).find((child) => nativeNode.value === child.getAttribute("value"));
      if (selectedOption) {
        selectedOption.setAttribute("selected", "");
      }
    }
  }
  function decorate(nativeNode, clonedNode, options) {
    if (isInstanceOfElement(clonedNode, Element)) {
      cloneCSSStyle(nativeNode, clonedNode, options);
      clonePseudoElements(nativeNode, clonedNode, options);
      cloneInputValue(nativeNode, clonedNode);
      cloneSelectValue(nativeNode, clonedNode);
    }
    return clonedNode;
  }
  async function ensureSVGSymbols(clone, options) {
    const uses = clone.querySelectorAll ? clone.querySelectorAll("use") : [];
    if (uses.length === 0) {
      return clone;
    }
    const processedDefs = {};
    for (let i = 0; i < uses.length; i++) {
      const use = uses[i];
      const id = use.getAttribute("xlink:href");
      if (id) {
        const exist = clone.querySelector(id);
        const definition = document.querySelector(id);
        if (!exist && definition && !processedDefs[id]) {
          processedDefs[id] = await cloneNode(definition, options, true);
        }
      }
    }
    const nodes = Object.values(processedDefs);
    if (nodes.length) {
      const ns = "http://www.w3.org/1999/xhtml";
      const svg = document.createElementNS(ns, "svg");
      svg.setAttribute("xmlns", ns);
      svg.style.position = "absolute";
      svg.style.width = "0";
      svg.style.height = "0";
      svg.style.overflow = "hidden";
      svg.style.display = "none";
      const defs2 = document.createElementNS(ns, "defs");
      svg.appendChild(defs2);
      for (let i = 0; i < nodes.length; i++) {
        defs2.appendChild(nodes[i]);
      }
      clone.appendChild(svg);
    }
    return clone;
  }
  async function cloneNode(node, options, isRoot) {
    if (!isRoot && options.filter && !options.filter(node)) {
      return null;
    }
    return Promise.resolve(node).then((clonedNode) => cloneSingleNode(clonedNode, options)).then((clonedNode) => cloneChildren(node, clonedNode, options)).then((clonedNode) => decorate(node, clonedNode, options)).then((clonedNode) => ensureSVGSymbols(clonedNode, options));
  }
  const URL_REGEX = /url\((['"]?)([^'"]+?)\1\)/g;
  const URL_WITH_FORMAT_REGEX = /url\([^)]+\)\s*format\((["']?)([^"']+)\1\)/g;
  const FONT_SRC_REGEX = /src:\s*(?:url\([^)]+\)\s*format\([^)]+\)[,;]\s*)+/g;
  function toRegex(url) {
    const escaped = url.replace(/([.*+?^${}()|\[\]\/\\])/g, "\\$1");
    return new RegExp(`(url\\(['"]?)(${escaped})(['"]?\\))`, "g");
  }
  function parseURLs(cssText) {
    const urls = [];
    cssText.replace(URL_REGEX, (raw, quotation, url) => {
      urls.push(url);
      return raw;
    });
    return urls.filter((url) => !isDataUrl(url));
  }
  async function embed(cssText, resourceURL, baseURL, options, getContentFromUrl) {
    try {
      const resolvedURL = baseURL ? resolveUrl(resourceURL, baseURL) : resourceURL;
      const contentType = getMimeType(resourceURL);
      let dataURL;
      if (getContentFromUrl) ;
      else {
        dataURL = await resourceToDataURL(resolvedURL, contentType, options);
      }
      return cssText.replace(toRegex(resourceURL), `$1${dataURL}$3`);
    } catch (error) {
    }
    return cssText;
  }
  function filterPreferredFontFormat(str, { preferredFontFormat }) {
    return !preferredFontFormat ? str : str.replace(FONT_SRC_REGEX, (match2) => {
      while (true) {
        const [src2, , format2] = URL_WITH_FORMAT_REGEX.exec(match2) || [];
        if (!format2) {
          return "";
        }
        if (format2 === preferredFontFormat) {
          return `src: ${src2};`;
        }
      }
    });
  }
  function shouldEmbed(url) {
    return url.search(URL_REGEX) !== -1;
  }
  async function embedResources(cssText, baseUrl, options) {
    if (!shouldEmbed(cssText)) {
      return cssText;
    }
    const filteredCSSText = filterPreferredFontFormat(cssText, options);
    const urls = parseURLs(filteredCSSText);
    return urls.reduce((deferred, url) => deferred.then((css) => embed(css, url, baseUrl, options)), Promise.resolve(filteredCSSText));
  }
  async function embedProp(propName, node, options) {
    var _a;
    const propValue = (_a = node.style) === null || _a === void 0 ? void 0 : _a.getPropertyValue(propName);
    if (propValue) {
      const cssString = await embedResources(propValue, null, options);
      node.style.setProperty(propName, cssString, node.style.getPropertyPriority(propName));
      return true;
    }
    return false;
  }
  async function embedBackground(clonedNode, options) {
    await embedProp("background", clonedNode, options) || await embedProp("background-image", clonedNode, options);
    await embedProp("mask", clonedNode, options) || await embedProp("-webkit-mask", clonedNode, options) || await embedProp("mask-image", clonedNode, options) || await embedProp("-webkit-mask-image", clonedNode, options);
  }
  async function embedImageNode(clonedNode, options) {
    const isImageElement = isInstanceOfElement(clonedNode, HTMLImageElement);
    if (!(isImageElement && !isDataUrl(clonedNode.src)) && !(isInstanceOfElement(clonedNode, SVGImageElement) && !isDataUrl(clonedNode.href.baseVal))) {
      return;
    }
    const url = isImageElement ? clonedNode.src : clonedNode.href.baseVal;
    const dataURL = await resourceToDataURL(url, getMimeType(url), options);
    await new Promise((resolve, reject) => {
      clonedNode.onload = resolve;
      clonedNode.onerror = options.onImageErrorHandler ? (...attributes) => {
        try {
          resolve(options.onImageErrorHandler(...attributes));
        } catch (error) {
          reject(error);
        }
      } : reject;
      const image = clonedNode;
      if (image.decode) {
        image.decode = resolve;
      }
      if (image.loading === "lazy") {
        image.loading = "eager";
      }
      if (isImageElement) {
        clonedNode.srcset = "";
        clonedNode.src = dataURL;
      } else {
        clonedNode.href.baseVal = dataURL;
      }
    });
  }
  async function embedChildren(clonedNode, options) {
    const children = toArray(clonedNode.childNodes);
    const deferreds = children.map((child) => embedImages(child, options));
    await Promise.all(deferreds).then(() => clonedNode);
  }
  async function embedImages(clonedNode, options) {
    if (isInstanceOfElement(clonedNode, Element)) {
      await embedBackground(clonedNode, options);
      await embedImageNode(clonedNode, options);
      await embedChildren(clonedNode, options);
    }
  }
  function applyStyle(node, options) {
    const { style: style2 } = node;
    if (options.backgroundColor) {
      style2.backgroundColor = options.backgroundColor;
    }
    if (options.width) {
      style2.width = `${options.width}px`;
    }
    if (options.height) {
      style2.height = `${options.height}px`;
    }
    const manual = options.style;
    if (manual != null) {
      Object.keys(manual).forEach((key) => {
        style2[key] = manual[key];
      });
    }
    return node;
  }
  const cssFetchCache = {};
  async function fetchCSS(url) {
    let cache2 = cssFetchCache[url];
    if (cache2 != null) {
      return cache2;
    }
    const res = await fetch(url);
    const cssText = await res.text();
    cache2 = { url, cssText };
    cssFetchCache[url] = cache2;
    return cache2;
  }
  async function embedFonts(data, options) {
    let cssText = data.cssText;
    const regexUrl = /url\(["']?([^"')]+)["']?\)/g;
    const fontLocs = cssText.match(/url\([^)]+\)/g) || [];
    const loadFonts = fontLocs.map(async (loc) => {
      let url = loc.replace(regexUrl, "$1");
      if (!url.startsWith("https://")) {
        url = new URL(url, data.url).href;
      }
      return fetchAsDataURL(url, options.fetchRequestInit, ({ result }) => {
        cssText = cssText.replace(loc, `url(${result})`);
        return [loc, result];
      });
    });
    return Promise.all(loadFonts).then(() => cssText);
  }
  function parseCSS(source) {
    if (source == null) {
      return [];
    }
    const result = [];
    const commentsRegex = /(\/\*[\s\S]*?\*\/)/gi;
    let cssText = source.replace(commentsRegex, "");
    const keyframesRegex = new RegExp("((@.*?keyframes [\\s\\S]*?){([\\s\\S]*?}\\s*?)})", "gi");
    while (true) {
      const matches = keyframesRegex.exec(cssText);
      if (matches === null) {
        break;
      }
      result.push(matches[0]);
    }
    cssText = cssText.replace(keyframesRegex, "");
    const importRegex = /@import[\s\S]*?url\([^)]*\)[\s\S]*?;/gi;
    const combinedCSSRegex = "((\\s*?(?:\\/\\*[\\s\\S]*?\\*\\/)?\\s*?@media[\\s\\S]*?){([\\s\\S]*?)}\\s*?})|(([\\s\\S]*?){([\\s\\S]*?)})";
    const unifiedRegex = new RegExp(combinedCSSRegex, "gi");
    while (true) {
      let matches = importRegex.exec(cssText);
      if (matches === null) {
        matches = unifiedRegex.exec(cssText);
        if (matches === null) {
          break;
        } else {
          importRegex.lastIndex = unifiedRegex.lastIndex;
        }
      } else {
        unifiedRegex.lastIndex = importRegex.lastIndex;
      }
      result.push(matches[0]);
    }
    return result;
  }
  async function getCSSRules(styleSheets, options) {
    const ret = [];
    const deferreds = [];
    styleSheets.forEach((sheet) => {
      if ("cssRules" in sheet) {
        try {
          toArray(sheet.cssRules || []).forEach((item, index) => {
            if (item.type === CSSRule.IMPORT_RULE) {
              let importIndex = index + 1;
              const url = item.href;
              const deferred = fetchCSS(url).then((metadata) => embedFonts(metadata, options)).then((cssText) => parseCSS(cssText).forEach((rule) => {
                try {
                  sheet.insertRule(rule, rule.startsWith("@import") ? importIndex += 1 : sheet.cssRules.length);
                } catch (error) {
                  console.error("Error inserting rule from remote css", {
                    rule,
                    error
                  });
                }
              })).catch((e) => {
                console.error("Error loading remote css", e.toString());
              });
              deferreds.push(deferred);
            }
          });
        } catch (e) {
          const inline2 = styleSheets.find((a) => a.href == null) || document.styleSheets[0];
          if (sheet.href != null) {
            deferreds.push(fetchCSS(sheet.href).then((metadata) => embedFonts(metadata, options)).then((cssText) => parseCSS(cssText).forEach((rule) => {
              inline2.insertRule(rule, inline2.cssRules.length);
            })).catch((err) => {
              console.error("Error loading remote stylesheet", err);
            }));
          }
          console.error("Error inlining remote css file", e);
        }
      }
    });
    return Promise.all(deferreds).then(() => {
      styleSheets.forEach((sheet) => {
        if ("cssRules" in sheet) {
          try {
            toArray(sheet.cssRules || []).forEach((item) => {
              ret.push(item);
            });
          } catch (e) {
            console.error(`Error while reading CSS rules from ${sheet.href}`, e);
          }
        }
      });
      return ret;
    });
  }
  function getWebFontRules(cssRules) {
    return cssRules.filter((rule) => rule.type === CSSRule.FONT_FACE_RULE).filter((rule) => shouldEmbed(rule.style.getPropertyValue("src")));
  }
  async function parseWebFontRules(node, options) {
    if (node.ownerDocument == null) {
      throw new Error("Provided element is not within a Document");
    }
    const styleSheets = toArray(node.ownerDocument.styleSheets);
    const cssRules = await getCSSRules(styleSheets, options);
    return getWebFontRules(cssRules);
  }
  function normalizeFontFamily(font) {
    return font.trim().replace(/["']/g, "");
  }
  function getUsedFonts(node) {
    const fonts = /* @__PURE__ */ new Set();
    function traverse(node2) {
      const fontFamily = node2.style.fontFamily || getComputedStyle(node2).fontFamily;
      fontFamily.split(",").forEach((font) => {
        fonts.add(normalizeFontFamily(font));
      });
      Array.from(node2.children).forEach((child) => {
        if (child instanceof HTMLElement) {
          traverse(child);
        }
      });
    }
    traverse(node);
    return fonts;
  }
  async function getWebFontCSS(node, options) {
    const rules = await parseWebFontRules(node, options);
    const usedFonts = getUsedFonts(node);
    const cssTexts = await Promise.all(rules.filter((rule) => usedFonts.has(normalizeFontFamily(rule.style.fontFamily))).map((rule) => {
      const baseUrl = rule.parentStyleSheet ? rule.parentStyleSheet.href : null;
      return embedResources(rule.cssText, baseUrl, options);
    }));
    return cssTexts.join("\n");
  }
  async function embedWebFonts(clonedNode, options) {
    const cssText = options.fontEmbedCSS != null ? options.fontEmbedCSS : options.skipFonts ? null : await getWebFontCSS(clonedNode, options);
    if (cssText) {
      const styleNode = document.createElement("style");
      const sytleContent = document.createTextNode(cssText);
      styleNode.appendChild(sytleContent);
      if (clonedNode.firstChild) {
        clonedNode.insertBefore(styleNode, clonedNode.firstChild);
      } else {
        clonedNode.appendChild(styleNode);
      }
    }
  }
  async function toSvg(node, options = {}) {
    const { width, height } = getImageSize(node, options);
    const clonedNode = await cloneNode(node, options, true);
    await embedWebFonts(clonedNode, options);
    await embedImages(clonedNode, options);
    applyStyle(clonedNode, options);
    const datauri = await nodeToDataURL(clonedNode, width, height);
    return datauri;
  }
  async function toCanvas(node, options = {}) {
    const { width, height } = getImageSize(node, options);
    const svg = await toSvg(node, options);
    const img = await createImage(svg);
    const canvas = document.createElement("canvas");
    const context = canvas.getContext("2d");
    const ratio = options.pixelRatio || getPixelRatio();
    const canvasWidth = options.canvasWidth || width;
    const canvasHeight = options.canvasHeight || height;
    canvas.width = canvasWidth * ratio;
    canvas.height = canvasHeight * ratio;
    if (!options.skipAutoScale) {
      checkCanvasDimensions(canvas);
    }
    canvas.style.width = `${canvasWidth}`;
    canvas.style.height = `${canvasHeight}`;
    if (options.backgroundColor) {
      context.fillStyle = options.backgroundColor;
      context.fillRect(0, 0, canvas.width, canvas.height);
    }
    context.drawImage(img, 0, 0, canvas.width, canvas.height);
    return canvas;
  }
  async function toBlob(node, options = {}) {
    const canvas = await toCanvas(node, options);
    const blob2 = await canvasToBlob(canvas);
    return blob2;
  }
  function convertToEmbed(url) {
    try {
      let embedHtml = "";
      if (url.includes("youtube.com") || url.includes("youtu.be")) {
        const videoId = url.match(/(?:youtube\.com\/watch\?v=|youtu\.be\/)([\w-]+)/)?.[1];
        if (videoId) {
          embedHtml = `<iframe width="320" height="200" src="https://www.youtube.com/embed/${videoId}" frameborder="0" allowfullscreen></iframe>`;
        }
      } else if (url.includes("twitter.com") || url.includes("x.com")) {
        embedHtml = `<blockquote class="twitter-tweet"><a href="${url}"></a></blockquote>
                         <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"><\/script>`;
      } else if (url.includes("tiktok.com")) {
        embedHtml = `<blockquote class="tiktok-embed" cite="${url}" data-video-id="${url.split("/").pop()}" style="max-width: 605px; min-width: 325px;">
                            <a href="${url}">Watch on TikTok</a>
                         </blockquote>
                         <script async src="https://www.tiktok.com/embed.js"><\/script>`;
      } else if (url.includes("instagram.com/p/")) {
        embedHtml = `<blockquote class="instagram-media" data-instgrm-permalink="${url}" data-instgrm-version="13">
                            <a href="${url}">View on Instagram</a>
                         </blockquote>
                         <script async src="https://www.instagram.com/embed.js"><\/script>`;
      }
      return embedHtml || `<a href="${url}" target="_blank" rel="noopener noreferrer">${url}</a>`;
    } catch (error) {
      console.error("Error generating embed:", error);
      return `<a href="${url}" target="_blank" rel="noopener noreferrer">${url}</a>`;
    }
  }
  function formatPostText(post2) {
    let text = post2.text;
    if (!post2.facets) return text;
    const charOffsets = buildByteToCharMap(text);
    const sortedFacets = [...post2.facets].reverse();
    for (const facet2 of sortedFacets) {
      const { index, features } = facet2;
      const start = charOffsets.findLast((c) => c.byteOffset <= index.byteStart)?.charIndex || 0;
      const end = charOffsets.findLast((c) => c.byteOffset <= index.byteEnd)?.charIndex || text.length;
      const originalText = text.slice(start, end);
      for (const feature of features) {
        const replacement = formatFacetFeature(feature, originalText);
        if (replacement) {
          text = text.slice(0, start) + replacement + text.slice(end + 1);
        }
      }
    }
    return text;
  }
  function buildByteToCharMap(text) {
    const charOffsets = [];
    const encoder = new TextEncoder();
    let byteOffset = 0;
    for (let charIndex = 0; charIndex < [...text].length; charIndex++) {
      const char = [...text][charIndex];
      charOffsets.push({ byteOffset, charIndex });
      byteOffset += encoder.encode(char).length;
    }
    return charOffsets;
  }
  function formatFacetFeature(feature, originalText) {
    switch (feature.$type) {
      case "app.bsky.richtext.facet#mention":
        return `<a href="https://bsky.app/profile/${feature.did}" class="mention">${originalText}</a>`;
      case "app.bsky.richtext.facet#link":
        return convertToEmbed(feature.uri);
      case "app.bsky.richtext.facet#tag":
        return `<a href="https://bsky.app/search?q=%23${feature.tag}" class="hashtag">${originalText}</a>`;
      default:
        return null;
    }
  }
  function urlForPost(post2) {
    return `https://bsky.app/profile/${post2.author.handle}/post/${post2.uri.split("/").slice(-1)[0]}`;
  }
  function extractQuotedPost(embed2) {
    if (!embed2) return null;
    if (embed2.record && embed2.record.author) {
      const record2 = embed2.record;
      return {
        avatar: record2.author?.avatar,
        displayName: record2.author?.displayName || record2.author?.handle,
        handle: record2.author?.handle,
        text: record2.value?.text || "",
        images: record2.embeds?.[0]?.images || null
      };
    }
    if (embed2.record?.record?.author) {
      const record2 = embed2.record.record;
      return {
        avatar: record2.author?.avatar,
        displayName: record2.author?.displayName || record2.author?.handle,
        handle: record2.author?.handle,
        text: record2.value?.text || "",
        images: record2.embeds?.[0]?.images || null
      };
    }
    return null;
  }
  function extractExternalLink(embed2) {
    if (!embed2) return null;
    if (embed2.external) {
      const ext = embed2.external;
      return {
        uri: ext.uri,
        title: ext.title || "",
        description: ext.description || "",
        thumb: ext.thumb || null,
        domain: ext.uri ? new URL(ext.uri).hostname : ""
      };
    }
    if (embed2.media?.external) {
      const ext = embed2.media.external;
      return {
        uri: ext.uri,
        title: ext.title || "",
        description: ext.description || "",
        thumb: ext.thumb || null,
        domain: ext.uri ? new URL(ext.uri).hostname : ""
      };
    }
    return null;
  }
  function formatPost(post2) {
    const formatter = Intl.NumberFormat("en", { notation: "compact" });
    return {
      postId: post2.cid,
      postUrl: urlForPost(post2),
      avatar: post2.author.avatar,
      displayName: post2.author.displayName || post2.author.handle,
      handle: post2.author.handle,
      content: formatPostText(post2.record),
      embed: post2.embed,
      quotedPost: extractQuotedPost(post2.embed),
      externalLink: extractExternalLink(post2.embed),
      timestamp: new Date(post2.record.createdAt).toLocaleString(),
      replySvg: constants.SIDECAR_SVG_REPLY,
      replyCount: formatter.format(post2.replyCount),
      repostSvg: constants.SIDECAR_SVG_REPOST[post2.viewer.repost ? 1 : 0],
      repostCount: formatter.format(post2.repostCount),
      likeSvg: constants.SIDECAR_SVG_LIKE[post2.viewer.like ? 1 : 0],
      likeCount: formatter.format(post2.likeCount)
    };
  }
  class GestureHandler {
    constructor(config2, itemHandler) {
      this.config = config2;
      this.itemHandler = itemHandler;
      this.minSwipeDistance = 50;
      this.swipeThreshold = 0.3;
      this.activeElement = null;
      this.startX = 0;
      this.startY = 0;
      this.currentX = 0;
      this.isHorizontalSwipe = null;
      this.handleTouchStart = this.handleTouchStart.bind(this);
      this.handleTouchMove = this.handleTouchMove.bind(this);
      this.handleTouchEnd = this.handleTouchEnd.bind(this);
    }
    /**
     * Initialize gesture handling on an item
     */
    init(item) {
      if (!item) return;
      item.addEventListener("touchstart", this.handleTouchStart, { passive: true });
      item.addEventListener("touchmove", this.handleTouchMove, { passive: false });
      item.addEventListener("touchend", this.handleTouchEnd, { passive: true });
    }
    /**
     * Remove gesture handling from an item
     */
    destroy(item) {
      if (!item) return;
      item.removeEventListener("touchstart", this.handleTouchStart);
      item.removeEventListener("touchmove", this.handleTouchMove);
      item.removeEventListener("touchend", this.handleTouchEnd);
    }
    handleTouchStart(e) {
      if (e.touches.length !== 1) return;
      const touch = e.touches[0];
      this.startX = touch.clientX;
      this.startY = touch.clientY;
      this.currentX = touch.clientX;
      this.activeElement = e.currentTarget;
      this.isHorizontalSwipe = null;
      this.createSwipeIndicators();
    }
    handleTouchMove(e) {
      if (!this.activeElement || e.touches.length !== 1) return;
      const touch = e.touches[0];
      const deltaX = touch.clientX - this.startX;
      const deltaY = touch.clientY - this.startY;
      if (this.isHorizontalSwipe === null && (Math.abs(deltaX) > 10 || Math.abs(deltaY) > 10)) {
        this.isHorizontalSwipe = Math.abs(deltaX) > Math.abs(deltaY);
      }
      if (this.isHorizontalSwipe) {
        e.preventDefault();
        this.currentX = touch.clientX;
        const translateX = Math.max(-100, Math.min(100, deltaX * 0.5));
        this.activeElement.style.transform = `translateX(${translateX}px)`;
        this.activeElement.style.transition = "none";
        this.updateSwipeIndicators(deltaX);
      }
    }
    handleTouchEnd(e) {
      if (!this.activeElement) return;
      const deltaX = this.currentX - this.startX;
      const itemWidth = this.activeElement.offsetWidth;
      const swipeRatio = Math.abs(deltaX) / itemWidth;
      const animDuration = getAnimationDuration$1(200, this.config);
      this.activeElement.style.transition = `transform ${animDuration}ms ease-out`;
      this.activeElement.style.transform = "";
      if (this.isHorizontalSwipe && swipeRatio >= this.swipeThreshold) {
        if (deltaX > this.minSwipeDistance) {
          this.onSwipeRight();
        } else if (deltaX < -this.minSwipeDistance) {
          this.onSwipeLeft();
        }
      }
      this.removeSwipeIndicators();
      this.activeElement = null;
      this.isHorizontalSwipe = null;
    }
    onSwipeRight() {
      if (this.itemHandler && this.itemHandler.likePost) {
        this.itemHandler.likePost(this.activeElement);
        announceToScreenReader$2("Post liked");
      }
    }
    onSwipeLeft() {
      if (this.itemHandler) {
        $(this.activeElement).removeClass("item-unread").addClass("item-read");
        this.itemHandler.markItemRead(this.activeElement);
        const animDuration = getAnimationDuration$1(200, this.config);
        $(this.activeElement).css({
          transition: `transform ${animDuration}ms ease-out, opacity ${animDuration}ms ease-out`,
          transform: "translateX(-100%)",
          opacity: 0
        });
        setTimeout(() => {
          $(this.activeElement).css({
            transform: "",
            opacity: ""
          });
          this.itemHandler.jumpToNextUnseenItem();
        }, animDuration);
        announceToScreenReader$2("Post marked as read");
      }
    }
    createSwipeIndicators() {
      if (!this.activeElement) return;
      const leftIndicator = document.createElement("div");
      leftIndicator.className = "swipe-indicator swipe-indicator-left";
      leftIndicator.innerHTML = `
      <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
        <path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"/>
      </svg>
    `;
      const rightIndicator = document.createElement("div");
      rightIndicator.className = "swipe-indicator swipe-indicator-right";
      rightIndicator.innerHTML = `
      <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
        <path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/>
      </svg>
    `;
      this.activeElement.style.position = "relative";
      this.activeElement.insertBefore(leftIndicator, this.activeElement.firstChild);
      this.activeElement.insertBefore(rightIndicator, this.activeElement.firstChild);
    }
    updateSwipeIndicators(deltaX) {
      const leftIndicator = this.activeElement?.querySelector(".swipe-indicator-left");
      const rightIndicator = this.activeElement?.querySelector(".swipe-indicator-right");
      if (leftIndicator) {
        leftIndicator.classList.toggle("swipe-indicator-active", deltaX < -this.minSwipeDistance);
      }
      if (rightIndicator) {
        rightIndicator.classList.toggle("swipe-indicator-active", deltaX > this.minSwipeDistance);
      }
    }
    removeSwipeIndicators() {
      if (!this.activeElement) return;
      this.activeElement.querySelectorAll(".swipe-indicator").forEach((el) => el.remove());
    }
  }
  class BottomSheet {
    constructor(config2, itemHandler) {
      this.config = config2;
      this.itemHandler = itemHandler;
      this.isVisible = false;
      this.sheetElement = null;
      this.backdropElement = null;
      this.currentItem = null;
      this.longPressTimer = null;
      this.longPressDuration = 500;
      this.startX = 0;
      this.startY = 0;
      this.moveThreshold = 10;
      this.handleLongPressStart = this.handleLongPressStart.bind(this);
      this.handleLongPressMove = this.handleLongPressMove.bind(this);
      this.handleLongPressEnd = this.handleLongPressEnd.bind(this);
      this.handleScroll = this.handleScroll.bind(this);
      this.hide = this.hide.bind(this);
    }
    /**
     * Initialize long press detection on an item
     */
    init(item) {
      if (!item) return;
      item.addEventListener("touchstart", this.handleLongPressStart, { passive: true });
      item.addEventListener("touchend", this.handleLongPressEnd, { passive: true });
      item.addEventListener("touchcancel", this.handleLongPressEnd, { passive: true });
    }
    /**
     * Remove long press detection from an item
     */
    destroy(item) {
      if (!item) return;
      item.removeEventListener("touchstart", this.handleLongPressStart);
      item.removeEventListener("touchend", this.handleLongPressEnd);
      item.removeEventListener("touchcancel", this.handleLongPressEnd);
    }
    handleLongPressStart(e) {
      if (e.touches.length !== 1) {
        this.handleLongPressEnd();
        return;
      }
      const touch = e.touches[0];
      this.startX = touch.clientX;
      this.startY = touch.clientY;
      this.currentItem = e.currentTarget;
      document.addEventListener("touchmove", this.handleLongPressMove, { passive: true });
      window.addEventListener("scroll", this.handleScroll, { passive: true, capture: true });
      this.longPressTimer = setTimeout(() => {
        this.show(this.currentItem);
      }, this.longPressDuration);
    }
    handleLongPressMove(e) {
      if (e.touches.length !== 1) {
        this.handleLongPressEnd();
        return;
      }
      if (!this.longPressTimer) return;
      const touch = e.touches[0];
      const deltaX = Math.abs(touch.clientX - this.startX);
      const deltaY = Math.abs(touch.clientY - this.startY);
      if (deltaX > this.moveThreshold || deltaY > this.moveThreshold) {
        this.handleLongPressEnd();
      }
    }
    handleScroll() {
      this.handleLongPressEnd();
    }
    handleLongPressEnd() {
      document.removeEventListener("touchmove", this.handleLongPressMove);
      window.removeEventListener("scroll", this.handleScroll, { capture: true });
      if (this.longPressTimer) {
        clearTimeout(this.longPressTimer);
        this.longPressTimer = null;
      }
    }
    /**
     * Show the bottom sheet for an item
     */
    show(item) {
      if (this.isVisible) return;
      this.currentItem = item;
      this.isVisible = true;
      this.backdropElement = document.createElement("div");
      this.backdropElement.className = "bottom-sheet-backdrop";
      this.backdropElement.addEventListener("click", this.hide);
      this.sheetElement = this.createSheet();
      document.body.appendChild(this.backdropElement);
      document.body.appendChild(this.sheetElement);
      document.body.style.overflow = "hidden";
      requestAnimationFrame(() => {
        this.backdropElement.classList.add("bottom-sheet-backdrop-visible");
        this.sheetElement.classList.add("bottom-sheet-visible");
      });
      announceToScreenReader$2("Action sheet opened. Select an action or tap outside to close.");
    }
    /**
     * Hide the bottom sheet
     */
    hide() {
      if (!this.isVisible) return;
      const animDuration = getAnimationDuration$1(200, this.config);
      this.backdropElement.classList.remove("bottom-sheet-backdrop-visible");
      this.sheetElement.classList.remove("bottom-sheet-visible");
      setTimeout(() => {
        if (this.backdropElement && this.backdropElement.parentNode) {
          this.backdropElement.parentNode.removeChild(this.backdropElement);
        }
        if (this.sheetElement && this.sheetElement.parentNode) {
          this.sheetElement.parentNode.removeChild(this.sheetElement);
        }
        this.backdropElement = null;
        this.sheetElement = null;
        this.isVisible = false;
        document.body.style.overflow = "";
      }, animDuration);
      announceToScreenReader$2("Action sheet closed.");
    }
    /**
     * Create the sheet DOM element
     */
    createSheet() {
      const sheet = document.createElement("div");
      sheet.className = "bottom-sheet";
      sheet.setAttribute("role", "dialog");
      sheet.setAttribute("aria-modal", "true");
      sheet.setAttribute("aria-label", "Post actions");
      const actions = this.getActions();
      sheet.innerHTML = `
      <div class="bottom-sheet-handle"></div>
      <div class="bottom-sheet-content">
        ${actions.map((action) => `
          <button class="bottom-sheet-action" data-action="${action.id}">
            <span class="bottom-sheet-action-icon">${action.icon}</span>
            <span class="bottom-sheet-action-label">${action.label}</span>
          </button>
        `).join("")}
      </div>
      <button class="bottom-sheet-cancel">Cancel</button>
    `;
      sheet.querySelector(".bottom-sheet-cancel").addEventListener("click", this.hide);
      sheet.querySelectorAll(".bottom-sheet-action").forEach((btn) => {
        btn.addEventListener("click", (e) => {
          const actionId = e.currentTarget.dataset.action;
          this.executeAction(actionId);
          this.hide();
        });
      });
      return sheet;
    }
    /**
     * Get available actions for the current item
     */
    getActions() {
      return [
        {
          id: "like",
          icon: '<svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/></svg>',
          label: "Like"
        },
        {
          id: "repost",
          icon: '<svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><path d="M7 7h10v3l4-4-4-4v3H5v6h2V7zm10 10H7v-3l-4 4 4 4v-3h12v-6h-2v4z"/></svg>',
          label: "Repost"
        },
        {
          id: "reply",
          icon: '<svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><path d="M10 9V5l-7 7 7 7v-4.1c5 0 8.5 1.6 11 5.1-1-5-4-10-11-11z"/></svg>',
          label: "Reply"
        },
        {
          id: "open",
          icon: '<svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><path d="M19 19H5V5h7V3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-7h-2v7zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3h-7z"/></svg>',
          label: "Open post"
        },
        {
          id: "markRead",
          icon: '<svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"/></svg>',
          label: "Mark as read"
        },
        {
          id: "screenshot",
          icon: '<svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><path d="M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2zM8.5 13.5l2.5 3.01L14.5 12l4.5 6H5l3.5-4.5z"/></svg>',
          label: "Screenshot"
        }
      ];
    }
    /**
     * Execute an action
     */
    executeAction(actionId) {
      if (!this.currentItem || !this.itemHandler) return;
      switch (actionId) {
        case "like":
          this.itemHandler.likePost(this.currentItem);
          break;
        case "repost":
          $(this.currentItem).find('button[data-testid="repostBtn"]').click();
          break;
        case "reply":
          $(this.currentItem).find('button[data-testid="replyBtn"]').click();
          break;
        case "open":
          this.itemHandler.openItem(this.currentItem);
          break;
        case "markRead":
          $(this.currentItem).removeClass("item-unread").addClass("item-read");
          this.itemHandler.markItemRead(this.currentItem);
          announceToScreenReader$2("Marked as read");
          break;
        case "screenshot":
          this.itemHandler.captureScreenshot(this.currentItem);
          break;
      }
    }
  }
  class NavigableList {
    /**
     * @param {Object} options - Configuration options
     * @param {string} [options.itemSelector] - CSS selector for navigable items (selector mode)
     * @param {HTMLElement} [options.container] - Container element to search within (selector mode)
     * @param {Function} [options.getItems] - Callback returning array of items (callback mode)
     * @param {string} [options.selectedClass] - CSS class for selected item (default: 'modal-item-selected')
     * @param {Function} [options.onSelect] - Called when selection changes: (element, index, oldIndex)
     * @param {Function} [options.onDeselect] - Called when item is deselected: (element, index)
     * @param {Function} [options.onScroll] - Custom scroll handler: (element). If not provided, uses scrollIntoView
     * @param {boolean} [options.autoScroll] - Whether to auto-scroll on selection (default: true)
     * @param {boolean} [options.wrapAround] - Whether to wrap from end to start (default: false)
     */
    constructor(options = {}) {
      this.itemSelector = options.itemSelector;
      this.container = options.container;
      this._getItemsCallback = options.getItems;
      this.selectedClass = options.selectedClass || "modal-item-selected";
      this.onSelect = options.onSelect;
      this.onDeselect = options.onDeselect;
      this.onScroll = options.onScroll;
      this.autoScroll = options.autoScroll !== false;
      this.wrapAround = options.wrapAround || false;
      this.selectedIndex = 0;
    }
    /**
     * Get all navigable items
     * @returns {HTMLElement[]}
     */
    getItems() {
      if (this._getItemsCallback) {
        const items = this._getItemsCallback();
        if (items && items.toArray) {
          return items.toArray();
        }
        return Array.isArray(items) ? items : [];
      }
      if (!this.container) return [];
      return Array.from(this.container.querySelectorAll(this.itemSelector));
    }
    /**
     * Get currently selected item
     * @returns {HTMLElement|null}
     */
    getSelectedItem() {
      const items = this.getItems();
      return items[this.selectedIndex] || null;
    }
    /**
     * Get current selection index
     * @returns {number}
     */
    getSelectedIndex() {
      return this.selectedIndex;
    }
    /**
     * Check if we're at the first item
     * @returns {boolean}
     */
    isAtStart() {
      return this.selectedIndex === 0;
    }
    /**
     * Check if we're at the last item
     * @returns {boolean}
     */
    isAtEnd() {
      const items = this.getItems();
      return this.selectedIndex >= items.length - 1;
    }
    /**
     * Navigate by direction
     * @param {number} direction - 1 for next, -1 for previous
     * @returns {boolean} - True if navigation moved to a different item
     */
    navigate(direction) {
      const items = this.getItems();
      if (!items.length) return false;
      const oldIndex = this.selectedIndex;
      let newIndex = this.selectedIndex + direction;
      if (this.wrapAround) {
        if (newIndex < 0) {
          newIndex = items.length - 1;
        } else if (newIndex >= items.length) {
          newIndex = 0;
        }
      } else {
        if (newIndex < 0) {
          newIndex = 0;
        } else if (newIndex >= items.length) {
          newIndex = items.length - 1;
        }
      }
      if (newIndex === oldIndex) {
        return false;
      }
      items.forEach((item) => item.classList.remove(this.selectedClass));
      const oldItem = items[oldIndex];
      if (oldItem && this.onDeselect) {
        this.onDeselect(oldItem, oldIndex);
      }
      this.selectedIndex = newIndex;
      const newItem = items[this.selectedIndex];
      if (newItem) {
        newItem.classList.add(this.selectedClass);
        if (this.autoScroll) {
          if (this.onScroll) {
            this.onScroll(newItem);
          } else {
            newItem.scrollIntoView({ block: "nearest", behavior: "smooth" });
          }
        }
        if (this.onSelect) {
          this.onSelect(newItem, this.selectedIndex, oldIndex);
        }
      }
      return true;
    }
    /**
     * Jump to specific index
     * @param {number} index - Target index
     * @param {boolean} [force=false] - Force selection even if already at this index
     * @returns {boolean} - True if selection changed (or forced)
     */
    jumpTo(index, force = false) {
      const items = this.getItems();
      if (!items.length) return false;
      const oldIndex = this.selectedIndex;
      const newIndex = Math.max(0, Math.min(index, items.length - 1));
      if (newIndex === oldIndex && !force) {
        return false;
      }
      items.forEach((item) => item.classList.remove(this.selectedClass));
      const oldItem = items[oldIndex];
      if (oldItem && this.onDeselect) {
        this.onDeselect(oldItem, oldIndex);
      }
      this.selectedIndex = newIndex;
      const newItem = items[this.selectedIndex];
      if (newItem) {
        newItem.classList.add(this.selectedClass);
        if (this.autoScroll) {
          if (this.onScroll) {
            this.onScroll(newItem);
          } else {
            newItem.scrollIntoView({ block: "nearest", behavior: "smooth" });
          }
        }
        if (this.onSelect) {
          this.onSelect(newItem, this.selectedIndex, oldIndex);
        }
      }
      return true;
    }
    /**
     * Jump to first item
     * @returns {boolean} - True if selection changed
     */
    jumpToFirst() {
      return this.jumpTo(0);
    }
    /**
     * Jump to last item
     * @returns {boolean} - True if selection changed
     */
    jumpToLast() {
      const items = this.getItems();
      return this.jumpTo(items.length - 1);
    }
    /**
     * Handle keyboard event
     * @param {KeyboardEvent} event
     * @returns {boolean} - True if event was handled
     */
    handleKeydown(event) {
      switch (event.key) {
        case "j":
        case "ArrowDown":
          event.preventDefault();
          this.navigate(1);
          return true;
        case "k":
        case "ArrowUp":
          event.preventDefault();
          this.navigate(-1);
          return true;
        case "Home":
          event.preventDefault();
          this.jumpToFirst();
          return true;
        case "End":
          event.preventDefault();
          this.jumpToLast();
          return true;
        default:
          return false;
      }
    }
    /**
     * Update selection after items change (e.g., async content load)
     * Ensures selectedIndex is within bounds and applies styling
     */
    updateSelection() {
      const items = this.getItems();
      items.forEach((item) => item.classList.remove(this.selectedClass));
      if (this.selectedIndex >= items.length) {
        this.selectedIndex = Math.max(0, items.length - 1);
      }
      const currentItem = items[this.selectedIndex];
      if (currentItem) {
        currentItem.classList.add(this.selectedClass);
      }
    }
    /**
     * Clear selection styling from all items
     */
    clearSelection() {
      const items = this.getItems();
      items.forEach((item) => item.classList.remove(this.selectedClass));
      if (this.onDeselect && items[this.selectedIndex]) {
        this.onDeselect(items[this.selectedIndex], this.selectedIndex);
      }
    }
    /**
     * Reset selection to first item
     */
    reset() {
      this.selectedIndex = 0;
      this.updateSelection();
    }
    /**
     * Set index without triggering selection callbacks (for external sync)
     * @param {number} index - New index value
     */
    setIndexSilent(index) {
      const items = this.getItems();
      this.selectedIndex = Math.max(0, Math.min(index, items.length - 1));
    }
  }
  let instance = null;
  class PostViewModal {
    constructor(config2, onClose) {
      if (instance) {
        instance.config = config2;
        instance.onClose = onClose;
        return instance;
      }
      this.config = config2;
      this.onClose = onClose;
      this.isVisible = false;
      this.modalEl = null;
      this.previousActiveElement = null;
      this.isReaderMode = false;
      this.navList = null;
      instance = this;
    }
    /**
     * Show the modal with post content and sidecar
     * @param {HTMLElement} postElement - The post element to display
     * @param {string} sidecarHtml - HTML content for the sidecar
     * @param {boolean} isUnrolledThread - Whether this is an unrolled thread (navigate posts, not replies)
     */
    show(postElement, sidecarHtml, isUnrolledThread = false) {
      if (this.isVisible) return;
      this.previousActiveElement = document.activeElement;
      this.isVisible = true;
      this.isReaderMode = false;
      this.isUnrolledThread = isUnrolledThread;
      this.modalEl = this.createModal(postElement, sidecarHtml, isUnrolledThread);
      document.body.appendChild(this.modalEl);
      if (isUnrolledThread) {
        this.threadNavList = new NavigableList({
          itemSelector: 'div[data-testid="contentHider-post"], .unrolled-reply',
          container: this.modalEl.querySelector(".post-view-modal-post"),
          selectedClass: "modal-item-selected"
        });
        this.sidecarNavList = new NavigableList({
          itemSelector: ".sidecar-post",
          container: this.modalEl.querySelector(".post-view-modal-sidecar"),
          selectedClass: "modal-item-selected"
        });
        this.navList = this.threadNavList;
        this.focusedPane = "thread";
      } else {
        this.navList = new NavigableList({
          itemSelector: ".sidecar-post",
          container: this.modalEl,
          selectedClass: "modal-item-selected"
        });
        this.threadNavList = null;
        this.sidecarNavList = null;
        this.focusedPane = "sidecar";
      }
      const closeBtn = this.modalEl.querySelector(".post-view-modal-close");
      if (closeBtn) {
        closeBtn.focus();
      }
      const navTarget = isUnrolledThread ? "posts (left/right to switch to replies)" : "replies";
      announceToScreenReader$2(`Post view opened. Press Escape to close, j/k to navigate ${navTarget}.`);
      this.keyHandler = (e) => this.handleKeydown(e);
      document.addEventListener("keydown", this.keyHandler, true);
      document.body.style.overflow = "hidden";
    }
    /**
     * Hide the modal
     */
    hide() {
      if (!this.isVisible || !this.modalEl) return;
      const animDuration = getAnimationDuration$1(200, this.config);
      this.modalEl.classList.add("post-view-modal-hiding");
      if (this.onClose) {
        this.onClose();
      }
      setTimeout(() => {
        if (this.modalEl && this.modalEl.parentNode) {
          this.modalEl.parentNode.removeChild(this.modalEl);
        }
        this.modalEl = null;
        this.isVisible = false;
        document.body.style.overflow = "";
        if (this.previousActiveElement) {
          this.previousActiveElement.focus();
        }
      }, animDuration);
      document.removeEventListener("keydown", this.keyHandler, true);
      announceToScreenReader$2("Post view closed.");
    }
    /**
     * Create the modal DOM element
     * @param {HTMLElement} postElement - The post element to clone
     * @param {string} sidecarHtml - HTML content for the sidecar
     * @param {boolean} isUnrolledThread - Whether this is an unrolled thread
     */
    createModal(postElement, sidecarHtml, isUnrolledThread = false) {
      const modal = document.createElement("div");
      modal.className = "post-view-modal";
      if (isUnrolledThread) {
        modal.classList.add("post-view-modal-thread");
      }
      modal.setAttribute("role", "dialog");
      modal.setAttribute("aria-modal", "true");
      modal.setAttribute("aria-labelledby", "post-view-modal-title");
      const postClone = postElement.cloneNode(true);
      postClone.classList.remove("selected", "item", "item-selection-active", "item-selection-inactive", "item-read", "item-unread");
      postClone.classList.add("post-view-modal-cloned-post");
      postClone.removeAttribute("data-bsky-navigator-item-index");
      postClone.removeAttribute("data-bsky-navigator-thread-offset");
      postClone.removeAttribute("data-testid");
      postClone.removeAttribute("tabindex");
      postClone.removeAttribute("role");
      postClone.style.border = "none";
      postClone.style.width = "100%";
      postClone.style.maxWidth = "100%";
      postClone.style.opacity = "1";
      const title = isUnrolledThread ? "Thread View" : "Post View";
      modal.innerHTML = `
      <div class="post-view-modal-backdrop"></div>
      <div class="post-view-modal-content">
        <div class="post-view-modal-header">
          <h2 id="post-view-modal-title">${title}</h2>
          <button class="post-view-modal-close" aria-label="Close">\xD7</button>
        </div>
        <div class="post-view-modal-body">
          <div class="post-view-modal-post"></div>
          <div class="post-view-modal-sidecar"></div>
        </div>
      </div>
    `;
      const postContainer = modal.querySelector(".post-view-modal-post");
      postContainer.appendChild(postClone);
      const sidecarContainer = modal.querySelector(".post-view-modal-sidecar");
      if (sidecarHtml) {
        sidecarContainer.innerHTML = sidecarHtml;
      } else {
        sidecarContainer.innerHTML = '<div class="post-view-modal-loading">Loading replies...</div>';
      }
      modal.querySelector(".post-view-modal-backdrop").addEventListener("click", () => this.hide());
      modal.querySelector(".post-view-modal-close").addEventListener("click", () => this.hide());
      return modal;
    }
    /**
     * Update the sidecar content (for async loading)
     * @param {string} sidecarHtml - HTML content for the sidecar
     */
    updateSidecar(sidecarHtml) {
      if (!this.modalEl) return;
      const sidecarContainer = this.modalEl.querySelector(".post-view-modal-sidecar");
      if (sidecarContainer) {
        sidecarContainer.innerHTML = sidecarHtml;
        if (this.isUnrolledThread) {
          this.sidecarNavList = new NavigableList({
            itemSelector: ".sidecar-post",
            container: sidecarContainer,
            selectedClass: "modal-item-selected"
          });
          if (this.focusedPane === "sidecar") {
            this.navList = this.sidecarNavList;
          }
        }
        this.updateSelection();
      }
    }
    /**
     * Show the modal in reader mode (full width, no sidecar)
     * @param {string} contentHtml - HTML content for the reader view
     * @param {string} title - Title for the modal header
     */
    showReaderMode(contentHtml, title = "Reader View") {
      if (this.isVisible) return;
      this.previousActiveElement = document.activeElement;
      this.isVisible = true;
      this.isReaderMode = true;
      this.modalEl = this.createReaderModal(contentHtml, title);
      document.body.appendChild(this.modalEl);
      this.navList = new NavigableList({
        itemSelector: ".reader-mode-post",
        container: this.modalEl,
        selectedClass: "modal-item-selected"
      });
      const closeBtn = this.modalEl.querySelector(".post-view-modal-close");
      if (closeBtn) {
        closeBtn.focus();
      }
      announceToScreenReader$2("Reader view opened. Press Escape to close, j/k to navigate posts.");
      this.keyHandler = (e) => this.handleKeydown(e);
      document.addEventListener("keydown", this.keyHandler, true);
      document.body.style.overflow = "hidden";
    }
    /**
     * Create the reader mode modal DOM element
     * @param {string} contentHtml - HTML content for the reader view
     * @param {string} title - Title for the modal header
     */
    createReaderModal(contentHtml, title) {
      const modal = document.createElement("div");
      modal.className = "post-view-modal post-view-modal-reader";
      modal.setAttribute("role", "dialog");
      modal.setAttribute("aria-modal", "true");
      modal.setAttribute("aria-labelledby", "post-view-modal-title");
      const fontSize = this.config.get("readerModeFontSize") || 16;
      modal.innerHTML = `
      <div class="post-view-modal-backdrop"></div>
      <div class="post-view-modal-content post-view-modal-content-reader">
        <div class="post-view-modal-header">
          <h2 id="post-view-modal-title">${title}</h2>
          <div class="reader-mode-font-controls">
            <button class="reader-mode-font-btn" data-action="decrease" aria-label="Decrease font size">\u2212</button>
            <input type="number" class="reader-mode-font-input" value="${fontSize}" min="10" max="32" aria-label="Font size">
            <button class="reader-mode-font-btn" data-action="increase" aria-label="Increase font size">+</button>
          </div>
          <button class="post-view-modal-close" aria-label="Close">\xD7</button>
        </div>
        <div class="post-view-modal-body post-view-modal-body-reader">
          <div class="post-view-modal-reader-content" style="font-size: ${fontSize}px;">
            ${contentHtml || '<div class="post-view-modal-loading">Loading thread...</div>'}
          </div>
        </div>
      </div>
    `;
      modal.querySelector(".post-view-modal-backdrop").addEventListener("click", () => this.hide());
      modal.querySelector(".post-view-modal-close").addEventListener("click", () => this.hide());
      const fontInput = modal.querySelector(".reader-mode-font-input");
      const contentEl = modal.querySelector(".post-view-modal-reader-content");
      modal.querySelectorAll(".reader-mode-font-btn").forEach((btn) => {
        btn.addEventListener("click", () => {
          const action = btn.dataset.action;
          let newSize = parseInt(fontInput.value, 10);
          if (action === "increase") {
            newSize = Math.min(32, newSize + 1);
          } else {
            newSize = Math.max(10, newSize - 1);
          }
          fontInput.value = newSize;
          contentEl.style.fontSize = `${newSize}px`;
          this.config.set("readerModeFontSize", newSize);
          announceToScreenReader$2(`Font size: ${newSize} pixels`);
        });
      });
      fontInput.addEventListener("change", () => {
        let newSize = parseInt(fontInput.value, 10);
        newSize = Math.max(10, Math.min(32, newSize));
        fontInput.value = newSize;
        contentEl.style.fontSize = `${newSize}px`;
        this.config.set("readerModeFontSize", newSize);
      });
      return modal;
    }
    /**
     * Update the reader mode content (for async loading)
     * @param {string} contentHtml - HTML content for the reader view
     */
    updateReaderContent(contentHtml) {
      if (!this.modalEl) return;
      const contentContainer = this.modalEl.querySelector(".post-view-modal-reader-content");
      if (contentContainer) {
        contentContainer.innerHTML = contentHtml;
        this.updateSelection();
      }
    }
    /**
     * Check if modal is currently visible
     */
    get visible() {
      return this.isVisible;
    }
    /**
     * Handle keyboard events for navigation
     * @param {KeyboardEvent} e - The keyboard event
     */
    handleKeydown(e) {
      if (e.key === "Escape") {
        e.preventDefault();
        e.stopPropagation();
        e.stopImmediatePropagation();
        this.hide();
        return;
      }
      if (this.isUnrolledThread && (e.key === "ArrowLeft" || e.key === "ArrowRight" || e.key === "h" || e.key === "l")) {
        e.preventDefault();
        e.stopPropagation();
        e.stopImmediatePropagation();
        this.switchPane(e.key === "ArrowLeft" || e.key === "h" ? "thread" : "sidecar");
        return;
      }
      const navKeys = ["j", "k", "ArrowDown", "ArrowUp", "Home", "End"];
      if (navKeys.includes(e.key)) {
        e.preventDefault();
        e.stopPropagation();
        e.stopImmediatePropagation();
        if (this.navList) {
          this.navList.handleKeydown(e);
        }
      }
    }
    /**
     * Switch focus between thread and sidecar panes
     * @param {string} pane - 'thread' or 'sidecar'
     */
    switchPane(pane) {
      if (!this.isUnrolledThread || this.focusedPane === pane) return;
      const currentItems = this.navList.getItems();
      currentItems.forEach((item) => item.classList.remove("modal-item-selected"));
      this.focusedPane = pane;
      this.navList = pane === "thread" ? this.threadNavList : this.sidecarNavList;
      this.navList.updateSelection();
      const target2 = pane === "thread" ? "thread posts" : "replies";
      announceToScreenReader$2(`Now navigating ${target2}.`);
    }
    /**
     * Update selection styling after content loads
     */
    updateSelection() {
      if (this.navList) {
        this.navList.updateSelection();
      }
    }
  }
  const svgToDataUrl = (svg) => `data:image/svg+xml,${encodeURIComponent(svg.trim())}`;
  const icons = {
    // Navigation arrows (ItemHandler)
    upArrow: svgToDataUrl(`<svg fill="#000000" height="800px" width="800px" version="1.1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512.024 512.024"><g><g><path d="M505.762,240.923L271.095,6.256c-8.341-8.341-21.824-8.341-30.165,0L6.263,240.923c-4.011,3.989-6.251,9.408-6.251,15.083v234.667c0,8.619,5.184,16.427,13.163,19.712c7.979,3.328,17.152,1.493,23.253-4.629l219.584-219.584l219.584,219.584c4.075,4.075,9.536,6.251,15.083,6.251c2.752,0,5.525-0.512,8.171-1.621c7.979-3.285,13.163-11.093,13.163-19.712V256.005C512.013,250.331,509.773,244.912,505.762,240.923z"/></g></g></svg>`),
    downArrow: svgToDataUrl(`<svg fill="#000000" height="800px" width="800px" version="1.1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512.015 512.015"><g><g><path d="M498.843,1.635c-7.979-3.328-17.152-1.472-23.253,4.629L256.006,225.848L36.422,6.264c-6.101-6.101-15.275-7.957-23.253-4.629C5.19,4.92,0.006,12.728,0.006,21.347v234.667c0,5.675,2.24,11.093,6.251,15.083l234.667,234.667c4.16,4.16,9.621,6.251,15.083,6.251c5.461,0,10.923-2.091,15.083-6.251l234.667-234.667c4.011-3.989,6.251-9.408,6.251-15.083V21.347C512.006,12.728,506.822,4.92,498.843,1.635z"/></g></g></svg>`),
    // Feed controls (FeedItemHandler)
    circleUp: svgToDataUrl(`<svg width="800px" height="800px" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10 0c5.514 0 10 4.486 10 10s-4.486 10-10 10S0 15.514 0 10 4.486 0 10 0zm1 8.414l1.293 1.293a1 1 0 101.414-1.414l-3-3a.998.998 0 00-1.414 0l-3 3a1 1 0 001.414 1.414L9 8.414V14a1 1 0 102 0V8.414z" fill="#5C5F62"/></svg>`),
    circleDown: svgToDataUrl(`<svg width="800px" height="800px" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10 20C4.486 20 0 15.514 0 10S4.486 0 10 0s10 4.486 10 10-4.486 10-10 10zm-1-8.414l-1.293-1.293a1 1 0 00-1.414 1.414l3 3a.998.998 0 001.414 0l3-3a1 1 0 00-1.414-1.414L11 11.586V6a1 1 0 00-2 0v5.586z" fill="#5C5F62"/></svg>`),
    timeHistory: svgToDataUrl(`<svg width="800px" height="800px" viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg"><g id="Layer_2" data-name="Layer 2"><g id="invisible_box" data-name="invisible box"><rect width="48" height="48" fill="none"/></g><g id="icons_Q2" data-name="icons Q2"><path d="M46,24A22,22,0,0,1,4.3,33.7a2,2,0,0,1,.5-2.6,2,2,0,0,1,3,.7A18,18,0,1,0,10.6,12h5.3A2.1,2.1,0,0,1,18,13.7,2,2,0,0,1,16,16H6a2,2,0,0,1-2-2V4.1A2.1,2.1,0,0,1,5.7,2,2,2,0,0,1,8,4V8.9A22,22,0,0,1,46,24Z"/><path d="M34,32a1.7,1.7,0,0,1-1-.3L22,25.1V14a2,2,0,0,1,4,0v8.9l9,5.4a1.9,1.9,0,0,1,.7,2.7A1.9,1.9,0,0,1,34,32Z"/></g></g></svg>`),
    mail: svgToDataUrl(`<svg width="800px" height="800px" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><g><path fill="none" d="M0 0h24v24H0z"/><path d="M3 3h18a1 1 0 0 1 1 1v16a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1zm17 4.238l-7.928 7.1L4 7.216V19h16V7.238zM4.511 5l7.55 6.662L19.502 5H4.511z"/></g></svg>`),
    mailUnread: svgToDataUrl(`<svg width="800px" height="800px" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><g><path fill="none" d="M0 0h24v24H0z"/><path d="M16.1 3a5.023 5.023 0 0 0 0 2H4.511l7.55 6.662 5.049-4.52c.426.527.958.966 1.563 1.285l-6.601 5.911L4 7.216V19h16V8.9a5.023 5.023 0 0 0 2 0V20a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1h13.1zM21 7a3 3 0 1 1 0-6 3 3 0 0 1 0 6z"/></g></svg>`),
    sortNumericDown: svgToDataUrl(`<svg width="800px" height="800px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M8.38001 19.75C8.27987 19.7512 8.1805 19.7324 8.08775 19.6946C7.99501 19.6568 7.91077 19.6008 7.84001 19.53L5.34001 17C5.19956 16.8593 5.12067 16.6687 5.12067 16.47C5.12067 16.2712 5.19956 16.0806 5.34001 15.94C5.48357 15.8013 5.67539 15.7238 5.87501 15.7238C6.07462 15.7238 6.26644 15.8013 6.41001 15.94L8.41001 17.94L10.41 15.94C10.5536 15.8013 10.7454 15.7238 10.945 15.7238C11.1446 15.7238 11.3364 15.8013 11.48 15.94C11.6205 16.0806 11.6993 16.2712 11.6993 16.47C11.6993 16.6687 11.6205 16.8593 11.48 17L8.98001 19.5C8.90562 19.5846 8.8129 19.6511 8.70893 19.6944C8.60495 19.7377 8.49245 19.7567 8.38001 19.75Z" fill="#000000"/><path d="M8.38001 19.75C8.18017 19.75 7.98836 19.6713 7.84611 19.5309C7.70387 19.3906 7.62264 19.1998 7.62001 19V5C7.62264 4.80017 7.70387 4.60942 7.84611 4.46905C7.98836 4.32868 8.18017 4.24998 8.38001 4.25C8.57718 4.25263 8.76539 4.33281 8.90389 4.47317C9.04238 4.61354 9.12003 4.80281 9.12001 5V19C9.12003 19.1972 9.04238 19.3865 8.90389 19.5268C8.76539 19.6672 8.57718 19.7474 8.38001 19.75Z" fill="#000000"/><path d="M17.12 19.2499C16.9228 19.2473 16.7346 19.1671 16.5961 19.0268C16.4576 18.8864 16.38 18.6971 16.38 18.4999V14.4399L15.99 14.6599C15.815 14.7567 15.6086 14.78 15.4164 14.7247C15.2242 14.6694 15.0618 14.54 14.965 14.3649C14.8682 14.1899 14.8449 13.9836 14.9002 13.7913C14.9555 13.5991 15.085 13.4367 15.26 13.3399L15.92 12.9799C16.0943 12.8527 16.2999 12.7753 16.5148 12.7559C16.7297 12.7365 16.9458 12.7759 17.14 12.8699C17.3633 12.9752 17.5518 13.1423 17.683 13.3515C17.8141 13.5606 17.8825 13.8031 17.88 14.0499V18.4999C17.8774 18.6998 17.7962 18.8905 17.6539 19.0309C17.5117 19.1713 17.3199 19.25 17.12 19.2499Z" fill="#000000"/><path d="M16.62 9.24998C16.1754 9.248 15.7414 9.11437 15.3727 8.86593C15.004 8.6175 14.7172 8.26541 14.5484 7.85411C14.3797 7.44281 14.3365 6.99072 14.4245 6.55493C14.5124 6.11913 14.7275 5.71916 15.0425 5.40549C15.3576 5.09182 15.7585 4.87852 16.1947 4.79251C16.6309 4.7065 17.0828 4.75164 17.4933 4.92222C17.9039 5.09281 18.2547 5.3812 18.5015 5.75099C18.7483 6.12078 18.88 6.5554 18.88 6.99998C18.8813 7.29667 18.8237 7.59067 18.7105 7.86491C18.5973 8.13915 18.4307 8.38817 18.2204 8.5975C18.0102 8.80683 17.7604 8.9723 17.4857 9.08431C17.2109 9.19632 16.9167 9.25263 16.62 9.24998ZM16.62 6.24998C16.4211 6.24998 16.2303 6.329 16.0897 6.46965C15.949 6.6103 15.87 6.80107 15.87 6.99998C15.87 7.19889 15.949 7.38966 16.0897 7.53031C16.2303 7.67096 16.4211 7.74998 16.62 7.74998C16.8189 7.74998 17.0097 7.67096 17.1503 7.53031C17.291 7.38966 17.37 7.19889 17.37 6.99998C17.37 6.80107 17.291 6.6103 17.1503 6.46965C17.0097 6.329 16.8189 6.24998 16.62 6.24998Z" fill="#000000"/><path d="M16.11 11.25H15.62C15.4211 11.25 15.2303 11.171 15.0897 11.0303C14.949 10.8897 14.87 10.6989 14.87 10.5C14.87 10.3011 14.949 10.1103 15.0897 9.96967C15.2303 9.82902 15.4211 9.75 15.62 9.75H16.11C16.4293 9.7433 16.7345 9.61752 16.9657 9.39735C17.197 9.17719 17.3376 8.87853 17.36 8.56C17.36 8.27 17.36 7.92 17.36 7.5V7C17.36 6.80281 17.4376 6.61354 17.5761 6.47317C17.7146 6.33281 17.9028 6.25263 18.1 6.25C18.2999 6.24998 18.4917 6.32868 18.6339 6.46905C18.7761 6.60942 18.8574 6.80017 18.86 7V7.5C18.86 7.95 18.86 8.32 18.86 8.64C18.817 9.34229 18.5093 10.0022 17.999 10.4865C17.4886 10.9709 16.8136 11.2437 16.11 11.25Z" fill="#000000"/></svg>`),
    sortNumericUp: svgToDataUrl(`<svg width="800px" height="800px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M10.75 8.24994C10.56 8.24994 10.37 8.17994 10.22 8.02994L8.25 6.05994L6.28 8.02994C5.99 8.31994 5.51 8.31994 5.22 8.02994C4.93 7.73994 4.93 7.25994 5.22 6.96994L7.72 4.46994C8.01 4.17994 8.49 4.17994 8.78 4.46994L11.28 6.96994C11.57 7.25994 11.57 7.73994 11.28 8.02994C11.13 8.17994 10.94 8.24994 10.75 8.24994Z" fill="#000000"/><path d="M8.25 19.75C7.84 19.75 7.5 19.41 7.5 19V5C7.5 4.59 7.84 4.25 8.25 4.25C8.66 4.25 9 4.59 9 5V19C9 19.41 8.66 19.75 8.25 19.75Z" fill="#000000"/><path d="M17 11.25C16.59 11.25 16.25 10.91 16.25 10.5V6.43997L15.86 6.64997C15.49 6.84997 15.04 6.71997 14.84 6.35997C14.64 5.99997 14.77 5.53997 15.13 5.33997L15.78 4.97997C16.14 4.71997 16.6 4.67997 17 4.85997C17.45 5.06997 17.74 5.52997 17.74 6.04997V10.5C17.74 10.91 17.4 11.25 16.99 11.25H17Z" fill="#000000"/><path d="M16.5 17.25C15.26 17.25 14.25 16.24 14.25 15C14.25 13.76 15.26 12.75 16.5 12.75C17.74 12.75 18.75 13.76 18.75 15C18.75 16.24 17.74 17.25 16.5 17.25ZM16.5 14.25C16.09 14.25 15.75 14.59 15.75 15C15.75 15.41 16.09 15.75 16.5 15.75C16.91 15.75 17.25 15.41 17.25 15C17.25 14.59 16.91 14.25 16.5 14.25Z" fill="#000000"/><path d="M15.98 19.25H15.5C15.09 19.25 14.75 18.91 14.75 18.5C14.75 18.09 15.09 17.75 15.5 17.75H15.98C16.63 17.75 17.2 17.21 17.23 16.56C17.24 16.27 17.24 15.92 17.24 15.5V15C17.24 14.59 17.58 14.25 17.99 14.25C18.4 14.25 18.74 14.59 18.74 15V15.5C18.74 15.95 18.74 16.32 18.72 16.64C18.65 18.08 17.41 19.25 15.97 19.25H15.98Z" fill="#000000"/></svg>`),
    preferencesOutline: svgToDataUrl(`<svg width="800px" height="800px" viewBox="0 0 32 32" version="1.1" xmlns="http://www.w3.org/2000/svg"><g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g id="Icon-Set" transform="translate(-152.000000, -359.000000)" fill="#000000"><path d="M182,387 C182,388.104 181.104,389 180,389 L156,389 C154.896,389 154,388.104 154,387 L154,363 C154,361.896 154.896,361 156,361 L180,361 C181.104,361 182,361.896 182,363 L182,387 L182,387 Z M180,359 L156,359 C153.791,359 152,360.791 152,363 L152,387 C152,389.209 153.791,391 156,391 L180,391 C182.209,391 184,389.209 184,387 L184,363 C184,360.791 182.209,359 180,359 L180,359 Z M172,378.4 C170.674,378.4 169.6,377.325 169.6,376 C169.6,374.675 170.674,373.6 172,373.6 C173.326,373.6 174.4,374.675 174.4,376 C174.4,377.325 173.326,378.4 172,378.4 L172,378.4 Z M178,375 L175.858,375 C175.413,373.277 173.862,372 172,372 C170.138,372 168.588,373.277 168.142,375 L158,375 C157.448,375 157,375.448 157,376 C157,376.553 157.448,377 158,377 L168.142,377 C168.587,378.723 170.138,380 172,380 C173.862,380 175.413,378.723 175.858,377 L178,377 C178.552,377 179,376.553 179,376 C179,375.448 178.552,375 178,375 L178,375 Z M163,370.4 C161.674,370.4 160.6,369.325 160.6,368 C160.6,366.675 161.674,365.601 163,365.601 C164.326,365.601 165.4,366.675 165.4,368 C165.4,369.325 164.326,370.4 163,370.4 L163,370.4 Z M178,367 L166.858,367 C166.413,365.277 164.862,364 163,364 C161.138,364 159.587,365.277 159.142,367 L158,367 C157.448,367 157,367.448 157,368 C157,368.553 157.448,369 158,369 L159.142,369 C159.587,370.723 161.138,372 163,372 C164.862,372 166.413,370.723 166.858,369 L178,369 C178.552,369 179,368.553 179,368 C179,367.448 178.552,367 178,367 L178,367 Z M163,386.4 C161.674,386.4 160.6,385.325 160.6,384 C160.6,382.675 161.674,381.601 163,381.601 C164.326,381.601 165.4,382.675 165.4,384 C165.4,385.325 164.326,386.4 163,386.4 L163,386.4 Z M178,383 L166.858,383 C166.413,381.278 164.862,380 163,380 C161.138,380 159.587,381.278 159.142,383 L158,383 C157.448,383 157,383.447 157,384 C157,384.553 157.448,385 158,385 L159.142,385 C159.587,386.723 161.138,388 163,388 C164.862,388 166.413,386.723 166.858,385 L178,385 C178.552,385 179,384.553 179,384 C179,383.447 178.552,383 178,383 L178,383 Z" id="preferences"></path></g></g></svg>`),
    preferencesFilled: svgToDataUrl(`<svg width="800px" height="800px" viewBox="0 0 32 32" version="1.1" xmlns="http://www.w3.org/2000/svg"><g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g id="Icon-Set-Filled" transform="translate(-154.000000, -361.000000)" fill="#000000"><path d="M165,367.601 C163.674,367.601 162.6,368.675 162.6,370 C162.6,371.325 163.674,372.4 165,372.4 C166.326,372.4 167.4,371.325 167.4,370 C167.4,368.675 166.326,367.601 165,367.601 L165,367.601 Z M174,375.6 C172.674,375.6 171.6,376.675 171.6,378 C171.6,379.325 172.674,380.4 174,380.4 C175.326,380.4 176.4,379.325 176.4,378 C176.4,376.675 175.326,375.6 174,375.6 L174,375.6 Z M180,371 L168.858,371 C168.413,372.723 166.862,374 165,374 C163.138,374 161.587,372.723 161.142,371 L160,371 C159.448,371 159,370.553 159,370 C159,369.448 159.448,369 160,369 L161.142,369 C161.587,367.277 163.138,366 165,366 C166.862,366 168.413,367.277 168.858,369 L180,369 C180.552,369 181,369.448 181,370 C181,370.553 180.552,371 180,371 L180,371 Z M180,379 L177.858,379 C177.413,380.723 175.862,382 174,382 C172.138,382 170.587,380.723 170.142,379 L160,379 C159.448,379 159,378.553 159,378 C159,377.448 159.448,377 160,377 L170.142,377 C170.588,375.277 172.138,374 174,374 C175.862,374 177.413,375.277 177.858,377 L180,377 C180.552,377 181,377.448 181,378 C181,378.553 180.552,379 180,379 L180,379 Z M180,387 L168.858,387 C168.413,388.723 166.862,390 165,390 C163.138,390 161.587,388.723 161.142,387 L160,387 C159.448,387 159,386.553 159,386 C159,385.447 159.448,385 160,385 L161.142,385 C161.587,383.278 163.138,382 165,382 C166.862,382 168.413,383.278 168.858,385 L180,385 C180.552,385 181,385.447 181,386 C181,386.553 180.552,387 180,387 L180,387 Z M182,361 L158,361 C155.791,361 154,362.791 154,365 L154,389 C154,391.209 155.791,393 158,393 L182,393 C184.209,393 186,391.209 186,389 L186,365 C186,362.791 184.209,361 182,361 L182,361 Z M165,383.601 C163.674,383.601 162.6,384.675 162.6,386 C162.6,387.325 163.674,388.4 165,388.4 C166.326,388.4 167.4,387.325 167.4,386 C167.4,384.675 166.326,383.601 165,383.601 L165,383.601 Z" id="preferences"></path></g></g></svg>`),
    // Content type indicators
    cameraMovie: svgToDataUrl(`<svg fill="#000000" width="800px" height="800px" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M18 11c0-.959-.68-1.761-1.581-1.954C16.779 8.445 17 7.75 17 7c0-2.206-1.794-4-4-4-1.517 0-2.821.857-3.5 2.104C8.821 3.857 7.517 3 6 3 3.794 3 2 4.794 2 7c0 .902.312 1.727.817 2.396A1.994 1.994 0 0 0 2 11v8c0 1.103.897 2 2 2h12c1.103 0 2-.897 2-2v-2.638l4 2v-7l-4 2V11zm-5-6c1.103 0 2 .897 2 2s-.897 2-2 2-2-.897-2-2 .897-2 2-2zM6 5c1.103 0 2 .897 2 2s-.897 2-2 2-2-.897-2-2 .897-2 2-2zM4 19v-8h12l.002 8H4z"/></svg>`),
    imageAlt: svgToDataUrl(`<svg fill="#000000" width="800px" height="800px" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M19 3H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2V5c0-1.103-.897-2-2-2zM5 19V5h14l.002 14H5z"/><path d="m10 14-1-1-3 4h12l-5-7z"/></svg>`),
    linkExternal: svgToDataUrl(`<svg fill="#000000" width="800px" height="800px" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="m13 3 3.293 3.293-7 7 1.414 1.414 7-7L21 11V3z"/><path d="M19 19H5V5h7l-2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2v-5l-2-2v7z"/></svg>`),
    detail: svgToDataUrl(`<svg fill="#000000" width="800px" height="800px" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M20 3H4c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h16c1.103 0 2-.897 2-2V5c0-1.103-.897-2-2-2zM4 19V5h16l.002 14H4z"/><path d="M6 7h12v2H6zm0 4h12v2H6zm0 4h6v2H6z"/></svg>`),
    repost: svgToDataUrl(`<svg fill="#000000" width="800px" height="800px" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M19 7a1 1 0 0 0-1-1h-8v2h7v5h-3l3.969 5L22 13h-3V7zM5 17a1 1 0 0 0 1 1h8v-2H7v-5h3L6 6l-4 5h3v6z"/></svg>`),
    reply: svgToDataUrl(`<svg fill="#000000" width="800px" height="800px" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M10 11h6v7h2v-8a1 1 0 0 0-1-1h-7V6l-5 4 5 4v-3z"/></svg>`),
    comment: svgToDataUrl(`<svg fill="#000000" width="800px" height="800px" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M20 2H4c-1.103 0-2 .897-2 2v18l5.333-4H20c1.103 0 2-.897 2-2V4c0-1.103-.897-2-2-2zm0 14H6.667L4 18V4h16v12z"/></svg>`),
    spoolOfThread: svgToDataUrl(`<svg fill="#000000" height="800px" width="800px" version="1.1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 436.979 436.979"><path d="m369.299,85.997c5.523,0 10-4.477 10-10 0-10.2 8.298-18.499 18.499-18.499h7.262c5.523,0 10-4.477 10-10v-37.498c0-5.523-4.477-10-10-10h-316.485c-5.523,0-10,4.477-10,10v37.498c0,5.523 4.477,10 10,10h7.262c10.2,0 18.499,8.298 18.499,18.499 0,5.523 4.477,10 10,10h7.487v134.873c0,28.153-22.904,51.057-51.058,51.057-21.419,0-38.846-17.426-38.846-38.846 0-16.033 13.044-29.077 29.077-29.077 11.724,0 21.261,9.538 21.261,21.261 0,5.523 4.477,10 10,10s10-4.477 10-10c0-22.751-18.51-41.261-41.261-41.261-27.061,0-49.077,22.016-49.077,49.077 0,32.448 26.398,58.846 58.846,58.846 20.025,0 38.129-8.34 51.058-21.712v80.767h-7.487c-5.523,0-10,4.477-10,10 0,10.2-8.298,18.499-18.499,18.499h-7.262c-5.523,0-10,4.477-10,10v37.498c0,5.523 4.477,10 10,10h316.485c5.523,0 10-4.477 10-10v-37.498c0-5.523-4.477-10-10-10h-7.262c-10.2,0-18.499-8.298-18.499-18.499 0-5.523-4.477-10-10-10h-7.487v-264.985h7.487zm-187.681,264.985l160.194-73.232v23.783l-108.176,49.449h-52.018zm65.469-264.985l82.86,37.879-26.001,11.886-108.863-49.765h52.004zm32.806,60.76l-26.013,11.892-102.057-46.657v-23.78l128.07,58.545zm-76.073,34.776l-51.997-23.771v-23.779l78.005,35.661-26.008,11.889zm-51.997-1.78l27.945,12.776-27.945,12.775v-25.551zm0,47.541l189.989-86.852v23.779l-189.989,86.852v-23.779zm0,45.77l189.989-86.852v23.779l-189.989,86.852v-23.779zm0,45.769l189.989-86.852v23.779l-189.989,86.852v-23.779zm143.369-232.836h46.62v21.312l-46.62-21.312zm99.868-65.997v17.498h-296.485v-17.498h296.485zm-31.014,37.498c-1.463,2.659-2.625,5.506-3.43,8.499h-227.597c-0.806-2.992-1.967-5.84-3.43-8.499h234.457zm-265.471,359.481v-17.498h296.485v17.498h-296.485zm31.014-37.498c1.463-2.659 2.625-5.506 3.43-8.499h227.597c0.806,2.992 1.967,5.84 3.43,8.499h-234.457zm152.154-28.499l60.069-27.458v27.458h-60.069z"/></svg>`)
  };
  const { waitForElement: waitForElement$2, announceToScreenReader: announceToScreenReader$1, getAnimationDuration } = utils$1;
  function extractPostIdFromUrl(url) {
    const match2 = url.match(/post\/([^/]+)/);
    return match2 ? match2[1] : null;
  }
  class ItemHandler extends Handler {
    POPUP_MENU_SELECTOR = "div[aria-label^='Context menu backdrop']";
    THREAD_PAGE_SELECTOR = "main > div > div > div";
    // Use shared color palette from constants
    FILTER_LIST_COLORS = constants.FILTER_LIST_COLORS;
    FLOATING_BUTTON_IMAGES = {
      prev: [icons.upArrow],
      next: [icons.downArrow]
    };
    constructor(name, config2, state2, api, selector) {
      super(name, config2, state2, api);
      this.selector = selector;
      this.initSelection();
      this.initSidecarTemplates();
      this.loadNewerCallback = null;
      this.debounceTimeout = null;
      this.isPopupVisible = false;
      this.ignoreMouseMovement = false;
      this.loading = false;
      this.loadingNew = false;
      this.enableScrollMonitor = false;
      this.enableIntersectionObserver = false;
      this.handlingClick = false;
      this.itemStats = {};
      this.visibleItems = [];
      this.scrollTick = false;
      this.scrollTop = 0;
      this.scrollDirection = 0;
      this.selfThreadCache = {};
      this.unrolledPostIds = /* @__PURE__ */ new Set();
      this.handleToDidCache = /* @__PURE__ */ new Map();
      this.hoverDebounceTimeout = null;
      this.hoverDebounceDelay = 100;
      this.userInitiatedScroll = false;
      if (this.state.mobileView && this.config.get("enableSwipeGestures")) {
        this.gestureHandler = new GestureHandler(this.config, this);
        this.bottomSheet = new BottomSheet(this.config, this);
      }
      this.onPopupAdd = this.onPopupAdd.bind(this);
      this.onPopupRemove = this.onPopupRemove.bind(this);
      this.onIntersection = this.onIntersection.bind(this);
      this.onFooterIntersection = this.onFooterIntersection.bind(this);
      this.onItemAdded = this.onItemAdded.bind(this);
      this.onScroll = this.onScroll.bind(this);
      this.handleNewThreadPage = this.handleNewThreadPage.bind(this);
      this.onItemMouseOver = this.onItemMouseOver.bind(this);
      this.onSidecarItemMouseOver = this.onSidecarItemMouseOver.bind(this);
      this.getTimestampForItem = this.getTimestampForItem.bind(this);
      this.onWheel = this.onWheel.bind(this);
      this.onProfileHoverCardAdd = this.onProfileHoverCardAdd.bind(this);
      this.onProfileHoverCardRemove = this.onProfileHoverCardRemove.bind(this);
      this._perfLog = [];
      this._perfCallCounts = {};
      this._perfLastReport = Date.now();
    }
    /**
     * Log performance metrics when performanceLogging is enabled.
     * Tracks call counts, timing, and can detect runaway loops.
     */
    perfLog(label, durationMs = null) {
      if (!this.config.get("performanceLogging")) return;
      const now = Date.now();
      const entry = {
        time: now,
        label,
        duration: durationMs
      };
      this._perfCallCounts[label] = (this._perfCallCounts[label] || 0) + 1;
      this._perfLog.push(entry);
      if (this._perfLog.length > 500) this._perfLog.shift();
      if (now - this._perfLastReport > 1e4) {
        this._perfLastReport = now;
        Object.entries(this._perfCallCounts).forEach(([k, v]) => {
          if (v > 100) {
            console.warn(`[perf] WARNING: ${k} called ${v} times in 10s - possible runaway loop!`);
          }
        });
        this._perfCallCounts = {};
      }
    }
    /**
     * Start a performance timer. Returns a function to call when done.
     */
    perfStart(label) {
      if (!this.config.get("performanceLogging")) return () => {
      };
      const start = performance.now();
      return () => {
        const duration = performance.now() - start;
        this.perfLog(label, duration);
      };
    }
    isActive() {
      return false;
    }
    activate() {
      this.keyState = [];
      this.popupObserver = waitForElement$2(
        this.POPUP_MENU_SELECTOR,
        this.onPopupAdd,
        this.onPopupRemove
      );
      this.hoverCardObserver = new MutationObserver(() => {
        if (isUserTyping()) return;
        this.perfLog("hoverCardObserver mutation");
        if (this.hoverCardDebounce) return;
        this.hoverCardDebounce = requestAnimationFrame(() => {
          this.hoverCardDebounce = null;
          const hoverCardAvatar = document.querySelector(
            'div[data-testid="userAvatarImage"][style*="width: 64px"]'
          );
          if (hoverCardAvatar && !this.currentHoverCard) {
            this.onProfileHoverCardAdd(hoverCardAvatar);
          } else if (!hoverCardAvatar && this.currentHoverCard) {
            this.currentHoverCard = null;
          }
        });
      });
      this.hoverCardObserver.observe(document.body, {
        childList: true,
        subtree: true
      });
      this.setupIntersectionObservers();
      this.setupItemObserver();
      this.setupLoadNewerObserver();
      this.setupFloatingButtons();
      this.enableScrollMonitor = true;
      this.enableIntersectionObserver = true;
      $(document).on("scroll", this.onScroll);
      $(document).on("wheel", this.onWheel);
      $(document).on("scrollend", () => {
        setTimeout(() => {
          this.ignoreMouseMovement = false;
          this.userInitiatedScroll = false;
          if (this.isFixedSidecar() && this.config.get("fixedSidecarVisible") === false && this.selectedItem && this.selectedItem.length) {
            this.positionFixedSidecarToggle();
            $("#fixed-sidecar-toggle").addClass("visible");
          }
        }, 500);
      });
      super.activate();
    }
    deactivate() {
      if (this.floatingButtonsObserver) this.floatingButtonsObserver.disconnect();
      if (this.observer) this.observer.disconnect();
      if (this.popupObserver) this.popupObserver.disconnect();
      if (this.hoverCardObserver) this.hoverCardObserver.disconnect();
      if (this.intersectionObserver) this.intersectionObserver.disconnect();
      this.disableFooterObserver();
      if (this.hoverDebounceTimeout) clearTimeout(this.hoverDebounceTimeout);
      if (this.intersectionDebounceTimeout) clearTimeout(this.intersectionDebounceTimeout);
      $("#fixed-sidecar-toggle").removeClass("visible");
      $("#fixed-sidecar-connector").removeClass("visible");
      $(this.selector).off("mouseover mouseleave");
      $(document).off("scroll", this.onScroll);
      $(document).off("wheel", this.onWheel);
      super.deactivate();
    }
    // ===========================================================================
    // Selection State Management
    // ===========================================================================
    initSelection() {
      this._index = null;
      this._replyIndex = null;
      this._threadIndex = null;
      this.postId = null;
      this.sidecarNavList = null;
      this.threadNavList = null;
      $("#fixed-sidecar-toggle").removeClass("visible");
      $("#fixed-sidecar-connector").removeClass("visible");
      this._currentSidecarPostId = null;
    }
    /**
     * Create or get the sidecar NavigableList for reply navigation
     */
    getSidecarNavList() {
      if (!this.sidecarNavList) {
        this.sidecarNavList = new NavigableList({
          getItems: () => this.getSidecarReplies(),
          selectedClass: "reply-selection-active",
          autoScroll: false,
          // We handle scrolling ourselves
          onSelect: (item, index) => {
            $(this.selectedItem).addClass("item-selection-child-focused");
            $(this.selectedItem).removeClass("item-selection-active");
            if (this._threadIndex != null) {
              const threadPost = this.getThreadNavList().getSelectedItem();
              if (threadPost) {
                $(threadPost).addClass("reply-selection-child-focused");
                $(threadPost).removeClass("reply-selection-active");
              }
            }
            this.scrollSidecarToReply(item);
          }
        });
      }
      return this.sidecarNavList;
    }
    /**
     * Create or get the thread NavigableList for unrolled thread navigation
     */
    getThreadNavList() {
      if (!this.threadNavList) {
        this.threadNavList = new NavigableList({
          getItems: () => this.getUnrolledThreadPosts(),
          selectedClass: "reply-selection-active",
          autoScroll: false,
          // We handle scrolling ourselves
          onSelect: (item, index) => {
            $(this.selectedItem).addClass("item-selection-child-focused");
            $(this.selectedItem).removeClass("item-selection-active");
            this.scrollThreadPostIntoView(item);
          }
        });
      }
      return this.threadNavList;
    }
    /**
     * Create or get the main NavigableList for feed item navigation
     */
    getMainNavList() {
      if (!this.mainNavList) {
        this.mainNavList = new NavigableList({
          getItems: () => this.items ? this.items.toArray() : [],
          selectedClass: "item-selection-active",
          autoScroll: false,
          // We handle scrolling ourselves
          onSelect: (item, newIndex, oldIndex) => {
            this._onMainItemSelected(item, newIndex, oldIndex);
          },
          onDeselect: (item, index) => {
            this._onMainItemDeselected(item, index);
          }
        });
      }
      return this.mainNavList;
    }
    /**
     * Called when a main feed item is selected via NavigableList
     * @private
     */
    _onMainItemSelected(item, newIndex, oldIndex) {
      this._index = newIndex;
      this._threadIndex = null;
      this._replyIndex = null;
      this.sidecarNavList = null;
      this.threadNavList = null;
      this.postId = this.postIdForItem($(item));
      this.updateInfoIndicator();
      if (this.state?.stateManager && this.postId) {
        this.state.stateManager.updateState({
          focusedPostId: this.postId,
          focusedIndex: newIndex
        });
      }
      if (item && document.contains(item)) {
        this.applyItemStyle(item, true);
      }
      if (!this._skipSidecar) {
        this._expandPromise = this.expandItem($(item));
      } else {
        this._expandPromise = null;
      }
      $(item).find("video").each((_i, video2) => {
        const playbackMode = this.config.get("videoPreviewPlayback");
        if (playbackMode === "Pause all") {
          this.pauseVideo(video2);
        } else if (playbackMode === "Play selected") {
          this.playVideo(video2);
        }
        if (this.config.get("videoDisableLoop")) {
          video2.removeAttribute("autoplay");
          video2.addEventListener("ended", function() {
            video2.load();
          });
        }
      });
    }
    /**
     * Called when a main feed item is deselected via NavigableList
     * @private
     */
    _onMainItemDeselected(item, index) {
      if (this._markOnDeselect && index != null) {
        this.markItemRead(index, true);
      }
      if (item && document.contains(item)) {
        this.applyItemStyle(item, false);
      }
    }
    /**
     * Get unrolled thread posts (main post + unrolled replies) for navigation
     */
    getUnrolledThreadPosts() {
      if (!this.selectedItem || !this.unrolledReplies.length) return [];
      const mainPost = $(this.selectedItem).find('div[data-testid="contentHider-post"]').first();
      return [mainPost[0], ...this.unrolledReplies.toArray()];
    }
    /**
     * Scroll a thread post into view, same as top-level posts.
     */
    scrollThreadPostIntoView(post2) {
      if (!post2) return;
      const toolbarHeight = this.getToolbarHeight();
      const posts = this.getUnrolledThreadPosts();
      if (posts.length > 0 && post2 === posts[0]) {
        const scrollContainer = $(this.selectedItem).find('div[data-testid="contentHider-post"]').first().parent()[0];
        if (scrollContainer) {
          scrollContainer.scrollTop = 0;
        }
        const container = this.selectedItem?.[0];
        if (container) {
          container.style.scrollMarginTop = `${toolbarHeight}px`;
          container.scrollIntoView({
            behavior: this.config.get("enableSmoothScrolling") ? "smooth" : "instant",
            block: "start"
          });
        }
        return;
      }
      post2.style.scrollMarginTop = `${toolbarHeight}px`;
      post2.scrollIntoView({
        behavior: this.config.get("enableSmoothScrolling") ? "smooth" : "instant",
        block: "start"
      });
    }
    /**
     * Scroll a thread element into view within its container.
     * Handles tall posts by scrolling incrementally (half container height at a time).
     * Returns true if scrolled, false if fully visible (can advance to next/prev).
     * @param {Element} element - The element to scroll into view
     * @param {number} direction - 1 for down, -1 for up
     */
    scrollThreadElementIntoView(element, direction = 1) {
      if (!element) return false;
      const el = element[0] || element;
      const scrollContainer = $(this.selectedItem).find('div[data-testid="contentHider-post"]').first().parent()[0];
      if (!scrollContainer) {
        return this.scrollElementIntoView(el, direction);
      }
      const containerRect = scrollContainer.getBoundingClientRect();
      const elRect = el.getBoundingClientRect();
      const toolbarHeight = this.getToolbarHeight();
      const visibleTop = Math.max(containerRect.top, toolbarHeight);
      const visibleBottom = containerRect.bottom;
      const visibleHeight = visibleBottom - visibleTop;
      const elHeight = elRect.bottom - elRect.top;
      if (elHeight > visibleHeight) {
        if (direction > 0) {
          if (elRect.bottom <= visibleBottom) {
            return false;
          }
          const remaining = elRect.bottom - visibleBottom;
          const scrollAmount = Math.min(visibleHeight * 0.5, remaining + 10);
          scrollContainer.scrollTop += scrollAmount;
          return true;
        } else {
          if (elRect.top >= visibleTop) {
            return false;
          }
          const remaining = visibleTop - elRect.top;
          const scrollAmount = Math.min(visibleHeight * 0.5, remaining + 10);
          scrollContainer.scrollTop -= scrollAmount;
          return true;
        }
      } else {
        const topOverlap = visibleTop - elRect.top;
        const bottomOverlap = elRect.bottom - visibleBottom;
        if (direction > 0) {
          if (elRect.bottom <= visibleBottom || bottomOverlap < 20) {
            return false;
          }
          const scrollAmount = bottomOverlap + 10;
          scrollContainer.scrollTop += scrollAmount;
          return true;
        } else {
          if (elRect.top >= visibleTop || topOverlap < 20) {
            return false;
          }
          const scrollAmount = topOverlap + 10;
          scrollContainer.scrollTop -= scrollAmount;
          return true;
        }
      }
    }
    set index(value) {
      this._index = value;
      this._threadIndex = null;
      this._replyIndex = null;
      this.sidecarNavList = null;
      this.threadNavList = null;
      this.postId = this.postIdForItem(this.selectedItem);
      this.updateInfoIndicator();
      if (this.state?.stateManager && this.postId) {
        this.state.stateManager.updateState({
          focusedPostId: this.postId,
          focusedIndex: value
        });
      }
    }
    get index() {
      return this._index;
    }
    get selectedItem() {
      return $(this.items[this.index]);
    }
    getReplyForIndex(index) {
      return this.getSidecarReplies().eq(index);
    }
    get selectedReply() {
      if (this._replyIndex == null) return $();
      return $(this.getSidecarNavList().getSelectedItem());
    }
    get replyIndex() {
      return this._replyIndex;
    }
    set replyIndex(value) {
      const replies = this.getSidecarReplies();
      if (value == null) {
        if (this._replyIndex != null) {
          this.getSidecarNavList().clearSelection();
          $(this.selectedItem).addClass("item-selection-active");
          $(this.selectedItem).removeClass("item-selection-child-focused");
          if (this._threadIndex != null) {
            const threadPost = this.getThreadNavList().getSelectedItem();
            if (threadPost) {
              $(threadPost).addClass("reply-selection-active");
              $(threadPost).removeClass("reply-selection-child-focused");
            }
          }
        }
        this._replyIndex = null;
        return;
      }
      if (value < 0 || value >= replies.length) {
        return;
      }
      const navList = this.getSidecarNavList();
      const wasNull = this._replyIndex == null;
      if (wasNull) {
        navList.reset();
        $(this.selectedItem).addClass("item-selection-child-focused");
        $(this.selectedItem).removeClass("item-selection-active");
        if (this._threadIndex != null) {
          const threadPost = this.getThreadNavList().getSelectedItem();
          if (threadPost) {
            $(threadPost).addClass("reply-selection-child-focused");
            $(threadPost).removeClass("reply-selection-active");
          }
        }
        if (value > 0) {
          navList.jumpTo(value);
        } else {
          navList.updateSelection();
        }
      } else {
        navList.jumpTo(value);
      }
      this._replyIndex = navList.getSelectedIndex();
    }
    get threadIndex() {
      return this._threadIndex;
    }
    set threadIndex(value) {
      const posts = this.getUnrolledThreadPosts();
      if (value < 0) {
        if (this._threadIndex != null) {
          this.getThreadNavList().clearSelection();
          $(this.selectedItem).addClass("item-selection-active");
          $(this.selectedItem).removeClass("item-selection-child-focused");
        }
        this._threadIndex = null;
        this.setIndex(this.index - 1, false, false);
        if (!this.isElementFullyVisible(this.selectedItem)) {
          this.scrollElementIntoView(this.selectedItem[0], -1);
        }
        return;
      }
      if (value >= posts.length) {
        if (this._threadIndex != null) {
          this.getThreadNavList().clearSelection();
          $(this.selectedItem).addClass("item-selection-active");
          $(this.selectedItem).removeClass("item-selection-child-focused");
        }
        this._threadIndex = null;
        this.setIndex(this.index + 1, false, false);
        if (!this.isElementFullyVisible(this.selectedItem)) {
          this.scrollElementIntoView(this.selectedItem[0], 1);
        }
        return;
      }
      if (value == null) {
        if (this._threadIndex != null) {
          this.getThreadNavList().clearSelection();
          $(this.selectedItem).addClass("item-selection-active");
          $(this.selectedItem).removeClass("item-selection-child-focused");
        }
        this._threadIndex = null;
        this.updateInfoIndicator();
        if (this.isFixedSidecar() && $("#fixed-sidecar-panel").hasClass("visible")) {
          this.updateSidecarConnector();
        }
        return;
      }
      const navList = this.getThreadNavList();
      const wasNull = this._threadIndex == null;
      if (wasNull) {
        navList.reset();
        $(this.selectedItem).addClass("item-selection-child-focused");
        $(this.selectedItem).removeClass("item-selection-active");
        if (value > 0) {
          navList.jumpTo(value);
        } else {
          navList.updateSelection();
        }
      } else {
        navList.jumpTo(value);
      }
      this._threadIndex = navList.getSelectedIndex();
      this.updateInfoIndicator();
      if (this.isFixedSidecar() && $("#fixed-sidecar-panel").hasClass("visible")) {
        this.updateSidecarConnector();
      }
    }
    get unrolledReplies() {
      return $(this.selectedItem).find(".unrolled-reply");
    }
    /**
     * Check if fixed sidecar mode is enabled (vs inline)
     * Handles both new string values ('Fixed'/'Inline') and legacy boolean (true/false)
     */
    isFixedSidecar() {
      const value = this.config.get("fixedSidecar");
      return value === true || value === "Fixed";
    }
    getPostForThreadIndex(index) {
      const posts = this.getUnrolledThreadPosts();
      return $(posts[index]);
    }
    get selectedPost() {
      if (this._threadIndex == null) return $();
      return $(this.getThreadNavList().getSelectedItem());
    }
    setIndex(index, mark, update, skipSidecar = false) {
      if (index < 0 || !this.items || index >= this.items.length) {
        return;
      }
      if (index === this.index) {
        return;
      }
      this._markOnDeselect = mark;
      this._skipSidecar = skipSidecar;
      const navList = this.getMainNavList();
      const isFirstSelection = this._index == null;
      const moved = navList.jumpTo(index, isFirstSelection);
      this._markOnDeselect = false;
      this._skipSidecar = false;
      if (update) {
        this.updateItems();
      }
      return moved;
    }
    getIndexFromItem(item) {
      return $(this.items).index(item);
    }
    getSidecarIndexFromItem(item) {
      const replies = this.getSidecarReplies();
      return replies.filter(":visible").index(item);
    }
    /**
     * Get the jQuery collection of sidecar replies, handling both inline and fixed sidecar modes
     */
    getSidecarReplies() {
      if (this.isFixedSidecar() && $("#fixed-sidecar-panel").hasClass("visible")) {
        return $("#fixed-sidecar-panel .fixed-sidecar-panel-content").find("div.sidecar-post");
      }
      return $(this.selectedItem).parent().find("div.sidecar-post");
    }
    /**
     * Get the sidecar container element for scrolling purposes
     */
    getSidecarContainer() {
      if (this.isFixedSidecar() && $("#fixed-sidecar-panel").hasClass("visible")) {
        return $("#fixed-sidecar-panel .fixed-sidecar-panel-content");
      }
      return $(this.selectedItem).parent().find(".sidecar-replies");
    }
    /**
     * Check if sidecar navigation is available (either inline or fixed sidecar with content)
     */
    isSidecarNavigationAvailable() {
      if (!this.config.get("showReplySidecar")) return false;
      if (this.isFixedSidecar()) {
        const panel = $("#fixed-sidecar-panel");
        if (!panel.hasClass("visible")) return false;
      }
      const replies = this.getSidecarReplies();
      return replies.length > 0;
    }
    /**
     * Scroll to a reply within the sidecar, handling both inline and fixed sidecar modes
     */
    scrollSidecarToReply(replyElement) {
      if (this.isFixedSidecar() && $("#fixed-sidecar-panel").hasClass("visible")) {
        const container = $("#fixed-sidecar-panel .fixed-sidecar-panel-content")[0];
        if (container && replyElement) {
          const containerRect = container.getBoundingClientRect();
          const replyRect = replyElement.getBoundingClientRect();
          if (replyRect.top < containerRect.top || replyRect.bottom > containerRect.bottom) {
            replyElement.scrollIntoView({
              behavior: this.config.get("enableSmoothScrolling") ? "smooth" : "instant",
              block: "nearest"
            });
          }
        }
      } else {
        this.scrollToElement(replyElement, "nearest");
      }
    }
    /**
     * Apply author rule highlighting to a sidecar post
     * @param {HTMLElement} post - The sidecar post element
     */
    applySidecarAuthorHighlight(post2) {
      const $post = $(post2);
      const handleEl = $post.find(".sidecar-post-handle");
      if (!handleEl.length) return;
      const handleText = handleEl.text().replace(/^@/, "");
      if (!handleText) return;
      const displayNameEl = $post.find(".sidecar-post-username");
      if (!this.config.get("ruleColorCoding")) {
        if (displayNameEl.length) {
          displayNameEl.css({ "background-color": "", "border": "", "border-radius": "", "padding": "" });
        }
        $post.find(".sidecar-post-avatar").css("box-shadow", "");
        return;
      }
      const categoryIndex = this.getFilterCategoryIndexForHandle(handleText);
      if (categoryIndex >= 0) {
        const color = this.getColorForCategoryIndex(categoryIndex);
        if (displayNameEl.length) {
          displayNameEl[0].style.setProperty("background-color", `${color}80`, "important");
          displayNameEl[0].style.setProperty("border", `1px solid ${color}88`, "important");
          displayNameEl[0].style.setProperty("border-radius", "3px", "important");
          displayNameEl[0].style.setProperty("padding", "0 2px", "important");
        }
        const avatar = $post.find(".sidecar-post-avatar");
        if (avatar.length) {
          avatar.css({
            "box-shadow": `0 0 0 3px ${color}`,
            "border-radius": "50%"
          });
        }
      } else {
        if (displayNameEl.length) {
          displayNameEl.css({ "background-color": "", "border": "", "border-radius": "", "padding": "" });
        }
        $post.find(".sidecar-post-avatar").css("box-shadow", "");
      }
    }
    // ===========================================================================
    // Sidecar & Thread Unrolling
    // ===========================================================================
    initSidecarTemplates() {
      waitForElement$2("#sidecar-replies-template", () => {
        this.repliesTemplate = Handlebars.compile($("#sidecar-replies-template").html());
      });
      waitForElement$2("#sidecar-post-template", () => {
        this.postTemplate = Handlebars.compile($("#sidecar-post-template").html());
        Handlebars.registerPartial("postTemplate", this.postTemplate);
      });
      waitForElement$2("#sidecar-body-template", () => {
        this.bodyTemplate = Handlebars.compile($("#sidecar-body-template").html());
        Handlebars.registerPartial("bodyTemplate", this.bodyTemplate);
      });
      waitForElement$2("#sidecar-footer-template", () => {
        this.footerTemplate = Handlebars.compile($("#sidecar-footer-template").html());
        Handlebars.registerPartial("footerTemplate", this.footerTemplate);
      });
      waitForElement$2("#sidecar-post-counts-template", () => {
        this.postCountsTemplate = Handlebars.compile($("#sidecar-post-counts-template").html());
        Handlebars.registerPartial("postCountsTemplate", this.postCountsTemplate);
      });
      waitForElement$2("#sidecar-embed-image-template", () => {
        this.imageTemplate = Handlebars.compile($("#sidecar-embed-image-template").html());
        Handlebars.registerPartial("imageTemplate", this.imageTemplate);
      });
      waitForElement$2("#sidecar-embed-quote-template", () => {
        this.quoteTemplate = Handlebars.compile($("#sidecar-embed-quote-template").html());
        Handlebars.registerPartial("quoteTemplate", this.quoteTemplate);
      });
      waitForElement$2("#sidecar-embed-external-template", () => {
        this.externalTemplate = Handlebars.compile($("#sidecar-embed-external-template").html());
        Handlebars.registerPartial("externalTemplate", this.externalTemplate);
      });
      waitForElement$2("#sidecar-skeleton-template", () => {
        this.skeletonTemplate = Handlebars.compile($("#sidecar-skeleton-template").html());
      });
      if (this.isFixedSidecar() && this.config.get("showReplySidecar")) {
        this.initFixedSidecarPanel();
      }
      if (!this.isFixedSidecar() && this.config.get("fixedSidecarVisible") === false) {
        $("body").addClass("inline-sidecar-hidden");
      }
    }
    /**
     * Initialize the fixed sidecar panel that displays thread context for the selected post
     */
    initFixedSidecarPanel() {
      $("#fixed-sidecar-panel").remove();
      $("#fixed-sidecar-toggle").remove();
      this.fixedSidecarPanel = $(`
      <div id="fixed-sidecar-panel" class="fixed-sidecar-panel">
        <div class="fixed-sidecar-panel-header">
          <span class="fixed-sidecar-panel-title">Thread Context</span>
          <button class="fixed-sidecar-panel-close" aria-label="Close sidecar panel">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M18 6L6 18M6 6l12 12"/>
            </svg>
          </button>
        </div>
        <div class="fixed-sidecar-panel-content">
          <div class="fixed-sidecar-panel-empty">Select a post to see thread context</div>
        </div>
      </div>
    `);
      this.fixedSidecarToggle = $(`
      <button id="fixed-sidecar-toggle" class="fixed-sidecar-toggle" aria-label="Show thread context" title="Show thread context (t)">
        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/>
          <line x1="9" y1="10" x2="15" y2="10"/>
        </svg>
        <span class="fixed-sidecar-toggle-count"></span>
      </button>
    `);
      this.fixedSidecarConnector = $(`
      <svg id="fixed-sidecar-connector" class="fixed-sidecar-connector">
        <defs>
          <marker id="sidecar-arrow" markerWidth="8" markerHeight="8" refX="6" refY="4" orient="auto">
            <path d="M0,0 L8,4 L0,8 L2,4 Z" fill="currentColor"/>
          </marker>
        </defs>
        <path class="fixed-sidecar-connector-path" fill="none" marker-end="url(#sidecar-arrow)"/>
      </svg>
    `);
      $("body").append(this.fixedSidecarPanel);
      $("body").append(this.fixedSidecarConnector);
      this.fixedSidecarPanel.find(".fixed-sidecar-panel-close").on("click", () => {
        this.config.set("fixedSidecarVisible", false);
        this.config.save();
        this.hideFixedSidecarPanel();
      });
      $(document).on("click", "#fixed-sidecar-toggle", async (e) => {
        e.preventDefault();
        e.stopPropagation();
        await this.openFixedSidecarPanel();
      });
      $(window).on("resize.fixedSidecar", () => {
        if ($("#fixed-sidecar-panel").hasClass("visible")) {
          this.positionFixedSidecarPanel();
        }
      });
    }
    /**
     * Position the fixed sidecar panel next to the feed container
     */
    positionFixedSidecarPanel() {
      const panel = $("#fixed-sidecar-panel");
      if (!panel.length) return;
      let feedContainer = document.querySelector('[data-testid="postThreadScreen"]') || document.querySelector('[data-testid="homeScreen"]') || document.querySelector('main[role="main"] [style*="max-width"]');
      const toolbarHeight = this.getToolbarHeight() || 60;
      const top = toolbarHeight + 8;
      if (feedContainer) {
        const rect = feedContainer.getBoundingClientRect();
        const gap = 16;
        const panelWidth = 350;
        const left = rect.right + gap;
        const availableWidth = window.innerWidth - left;
        if (availableWidth >= panelWidth) {
          panel.css({
            left: `${left}px`,
            right: "auto",
            top: `${top}px`
          });
        } else {
          panel.css({
            left: "auto",
            right: "16px",
            top: `${top}px`
          });
        }
      } else {
        panel.css({
          left: "auto",
          right: "16px",
          top: `${top}px`
        });
      }
    }
    /**
     * Update the SVG connector line between the selected post and the sidecar panel
     */
    updateSidecarConnector() {
      const connector = $("#fixed-sidecar-connector");
      const panel = $("#fixed-sidecar-panel");
      const $item = this.selectedItem;
      if (!connector.length || !panel.length || !$item || !$item.length) {
        connector.removeClass("visible");
        return;
      }
      if (!panel.hasClass("visible")) {
        connector.removeClass("visible");
        return;
      }
      const $thread = $item.closest(".thread");
      const threadRect = $thread.length ? $thread[0].getBoundingClientRect() : null;
      let $targetPost = $item;
      if (this._threadIndex != null && this.unrolledReplies.length > 0) {
        const threadPost = this.getPostForThreadIndex(this._threadIndex);
        if (threadPost && threadPost.length) {
          $targetPost = threadPost;
        }
      }
      const itemRect = $item[0].getBoundingClientRect();
      const targetRect = $targetPost[0].getBoundingClientRect();
      const panelRect = panel[0].getBoundingClientRect();
      if (itemRect.width === 0 || itemRect.height === 0 || itemRect.right <= 0 || itemRect.left >= window.innerWidth || !document.contains($item[0])) {
        connector.removeClass("visible");
        return;
      }
      let startX;
      if (threadRect && this._threadIndex != null) {
        startX = threadRect.right;
      } else {
        startX = itemRect.right;
      }
      const startY = targetRect.top + 20;
      const endX = panelRect.left;
      const endY = panelRect.top + 30;
      const midX = (startX + endX) / 2;
      let path;
      if (this._threadIndex != null) {
        const controlX1 = startX + (endX - startX) * 0.3;
        const controlX2 = startX + (endX - startX) * 0.7;
        path = `M ${startX} ${startY} C ${controlX1} ${startY}, ${controlX2} ${endY}, ${endX} ${endY}`;
      } else {
        path = `M ${startX} ${startY} C ${midX} ${startY}, ${midX} ${endY}, ${endX} ${endY}`;
      }
      connector.attr("width", window.innerWidth);
      connector.attr("height", window.innerHeight);
      connector.css({
        position: "fixed",
        top: 0,
        left: 0,
        pointerEvents: "none"
      });
      connector.find(".fixed-sidecar-connector-path").attr("d", path);
      connector.addClass("visible");
    }
    /**
     * Show the fixed sidecar panel
     */
    showFixedSidecarPanel() {
      this.positionFixedSidecarPanel();
      $("#fixed-sidecar-panel").addClass("visible");
      $("#fixed-sidecar-connector").addClass("visible");
      $("#fixed-sidecar-toggle").removeClass("visible");
      this.updateSidecarConnector();
    }
    /**
     * Hide the fixed sidecar panel
     */
    hideFixedSidecarPanel() {
      $("#fixed-sidecar-panel").removeClass("visible");
      $("#fixed-sidecar-connector").removeClass("visible");
      this._currentSidecarPostId = null;
      this.positionFixedSidecarToggle();
      $("#fixed-sidecar-toggle").addClass("visible");
    }
    /**
     * Position the toggle button next to the selected item using fixed positioning.
     * The toggle is appended to body to avoid click events propagating through the post.
     */
    positionFixedSidecarToggle() {
      const toggle = this.fixedSidecarToggle;
      if (!toggle || !toggle.length) return;
      const $item = this.selectedItem;
      if (!$item || !$item.length) {
        toggle.removeClass("visible");
        return;
      }
      if (!toggle.parent().is("body")) {
        toggle.detach();
        $("body").append(toggle);
      }
      const rect = $item[0].getBoundingClientRect();
      window.scrollY || document.documentElement.scrollTop;
      toggle.css({
        position: "fixed",
        top: `${rect.top + 8}px`,
        left: `${rect.right + 8}px`,
        right: "auto"
      });
    }
    /**
     * Open the fixed sidecar panel with current item's thread
     */
    async openFixedSidecarPanel() {
      if (!this.api) {
        console.warn("[bsky-nav] openFixedSidecarPanel: API not initialized");
        return;
      }
      if (!this.items?.length) {
        await this.loadItems();
      }
      if (!this.selectedItem?.length && this.items?.length > 0) {
        this.setIndex(0, true);
      }
      if (!this.selectedItem?.length) {
        console.warn("[bsky-nav] openFixedSidecarPanel: no items available");
        return;
      }
      this.config.set("fixedSidecarVisible", true);
      this.config.save();
      const thread = await this.getThreadForItem(this.selectedItem);
      if (thread) {
        await this.updateFixedSidecarPanel(this.selectedItem, thread);
      }
    }
    /**
     * Toggle the fixed sidecar panel visibility
     */
    async toggleFixedSidecarPanel(item) {
      const panel = $("#fixed-sidecar-panel");
      if (panel.hasClass("visible")) {
        this.config.set("fixedSidecarVisible", false);
        this.config.save();
        this.hideFixedSidecarPanel();
      } else if (item && this.api) {
        this.config.set("fixedSidecarVisible", true);
        this.config.save();
        const thread = await this.getThreadForItem(item);
        if (thread) {
          await this.updateFixedSidecarPanel(item, thread);
        }
      }
    }
    /**
     * Toggle the inline sidecar visibility globally for all posts
     */
    toggleInlineSidecar(item) {
      const isCurrentlyVisible = this.config.get("fixedSidecarVisible") !== false;
      if (isCurrentlyVisible) {
        this.config.set("fixedSidecarVisible", false);
        $("body").addClass("inline-sidecar-hidden");
        $(".sidecar-replies").not(".post-view-modal *").hide();
        $(item).addClass("sidecar-collapsed");
      } else {
        this.config.set("fixedSidecarVisible", true);
        $("body").removeClass("inline-sidecar-hidden");
        $(".sidecar-replies").not(".post-view-modal *").show();
        $(item).removeClass("sidecar-collapsed");
      }
    }
    /**
     * Update the fixed sidecar panel with content for the given item
     */
    async updateFixedSidecarPanel(item, thread) {
      if (!this.fixedSidecarPanel || !document.contains(this.fixedSidecarPanel[0])) {
        this.initFixedSidecarPanel();
      }
      const itemPostId = this.postIdForItem(item);
      if (this._currentSidecarPostId === itemPostId && $("#fixed-sidecar-panel").hasClass("visible")) {
        return;
      }
      this._currentSidecarPostId = itemPostId;
      const contentContainer = $("#fixed-sidecar-panel .fixed-sidecar-panel-content");
      contentContainer.html(this.getSkeletonContent());
      await this.waitForElementStable(item);
      this.showFixedSidecarPanel();
      const sidecarContent = await this.getSidecarContent(item, thread);
      contentContainer.html(sidecarContent);
      contentContainer.find(".sidecar-post").each((i, post2) => {
        $(post2).on("mouseover", this.onSidecarItemMouseOver);
        if (this.highlightFilterMatches) {
          this.highlightFilterMatches(post2);
        }
        this.applySidecarAuthorHighlight(post2);
      });
      contentContainer.find(".sidecar-section-toggle").each((i, toggle) => {
        $(toggle).on("click", (e) => {
          e.preventDefault();
          const btn = $(e.currentTarget);
          const contentId = btn.attr("aria-controls");
          const content = $(`#${contentId}`);
          const isExpanded = btn.attr("aria-expanded") === "true";
          btn.attr("aria-expanded", !isExpanded);
          btn.find(".sidecar-section-icon").text(isExpanded ? "\u25B6" : "\u25BC");
          if (isExpanded) {
            content.slideUp(getAnimationDuration(200, this.config));
          } else {
            content.slideDown(getAnimationDuration(200, this.config));
          }
        });
      });
    }
    /**
     * Clear the fixed sidecar panel content
     */
    clearFixedSidecarPanel() {
      if (this.fixedSidecarPanel) {
        const contentContainer = this.fixedSidecarPanel.find(".fixed-sidecar-panel-content");
        contentContainer.html('<div class="fixed-sidecar-panel-empty">Select a post to see thread context</div>');
      }
    }
    getSkeletonContent() {
      if (this.skeletonTemplate) {
        return this.skeletonTemplate({});
      }
      return `<div class="sidecar-replies sidecar-skeleton" role="status" aria-label="Loading replies">
      <div class="skeleton-post">
        <div class="skeleton-header">
          <div class="skeleton-avatar skeleton-shimmer"></div>
          <div class="skeleton-author">
            <div class="skeleton-line skeleton-line-short skeleton-shimmer"></div>
            <div class="skeleton-line skeleton-line-medium skeleton-shimmer"></div>
          </div>
        </div>
        <div class="skeleton-body">
          <div class="skeleton-line skeleton-line-full skeleton-shimmer"></div>
          <div class="skeleton-line skeleton-line-full skeleton-shimmer"></div>
          <div class="skeleton-line skeleton-line-medium skeleton-shimmer"></div>
        </div>
      </div>
      <span class="sr-only">Loading replies...</span>
    </div>`;
    }
    shouldUnroll(_item) {
      return this.config.get("unrollThreads");
    }
    shouldShowSidecar(item) {
      return this.config.get("showReplySidecar") && $(item).closest(".thread").outerWidth() >= this.config.get("showReplySidecarMinimumWidth");
    }
    shouldExpand(item) {
      return this.shouldShowSidecar(item) || this.shouldUnroll(item);
    }
    async expandItem(item) {
      if (!this.shouldExpand(item)) {
        return;
      }
      const thread = await this.getThreadForItem(item);
      if (!thread) {
        return;
      }
      if (this.shouldUnroll(item)) {
        await this.unrollThread(item, thread, true);
      }
      if (this.shouldShowSidecar(item)) {
        await this.showSidecar(item, thread, true);
      }
    }
    async unrollThread(item, thread) {
      if (thread.parent && thread.parent.post && thread.parent.post.author.did == thread.post.author.did) {
        return;
      }
      if (thread.replies.map((r) => r.post && r.post.author.did).includes(thread.post.author.did)) {
        let isRedundant = function(item2, threadIndex2) {
          return $(item2).data("bsky-navigator-thread-offset") != 0 && $(item2).closest(".thread").data("bsky-navigator-thread-index") == threadIndex2;
        };
        const postId = this.postIdForItem(item);
        if (postId) {
          this.selfThreadCache[postId] = true;
          if (typeof this.updateScrollIndicator === "function") {
            this.updateScrollIndicator();
          }
        }
        const unrolledPosts = await this.api.unrollThread(thread);
        const parent = $(item).find('div[data-testid="contentHider-post"]').first().parent();
        parent.css({ "overflow-y": "scroll", "max-height": "80vH", "padding-top": "1em", "overscroll-behavior": "contain" });
        let div = $(parent).find("div.unrolled-replies");
        if ($(div).length) {
          $(div).empty();
        } else {
          div = $('<div class="unrolled-replies"/>');
          parent.append(div);
        }
        const totalPosts = unrolledPosts.length;
        const firstPostUrl = urlForPost(unrolledPosts[0]);
        let firstBadge = parent.find(".unrolled-post-first");
        if (!firstBadge.length) {
          parent.css("padding-left", "44px");
          parent.css("position", "relative");
          firstBadge = $(`<a href="${firstPostUrl}" class="unrolled-post-number unrolled-post-first" title="Post 1 of ${totalPosts}">1<span class="unrolled-post-total">/${totalPosts}</span></a>`);
          parent.prepend(firstBadge);
        } else {
          firstBadge.attr("title", `Post 1 of ${totalPosts}`);
          firstBadge.html(`1<span class="unrolled-post-total">/${totalPosts}</span>`);
        }
        const unrolledIds = [];
        unrolledPosts.slice(1).map((p, i) => {
          const postNum = i + 2;
          const postId2 = p.uri.split("/").slice(-1)[0];
          unrolledIds.push(postId2);
          this.unrolledPostIds.add(postId2);
          const reply = $('<div class="unrolled-reply"/>');
          reply.attr("data-unrolled-post-id", postId2);
          reply.append($('<hr class="unrolled-divider"/>'));
          const isLastPost = postNum === totalPosts;
          const postNumberClass = isLastPost ? "unrolled-post-number unrolled-post-last" : "unrolled-post-number";
          reply.append(
            $(
              `<a href="${urlForPost(p)}" class="${postNumberClass}" title="Post ${postNum} of ${totalPosts}">${postNum}<span class="unrolled-post-total">/${totalPosts}</span></a>`
            )
          );
          reply.append($(this.bodyTemplate(formatPost(p))));
          reply.append($(this.footerTemplate(formatPost(p))));
          div.append(reply);
        });
        const threadIndex = $(item).closest(".thread").data("bsky-navigator-thread-index");
        this.items.each((i, feedItem) => {
          const feedItemPostId = this.postIdForItem(feedItem);
          if (feedItemPostId && unrolledIds.includes(feedItemPostId)) {
            $(feedItem).addClass("filtered unrolled-duplicate");
            $(feedItem).closest(".thread").addClass("has-unrolled-duplicate");
          }
        });
        this.items.each((i, item2) => {
          if (isRedundant(item2, threadIndex)) {
            $(item2).addClass("filtered");
          }
        });
        this.items = this.items.filter((i, item2) => {
          if (isRedundant(item2, threadIndex)) return false;
          if ($(item2).hasClass("unrolled-duplicate")) return false;
          return true;
        });
        const currentItem = item;
        requestAnimationFrame(() => {
          if (this.selectedItem?.[0] !== currentItem[0]) return;
          this._threadIndex = 0;
          $(this.selectedItem).addClass("item-selection-child-focused");
          $(this.selectedItem).removeClass("item-selection-active");
          this.getThreadNavList().updateSelection();
        });
        const rootPostId = thread.post.uri?.split("/").slice(-1)[0];
        if (rootPostId) {
          const threadPostIds = /* @__PURE__ */ new Set([rootPostId, ...unrolledIds]);
          const unrolledThread = $(item).closest(".thread")[0];
          $("div.thread").each(function() {
            const threadEl = $(this);
            if (this === unrolledThread) return;
            if (threadEl.hasClass("unrolled-view-full-thread-hidden")) return;
            const items = threadEl.find('[role="link"]');
            const realPosts = items.filter(function() {
              const $item = $(this);
              const testId = $item.attr("data-testid") || "";
              const ariaLabel = $item.attr("aria-label") || "";
              const hasPostUI = $item.find('[data-testid="postText"], [data-testid="likeBtn"]').length > 0;
              return testId.startsWith("feedItem-by-") || testId.startsWith("postThreadItem-by-") || ariaLabel.startsWith("Post by ") || hasPostUI;
            });
            const viewFullThreadItems = items.filter(function() {
              const $item = $(this);
              const testId = $item.attr("data-testid") || "";
              const ariaLabel = $item.attr("aria-label") || "";
              const hasPostUI = $item.find('[data-testid="postText"], [data-testid="likeBtn"]').length > 0;
              return !testId.startsWith("feedItem-by-") && !testId.startsWith("postThreadItem-by-") && !ariaLabel.startsWith("Post by ") && !hasPostUI;
            });
            if (viewFullThreadItems.length > 0 && realPosts.length === 0) {
              const links = threadEl.find('a[href*="/post/"]');
              const matchesThread = links.toArray().some((link) => {
                const href = $(link).attr("href");
                const linkPostId = href?.split("/post/")[1]?.split("?")[0];
                return linkPostId && threadPostIds.has(linkPostId);
              });
              if (matchesThread) {
                threadEl.addClass("unrolled-view-full-thread-hidden");
              }
            }
          });
        }
      }
    }
    async getSidecarContent(item, thread) {
      if (!item) {
        return this.repliesTemplate({});
      }
      const post2 = thread.post;
      const replies = thread.replies.filter((reply) => reply.post).filter((reply) => {
        const replyPostId = reply.post.uri?.split("/").slice(-1)[0];
        return !replyPostId || !this.unrolledPostIds.has(replyPostId);
      }).map((reply) => reply?.post).sort((a, b) => {
        switch (this.config.get("sidecarReplySortOrder")) {
          case "Default":
            return 0;
          case "Oldest First":
            return new Date(a.record.createdAt) - new Date(b.record.createdAt);
          case "Newest First":
            return new Date(b.record.createdAt) - new Date(a.record.createdAt);
          case "Most Liked First":
            return b.likeCount - a.likeCount;
          case "Most Reposted First":
            return b.repostCount - a.repostCount;
          default:
            console.error(`unknown sort order: ${this.config.get("sidecarReplySortOrder")}`);
        }
      }).map(formatPost);
      return this.repliesTemplate({
        postId: post2.cid,
        parent: thread.parent ? formatPost(thread.parent.post) : null,
        replies
      });
    }
    async showSidecar(item, thread, action = null) {
      if (this.isFixedSidecar()) {
        if (this.config.get("fixedSidecarVisible") !== false) {
          await this.updateFixedSidecarPanel(item, thread);
        } else {
          const toggle = $("#fixed-sidecar-toggle");
          const hasContext = thread && (thread.parent || thread.replies && thread.replies.length > 0);
          toggle.toggleClass("has-context", hasContext);
          let replyCount = thread?.replies?.length || 0;
          if (replyCount > 0 && this.shouldUnroll(item) && thread?.post?.author?.did) {
            const authorDid = thread.post.author.did;
            replyCount = thread.replies.filter((r) => r.post?.author?.did !== authorDid).length;
          }
          const countEl = toggle.find(".fixed-sidecar-toggle-count");
          if (replyCount > 0) {
            countEl.text(replyCount).show();
          } else {
            countEl.hide();
          }
          this.positionFixedSidecarToggle();
          toggle.addClass("visible");
        }
        return;
      }
      const container = $(item).parent();
      if (!container.length || !document.contains(container[0])) {
        return;
      }
      const itemKey = this.postIdForItem(item) || Date.now();
      if (container.data("sidecar-loading") === itemKey) {
        return;
      }
      container.data("sidecar-loading", itemKey);
      container.find(".sidecar-replies").each((i, el) => {
        try {
          if (el.parentNode) el.parentNode.removeChild(el);
        } catch (e) {
        }
      });
      if (!document.contains(container[0])) {
        container.removeData("sidecar-loading");
        return;
      }
      const skeletonContent = this.getSkeletonContent();
      $(container).append(skeletonContent);
      const sidecarContent = await this.getSidecarContent(item, thread);
      if (!document.contains(container[0])) {
        container.removeData("sidecar-loading");
        return;
      }
      container.find(".sidecar-replies").each((i, el) => {
        try {
          if (el.parentNode) el.parentNode.removeChild(el);
        } catch (e) {
        }
      });
      container.append($(sidecarContent));
      const hasSidecarContent = container.find(".sidecar-post").length > 0;
      if (hasSidecarContent) {
        $(item).addClass("has-sidecar");
      } else {
        $(item).removeClass("has-sidecar");
        container.find(".sidecar-replies").remove();
        container.removeData("sidecar-loading");
        return;
      }
      container.find(".sidecar-post").each((i, post2) => {
        $(post2).on("mouseover", this.onSidecarItemMouseOver);
        if (this.highlightFilterMatches) {
          this.highlightFilterMatches(post2);
        }
        this.applySidecarAuthorHighlight(post2);
      });
      container.find(".sidecar-section-toggle").each((i, toggle) => {
        $(toggle).on("click", (e) => {
          e.preventDefault();
          const btn = $(e.currentTarget);
          const contentId = btn.attr("aria-controls");
          const content = $(`#${contentId}`);
          const isExpanded = btn.attr("aria-expanded") === "true";
          btn.attr("aria-expanded", !isExpanded);
          btn.find(".sidecar-section-icon").text(isExpanded ? "\u25B6" : "\u25BC");
          if (isExpanded) {
            content.slideUp(getAnimationDuration(200, this.config));
          } else {
            content.slideDown(getAnimationDuration(200, this.config));
          }
        });
      });
      const sidecar = container.find(".sidecar-replies")[0];
      const globallyHidden = this.config.get("fixedSidecarVisible") === false;
      const display = globallyHidden ? "none" : action == null ? sidecar && $(sidecar).is(":visible") ? "none" : "flex" : action ? "flex" : "none";
      container.find(".sidecar-replies").css("display", display);
      if (globallyHidden) {
        $(item).addClass("sidecar-collapsed");
      }
      container.removeData("sidecar-loading");
    }
    // ===========================================================================
    // Keyboard Handling
    // ===========================================================================
    handleInput(event) {
      if (isUserTyping()) {
        return true;
      }
      if (isModalOpen()) {
        return true;
      }
      if (this.handleMovementKey(event)) {
        return event.key;
      } else if (this.handleItemKey(event)) {
        return event.key;
      } else if (event.key == "U") {
        this.loadOlderItems();
      } else {
        return super.handleInput(event);
      }
    }
    handleItemKey(event) {
      if (this.isPopupVisible) {
        return false;
      }
      if (event.altKey && !event.metaKey) {
        return this.handleRuleShortcut(event);
      }
      if (!event.metaKey) {
        return this.handleItemAction(event);
      }
      return false;
    }
    handleRuleShortcut(event) {
      if (!event.code.startsWith("Digit")) {
        return false;
      }
      const num = parseInt(event.code.substr(5)) - 1;
      $("#bsky-navigator-search").autocomplete("disable");
      if (num >= 0) {
        const ruleNames = Object.keys(this.state.rules).filter((k) => !k.startsWith("_"));
        const ruleName = ruleNames[num];
        $("#bsky-navigator-search").val(`${event.shiftKey ? "!" : ""}$${ruleName}`);
      } else {
        $("#bsky-navigator-search").val(null);
      }
      $("#bsky-navigator-search").trigger("input");
      $("#bsky-navigator-search").autocomplete("enable");
      return event.key;
    }
    handleItemAction(event) {
      if (this.rulesDropdownActive) {
        return false;
      }
      const item = this.selectedItem;
      switch (event.key) {
        case "o":
        case "Enter":
          this.openCurrentItem(item);
          break;
        case "O":
          this.openInnerPost(item);
          break;
        case "i":
          this.openFirstLink(item);
          break;
        case "m":
          this.toggleMedia(item, event);
          break;
        case "r":
          this.openReplyDialog(item);
          break;
        case "l":
          this.handleLikeAction(item);
          break;
        case "p":
          this.openRepostMenu(item);
          break;
        case "P":
          this.repostImmediately(item);
          break;
        case ".":
          this.markItemRead(this.index, null);
          break;
        case "A":
          this.markVisibleRead();
          break;
        case ";":
          if (this.api) {
            this.expandItem(this.selectedItem);
          }
          break;
        case "c":
          this.captureScreenshot(item[0]);
          break;
        case "v":
          this.showPostViewModal(item);
          break;
        case "V":
          this.showReaderModeModal(item);
          break;
        case "t":
          if (this.isFixedSidecar()) {
            this.toggleFixedSidecarPanel(item);
          } else {
            this.toggleInlineSidecar(item);
          }
          break;
        case "+":
          this.openAddToRulesForItem(item);
          break;
        case "-":
          this.openRemoveFromRulesForItem(item);
          break;
        case "s":
          this.savePost(item);
          break;
        case "S":
          this.openShareMenu(item);
          break;
        case "!":
          this.showTimeoutPopup(item);
          break;
        case "f":
          this.showFollowConfirmation(item, true);
          break;
        case "F":
          this.showFollowConfirmation(item, false);
          break;
        default:
          if (!isNaN(parseInt(event.key))) {
            this.switchToTab(parseInt(event.key) - 1);
          } else {
            return false;
          }
      }
      return event.key;
    }
    handleMovementKey(event) {
      let moved = false;
      if (this.isPopupVisible) {
        return;
      }
      this.ignoreMouseMovement = true;
      this.userInitiatedScroll = false;
      const pageKeysEnabled = this.config.get("enablePageKeys");
      ["PageDown", "PageUp", "Home", "End"].includes(event.key);
      if (this.keyState.length == 0) {
        const movementKeys = ["j", "k", "h", "ArrowDown", "ArrowUp", "ArrowLeft", "ArrowRight", "J", "G"];
        if (pageKeysEnabled) {
          movementKeys.push("PageDown", "PageUp", "Home", "End");
        }
        if (movementKeys.includes(event.key)) {
          const sidecarFocused = this.isSidecarNavigationAvailable() && this.replyIndex != null;
          if (["j", "ArrowDown"].indexOf(event.key) != -1) {
            event.preventDefault();
            if (sidecarFocused) {
              this.replyIndex += 1;
            } else if (this.config.get("unrolledPostSelection") && this.unrolledReplies.length > 0 && this.threadIndex !== null) {
              const currentThreadPost = this.getPostForThreadIndex(this.threadIndex);
              if (!this.scrollThreadElementIntoView(currentThreadPost[0], 1)) {
                if (this.threadIndex < this.unrolledReplies.length) {
                  if (event.key == "j") this.markItemRead(this.index, true);
                  this.threadIndex += 1;
                } else {
                  this.jumpToNext(event.key == "j");
                }
              }
            } else {
              const isVisible = this.isElementFullyVisible(this.selectedItem);
              if (!isVisible) {
                if (!this.scrollElementIntoView(this.selectedItem[0], 1)) {
                  moved = this.jumpToNext(event.key == "j");
                }
              } else {
                moved = this.jumpToNext(event.key == "j");
              }
            }
          } else if (["k", "ArrowUp"].indexOf(event.key) != -1) {
            event.preventDefault();
            if (sidecarFocused) {
              this.replyIndex -= 1;
            } else if (this.config.get("unrolledPostSelection") && this.unrolledReplies.length > 0 && this.threadIndex !== null) {
              const currentThreadPost = this.getPostForThreadIndex(this.threadIndex);
              if (!this.scrollThreadElementIntoView(currentThreadPost[0], -1)) {
                if (this.threadIndex > 0) {
                  if (event.key == "k") this.markItemRead(this.index, true);
                  this.threadIndex -= 1;
                } else {
                  this.jumpToPrev(event.key == "k");
                }
              }
            } else {
              if (!this.isElementFullyVisible(this.selectedItem)) {
                if (!this.scrollElementIntoView(this.selectedItem[0], -1)) {
                  moved = this.jumpToPrev(event.key == "k");
                }
              } else {
                moved = this.jumpToPrev(event.key == "k");
              }
            }
          } else if (event.key == "PageDown") {
            event.preventDefault();
            if (sidecarFocused) {
              moved = this.jumpSidecarByPage(1);
            } else {
              moved = this.jumpByPage(1);
            }
          } else if (event.key == "PageUp") {
            event.preventDefault();
            if (sidecarFocused) {
              moved = this.jumpSidecarByPage(-1);
            } else {
              moved = this.jumpByPage(-1);
            }
          } else if (event.key == "Home") {
            event.preventDefault();
            if (sidecarFocused) {
              this.replyIndex = 0;
            } else {
              this.setIndex(0, false, true);
            }
            moved = true;
          } else if (event.key == "End") {
            event.preventDefault();
            if (sidecarFocused) {
              const replies = this.getSidecarReplies();
              this.replyIndex = replies.length - 1;
            } else {
              this.setIndex(this.items.length - 1, false, true);
            }
            moved = true;
          } else if (event.key == "h") {
            const back_button = $("button[aria-label^='Back' i]").filter(":visible");
            if (back_button.length) {
              back_button.click();
            } else {
              history.back(1);
            }
          } else if (event.key == "ArrowLeft") {
            event.preventDefault();
            if (!this.isSidecarNavigationAvailable() || this.replyIndex == null) {
              return;
            }
            this.toggleFocus();
          } else if (event.key == "ArrowRight") {
            event.preventDefault();
            if (!this.isSidecarNavigationAvailable() || this.replyIndex != null) {
              return;
            }
            this.toggleFocus();
          } else if (event.key == "G") {
            event.preventDefault();
            moved = this.setIndex(this.items.length - 1, false, true);
          } else if (event.key == "J") {
            event.preventDefault();
            this.markThreadReadAndAdvance(1);
          } else if (event.key == "K") {
            event.preventDefault();
            this.markThreadReadAndAdvance(-1);
          }
          moved = true;
        } else if (event.key == "g") {
          this.keyState.push(event.key);
        }
      } else if (this.keyState[0] == "g") {
        if (event.key == "g") {
          if (this.index < this.items.length) {
            this.setIndex(0, false, true);
          }
          moved = true;
        }
        this.keyState = [];
      }
      if (moved) {
        this.lastMousePosition = null;
      }
    }
    openCurrentItem(item) {
      if (this.replyIndex == null) {
        $(item).click();
      } else {
        this.selectedReply.find(".sidecar-post-timestamp a")[0].click();
      }
    }
    openInnerPost(item) {
      $(item).find("div[aria-label^='Post by']").click();
    }
    openFirstLink(item) {
      const link = $(item).find(constants.LINK_SELECTOR);
      if (link.length) {
        link[0].click();
      }
    }
    toggleMedia(item, event) {
      const media = $(item).find("img[src*='feed_thumbnail']");
      if (media.length > 0) {
        this.hideThreadContextForMedia();
        media[0].click();
        this.watchForMediaClose();
        return;
      }
      const video2 = $(item).find("video")[0];
      if (video2) {
        event.preventDefault();
        if (video2.muted) {
          video2.muted = false;
        }
        if (video2.paused) {
          this.hideThreadContextForMedia();
          this.playVideo(video2);
        } else {
          this.pauseVideo(video2);
          this.restoreThreadContextAfterMedia();
        }
      }
    }
    /**
     * Hide the thread context panel when viewing media
     */
    hideThreadContextForMedia() {
      if (this.isFixedSidecar()) {
        const panel = $("#fixed-sidecar-panel");
        if (panel.length) {
          this._sidecarWasVisibleBeforeMedia = panel.hasClass("visible");
          panel[0].style.setProperty("display", "none", "important");
        }
      } else {
        const sidecar = $(this.selectedItem).parent().find(".sidecar-replies");
        if (sidecar.length && sidecar.is(":visible")) {
          this._sidecarWasVisibleBeforeMedia = true;
          sidecar.hide();
        }
      }
    }
    /**
     * Restore the thread context panel after media is closed
     */
    restoreThreadContextAfterMedia() {
      if (this._sidecarWasVisibleBeforeMedia) {
        this._sidecarWasVisibleBeforeMedia = false;
        if (this.isFixedSidecar()) {
          const panel = $("#fixed-sidecar-panel")[0];
          if (panel) {
            panel.style.removeProperty("display");
          }
        } else {
          const sidecar = $(this.selectedItem).parent().find(".sidecar-replies");
          sidecar.show();
        }
      }
    }
    /**
     * Watch for Bluesky's media lightbox to close
     */
    watchForMediaClose() {
      if (this._mediaCloseHandler) {
        document.removeEventListener("click", this._mediaCloseHandler, true);
        document.removeEventListener("keydown", this._mediaCloseHandler, true);
      }
      setTimeout(() => {
        this._mediaCloseHandler = (e) => {
          if (e.key === "Escape" || e.type === "click") {
            setTimeout(() => {
              this.restoreThreadContextAfterMedia();
              document.removeEventListener("click", this._mediaCloseHandler, true);
              document.removeEventListener("keydown", this._mediaCloseHandler, true);
              this._mediaCloseHandler = null;
            }, 100);
          }
        };
        document.addEventListener("click", this._mediaCloseHandler, true);
        document.addEventListener("keydown", this._mediaCloseHandler, true);
      }, 300);
    }
    openReplyDialog(item) {
      const button = $(item).find("button[aria-label^='Reply']");
      if (button.length) {
        const wasVisible = this.isElementInViewport(button[0]);
        button.focus();
        button.click();
        if (!wasVisible) {
          this.showActionFeedback(button[0]);
        }
      }
    }
    handleLikeAction(item) {
      if (this.config.get("showReplySidecar") && this.replyIndex != null) {
        this.likePost(this.selectedReply);
      } else if (this.threadIndex) {
        this.likePost(this.selectedPost);
      } else {
        const button = $(item).find("button[data-testid='likeBtn']");
        if (button.length) {
          const wasVisible = this.isElementInViewport(button[0]);
          button.click();
          if (!wasVisible) {
            setTimeout(() => this.showActionFeedback(button[0]), 50);
          }
        }
      }
    }
    openRepostMenu(item) {
      const button = $(item).find("button[aria-label^='Repost']");
      if (button.length) {
        const wasVisible = this.isElementInViewport(button[0]);
        button.click();
        if (!wasVisible) {
          this.waitForRepostMenu();
        }
      }
    }
    /**
     * Wait for repost menu to appear and show feedback
     */
    waitForRepostMenu() {
      let attempts = 0;
      const maxAttempts = 20;
      const checkInterval = setInterval(() => {
        attempts++;
        const repostItem = $("div[aria-label^='Repost'][role='menuitem']");
        const quoteItem = $("div[aria-label^='Quote'][role='menuitem']");
        if (repostItem.length || quoteItem.length) {
          clearInterval(checkInterval);
          this.showRepostMenuFeedback(repostItem, quoteItem);
        } else if (attempts >= maxAttempts) {
          clearInterval(checkInterval);
        }
      }, 50);
    }
    /**
     * Show repost menu options at the bottom of the screen
     */
    showRepostMenuFeedback(repostItem, quoteItem) {
      $(".bsky-nav-menu-feedback").remove();
      const $feedback = $('<div class="bsky-nav-menu-feedback"></div>');
      const $menu = $('<div class="bsky-nav-menu-feedback-menu"></div>');
      const items = [];
      let selectedIndex = 0;
      let cleanedUp = false;
      let menuObserver = null;
      const originalMenuItem = repostItem.length ? repostItem[0] : quoteItem[0];
      const cleanup = () => {
        if (cleanedUp) return;
        cleanedUp = true;
        if (menuObserver) menuObserver.disconnect();
        $(document).off("click.repostMenuFeedback");
        $(document).off("keydown.repostMenuFeedback");
        $feedback.removeClass("visible");
        setTimeout(() => $feedback.remove(), 200);
      };
      if (originalMenuItem) {
        menuObserver = new MutationObserver(() => {
          if (!document.contains(originalMenuItem)) {
            cleanup();
          }
        });
        menuObserver.observe(document.body, { childList: true, subtree: true });
      }
      const closeHandler = (e) => {
        if (!$(e.target).closest(".bsky-nav-menu-feedback-menu").length) {
          cleanup();
        }
      };
      const keyHandler = (e) => {
        switch (e.key) {
          case "ArrowDown":
          case "j":
            e.preventDefault();
            e.stopPropagation();
            selectedIndex = (selectedIndex + 1) % items.length;
            updateSelection();
            break;
          case "ArrowUp":
          case "k":
            e.preventDefault();
            e.stopPropagation();
            selectedIndex = (selectedIndex - 1 + items.length) % items.length;
            updateSelection();
            break;
          case "Enter":
            e.preventDefault();
            e.stopPropagation();
            items[selectedIndex].original.click();
            cleanup();
            break;
          case "Escape":
            e.preventDefault();
            e.stopPropagation();
            cleanup();
            break;
        }
      };
      const updateSelection = () => {
        items.forEach((item, i) => {
          item.$el.toggleClass("bsky-nav-menu-item-selected", i === selectedIndex);
        });
      };
      if (repostItem.length) {
        const $repost = repostItem.clone();
        $repost.attr("data-index", items.length);
        $repost.on("click", () => {
          repostItem.click();
        });
        $menu.append($repost);
        items.push({ $el: $repost, original: repostItem });
      }
      if (quoteItem.length) {
        const $quote = quoteItem.clone();
        $quote.attr("data-index", items.length);
        $quote.on("click", () => {
          quoteItem.click();
        });
        $menu.append($quote);
        items.push({ $el: $quote, original: quoteItem });
      }
      $feedback.append($menu);
      $("body").append($feedback);
      updateSelection();
      setTimeout(() => {
        $(document).on("click.repostMenuFeedback", closeHandler);
        $(document).on("keydown.repostMenuFeedback", keyHandler);
      }, 10);
      requestAnimationFrame(() => {
        $feedback.addClass("visible");
      });
    }
    repostImmediately(item) {
      const button = $(item).find("button[aria-label^='Repost']");
      if (button.length) {
        const wasVisible = this.isElementInViewport(button[0]);
        button.click();
        setTimeout(() => {
          $("div[aria-label^='Repost'][role='menuitem']").click();
          if (!wasVisible) {
            setTimeout(() => this.showActionFeedback(button[0]), 50);
          }
        }, constants.REPOST_MENU_DELAY);
      }
    }
    savePost(item) {
      const button = $(item).find("button[data-testid='postBookmarkBtn']");
      if (button.length) {
        const wasVisible = this.isElementInViewport(button[0]);
        button.click();
        if (!wasVisible) {
          setTimeout(() => this.showActionFeedback(button[0]), 50);
        }
      }
    }
    openShareMenu(item) {
      const button = $(item).find("button[data-testid='postShareBtn']");
      if (button.length) {
        const wasVisible = this.isElementInViewport(button[0]);
        button.click();
        if (!wasVisible) {
          this.showActionFeedback(button[0]);
        }
      }
    }
    /**
     * Check if an element is visible in the viewport
     * @param {HTMLElement} element - The element to check
     * @returns {boolean} True if element is at least partially visible
     */
    isElementInViewport(element) {
      if (!element) return false;
      const rect = element.getBoundingClientRect();
      const statusBar = document.getElementById("statusBar");
      const statusBarHeight = statusBar ? statusBar.getBoundingClientRect().height : 0;
      const effectiveViewportHeight = window.innerHeight - statusBarHeight;
      return rect.top < effectiveViewportHeight && rect.bottom > 0 && rect.left < window.innerWidth && rect.right > 0;
    }
    /**
     * Show a brief visual feedback indicator using the actual button icon
     * @param {HTMLElement} button - The button element containing the icon
     */
    showActionFeedback(button) {
      $(".bsky-nav-action-feedback").remove();
      const svg = $(button).find("svg").first();
      if (!svg.length) return;
      const svgClone = svg.clone();
      svgClone.attr("width", "32").attr("height", "32");
      const $feedback = $('<div class="bsky-nav-action-feedback"></div>');
      $feedback.append(svgClone);
      $("body").append($feedback);
      requestAnimationFrame(() => {
        $feedback.addClass("visible");
      });
      setTimeout(() => {
        $feedback.removeClass("visible");
        setTimeout(() => $feedback.remove(), 300);
      }, 800);
    }
    switchToTab(tabIndex) {
      const tabs = $("div[role='tablist'] > div > div > div").filter(":visible");
      if (tabs[tabIndex]) {
        tabs[tabIndex].click();
      }
    }
    toggleFocus() {
      if (this.replyIndex == null) {
        this.replyIndex = 0;
      } else {
        this.replyIndex = null;
      }
    }
    jumpToPrev(mark) {
      this.setIndex(this.index - 1, mark, true);
      return true;
    }
    jumpToNext(mark) {
      if (this.index < this.items.length) {
        if (this.index === this.items.length - 1) {
          if (mark) {
            this.markItemRead(this.index, true);
          }
        } else {
          this.setIndex(this.index + 1, mark, true);
        }
      } else {
        const next = $(this.selectedItem).parent().parent().parent().next();
        if (next && $.trim(next.text()) == "Continue thread...") {
          this.loadPageObserver = waitForElement$2(
            this.THREAD_PAGE_SELECTOR,
            this.handleNewThreadPage
          );
          $(next).find("div").click();
        }
      }
      return true;
    }
    jumpByPage(direction) {
      const viewportHeight = window.innerHeight;
      const currentItem = this.selectedItem;
      if (!currentItem) return false;
      const itemHeight = $(currentItem).outerHeight(true) || 200;
      const itemsPerPage = Math.max(1, Math.floor(viewportHeight / itemHeight) - 1);
      const newIndex = Math.max(0, Math.min(this.items.length - 1, this.index + direction * itemsPerPage));
      if (newIndex !== this.index) {
        this.setIndex(newIndex, false, true);
        return true;
      }
      return false;
    }
    jumpSidecarByPage(direction) {
      const replies = this.getSidecarReplies();
      if (!replies.length) return false;
      const sidecar = this.getSidecarContainer();
      const sidecarHeight = sidecar.height() || window.innerHeight;
      const currentReply = replies.eq(this.replyIndex);
      const replyHeight = currentReply.outerHeight(true) || 100;
      const repliesPerPage = Math.max(1, Math.floor(sidecarHeight / replyHeight) - 1);
      const newIndex = Math.max(0, Math.min(replies.length - 1, this.replyIndex + direction * repliesPerPage));
      if (newIndex !== this.replyIndex) {
        this.replyIndex = newIndex;
        return true;
      }
      return false;
    }
    jumpToNextUnseenItem(mark) {
      let i;
      for (i = this.index + 1; i < this.items.length - 1; i++) {
        const postId = this.postIdForItem(this.items[i]);
        if (!this.state.seen[postId]) {
          break;
        }
      }
      this.setIndex(i, mark);
      this.updateItems();
    }
    /**
     * Mark the entire current thread (main post + unrolled replies) as read
     * and advance to the next or previous thread
     * @param {number} direction - 1 for next, -1 for previous
     */
    markThreadReadAndAdvance(direction) {
      const startIndex = this.index;
      const mainItem = this.items[startIndex];
      const mainPostId = this.postIdForItem(mainItem);
      if (mainPostId) {
        this.markPostRead(mainPostId, true);
        this.applyItemStyle(mainItem, false);
      }
      if (this.unrolledReplies.length) {
        this.unrolledReplies.each((i, reply) => {
          const replyPostId = this.postIdForItem(reply);
          if (replyPostId) {
            this.markPostRead(replyPostId, true);
          }
          $(reply).addClass("item-read").removeClass("item-unread");
        });
      }
      this.threadIndex = null;
      const targetIndex = startIndex + direction;
      if (targetIndex >= 0 && targetIndex < this.items.length) {
        this.setIndex(targetIndex, false, false);
        const el = this.selectedItem[0];
        if (el) {
          const rect = el.getBoundingClientRect();
          const toolbarHeight = this.getToolbarHeight();
          const scrollAmount = rect.top - toolbarHeight;
          this.ignoreMouseMovement = true;
          window.scrollBy({
            top: scrollAmount,
            behavior: this.config.get("enableSmoothScrolling") ? "smooth" : "instant"
          });
          setTimeout(() => {
            this.ignoreMouseMovement = false;
          }, 500);
        }
      }
      this.updateInfoIndicator();
    }
    jumpToPost(postId, skipScroll = false) {
      for (const [i, item] of $(this.items).get().entries()) {
        const other = this.postIdForItem(item);
        if (postId == other) {
          this.setIndex(i);
          if (!skipScroll) {
            this.updateItems();
          }
          return true;
        }
      }
      return false;
    }
    // ===========================================================================
    // Item Actions (like, screenshot, mark read, video)
    // ===========================================================================
    async likePost(post2) {
      try {
        const postUrl = this.urlForItem(post2);
        if (!postUrl) {
          console.error("Failed to get post URL for like action", post2);
          return;
        }
        const uri = await this.api.getAtprotoUri(postUrl);
        const thread = await this.api.getThread(uri);
        const { likeCount, viewer, cid: cid2 } = thread.post;
        const isLiked = !!viewer.like;
        if (isLiked) {
          await this.api.agent.deleteLike(viewer.like);
        } else {
          await this.api.agent.like(uri, cid2);
        }
        this.updateLikeUI(post2, likeCount, isLiked);
      } catch (error) {
        console.error("Failed to toggle like:", error);
      }
    }
    updateLikeUI(post2, currentLikeCount, wasLiked) {
      const newCount = wasLiked ? currentLikeCount - 1 : currentLikeCount + 1;
      const svgIndex = wasLiked ? 0 : 1;
      const likeButton = $(post2).find(".sidecar-like-button");
      likeButton.html(constants.SIDECAR_SVG_LIKE[svgIndex]);
      $(post2).find(".sidecar-count-label-likes").html(Math.max(0, newCount));
      const animDuration = getAnimationDuration(300, this.config);
      if (animDuration > 0) {
        likeButton.addClass(wasLiked ? "like-animation-unlike" : "like-animation-like");
        setTimeout(() => {
          likeButton.removeClass("like-animation-like like-animation-unlike");
        }, animDuration);
      }
      const action = wasLiked ? "unliked" : "liked";
      announceToScreenReader$1(`Post ${action}. ${newCount} ${newCount === 1 ? "like" : "likes"}.`);
    }
    async captureScreenshot(item) {
      try {
        const fetchImageAsDataUrl = (url) => {
          return new Promise((resolve) => {
            GM_xmlhttpRequest({
              method: "GET",
              url,
              responseType: "blob",
              onload: (response) => {
                if (response.status !== 200 || !response.response) {
                  console.error("[bsky-nav] Bad response for:", url);
                  resolve({ url, dataUrl: null });
                  return;
                }
                const reader = new FileReader();
                reader.onloadend = () => {
                  resolve({ url, dataUrl: reader.result });
                };
                reader.onerror = (err) => {
                  console.error("[bsky-nav] FileReader error for:", url, err);
                  resolve({ url, dataUrl: null });
                };
                reader.readAsDataURL(response.response);
              },
              onerror: (err) => {
                console.error("[bsky-nav] GM_xmlhttpRequest error for:", url, err);
                resolve({ url, dataUrl: null });
              }
            });
          });
        };
        const imageUrls = /* @__PURE__ */ new Map();
        const urlsToFetch = /* @__PURE__ */ new Set();
        const images2 = item.querySelectorAll("img");
        images2.forEach((img) => {
          if (img.src && img.src.startsWith("http")) {
            urlsToFetch.add(img.src);
          }
          if (img.srcset) {
            const srcsetUrls = img.srcset.split(",").map((s) => s.trim().split(" ")[0]);
            srcsetUrls.forEach((url) => {
              if (url.startsWith("http")) urlsToFetch.add(url);
            });
          }
        });
        const bgDivs = item.querySelectorAll('[style*="background-image"]');
        bgDivs.forEach((div) => {
          const style2 = div.getAttribute("style") || "";
          const match2 = style2.match(/background-image:\s*url\(["']?([^"')]+)["']?\)/);
          if (match2 && match2[1] && match2[1].startsWith("http")) {
            urlsToFetch.add(match2[1]);
          }
        });
        const allElements = item.querySelectorAll("*");
        allElements.forEach((el) => {
          const computed = window.getComputedStyle(el);
          const bgImage = computed.backgroundImage;
          if (bgImage && bgImage !== "none") {
            const match2 = bgImage.match(/url\(["']?([^"')]+)["']?\)/);
            if (match2 && match2[1] && match2[1].startsWith("http")) {
              urlsToFetch.add(match2[1]);
            }
          }
        });
        const fetchPromises = Array.from(urlsToFetch).map((url) => fetchImageAsDataUrl(url));
        const results = await Promise.race([
          Promise.all(fetchPromises),
          new Promise((resolve) => setTimeout(() => resolve([]), 5e3))
        ]);
        results.forEach(({ url, dataUrl }) => {
          if (dataUrl) {
            imageUrls.set(url, dataUrl);
          }
        });
        const findDataUrl = (url) => {
          if (!url) return null;
          if (imageUrls.has(url)) return imageUrls.get(url);
          const baseUrl = url.split("?")[0];
          for (const [key, val] of imageUrls) {
            if (key.split("?")[0] === baseUrl) return val;
            if (key.includes(baseUrl) || baseUrl.includes(key.split("?")[0])) return val;
          }
          return null;
        };
        const originalValues = [];
        const itemImages = item.querySelectorAll("img");
        itemImages.forEach((img) => {
          const dataUrl = findDataUrl(img.src);
          if (dataUrl) {
            originalValues.push({ el: img, attr: "src", value: img.src });
            img.src = dataUrl;
          }
        });
        const bgElements = item.querySelectorAll("*");
        bgElements.forEach((el) => {
          const inlineStyle = el.getAttribute("style") || "";
          let match2 = inlineStyle.match(/background-image:\s*url\(["']?([^"')]+)["']?\)/);
          if (match2 && match2[1]) {
            const dataUrl = findDataUrl(match2[1]);
            if (dataUrl) {
              originalValues.push({ el, attr: "style-bg", value: el.style.backgroundImage });
              el.style.backgroundImage = `url("${dataUrl}")`;
            }
          }
        });
        await new Promise((resolve) => setTimeout(resolve, 100));
        const actionButtons = item.querySelectorAll('[data-testid="repostBtn"], [data-testid="likeBtn"], [data-testid="replyBtn"], [data-testid="postDropdownBtn"]');
        const hiddenButtons = [];
        actionButtons.forEach((btn) => {
          const container = btn.closest('div[style*="flex"]') || btn.parentElement;
          if (container && container.style.display !== "none") {
            hiddenButtons.push({ el: container, display: container.style.display });
            container.style.display = "none";
          }
        });
        const blob2 = await toBlob(item, {
          backgroundColor: "#ffffff",
          pixelRatio: 2,
          skipFonts: true,
          // Skip font processing to avoid issues
          filter: (node) => {
            if (node.tagName === "SCRIPT") return false;
            if (node.tagName === "LINK" && node.rel === "stylesheet") return false;
            return true;
          }
        });
        hiddenButtons.forEach(({ el, display }) => {
          el.style.display = display;
        });
        originalValues.forEach(({ el, attr, value }) => {
          if (attr === "src") {
            el.src = value;
          } else if (attr === "style-bg") {
            el.style.backgroundImage = value;
          }
        });
        await navigator.clipboard.write([
          new ClipboardItem({
            "image/png": blob2
          })
        ]);
        const notification2 = $("<div>").css({
          position: "fixed",
          top: "20px",
          right: "20px",
          padding: "10px 20px",
          backgroundColor: "#4CAF50",
          color: "white",
          borderRadius: "4px",
          zIndex: 1e4,
          fontSize: "14px"
        }).text("Screenshot copied to clipboard!");
        $("body").append(notification2);
        setTimeout(() => notification2.fadeOut(500, () => notification2.remove()), 2e3);
      } catch (err) {
        console.error("Failed to capture screenshot:", err);
      }
    }
    async showPostViewModal(item) {
      const postElement = item[0];
      if (!postElement) {
        console.warn("showPostViewModal: no post element found");
        return;
      }
      const hasUnrolledThread = $(postElement).find(".unrolled-reply").length > 0;
      if (!this.postViewModal) {
        this.postViewModal = new PostViewModal(this.config, () => {
          this.isPopupVisible = false;
        });
      }
      this.isPopupVisible = true;
      this.postViewModal.show(postElement, null, hasUnrolledThread);
      try {
        const thread = await this.getThreadForItem(postElement);
        if (thread) {
          const sidecarHtml = await this.getSidecarContent(postElement, thread);
          const wrappedHtml = `<div class="post-view-modal-sidecar-content">${sidecarHtml}</div>`;
          this.postViewModal.updateSidecar(wrappedHtml);
        } else {
          this.postViewModal.updateSidecar('<div class="post-view-modal-error">Could not load replies</div>');
        }
      } catch (err) {
        console.error("Failed to load thread for post view modal:", err);
        this.postViewModal.updateSidecar('<div class="post-view-modal-error">Error loading replies</div>');
      }
    }
    async showReaderModeModal(item) {
      const postElement = item[0];
      if (!postElement) {
        console.warn("showReaderModeModal: no post element found");
        return;
      }
      if (!this.postViewModal) {
        this.postViewModal = new PostViewModal(this.config, () => {
          this.isPopupVisible = false;
        });
      }
      this.isPopupVisible = true;
      this.postViewModal.showReaderMode(null, "Reader View");
      try {
        const thread = await this.getThreadForItem(postElement);
        if (thread) {
          const unrolledPosts = await this.api.unrollThread(thread);
          const authorName = thread.post.author.displayName || thread.post.author.handle;
          const readerHtml = this.buildReaderContent(unrolledPosts, authorName);
          this.postViewModal.updateReaderContent(readerHtml);
        } else {
          this.postViewModal.updateReaderContent('<div class="post-view-modal-error">Could not load thread</div>');
        }
      } catch (err) {
        console.error("Failed to load thread for reader mode:", err);
        this.postViewModal.updateReaderContent('<div class="post-view-modal-error">Error loading thread</div>');
      }
    }
    buildReaderContent(posts, authorName) {
      if (!posts || posts.length === 0) {
        return '<div class="post-view-modal-error">No posts found</div>';
      }
      const bodyTemplate = Handlebars.compile($("#sidecar-body-template").html());
      Handlebars.registerPartial("bodyTemplate", bodyTemplate);
      let html = `<div class="reader-mode-thread">`;
      const totalPosts = posts.length;
      html += `<div class="reader-mode-author">Thread by ${this.escapeHtml(authorName)} (${totalPosts} post${totalPosts > 1 ? "s" : ""})</div>`;
      posts.forEach((post2, index) => {
        const postNum = index + 1;
        const formattedPost = formatPost(post2);
        html += `
        <article class="reader-mode-post" data-post-index="${index}">
          <div class="reader-mode-post-number">${postNum}<span class="reader-mode-post-total">/${totalPosts}</span></div>
          <div class="reader-mode-post-content">
            ${bodyTemplate(formattedPost)}
          </div>
        </article>
      `;
      });
      html += `</div>`;
      return html;
    }
    escapeHtml(text) {
      const div = document.createElement("div");
      div.textContent = text;
      return div.innerHTML;
    }
    markItemRead(index, isRead) {
      if (this.name == "post" && !this.config.get("savePostState")) {
        return;
      }
      const mainItem = $(this.items)[index];
      const item = this.threadIndex != null ? this.getPostForThreadIndex(this.threadIndex) : mainItem;
      const postId = this.postIdForItem(item) || this.postIdForItem(mainItem);
      if (!postId) {
        console.warn("markItemRead: no postId found");
        return;
      }
      const markedRead = this.markPostRead(postId, isRead);
      if (this.unrolledReplies.length) {
        $(item).addClass(markedRead ? "item-read" : "item-unread");
        $(item).removeClass(markedRead ? "item-unread" : "item-read");
      } else {
        this.applyItemStyle(mainItem, index == this.index);
      }
      if (this.unrolledReplies.length && this.unrolledReplies.get().every((r) => $(r).hasClass("item-read"))) {
        this.markPostRead(this.postIdForItem(mainItem), isRead);
        this.applyItemStyle(this.items[index], index == this.index);
      }
      if (!markedRead && !this.state.filter) {
        $(mainItem).removeClass("filtered");
        $(mainItem).closest(".thread").removeClass("filtered");
      }
      this.updateInfoIndicator();
    }
    markPostRead(postId, isRead) {
      const currentTime = (/* @__PURE__ */ new Date()).toISOString();
      const seen = { ...this.state.seen };
      if (isRead || isRead == null && !seen[postId]) {
        seen[postId] = currentTime;
      } else {
        delete seen[postId];
      }
      this.state.stateManager.updateState({ seen, lastUpdated: currentTime });
      return !!seen[postId];
    }
    markVisibleRead() {
      $(this.items).each((i, _item) => {
        this.markItemRead(i, true);
      });
    }
    playVideo(video2) {
      video2.dataset.allowPlay = "true";
      video2.play();
    }
    pauseVideo(video2) {
      video2.dataset.allowPlay = "true";
      video2.pause();
    }
    // ===========================================================================
    // Observer Setup
    // ===========================================================================
    setupIntersectionObservers() {
      this.intersectionObserver = new IntersectionObserver(this.onIntersection, {
        root: null,
        threshold: Array.from({ length: 101 }, (_, i) => i / 100)
      });
      this.setupIntersectionObserver();
      this.footerIntersectionObserver = new IntersectionObserver(this.onFooterIntersection, {
        root: null,
        threshold: Array.from({ length: 101 }, (_, i) => i / 100)
      });
    }
    setupIntersectionObserver() {
      if (this.intersectionObserver) {
        $(this.items).each((i, item) => {
          this.intersectionObserver.observe($(item)[0]);
        });
      }
    }
    setupItemObserver() {
      const safeSelector = `${this.selector}:not(.thread ${this.selector})`;
      this.observer = waitForElement$2(safeSelector, (element) => {
        this.onItemAdded(element);
        this.onItemRemoved(element);
      });
    }
    setupLoadNewerObserver() {
      this.loadNewerObserver = waitForElement$2(constants.LOAD_NEW_BUTTON_SELECTOR, (button, observer) => {
        if (observer) observer.disconnect();
        const btn = $(button)[0];
        if (this.loadNewerButton === btn) return;
        this.loadNewerButton = btn;
        $("img#loadNewerIndicatorImage").addClass("image-highlight");
        $("img#loadNewerIndicatorImage").removeClass("toolbar-icon-pending");
        if ($("#messageActions").length && $("#loadNewerAction").length === 0) {
          $("#messageActions").append($('<div id="loadNewerAction"><a>Load newer posts</a></div>'));
          $("#loadNewerAction > a").on("click", () => this.loadNewerItems());
        }
        this.showNewPostsPill();
      });
    }
    showNewPostsPill() {
      $("#bsky-navigator-new-posts-pill").remove();
      const pill = $(`
      <button id="bsky-navigator-new-posts-pill" class="new-posts-pill" aria-label="Load new posts">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
          <path d="M12 4l-8 8h6v8h4v-8h6z"/>
        </svg>
        <span>New posts</span>
      </button>
    `);
      pill.on("click", (e) => {
        e.preventDefault();
        this.hideNewPostsPill();
        this.loadNewerItems();
      });
      $("body").append(pill);
      announceToScreenReader$1("New posts available. Press u to load.");
    }
    hideNewPostsPill() {
      const pill = $("#bsky-navigator-new-posts-pill");
      pill.addClass("new-posts-pill-hiding");
      setTimeout(() => pill.remove(), 200);
    }
    setupFloatingButtons() {
      this.floatingButtonsObserver = waitForElement$2(
        this.state.mobileView ? constants.HOME_SCREEN_SELECTOR : constants.LEFT_SIDEBAR_SELECTOR,
        (container) => {
          if (!this.prevButton) {
            this.prevButton = $(
              `<div id="prevButton" title="previous post" class="css-175oi2r r-1loqt21 r-1otgn73 r-1oszu61 r-16y2uox r-1777fci r-gu64tb"><img id="prevButtonImage" class="indicator-image" src="${this.FLOATING_BUTTON_IMAGES.prev[0]}"/></div>`
            );
            $(container).append(this.prevButton);
            if (this.state.mobileView) {
              $("#prevButton").addClass("mobile");
            }
            $("#prevButton").on("click", (event) => {
              event.preventDefault();
              this.jumpToPrev(true);
            });
          }
          if (!this.nextButton) {
            this.nextButton = $(
              `<div id="nextButton" title="next post" class="css-175oi2r r-1loqt21 r-1otgn73 r-1oszu61 r-16y2uox r-1777fci r-gu64tb"><img id="nextButtonImage" class="indicator-image" src="${this.FLOATING_BUTTON_IMAGES.next[0]}"/></div>`
            );
            $(this.prevButton).after(this.nextButton);
            if (this.state.mobileView) {
              $("#nextButton").addClass("mobile");
            }
            $("#nextButton").on("click", (event) => {
              event.preventDefault();
              this.jumpToNext(true);
            });
          }
        }
      );
    }
    enableFooterObserver() {
      if (this.config.get("disableLoadMoreOnScroll")) return;
      if (!this.state.feedSortReverse && this.items.length > 0) {
        this.footerIntersectionObserver.observe(this.items.slice(-1)[0]);
      }
    }
    disableFooterObserver() {
      if (this.footerIntersectionObserver) {
        this.footerIntersectionObserver.disconnect();
      }
    }
    // ===========================================================================
    // Event Handlers
    // ===========================================================================
    onItemAdded(element) {
      this.perfLog("onItemAdded");
      this.applyItemStyle(element);
      clearTimeout(this.loadItemsDebounceTimeout);
      this.loadItemsDebounceTimeout = setTimeout(() => this.loadItems({ preserveSelection: true }), 500);
      if (this.gestureHandler) {
        this.gestureHandler.init(element);
      }
      if (this.bottomSheet) {
        this.bottomSheet.init(element);
      }
    }
    onItemRemoved(_element) {
    }
    /**
     * Handle wheel events - mark scroll as user-initiated
     */
    onWheel(_event) {
      this.userInitiatedScroll = true;
    }
    /**
     * Handle scroll events - track direction and set ignoreMouseMovement
     */
    onScroll(_event) {
      this.perfLog("onScroll");
      if (!this.enableScrollMonitor) {
        return;
      }
      this.ignoreMouseMovement = true;
      if (!this.scrollTick) {
        requestAnimationFrame(() => {
          const currentScroll = $(window).scrollTop();
          if (currentScroll > this.scrollTop) {
            this.scrollDirection = -1;
          } else if (currentScroll < this.scrollTop) {
            this.scrollDirection = 1;
          }
          this.scrollTop = currentScroll;
          this.scrollTick = false;
          if (this.isFixedSidecar() && this.config.get("fixedSidecarVisible") === false && $("#fixed-sidecar-toggle").hasClass("visible")) {
            this.positionFixedSidecarToggle();
          }
          if (this.isFixedSidecar() && $("#fixed-sidecar-panel").hasClass("visible")) {
            this.updateSidecarConnector();
          }
        });
        this.scrollTick = true;
      }
    }
    /**
     * Handle intersection observer events - track visible items and focus best target
     */
    onIntersection(entries) {
      if (!this.enableIntersectionObserver || this.loading || this.loadingNew) {
        return;
      }
      entries.forEach((entry) => {
        if (entry.isIntersecting) {
          this.visibleItems = this.visibleItems.filter((item) => item.target != entry.target);
          this.visibleItems.push(entry);
        } else {
          const oldLength = this.visibleItems.length;
          this.visibleItems = this.visibleItems.filter((item) => item.target != entry.target);
          if (this.visibleItems.length < oldLength) {
            if (this.config.get("markReadOnScroll")) {
              const index = this.getIndexFromItem(entry.target);
              this.markItemRead(index, true);
            }
          }
        }
      });
      if (!this.visibleItems.length) return;
      if (this.intersectionDebounceTimeout) {
        clearTimeout(this.intersectionDebounceTimeout);
      }
      this.intersectionDebounceTimeout = setTimeout(() => {
        this.selectBestVisibleItem();
      }, 50);
    }
    /**
     * Select the best visible item based on scroll direction
     * Scrolling down: select item closest to bottom where bottom is visible
     * Scrolling up: select item closest to top where top is visible
     */
    selectBestVisibleItem() {
      if (!this.config.get("scrollToFocus")) return;
      if (!this.userInitiatedScroll) return;
      const toolbarHeight = this.getToolbarHeight();
      const statusBarHeight = this.getStatusBarHeight();
      const viewportTop = toolbarHeight;
      const viewportBottom = window.innerHeight - statusBarHeight;
      const visibleInViewport = [];
      $(this.items).each((arrayIndex, item) => {
        if ($(item).parents(this.selector).length > 0) return;
        const rect = item.getBoundingClientRect();
        if (rect.height > 0 && rect.bottom > viewportTop && rect.top < viewportBottom) {
          visibleInViewport.push({ item, rect, arrayIndex });
        }
      });
      if (!visibleInViewport.length) return;
      let newIndex = -1;
      if (this.scrollDirection === -1) {
        let bestBottom = -Infinity;
        for (const v of visibleInViewport) {
          if (v.rect.bottom <= viewportBottom && v.rect.bottom > bestBottom) {
            bestBottom = v.rect.bottom;
            newIndex = v.arrayIndex;
          }
        }
        if (newIndex < 0) {
          let closestDist = Infinity;
          for (const v of visibleInViewport) {
            const dist2 = Math.abs(v.rect.bottom - viewportBottom);
            if (dist2 < closestDist) {
              closestDist = dist2;
              newIndex = v.arrayIndex;
            }
          }
        }
      } else {
        let bestTop = Infinity;
        for (const v of visibleInViewport) {
          if (v.rect.top >= viewportTop && v.rect.top < bestTop) {
            bestTop = v.rect.top;
            newIndex = v.arrayIndex;
          }
        }
        if (newIndex < 0) {
          let closestDist = Infinity;
          for (const v of visibleInViewport) {
            const dist2 = Math.abs(v.rect.top - viewportTop);
            if (dist2 < closestDist) {
              closestDist = dist2;
              newIndex = v.arrayIndex;
            }
          }
        }
      }
      if (newIndex >= 0 && newIndex !== this.index) {
        this.setIndex(newIndex, false, false, true);
      }
    }
    /**
     * Get the height of the toolbar at the top (fixed position, not scroll-dependent)
     * Includes any sticky tab bars (profile page, home feed tabs)
     */
    getToolbarHeight() {
      let height = 0;
      const navigatorToolbar = $("#bsky-navigator-toolbar, #bsky-navigator-global-toolbar").filter(":visible").first();
      if (navigatorToolbar.length) {
        height += navigatorToolbar.outerHeight(true) || 0;
      }
      const tabBar = $('div[data-testid="profilePager"], div[data-testid="homeScreenFeedTabs"]').filter(":visible").first();
      if (tabBar.length) {
        height += tabBar.outerHeight(true) || 0;
      }
      const focusRingSpace = 4;
      return Math.max(height, 60) + focusRingSpace;
    }
    /**
     * Get the height of the status bar at the bottom
     */
    getStatusBarHeight() {
      const statusBar = $("#statusBar");
      if (statusBar.length && statusBar.is(":visible")) {
        return statusBar.outerHeight() || 0;
      }
      return 0;
    }
    /**
     * Scroll to make an element more visible, accounting for toolbar and status bar.
     * For tall posts that don't fit, scrolls by a page amount.
     * Returns true if scrolled, false if element is already fully visible and should jump to next/prev.
     */
    scrollElementIntoView(element, direction = 1) {
      if (!element) return false;
      const el = element[0] || element;
      const rect = el.getBoundingClientRect();
      const toolbarHeight = this.getToolbarHeight();
      const statusBarHeight = this.getStatusBarHeight();
      const viewportHeight = window.innerHeight - toolbarHeight - statusBarHeight;
      const viewportBottom = window.innerHeight - statusBarHeight;
      let scrollAmount;
      const postHeight = rect.bottom - rect.top;
      if (postHeight > viewportHeight) {
        if (direction > 0) {
          if (rect.bottom <= viewportBottom) {
            return false;
          }
          const remaining = rect.bottom - viewportBottom;
          scrollAmount = Math.min(viewportHeight * 0.5, remaining + 10);
        } else {
          if (rect.top >= toolbarHeight) {
            return false;
          }
          const remaining = toolbarHeight - rect.top;
          scrollAmount = -Math.min(viewportHeight * 0.5, remaining + 10);
        }
      } else if (rect.top < toolbarHeight) {
        const topOverlap = toolbarHeight - rect.top;
        const bottomOverlap = rect.bottom - viewportBottom;
        if (bottomOverlap > 0 && topOverlap < 20 && bottomOverlap < 20) {
          return false;
        }
        scrollAmount = rect.top - toolbarHeight - 10;
      } else if (rect.bottom > viewportBottom) {
        const bottomOverlap = rect.bottom - viewportBottom;
        const topGap = rect.top - toolbarHeight;
        if (topGap < 20 && bottomOverlap < 20) {
          return false;
        }
        if (direction > 0) {
          scrollAmount = rect.bottom - viewportBottom + 10;
        } else {
          scrollAmount = rect.top - toolbarHeight - 10;
        }
      } else {
        return false;
      }
      this.ignoreMouseMovement = true;
      window.scrollBy({
        top: scrollAmount,
        behavior: this.config.get("enableSmoothScrolling") ? "smooth" : "instant"
      });
      setTimeout(() => {
        this.ignoreMouseMovement = false;
      }, 500);
      return true;
    }
    /**
     * Check if an element is fully visible in the viewport,
     * accounting for toolbar and status bar.
     */
    isElementFullyVisible(element) {
      if (!element || element.length !== void 0 && element.length === 0) return false;
      const el = element[0] || element;
      const rect = el.getBoundingClientRect();
      const toolbarHeight = this.getToolbarHeight();
      const statusBarHeight = this.getStatusBarHeight();
      const viewportTop = toolbarHeight;
      const viewportBottom = window.innerHeight - statusBarHeight;
      const tolerance = 2;
      return rect.top >= viewportTop - tolerance && rect.bottom <= viewportBottom + tolerance;
    }
    onPopupAdd() {
      this.isPopupVisible = true;
    }
    onPopupRemove() {
      this.isPopupVisible = false;
    }
    /**
     * Called when a profile hover card appears in the DOM
     */
    onProfileHoverCardAdd(avatarElement) {
      let card = avatarElement.closest('div[style*="width: 300px"]');
      if (!card) {
        card = avatarElement.closest('div[style*="will-change: transform"]')?.querySelector('div[style*="width: 300px"]');
      }
      if (!card) return;
      this.currentHoverCard = card;
      if (card.querySelector(".bsky-nav-add-to-rules-btn")) return;
      const profileLink = card.querySelector('a[href^="/profile/"]');
      if (!profileLink) return;
      const href = profileLink.getAttribute("href");
      const handle2 = href.replace("/profile/", "").split("/")[0];
      const followButton = card.querySelector('button[aria-label="Following"], button[aria-label="Follow"]');
      if (!followButton) return;
      const addButton = document.createElement("button");
      addButton.className = "bsky-nav-add-to-rules-btn";
      addButton.setAttribute("aria-label", "Add to filter rules");
      addButton.setAttribute("title", "Add to filter rules");
      addButton.innerHTML = `
      <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <path d="M12 5v14M5 12h14"/>
      </svg>
    `;
      followButton.parentNode.insertBefore(addButton, followButton);
      addButton.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();
        const rect = addButton.getBoundingClientRect();
        this.showAddToRulesDropdown(rect, handle2);
      });
    }
    /**
     * Called when a profile hover card is removed from the DOM
     */
    onProfileHoverCardRemove() {
    }
    /**
     * Toggle author hover card visibility for the current context
     * (main item, sidecar reply, or thread post)
     * @param {HTMLElement} item - The selected item
     */
    toggleAuthorHoverCard(item) {
      const existingCard = document.querySelector(".bsky-nav-profile-card");
      if (existingCard) {
        existingCard.remove();
        return;
      }
      let $searchContext;
      let isSidecarContext = false;
      if (this._replyIndex != null && this.selectedReply.length) {
        $searchContext = this.selectedReply;
        isSidecarContext = true;
      } else if (this._threadIndex != null) {
        $searchContext = $(item);
      } else {
        $searchContext = $(item);
      }
      if (!$searchContext || !$searchContext.length) return;
      let allProfileLinks = $searchContext.find('a[href*="/profile/"]');
      if (allProfileLinks.length === 0) {
        $searchContext = $(item);
        allProfileLinks = $searchContext.find('a[href*="/profile/"]');
      }
      let profileLink;
      if (this._replyIndex != null || allProfileLinks.length <= 1) {
        profileLink = allProfileLinks.first()[0];
      } else {
        const avatarLink = allProfileLinks.filter((i, el) => $(el).find("img").length > 0).first()[0];
        if (avatarLink) {
          const authorHref = $(avatarLink).attr("href");
          const authorLinks = allProfileLinks.filter((i, el) => $(el).attr("href") === authorHref);
          const authorNonAvatarLinks = authorLinks.filter((i, el) => $(el).find("img").length === 0);
          if (authorNonAvatarLinks.length > 0) {
            profileLink = authorNonAvatarLinks.first()[0];
          } else {
            profileLink = avatarLink;
          }
        } else {
          profileLink = allProfileLinks.eq(1)[0] || allProfileLinks.first()[0];
        }
      }
      if (!profileLink) return;
      if (isSidecarContext) {
        this.showCustomProfileCard(profileLink);
        return;
      }
      if (this.currentHoverCard) {
        const rect = profileLink.getBoundingClientRect();
        const pageWindow = typeof unsafeWindow !== "undefined" ? unsafeWindow : window;
        const pointerOptions = {
          bubbles: true,
          cancelable: true,
          view: pageWindow,
          clientX: rect.left + rect.width / 2,
          clientY: rect.top + rect.height / 2,
          pointerType: "mouse"
        };
        const mouseOptions = {
          bubbles: true,
          cancelable: true,
          view: pageWindow,
          clientX: rect.left + rect.width / 2,
          clientY: rect.top + rect.height / 2
        };
        profileLink.dispatchEvent(new PointerEvent("pointerout", pointerOptions));
        profileLink.dispatchEvent(new PointerEvent("pointerleave", { ...pointerOptions, bubbles: false }));
        profileLink.dispatchEvent(new MouseEvent("mouseout", mouseOptions));
        profileLink.dispatchEvent(new MouseEvent("mouseleave", { ...mouseOptions, bubbles: false }));
        this.currentHoverCard = null;
        return;
      }
      this.triggerNativeHoverCard(profileLink);
    }
    /**
     * Dismiss any visible hover card (native or custom)
     */
    dismissHoverCard() {
      const customCard = document.querySelector(".bsky-nav-profile-card");
      if (customCard) {
        customCard.remove();
      }
      if (this.currentHoverCard) {
        const escapeEvent = new KeyboardEvent("keydown", {
          key: "Escape",
          code: "Escape",
          keyCode: 27,
          which: 27,
          bubbles: true,
          cancelable: true
        });
        this.currentHoverCard.dispatchEvent(escapeEvent);
        document.dispatchEvent(escapeEvent);
        if (this.selectedItem && this.selectedItem.length) {
          this.selectedItem[0].focus({ preventScroll: true });
        }
        this.currentHoverCard = null;
      }
    }
    /**
     * Trigger native Bluesky hover card by dispatching mouse events
     * @param {HTMLElement} profileLink - The profile link element
     */
    triggerNativeHoverCard(profileLink) {
      const rect = profileLink.getBoundingClientRect();
      const centerX = rect.left + rect.width / 2;
      const centerY = rect.top + rect.height / 2;
      const pageWindow = typeof unsafeWindow !== "undefined" ? unsafeWindow : window;
      const pointerOptions = {
        bubbles: true,
        cancelable: true,
        view: pageWindow,
        clientX: centerX,
        clientY: centerY,
        screenX: centerX,
        screenY: centerY,
        pointerType: "mouse"
      };
      const mouseOptions = {
        bubbles: true,
        cancelable: true,
        view: pageWindow,
        clientX: centerX,
        clientY: centerY,
        screenX: centerX,
        screenY: centerY
      };
      profileLink.dispatchEvent(new PointerEvent("pointerout", pointerOptions));
      profileLink.dispatchEvent(new PointerEvent("pointerleave", { ...pointerOptions, bubbles: false }));
      profileLink.dispatchEvent(new MouseEvent("mouseout", mouseOptions));
      profileLink.dispatchEvent(new MouseEvent("mouseleave", { ...mouseOptions, bubbles: false }));
      setTimeout(() => {
        profileLink.dispatchEvent(new PointerEvent("pointerover", pointerOptions));
        profileLink.dispatchEvent(new PointerEvent("pointerenter", { ...pointerOptions, bubbles: false }));
        profileLink.dispatchEvent(new MouseEvent("mouseover", mouseOptions));
        profileLink.dispatchEvent(new MouseEvent("mouseenter", { ...mouseOptions, bubbles: false }));
        profileLink.dispatchEvent(new PointerEvent("pointermove", pointerOptions));
        profileLink.dispatchEvent(new MouseEvent("mousemove", mouseOptions));
      }, 10);
    }
    /**
     * Show custom profile card for sidecar replies (where native hover card doesn't work)
     * @param {HTMLElement} profileLink - The profile link element
     */
    async showCustomProfileCard(profileLink) {
      const href = profileLink.getAttribute("href") || "";
      const handleMatch = href.match(/\/profile\/([^/?]+)/);
      if (!handleMatch) return;
      const handle2 = handleMatch[1];
      const rect = profileLink.getBoundingClientRect();
      const card = document.createElement("div");
      card.className = "bsky-nav-profile-card";
      const cardWidth = 300;
      let left = rect.left;
      let top = rect.bottom + 8;
      if (left + cardWidth > window.innerWidth) {
        left = window.innerWidth - cardWidth - 16;
      }
      if (top + 250 > window.innerHeight) {
        top = rect.top - 258;
      }
      card.style.left = `${left}px`;
      card.style.top = `${top}px`;
      card.innerHTML = `<div class="bsky-nav-profile-card-loading">Loading...</div>`;
      document.body.appendChild(card);
      const dismissOnClickOutside = (e) => {
        if (!card.contains(e.target)) {
          card.remove();
          document.removeEventListener("click", dismissOnClickOutside);
          document.removeEventListener("keydown", dismissOnEscape);
        }
      };
      const dismissOnEscape = (e) => {
        if (e.key === "Escape") {
          card.remove();
          document.removeEventListener("click", dismissOnClickOutside);
          document.removeEventListener("keydown", dismissOnEscape);
        }
      };
      setTimeout(() => {
        document.addEventListener("click", dismissOnClickOutside);
        document.addEventListener("keydown", dismissOnEscape);
      }, 100);
      try {
        if (!this.api) {
          throw new Error("API not available");
        }
        const profile2 = await this.api.getProfile(handle2);
        const formatCount = (n) => {
          if (n >= 1e6) return (n / 1e6).toFixed(1) + "M";
          if (n >= 1e3) return (n / 1e3).toFixed(1) + "K";
          return n.toString();
        };
        card.innerHTML = `
        <div class="bsky-nav-profile-card-banner" style="${profile2.banner ? `background-image: url(${profile2.banner})` : ""}"></div>
        <div class="bsky-nav-profile-card-content">
          <img class="bsky-nav-profile-card-avatar" src="${profile2.avatar || ""}" alt="${profile2.displayName || handle2}'s avatar">
          <div class="bsky-nav-profile-card-names">
            <div class="bsky-nav-profile-card-displayname">${this.escapeHtml(profile2.displayName || handle2)}</div>
            <div class="bsky-nav-profile-card-handle"><a href="https://bsky.app/profile/${handle2}" target="_blank">@${handle2}</a></div>
          </div>
          ${profile2.description ? `<div class="bsky-nav-profile-card-bio">${this.escapeHtml(profile2.description)}</div>` : ""}
          <div class="bsky-nav-profile-card-stats">
            <div class="bsky-nav-profile-card-stat">
              <span class="bsky-nav-profile-card-stat-value">${formatCount(profile2.followersCount || 0)}</span>
              <span class="bsky-nav-profile-card-stat-label">followers</span>
            </div>
            <div class="bsky-nav-profile-card-stat">
              <span class="bsky-nav-profile-card-stat-value">${formatCount(profile2.followsCount || 0)}</span>
              <span class="bsky-nav-profile-card-stat-label">following</span>
            </div>
            <div class="bsky-nav-profile-card-stat">
              <span class="bsky-nav-profile-card-stat-value">${formatCount(profile2.postsCount || 0)}</span>
              <span class="bsky-nav-profile-card-stat-label">posts</span>
            </div>
          </div>
          <div class="bsky-nav-profile-card-actions">
            <button class="bsky-nav-profile-card-btn bsky-nav-profile-card-btn-primary" data-action="view-profile">View Profile</button>
          </div>
        </div>
      `;
        card.querySelector('[data-action="view-profile"]').addEventListener("click", () => {
          window.location.href = `/profile/${handle2}`;
          card.remove();
        });
      } catch (error) {
        console.error("[bsky-nav] Failed to fetch profile:", error);
        card.innerHTML = `<div class="bsky-nav-profile-card-error">Failed to load profile</div>`;
      }
    }
    /**
     * Open Add to Rules dropdown for the author of the selected item,
     * or for selected text if any text is selected.
     * @param {jQuery} item - The selected item
     */
    openAddToRulesForItem(item) {
      if (!item || !item.length) return;
      const selection = window.getSelection();
      const selectedText = selection ? selection.toString().trim() : "";
      if (selectedText) {
        const range = selection.getRangeAt(0);
        const rect2 = range.getBoundingClientRect();
        this.showAddToRulesDropdown(rect2, { selectedText });
        return;
      }
      const handle2 = this.getAuthorHandle(item);
      if (!handle2) return;
      const authorElement = $(item).find(constants.PROFILE_SELECTOR).find("span").eq(0)[0];
      let rect;
      if (authorElement) {
        rect = authorElement.getBoundingClientRect();
        if (rect.top > 0 && rect.left > 0) {
          this.showAddToRulesDropdown(rect, { handle: handle2 });
          return;
        }
      }
      rect = item[0].getBoundingClientRect();
      this.showAddToRulesDropdown(rect, { handle: handle2 });
    }
    /**
     * Open Remove from Rules dropdown for the author of the selected item.
     * Shows only categories where the author exists.
     * @param {jQuery} item - The selected item
     */
    openRemoveFromRulesForItem(item) {
      if (!item || !item.length) return;
      const handle2 = this.getAuthorHandle(item);
      if (!handle2) return;
      const authorElement = $(item).find(constants.PROFILE_SELECTOR).find("span").eq(0)[0];
      let rect;
      if (authorElement) {
        rect = authorElement.getBoundingClientRect();
        if (rect.top > 0 && rect.left > 0) {
          this.showRemoveFromRulesDropdown(rect, handle2);
          return;
        }
      }
      rect = item[0].getBoundingClientRect();
      this.showRemoveFromRulesDropdown(rect, handle2);
    }
    /**
     * Show dropdown to select which rule category or list to add to
     * @param {DOMRect} buttonRect - The bounding rect of the button (captured before hover card disappears)
     * @param {Object} options - Either { handle } for author rule or { selectedText } for content rule
     */
    showAddToRulesDropdown(buttonRect, options) {
      const isContentRule = typeof options === "object" && options.selectedText;
      const handle2 = typeof options === "string" ? options : options.handle;
      const selectedText = isContentRule ? options.selectedText : null;
      $(".bsky-nav-rules-dropdown").remove();
      this.rulesDropdownActive = true;
      let rulesConfig = this.config.get("rulesConfig") || "";
      if (this.config.modal?.isVisible && this.config.modal?.pendingChanges?.rulesConfig) {
        rulesConfig = this.config.modal.pendingChanges.rulesConfig;
      }
      const categories = this.parseRuleCategories(rulesConfig);
      const activeFilter = this.state.filter || "";
      const activeRuleMatch = activeFilter.match(/\$(\S+)/);
      const activeCategory = activeRuleMatch ? activeRuleMatch[1] : null;
      const headerText = isContentRule ? `Add "${selectedText.length > 30 ? selectedText.substring(0, 30) + "..." : selectedText}" to:` : `Add @${handle2} to:`;
      const listCache = this.state.listCache;
      const hasLists = !isContentRule && listCache && this.api;
      const dropdown = $(`
      <div class="bsky-nav-rules-dropdown">
        <div class="bsky-nav-rules-dropdown-header">${headerText}</div>
        ${hasLists ? `
        <div class="bsky-nav-rules-dropdown-tabs">
          <button class="bsky-nav-rules-tab active" data-tab="rules">Rules</button>
          <button class="bsky-nav-rules-tab" data-tab="lists">Lists</button>
        </div>
        ` : ""}
        <div class="bsky-nav-rules-tab-content bsky-nav-rules-tab-rules active">
          <div class="bsky-nav-rules-dropdown-actions">
            <button class="bsky-nav-rules-action-btn bsky-nav-rules-allow" data-action="allow">
              <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M20 6L9 17l-5-5"/>
              </svg>
              Allow
            </button>
            <button class="bsky-nav-rules-action-btn bsky-nav-rules-deny" data-action="deny">
              <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M18 6L6 18M6 6l12 12"/>
              </svg>
              Deny
            </button>
          </div>
          <div class="bsky-nav-rules-dropdown-categories">
            ${categories.length > 0 ? categories.map((cat, index) => {
        const color = this.getColorForCategory(cat);
        const isDark = window.matchMedia("(prefers-color-scheme: dark)").matches;
        const sc = isDark ? "rgba(255,255,255,0.9)" : "rgba(0,0,0,0.9)";
        const shadow = `1px 1px 0 ${sc}, -1px -1px 0 ${sc}, 1px -1px 0 ${sc}, -1px 1px 0 ${sc}`;
        return `
                  <button class="bsky-nav-rules-category-btn${activeCategory === cat ? " selected" : ""}" data-category="${cat}" style="color: ${color}; text-shadow: ${shadow}">
                    ${cat}
                  </button>
                `;
      }).join("") : '<div class="bsky-nav-rules-no-categories">No rule categories defined.<br>Create one in Settings \u2192 Rules.</div>'}
          </div>
          <div class="bsky-nav-rules-list-option" style="display: none;">
            <label>
              <input type="checkbox" class="bsky-nav-rules-add-to-list-checkbox" checked>
              <span class="bsky-nav-rules-list-option-text">Add to list "<span class="bsky-nav-rules-list-name"></span>"</span>
            </label>
          </div>
          <div class="bsky-nav-rules-dropdown-footer">
            <input type="text" class="bsky-nav-rules-quick-filter" placeholder="${categories.length > 0 ? "Type # or name..." : "Create first category..."}" autocomplete="off" spellcheck="false">
            <button class="bsky-nav-rules-create-btn" title="Create new category">+</button>
            <button class="bsky-nav-rules-cancel-btn">Cancel</button>
          </div>
        </div>
        ${hasLists ? `
        <div class="bsky-nav-rules-tab-content bsky-nav-rules-tab-lists">
          <div class="bsky-nav-rules-dropdown-lists">
            <div class="bsky-nav-rules-lists-loading">Loading lists...</div>
          </div>
          <div class="bsky-nav-rules-dropdown-footer">
            <button class="bsky-nav-rules-cancel-btn">Cancel</button>
          </div>
        </div>
        ` : ""}
      </div>
    `);
      dropdown.css({
        position: "fixed",
        top: buttonRect.top + "px",
        left: buttonRect.left + "px",
        zIndex: 10001
      });
      $("body").append(dropdown);
      let selectedAction = "allow";
      dropdown.find(".bsky-nav-rules-allow").addClass("selected");
      dropdown.find(".bsky-nav-rules-action-btn").on("click", function() {
        dropdown.find(".bsky-nav-rules-action-btn").removeClass("selected");
        $(this).addClass("selected");
        selectedAction = $(this).data("action");
      });
      const closeDropdown = () => {
        dropdown.remove();
        this.rulesDropdownActive = false;
        $(document).off("mousedown.rulesDropdown");
        $(document).off("keydown.rulesDropdown");
      };
      dropdown.find(".bsky-nav-rules-cancel-btn").on("click", () => {
        closeDropdown();
      });
      const addRule = (category, action) => {
        if (isContentRule) {
          this.addContentToRules(selectedText, category, action);
        } else {
          this.addAuthorToRules(handle2, category, action);
        }
      };
      if (hasLists) {
        let listsLoaded = false;
        dropdown.find(".bsky-nav-rules-tab").on("click", async (e) => {
          const tab = $(e.target).data("tab");
          dropdown.find(".bsky-nav-rules-tab").removeClass("active");
          $(e.target).addClass("active");
          dropdown.find(".bsky-nav-rules-tab-content").removeClass("active");
          dropdown.find(`.bsky-nav-rules-tab-${tab}`).addClass("active");
          if (tab === "lists" && !listsLoaded) {
            listsLoaded = true;
            const listsContainer = dropdown.find(".bsky-nav-rules-dropdown-lists");
            listsContainer.html('<div class="bsky-nav-rules-loading">Loading lists...</div>');
            try {
              const listNames = await listCache.getListNames(true);
              if (listNames.length === 0) {
                listsContainer.html('<div class="bsky-nav-rules-no-lists">No lists found.<br>Create one in Bluesky settings.</div>');
              } else {
                listsContainer.empty();
                for (const name of listNames) {
                  const btn = $('<button class="bsky-nav-rules-list-btn"></button>').attr("data-list", name).text(name);
                  listsContainer.append(btn);
                }
                listsContainer.find(".bsky-nav-rules-list-btn").on("click", async (e2) => {
                  const listName = $(e2.target).data("list");
                  const btn = $(e2.target);
                  btn.text("Adding...").prop("disabled", true);
                  try {
                    const did2 = await this.api.resolveHandleToDid(handle2);
                    if (!did2) {
                      throw new Error("Could not resolve handle");
                    }
                    const listUri = await listCache.getListUri(listName);
                    if (!listUri) {
                      throw new Error("Could not find list");
                    }
                    await this.api.addToList(listUri, did2);
                    listCache.invalidate(listName);
                    closeDropdown();
                    if (typeof showToast === "function") {
                      showToast(`Added @${handle2} to ${listName}`);
                    }
                  } catch (error) {
                    console.error("Failed to add to list:", error);
                    btn.text(listName).prop("disabled", false);
                    alert(`Failed to add to list: ${error.message}`);
                  }
                });
              }
            } catch (error) {
              console.error("Failed to load lists:", error);
              dropdown.find(".bsky-nav-rules-dropdown-lists").html(
                '<div class="bsky-nav-rules-no-lists">Failed to load lists.</div>'
              );
            }
          }
        });
      }
      const addToListCheckbox = dropdown.find(".bsky-nav-rules-add-to-list-checkbox");
      const addAuthorToCategory = async (category) => {
        const backingList = !isContentRule && this.state.rules?._backingLists?.[category];
        const shouldAddToList = backingList && this.api && this.state.listCache && addToListCheckbox.is(":checked");
        if (shouldAddToList) {
          await this.addAuthorToList(handle2, backingList);
        } else {
          addRule(category, selectedAction);
        }
        closeDropdown();
      };
      dropdown.find(".bsky-nav-rules-category-btn").on("click", async (e) => {
        const category = $(e.target).data("category");
        await addAuthorToCategory(category);
      });
      const quickFilterInput = dropdown.find(".bsky-nav-rules-quick-filter");
      dropdown.find(".bsky-nav-rules-create-btn").on("click", () => {
        const newCategory = quickFilterInput.val().trim();
        if (newCategory && !/^\d+$/.test(newCategory)) {
          addRule(newCategory, selectedAction);
          closeDropdown();
        }
      });
      dropdown.on("mousedown mouseup click", (e) => {
        e.stopPropagation();
      });
      const closeHandler = (e) => {
        if (!$(e.target).closest(".bsky-nav-rules-dropdown").length && !$(e.target).closest(".bsky-nav-add-to-rules-btn").length) {
          closeDropdown();
        }
      };
      setTimeout(() => {
        $(document).on("mousedown.rulesDropdown", closeHandler);
      }, 100);
      const categoryButtons = dropdown.find(".bsky-nav-rules-category-btn");
      const listOptionEl = dropdown.find(".bsky-nav-rules-list-option");
      const listNameEl = dropdown.find(".bsky-nav-rules-list-name");
      const updateListOption = (category) => {
        if (isContentRule || !category) {
          listOptionEl.hide();
          return;
        }
        const backingList = this.state.rules?._backingLists?.[category];
        if (backingList && this.api && this.state.listCache) {
          listNameEl.text(backingList);
          listOptionEl.show();
        } else {
          listOptionEl.hide();
        }
      };
      const selectCategory = (index) => {
        if (index >= 0 && index < categoryButtons.filter(":visible").length) {
          categoryButtons.removeClass("selected");
          const visibleButtons = categoryButtons.filter(":visible");
          const selected = visibleButtons.eq(index);
          selected.addClass("selected");
          selected[0].scrollIntoView({ block: "nearest", behavior: "smooth" });
          updateListOption(selected.data("category"));
        }
      };
      const filterCategories = (filterText) => {
        const lowerFilter = filterText.toLowerCase();
        let visibleCount = 0;
        let firstVisible = null;
        categoryButtons.each(function() {
          const btn = $(this);
          const category = btn.data("category").toLowerCase();
          const matches = category.includes(lowerFilter);
          btn.toggle(matches);
          if (matches) {
            visibleCount++;
            if (!firstVisible) firstVisible = btn;
          }
        });
        if (firstVisible) {
          categoryButtons.removeClass("selected");
          firstVisible.addClass("selected");
          updateListOption(firstVisible.data("category"));
        } else {
          updateListOption(null);
        }
        const createBtn = dropdown.find(".bsky-nav-rules-create-btn");
        const isNewCategory = filterText && !/^\d+$/.test(filterText) && !categories.some((cat) => cat.toLowerCase() === lowerFilter);
        createBtn.toggle(isNewCategory);
        return { visibleCount, firstVisible };
      };
      const processInput = () => {
        const val = quickFilterInput.val();
        if (/^\d+$/.test(val)) {
          const num = parseInt(val);
          categoryButtons.show();
          if (num > 0 && num <= categoryButtons.length) {
            selectCategory(num - 1);
          }
          dropdown.find(".bsky-nav-rules-create-btn").hide();
        } else if (val) {
          filterCategories(val);
        } else {
          categoryButtons.show();
          dropdown.find(".bsky-nav-rules-create-btn").show();
        }
      };
      quickFilterInput.on("input", () => {
        processInput();
      });
      setTimeout(() => quickFilterInput.focus(), 50);
      if (activeCategory) {
        updateListOption(activeCategory);
      }
      const keyHandler = (e) => {
        if (e.key === "Enter") {
          e.preventDefault();
          e.stopPropagation();
          const val = quickFilterInput.val().trim();
          const selected = dropdown.find(".bsky-nav-rules-category-btn.selected:visible");
          if (selected.length) {
            const category = selected.data("category");
            addAuthorToCategory(category);
          } else if (val && !/^\d+$/.test(val)) {
            addRule(val, selectedAction);
            closeDropdown();
          }
          return;
        }
        if (e.key === "Escape") {
          e.preventDefault();
          e.stopPropagation();
          closeDropdown();
          return;
        }
        if (e.key === "ArrowDown" || e.key === "ArrowUp") {
          e.preventDefault();
          e.stopPropagation();
          const visibleButtons = categoryButtons.filter(":visible");
          if (visibleButtons.length === 0) return;
          const currentSelected = visibleButtons.filter(".selected");
          let currentIndex = currentSelected.length ? visibleButtons.index(currentSelected) : -1;
          if (e.key === "ArrowDown") {
            currentIndex = (currentIndex + 1) % visibleButtons.length;
          } else {
            currentIndex = currentIndex <= 0 ? visibleButtons.length - 1 : currentIndex - 1;
          }
          categoryButtons.removeClass("selected");
          visibleButtons.eq(currentIndex).addClass("selected");
          visibleButtons[currentIndex].scrollIntoView({ block: "nearest", behavior: "smooth" });
          return;
        }
        if (e.key === "Tab") {
          e.preventDefault();
          e.stopPropagation();
          const allowBtn = dropdown.find(".bsky-nav-rules-allow");
          const denyBtn = dropdown.find(".bsky-nav-rules-deny");
          if (allowBtn.hasClass("selected")) {
            allowBtn.removeClass("selected");
            denyBtn.addClass("selected");
            selectedAction = "deny";
          } else {
            denyBtn.removeClass("selected");
            allowBtn.addClass("selected");
            selectedAction = "allow";
          }
          return;
        }
      };
      $(document).on("keydown.rulesDropdown", keyHandler);
    }
    /**
     * Parse rule categories from config text
     */
    parseRuleCategories(configText) {
      const categories = [];
      const lines = configText.split("\n");
      for (const line of lines) {
        const match2 = line.trim().match(/^\[([^\]]+?)(?:\s*(?:->|)\s*.*)?\]$/);
        if (match2) {
          categories.push(match2[1].trim());
        }
      }
      return categories;
    }
    /**
     * Show choice popup for adding to a list-backed category
     * @param {Element} targetEl - Element to position popup near
     * @param {string} handle - Handle to add
     * @param {string} category - Category name
     * @param {string} backingList - Name of the backing list
     * @param {string} action - 'allow' or 'deny'
     * @param {Function} closeParentDropdown - Function to close the parent dropdown
     * @param {Function} addRuleCallback - Function to add rule to local config
     */
    showListBackedAddChoice(targetEl, handle2, category, backingList, action, closeParentDropdown, addRuleCallback) {
      $(".bsky-nav-list-choice-popup").remove();
      const rect = targetEl.getBoundingClientRect();
      const popup = $(`
      <div class="bsky-nav-list-choice-popup">
        <div class="bsky-nav-list-choice-header">
          Add @${handle2} to "${category}"
        </div>
        <div class="bsky-nav-list-choice-info">
          This category is backed by list "${backingList}"
        </div>
        <div class="bsky-nav-list-choice-buttons">
          <button class="bsky-nav-list-choice-btn primary" data-choice="list">
            Add to List
          </button>
          <button class="bsky-nav-list-choice-btn secondary" data-choice="rules">
            Add to Rules Only
          </button>
        </div>
      </div>
    `);
      popup.css({
        position: "fixed",
        top: rect.bottom + 5 + "px",
        left: rect.left + "px",
        zIndex: 10002
      });
      $("body").append(popup);
      popup.find(".bsky-nav-list-choice-btn").on("click", async (e) => {
        const choice = $(e.target).data("choice");
        popup.remove();
        if (choice === "list") {
          await this.addAuthorToList(handle2, backingList);
          closeParentDropdown();
        } else {
          addRuleCallback(category, action);
          closeParentDropdown();
        }
      });
      setTimeout(() => {
        $(document).one("mousedown.listChoice", (e) => {
          if (!$(e.target).closest(".bsky-nav-list-choice-popup").length) {
            popup.remove();
          }
        });
      }, 100);
      $(document).one("keydown.listChoice", (e) => {
        if (e.key === "Escape") {
          popup.remove();
        }
      });
    }
    /**
     * Parse duration string to milliseconds
     * @param {string} duration - Duration like '1h', '6h', '1d', '7d', '30d'
     * @returns {number} Milliseconds
     */
    parseDurationToMs(duration) {
      const match2 = duration.match(/^(\d+)([hd])$/);
      if (!match2) return 24 * 60 * 60 * 1e3;
      const value = parseInt(match2[1]);
      const unit = match2[2];
      if (unit === "h") return value * 60 * 60 * 1e3;
      if (unit === "d") return value * 24 * 60 * 60 * 1e3;
      return 24 * 60 * 60 * 1e3;
    }
    /**
     * Format duration string for display
     * @param {string} duration - Duration like '1h', '1d'
     * @returns {string} Human readable like '1 hour', '1 day'
     */
    formatDurationLabel(duration) {
      const labels2 = {
        "1h": "1 hour",
        "6h": "6 hours",
        "12h": "12 hours",
        "1d": "1 day",
        "3d": "3 days",
        "7d": "7 days",
        "14d": "14 days",
        "30d": "30 days"
      };
      return labels2[duration] || duration;
    }
    /**
     * Show popup to confirm timing out an author
     * @param {jQuery} item - The post element
     */
    showTimeoutPopup(item) {
      $(".bsky-nav-timeout-popup").remove();
      const handle2 = this.getAuthorHandle(item);
      if (!handle2) {
        console.warn("Could not get author handle for timeout");
        return;
      }
      if (this.isTimedOut(handle2)) {
        this.showRemoveTimeoutPopup(item, handle2);
        return;
      }
      const defaultDuration = this.config.get("timeoutDefaultDuration") || "1d";
      const durations = ["1h", "6h", "12h", "1d", "3d", "7d", "14d", "30d"];
      const rect = item[0].getBoundingClientRect();
      const popup = $(`
      <div class="bsky-nav-timeout-popup">
        <div class="bsky-nav-timeout-header">
          Timeout @${handle2}
        </div>
        <div class="bsky-nav-timeout-body">
          <label class="bsky-nav-timeout-label">
            Duration:
            <select class="bsky-nav-timeout-select">
              ${durations.map((d) => `<option value="${d}" ${d === defaultDuration ? "selected" : ""}>${this.formatDurationLabel(d)}</option>`).join("")}
            </select>
          </label>
        </div>
        <div class="bsky-nav-timeout-buttons">
          <button class="bsky-nav-timeout-btn cancel">Cancel</button>
          <button class="bsky-nav-timeout-btn confirm">Timeout</button>
        </div>
      </div>
    `);
      popup.css({
        position: "fixed",
        top: Math.min(rect.top, window.innerHeight - 200) + "px",
        left: Math.min(rect.left + 50, window.innerWidth - 250) + "px",
        zIndex: 10002
      });
      $("body").append(popup);
      popup.find(".bsky-nav-timeout-btn.confirm").on("click", () => {
        const duration = popup.find(".bsky-nav-timeout-select").val();
        this.addTimeout(handle2, duration);
        popup.remove();
        $(document).off(".timeout");
      });
      popup.find(".bsky-nav-timeout-btn.cancel").on("click", () => {
        popup.remove();
        $(document).off(".timeout");
      });
      setTimeout(() => {
        $(document).on("mousedown.timeout", (e) => {
          if (!$(e.target).closest(".bsky-nav-timeout-popup").length) {
            popup.remove();
            $(document).off(".timeout");
          }
        });
      }, 100);
      $(document).on("keydown.timeout", (e) => {
        if (e.key === "Escape") {
          popup.remove();
          $(document).off(".timeout");
        }
      });
    }
    /**
     * Show popup to remove an existing timeout
     * @param {jQuery} item - The post element
     * @param {string} handle - The author handle
     */
    showRemoveTimeoutPopup(item, handle2) {
      const rect = item[0].getBoundingClientRect();
      const expiresAt = this.state.timeouts[handle2];
      const timeRemaining = this.formatTimeRemaining(expiresAt - Date.now());
      const popup = $(`
      <div class="bsky-nav-timeout-popup">
        <div class="bsky-nav-timeout-header">
          @${handle2} is timed out
        </div>
        <div class="bsky-nav-timeout-body">
          <div class="bsky-nav-timeout-info">
            Expires in ${timeRemaining}
          </div>
        </div>
        <div class="bsky-nav-timeout-buttons">
          <button class="bsky-nav-timeout-btn cancel">Keep Timeout</button>
          <button class="bsky-nav-timeout-btn confirm">Remove Timeout</button>
        </div>
      </div>
    `);
      popup.css({
        position: "fixed",
        top: Math.min(rect.top, window.innerHeight - 200) + "px",
        left: Math.min(rect.left + 50, window.innerWidth - 250) + "px",
        zIndex: 10002
      });
      $("body").append(popup);
      popup.find(".bsky-nav-timeout-btn.confirm").on("click", () => {
        this.removeTimeout(handle2);
        popup.remove();
        $(document).off(".timeout");
      });
      popup.find(".bsky-nav-timeout-btn.cancel").on("click", () => {
        popup.remove();
        $(document).off(".timeout");
      });
      setTimeout(() => {
        $(document).on("mousedown.timeout", (e) => {
          if (!$(e.target).closest(".bsky-nav-timeout-popup").length) {
            popup.remove();
            $(document).off(".timeout");
          }
        });
      }, 100);
      $(document).on("keydown.timeout", (e) => {
        if (e.key === "Escape") {
          popup.remove();
          $(document).off(".timeout");
        }
      });
    }
    /**
     * Show confirmation popup for following/unfollowing an author
     * @param {jQuery} item - The post element
     * @param {boolean} isFollow - True for follow, false for unfollow
     */
    showFollowConfirmation(item, isFollow) {
      $(".bsky-nav-follow-popup").remove();
      const handle2 = this.getAuthorHandle(item);
      if (!handle2) {
        console.warn("Could not get author handle for follow action");
        return;
      }
      const action = isFollow ? "Follow" : "Unfollow";
      const rect = item[0].getBoundingClientRect();
      const popup = $(`
      <div class="bsky-nav-follow-popup bsky-nav-timeout-popup">
        <div class="bsky-nav-timeout-header">
          ${action} @${handle2}?
        </div>
        <div class="bsky-nav-timeout-buttons">
          <button class="bsky-nav-timeout-btn cancel">Cancel</button>
          <button class="bsky-nav-timeout-btn confirm">${action}</button>
        </div>
      </div>
    `);
      popup.css({
        position: "fixed",
        top: Math.min(rect.top, window.innerHeight - 150) + "px",
        left: Math.min(rect.left + 50, window.innerWidth - 250) + "px",
        zIndex: 10002
      });
      $("body").append(popup);
      this.isPopupVisible = true;
      const closePopup = () => {
        popup.remove();
        $(document).off(".follow");
        this.isPopupVisible = false;
      };
      popup.find(".bsky-nav-timeout-btn.confirm").on("click", () => {
        closePopup();
        this.executeFollowAction(item, isFollow, handle2);
      });
      popup.find(".bsky-nav-timeout-btn.cancel").on("click", () => {
        closePopup();
      });
      setTimeout(() => {
        $(document).on("mousedown.follow", (e) => {
          if (!$(e.target).closest(".bsky-nav-follow-popup").length) {
            closePopup();
          }
        });
      }, 100);
      $(document).on("keydown.follow", (e) => {
        if (e.key === "Escape") {
          closePopup();
        } else if (e.key === "Enter") {
          e.preventDefault();
          closePopup();
          this.executeFollowAction(item, isFollow, handle2);
        }
      });
    }
    /**
     * Execute the follow/unfollow action by triggering the hover card and clicking the button
     * Falls back to direct API call if hover card doesn't appear
     * @param {jQuery} item - The post element
     * @param {boolean} isFollow - True for follow, false for unfollow
     * @param {string} handle - The author's handle
     */
    async executeFollowAction(item, isFollow, handle2) {
      const $item = $(item);
      const allProfileLinks = $item.find('a[href*="/profile/"]');
      let profileLink = null;
      allProfileLinks.each((i, el) => {
        const href = $(el).attr("href") || "";
        const match2 = href.match(/\/profile\/([^/]+)/);
        if (match2 && match2[1] === handle2) {
          if (!profileLink || $(el).find("img").length === 0) {
            profileLink = el;
          }
        }
      });
      if (!profileLink) {
        await this.executeFollowViaAPI(handle2, isFollow);
        return;
      }
      const rect = profileLink.getBoundingClientRect();
      const pageWindow = typeof unsafeWindow !== "undefined" ? unsafeWindow : window;
      const pointerOptions = {
        bubbles: true,
        cancelable: true,
        view: pageWindow,
        clientX: rect.left + rect.width / 2,
        clientY: rect.top + rect.height / 2,
        pointerType: "mouse"
      };
      const mouseOptions = {
        bubbles: true,
        cancelable: true,
        view: pageWindow,
        clientX: rect.left + rect.width / 2,
        clientY: rect.top + rect.height / 2
      };
      profileLink.dispatchEvent(new PointerEvent("pointerenter", { ...pointerOptions, bubbles: false }));
      profileLink.dispatchEvent(new PointerEvent("pointerover", pointerOptions));
      profileLink.dispatchEvent(new MouseEvent("mouseenter", { ...mouseOptions, bubbles: false }));
      profileLink.dispatchEvent(new MouseEvent("mouseover", mouseOptions));
      const buttonLabel = isFollow ? "Follow" : "Following";
      const maxAttempts = 15;
      let attempts = 0;
      const dismissHoverCard = () => {
        profileLink.dispatchEvent(new PointerEvent("pointerout", pointerOptions));
        profileLink.dispatchEvent(new PointerEvent("pointerleave", { ...pointerOptions, bubbles: false }));
        profileLink.dispatchEvent(new MouseEvent("mouseout", mouseOptions));
        profileLink.dispatchEvent(new MouseEvent("mouseleave", { ...mouseOptions, bubbles: false }));
      };
      const tryClickButton = async () => {
        attempts++;
        const buttonTestId = isFollow ? "followBtn" : "unfollowBtn";
        const hoverCard = document.querySelector('div[data-testid="profileHoverCard"]');
        let followBtn = null;
        if (hoverCard) {
          followBtn = hoverCard.querySelector(`button[data-testid="${buttonTestId}"]`);
          if (!followBtn) {
            followBtn = hoverCard.querySelector(`button[aria-label="${buttonLabel}"]`);
          }
        }
        if (followBtn) {
          followBtn.click();
          setTimeout(dismissHoverCard, 300);
          return;
        }
        const customCardBtn = document.querySelector(
          `.bsky-nav-profile-card button[aria-label="${buttonLabel}"]`
        );
        if (customCardBtn) {
          customCardBtn.click();
          setTimeout(() => {
            const card = document.querySelector(".bsky-nav-profile-card");
            if (card) card.remove();
          }, 300);
          return;
        }
        if (attempts < maxAttempts) {
          setTimeout(tryClickButton, 100);
        } else {
          dismissHoverCard();
          await this.executeFollowViaAPI(handle2, isFollow);
        }
      };
      setTimeout(tryClickButton, 200);
    }
    /**
     * Follow/unfollow a user directly via the Bluesky API
     * @param {string} handle - The user's handle
     * @param {boolean} isFollow - True for follow, false for unfollow
     */
    async executeFollowViaAPI(handle2, isFollow) {
      try {
        const { did: did2, followUri } = await this.api.getFollowStatus(handle2);
        if (isFollow) {
          if (followUri) {
            this.showRuleAddedNotification(`Already following @${handle2}`, "info");
            return;
          }
          await this.api.follow(did2);
          this.showRuleAddedNotification(`Followed @${handle2}`, "success");
        } else {
          if (!followUri) {
            this.showRuleAddedNotification(`Not following @${handle2}`, "info");
            return;
          }
          await this.api.unfollow(followUri);
          this.showRuleAddedNotification(`Unfollowed @${handle2}`, "success");
        }
      } catch (error) {
        console.error(`Failed to ${isFollow ? "follow" : "unfollow"} @${handle2}:`, error);
        this.showRuleAddedNotification(`Failed to ${isFollow ? "follow" : "unfollow"} @${handle2}`, "error");
      }
    }
    /**
     * Format remaining time for display
     * @param {number} ms - Milliseconds remaining
     * @returns {string} Human readable time remaining
     */
    formatTimeRemaining(ms) {
      if (ms <= 0) return "expired";
      const hours = Math.floor(ms / (1e3 * 60 * 60));
      const days = Math.floor(hours / 24);
      const remainingHours = hours % 24;
      if (days > 0) {
        return remainingHours > 0 ? `${days}d ${remainingHours}h` : `${days} day${days > 1 ? "s" : ""}`;
      }
      if (hours > 0) {
        return `${hours} hour${hours > 1 ? "s" : ""}`;
      }
      const minutes = Math.floor(ms / (1e3 * 60));
      return `${minutes} minute${minutes !== 1 ? "s" : ""}`;
    }
    /**
     * Add a timeout for an author
     * @param {string} handle - Author handle
     * @param {string} duration - Duration string like '1h', '1d'
     */
    addTimeout(handle2, duration) {
      const durationMs = this.parseDurationToMs(duration);
      const expiresAt = Date.now() + durationMs;
      const currentTimeouts = this.state.timeouts || {};
      const newTimeouts = { ...currentTimeouts, [handle2]: expiresAt };
      this.state.stateManager.updateState({ timeouts: newTimeouts });
      this.state.stateManager.saveStateImmediately(true, true);
      this.filterItems();
      this.updateFilterEnforcement();
      console.log(`Timed out @${handle2} until ${new Date(expiresAt).toLocaleString()}`);
    }
    /**
     * Remove a timeout for an author
     * @param {string} handle - Author handle
     */
    removeTimeout(handle2) {
      if (!this.state.timeouts) return;
      const { [handle2]: _removed, ...remainingTimeouts } = this.state.timeouts;
      this.state.stateManager.updateState({ timeouts: remainingTimeouts });
      this.state.stateManager.saveStateImmediately(true, true);
      this.filterItems();
      this.updateFilterEnforcement();
      console.log(`Removed timeout for @${handle2}`);
    }
    /**
     * Check if an author is currently timed out
     * @param {string} handle - Author handle
     * @returns {boolean} True if timed out (does not modify state - use cleanupExpiredTimeouts for cleanup)
     */
    isTimedOut(handle2) {
      if (!this.state.timeouts) {
        return false;
      }
      const expiresAt = this.state.timeouts[handle2];
      if (!expiresAt) {
        return false;
      }
      return Date.now() < expiresAt;
    }
    /**
     * Clean up all expired timeouts
     * @returns {number} Number of expired timeouts removed
     */
    cleanupExpiredTimeouts() {
      if (!this.state.timeouts) return 0;
      const now = Date.now();
      const currentTimeouts = this.state.timeouts;
      const activeTimeouts = {};
      let removed = 0;
      for (const [handle2, expiresAt] of Object.entries(currentTimeouts)) {
        if (now < expiresAt) {
          activeTimeouts[handle2] = expiresAt;
        } else {
          removed++;
          console.log(`Timeout expired for @${handle2}`);
        }
      }
      if (removed > 0) {
        this.state.stateManager.updateState({ timeouts: activeTimeouts });
        this.state.stateManager.saveStateImmediately(true, true);
      }
      return removed;
    }
    /**
     * Show dropdown to select which rule category to remove the author from
     * @param {DOMRect} buttonRect - Position rect
     * @param {string} handle - Handle to remove
     */
    showRemoveFromRulesDropdown(buttonRect, handle2) {
      $(".bsky-nav-rules-dropdown").remove();
      this.rulesDropdownActive = true;
      const categoriesWithAuthor = this.findCategoriesWithAuthor(handle2);
      if (categoriesWithAuthor.length === 0) {
        this.showRuleAddedNotification(`@${handle2} not found in any rule set`, "info");
        this.rulesDropdownActive = false;
        return;
      }
      const dropdown = $(`
      <div class="bsky-nav-rules-dropdown">
        <div class="bsky-nav-rules-dropdown-header">Remove @${handle2} from:</div>
        <div class="bsky-nav-rules-dropdown-categories">
          ${categoriesWithAuthor.map(({ category, inList, inRules, listName }) => {
        const color = this.getColorForCategory(category);
        const isDark = window.matchMedia("(prefers-color-scheme: dark)").matches;
        const sc = isDark ? "rgba(255,255,255,0.9)" : "rgba(0,0,0,0.9)";
        const shadow = `1px 1px 0 ${sc}, -1px -1px 0 ${sc}, 1px -1px 0 ${sc}, -1px 1px 0 ${sc}`;
        const location = inList && inRules ? `(list & rules)` : inList ? `(list: ${listName})` : `(rules)`;
        return `
            <button class="bsky-nav-rules-category-btn bsky-nav-rules-remove-btn"
                    data-category="${category}"
                    data-in-list="${inList}"
                    data-in-rules="${inRules}"
                    data-list-name="${listName || ""}"
                    style="color: ${color}; text-shadow: ${shadow}">
              ${category} <span class="bsky-nav-rules-location">${location}</span>
            </button>
          `;
      }).join("")}
        </div>
        <div class="bsky-nav-rules-dropdown-footer">
          <button class="bsky-nav-rules-cancel-btn">Cancel</button>
        </div>
      </div>
    `);
      dropdown.css({
        position: "fixed",
        top: buttonRect.top + "px",
        left: buttonRect.left + "px",
        zIndex: 10001
      });
      $("body").append(dropdown);
      const closeDropdown = () => {
        dropdown.remove();
        this.rulesDropdownActive = false;
        $(document).off("mousedown.rulesDropdown");
        $(document).off("keydown.rulesDropdown");
      };
      dropdown.find(".bsky-nav-rules-remove-btn").on("click", async (e) => {
        const btn = $(e.currentTarget);
        const category = btn.data("category");
        const inList = btn.data("in-list");
        const inRules = btn.data("in-rules");
        const listName = btn.data("list-name");
        btn.text("Removing...").prop("disabled", true);
        await this.removeAuthorFromCategory(handle2, category, inList, inRules, listName);
        closeDropdown();
      });
      dropdown.find(".bsky-nav-rules-cancel-btn").on("click", () => {
        closeDropdown();
      });
      dropdown.on("mousedown mouseup click", (e) => {
        e.stopPropagation();
      });
      setTimeout(() => {
        $(document).on("mousedown.rulesDropdown", (e) => {
          if (!$(e.target).closest(".bsky-nav-rules-dropdown").length) {
            closeDropdown();
          }
        });
      }, 100);
      $(document).on("keydown.rulesDropdown", (e) => {
        if (e.key === "Escape") {
          closeDropdown();
          e.preventDefault();
        } else if (e.key === "Enter") {
          const firstBtn = dropdown.find(".bsky-nav-rules-remove-btn").first();
          if (firstBtn.length) {
            firstBtn.trigger("click");
          }
          e.preventDefault();
        }
      });
    }
    /**
     * Find all categories where the author exists (in list or rules)
     * @param {string} handle - Handle to search for
     * @returns {Array<{ category: string, inList: boolean, inRules: boolean, listName: string|null }>}
     */
    findCategoriesWithAuthor(handle2) {
      const results = [];
      const rules = this.state.rules;
      if (!rules) return results;
      const normalizedHandle = handle2.replace(/^@/, "").toLowerCase();
      for (const category of Object.keys(rules).filter((k) => !k.startsWith("_"))) {
        const categoryRules = rules[category];
        if (!Array.isArray(categoryRules)) continue;
        const backingList = rules._backingLists?.[category];
        let inList = false;
        let inRules = false;
        if (backingList && this.state.listCache) {
          const isInListSync = this.state.listCache.isInListSync(handle2, backingList);
          if (isInListSync === true) {
            inList = true;
          }
        }
        for (const rule of categoryRules) {
          if (rule.type === "from") {
            const ruleHandle = rule.value.replace(/^@/, "").toLowerCase();
            if (ruleHandle === normalizedHandle || ruleHandle === normalizedHandle.split(".")[0]) {
              inRules = true;
              break;
            }
          }
        }
        if (inList || inRules) {
          results.push({ category, inList, inRules, listName: backingList || null });
        }
      }
      return results;
    }
    /**
     * Remove an author from a category (both list and rules if present)
     * @param {string} handle - Handle to remove
     * @param {string} category - Category name
     * @param {boolean} inList - Whether author is in the backing list
     * @param {boolean} inRules - Whether author is in local rules
     * @param {string|null} listName - Name of the backing list
     */
    async removeAuthorFromCategory(handle2, category, inList, inRules, listName) {
      let removedFromList = false;
      let removedFromRules = false;
      if (inList && listName && this.api && this.state.listCache) {
        try {
          await this.removeAuthorFromList(handle2, listName);
          removedFromList = true;
        } catch (error) {
          console.warn("Failed to remove from list:", error);
          this.showRuleAddedNotification(`Failed to remove from list: ${error.message}`, "error");
        }
      }
      if (inRules) {
        this.removeAuthorFromRules(handle2, category);
        removedFromRules = true;
      }
      if (removedFromList && removedFromRules) {
        this.showRuleAddedNotification(`Removed @${handle2} from "${category}" (list & rules)`);
      } else if (removedFromList) {
        this.showRuleAddedNotification(`Removed @${handle2} from list "${listName}"`);
      } else if (removedFromRules) {
        this.showRuleAddedNotification(`Removed @${handle2} from "${category}" rules`);
      }
      this.scheduleHighlightRefresh();
    }
    /**
     * Remove an author from a Bluesky list
     * @param {string} handle - Handle to remove (without @)
     * @param {string} listName - Name of the list
     */
    async removeAuthorFromList(handle2, listName) {
      const listitemUri = await this.state.listCache.getMemberUri(handle2, listName);
      if (!listitemUri) {
        throw new Error(`Member not found in list "${listName}"`);
      }
      await this.api.removeFromList(listitemUri);
      this.state.listCache.removeMemberFromCache(handle2, listName);
    }
    /**
     * Remove an author rule from the config
     * @param {string} handle - Handle to remove
     * @param {string} category - Category name
     */
    removeAuthorFromRules(handle2, category) {
      let rulesConfig = this.config.get("rulesConfig") || "";
      const normalizedHandle = handle2.replace(/^@/, "").toLowerCase();
      const lines = rulesConfig.split("\n");
      const newLines = [];
      let inTargetCategory = false;
      for (const line of lines) {
        const sectionMatch = line.trim().match(/^\[([^\]]+?)(?:\s*(?:->|)\s*.*)?\]$/);
        if (sectionMatch) {
          inTargetCategory = sectionMatch[1].trim().toLowerCase() === category.toLowerCase();
          newLines.push(line);
          continue;
        }
        if (inTargetCategory) {
          const ruleMatch = line.trim().match(/^(allow|deny)\s+from\s+@?(.+)$/i);
          if (ruleMatch) {
            const ruleHandle = ruleMatch[2].toLowerCase();
            if (ruleHandle === normalizedHandle || ruleHandle === normalizedHandle.split(".")[0] || ruleHandle + ".bsky.social" === normalizedHandle) {
              continue;
            }
          }
        }
        newLines.push(line);
      }
      const newConfig = newLines.join("\n");
      this.config.set("rulesConfig", newConfig);
      if (this.state.parseRulesConfig) {
        this.state.rules = this.state.parseRulesConfig(newConfig);
      }
    }
    /**
     * Add an author to a Bluesky list
     * @param {string} handle - Handle to add (without @)
     * @param {string} listName - Name of the list
     */
    async addAuthorToList(handle2, listName) {
      try {
        const listUri = await this.state.listCache.getListUri(listName);
        if (!listUri) {
          this.showRuleAddedNotification(`List "${listName}" not found`, "error");
          return false;
        }
        const cleanHandle = handle2.replace(/^@/, "");
        const did2 = await this.api.resolveHandleToDid(cleanHandle);
        if (!did2) {
          this.showRuleAddedNotification(`Could not resolve @${cleanHandle}`, "error");
          return false;
        }
        const listitemUri = await this.api.addToList(listUri, did2);
        this.state.listCache.addMemberToCache(cleanHandle, listName, listitemUri);
        this.scheduleHighlightRefresh();
        this.showRuleAddedNotification(`Added @${cleanHandle} to list "${listName}"`);
        return true;
      } catch (error) {
        console.warn("Failed to add to list:", error);
        this.showRuleAddedNotification(`Failed to add to list: ${error.message}`, "error");
        return false;
      }
    }
    /**
     * Add an author to the rules config
     */
    addAuthorToRules(handle2, category, action) {
      let rulesConfig = this.config.get("rulesConfig") || "";
      const rule = `${action} from @${handle2}`;
      if (rulesConfig.includes(rule)) {
        this.showRuleAddedNotification(`@${handle2} already has this rule`);
        return;
      }
      const oppositeAction = action === "allow" ? "deny" : "allow";
      const oppositeRule = `${oppositeAction} from @${handle2}`;
      const categoryHeader = `[${category}]`;
      let replacedOpposite = false;
      if (rulesConfig.includes(categoryHeader)) {
        const lines = rulesConfig.split("\n");
        const newLines = [];
        let inCategory = false;
        let ruleAdded = false;
        for (const line of lines) {
          if (inCategory && line.trim() === oppositeRule) {
            newLines.push(rule);
            ruleAdded = true;
            replacedOpposite = true;
            continue;
          }
          newLines.push(line);
          if (line.trim() === categoryHeader) {
            inCategory = true;
          } else if (line.trim().startsWith("[")) {
            if (inCategory && !ruleAdded) {
              newLines.splice(newLines.length - 1, 0, rule);
              ruleAdded = true;
            }
            inCategory = false;
          }
        }
        if (inCategory && !ruleAdded) {
          newLines.push(rule);
        }
        rulesConfig = newLines.join("\n");
        if (replacedOpposite) {
          this.showRuleAddedNotification(`Updated @${handle2} to ${action} in ${category}`);
        }
      } else {
        if (rulesConfig && !rulesConfig.endsWith("\n")) {
          rulesConfig += "\n";
        }
        rulesConfig += `
${categoryHeader}
${rule}`;
      }
      this.config.set("rulesConfig", rulesConfig);
      this.config.save();
      if (this.state.stateManager) {
        this.state.stateManager.saveStateImmediately(true, true);
      }
      if (!replacedOpposite) {
        this.showRuleAddedNotification(handle2, category, action);
      }
      this.onRulesChanged();
    }
    /**
     * Add content text to the rules config with word boundary matching
     * @param {string} text - The text to match
     * @param {string} category - The category to add the rule to
     * @param {string} action - Either 'allow' or 'deny'
     */
    addContentToRules(text, category, action) {
      let rulesConfig = this.config.get("rulesConfig") || "";
      const escapedText = text.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      const ruleValue = `\\b${escapedText}\\b`;
      const rule = `${action} content "${ruleValue}"`;
      if (rulesConfig.includes(rule)) {
        this.showRuleAddedNotification(`"${text}" already has this rule`);
        return;
      }
      const oppositeAction = action === "allow" ? "deny" : "allow";
      const oppositeRule = `${oppositeAction} content "${ruleValue}"`;
      const categoryHeader = `[${category}]`;
      let replacedOpposite = false;
      if (rulesConfig.includes(categoryHeader)) {
        const lines = rulesConfig.split("\n");
        const newLines = [];
        let inCategory = false;
        let ruleAdded = false;
        for (const line of lines) {
          if (inCategory && line.trim() === oppositeRule) {
            newLines.push(rule);
            ruleAdded = true;
            replacedOpposite = true;
            continue;
          }
          newLines.push(line);
          if (line.trim() === categoryHeader) {
            inCategory = true;
          } else if (line.trim().startsWith("[")) {
            if (inCategory && !ruleAdded) {
              newLines.splice(newLines.length - 1, 0, rule);
              ruleAdded = true;
            }
            inCategory = false;
          }
        }
        if (inCategory && !ruleAdded) {
          newLines.push(rule);
        }
        rulesConfig = newLines.join("\n");
        if (replacedOpposite) {
          this.showRuleAddedNotification(`Updated "${text}" to ${action} in ${category}`);
        }
      } else {
        if (rulesConfig && !rulesConfig.endsWith("\n")) {
          rulesConfig += "\n";
        }
        rulesConfig += `
${categoryHeader}
${rule}`;
      }
      this.config.set("rulesConfig", rulesConfig);
      this.config.save();
      if (this.state.stateManager) {
        this.state.stateManager.saveStateImmediately(true, true);
      }
      if (!replacedOpposite) {
        this.showRuleAddedNotification(`"${text}"`, category, action);
      }
      this.onRulesChanged();
    }
    /**
     * Parse rules config using the shared function from state
     */
    parseRulesForState(configText) {
      if (this.state.parseRulesConfig) {
        return this.state.parseRulesConfig(configText);
      }
      console.warn("[bsky-nav] parseRulesConfig not found on state, rules may not parse correctly");
      return {};
    }
    /**
     * Check if a handle matches any rule in a category (including via includes).
     * @param {string} normalizedHandle - The handle to check (with @)
     * @param {string} categoryName - The category to check
     * @param {Set} [visited] - Set of visited categories for circular dependency detection
     * @returns {boolean} True if handle matches any rule in the category
     * @private
     */
    handleMatchesCategory(normalizedHandle, categoryName, visited = /* @__PURE__ */ new Set(), debug = false) {
      if (visited.has(categoryName)) {
        return false;
      }
      if (categoryName.startsWith("_")) {
        return false;
      }
      const rules = this.state.rules?.[categoryName];
      if (!rules || !Array.isArray(rules)) return false;
      visited.add(categoryName);
      const backingList = this.state.rules._backingLists?.[categoryName];
      if (backingList && this.state.listCache) {
        const result = this.state.listCache.isInListSync(normalizedHandle, backingList);
        if (debug) console.log(`[debug] ${normalizedHandle} in backing list "${backingList}": ${result}`);
        if (result === true) {
          if (debug) console.log(`[debug] MATCH: ${normalizedHandle} found in backing list "${backingList}" for category "${categoryName}"`);
          return true;
        }
        if (result === void 0) {
          this.state.listCache.getMembers(backingList).then(() => {
            this.scheduleHighlightRefresh();
          });
        }
      }
      for (const rule of rules) {
        if (rule.type === "from" && rule.value.toLowerCase() === normalizedHandle.toLowerCase()) {
          if (debug) console.log(`[debug] MATCH: ${normalizedHandle} matches from rule "${rule.value}" in category "${categoryName}"`);
          return true;
        }
        if (rule.type === "include") {
          if (this.handleMatchesCategory(normalizedHandle, rule.value, visited, debug)) {
            if (debug) console.log(`[debug] MATCH: ${normalizedHandle} matches via include of "${rule.value}" in category "${categoryName}"`);
            return true;
          }
        }
        if (rule.type === "list") {
          const result = this.state.listCache?.isInListSync(normalizedHandle, rule.value);
          if (debug) console.log(`[debug] ${normalizedHandle} in list rule "${rule.value}": ${result}`);
          if (result === true) {
            if (debug) console.log(`[debug] MATCH: ${normalizedHandle} found in list rule "${rule.value}" in category "${categoryName}"`);
            return true;
          }
          if (result === void 0 && this.state.listCache) {
            this.state.listCache.getMembers(rule.value).then(() => {
              this.scheduleHighlightRefresh();
            });
          }
        }
      }
      if (debug) console.log(`[debug] NO MATCH: ${normalizedHandle} not found in category "${categoryName}"`);
      return false;
    }
    /**
     * Debug helper - check why a handle matches a category
     * Call from console: unsafeWindow.blueskyNavigatorState.handlers.feed.debugHandleMatch('@handle', 'category')
     */
    debugHandleMatch(handle2, categoryName) {
      const normalizedHandle = handle2.startsWith("@") ? handle2 : `@${handle2}`;
      console.log(`[debug] Checking ${normalizedHandle} against category "${categoryName}"`);
      console.log(`[debug] Rules for "${categoryName}":`, this.state.rules?.[categoryName]);
      console.log(`[debug] Backing list for "${categoryName}":`, this.state.rules?._backingLists?.[categoryName]);
      return this.handleMatchesCategory(normalizedHandle, categoryName, /* @__PURE__ */ new Set(), true);
    }
    /**
     * Debug helper - compare state.rules with what would be parsed from config
     * Call from console: unsafeWindow.blueskyNavigatorState.handlers.feed.debugRulesSync()
     */
    debugRulesSync() {
      const configText = this.config.get("rulesConfig") || "";
      const parsedFromConfig = this.parseRulesForState(configText);
      console.log("[debug] === Rules Sync Check ===");
      console.log("[debug] Config text:", configText);
      console.log("[debug] Parsed from config:", parsedFromConfig);
      console.log("[debug] Current state.rules:", this.state.rules);
      const stateCategories = Object.keys(this.state.rules || {}).filter((k) => !k.startsWith("_"));
      const configCategories = Object.keys(parsedFromConfig || {}).filter((k) => !k.startsWith("_"));
      console.log("[debug] State categories:", stateCategories);
      console.log("[debug] Config categories:", configCategories);
      for (const cat of stateCategories) {
        const stateRules = this.state.rules[cat];
        const configRules = parsedFromConfig[cat];
        if (JSON.stringify(stateRules) !== JSON.stringify(configRules)) {
          console.log(`[debug] MISMATCH in category "${cat}":`);
          console.log(`[debug]   State:`, stateRules);
          console.log(`[debug]   Config:`, configRules);
        }
      }
      console.log("[debug] State _backingLists:", this.state.rules?._backingLists);
      console.log("[debug] Config _backingLists:", parsedFromConfig?._backingLists);
    }
    /**
     * Get the index of the first filter category that contains a handle.
     * Returns -1 if handle is not in any filter list.
     * @param {string} handle - The handle to search for (with or without @)
     * @returns {number} Index of the category, or -1 if not found
     */
    getFilterCategoryIndexForHandle(handle2) {
      if (!handle2 || !this.state.rules) {
        return -1;
      }
      const normalizedHandle = handle2.startsWith("@") ? handle2 : `@${handle2}`;
      const categories = Object.keys(this.state.rules).filter((k) => !k.startsWith("_"));
      for (let i = 0; i < categories.length; i++) {
        if (this.handleMatchesCategory(normalizedHandle, categories[i])) {
          return i;
        }
      }
      return -1;
    }
    /**
     * Check if content matches any rule in a category (including via includes).
     * @param {string} content - The content to check
     * @param {string} categoryName - The category to check
     * @param {Set} [visited] - Set of visited categories for circular dependency detection
     * @returns {boolean} True if content matches any rule in the category
     * @private
     */
    contentMatchesCategory(content, categoryName, visited = /* @__PURE__ */ new Set()) {
      if (visited.has(categoryName)) {
        return false;
      }
      if (categoryName.startsWith("_")) {
        return false;
      }
      const rules = this.state.rules?.[categoryName];
      if (!rules || !Array.isArray(rules)) return false;
      visited.add(categoryName);
      for (const rule of rules) {
        if (rule.type === "content") {
          try {
            const pattern = new RegExp(rule.value, "i");
            if (pattern.test(content)) {
              return true;
            }
          } catch (e) {
          }
        }
        if (rule.type === "include") {
          if (this.contentMatchesCategory(content, rule.value, visited)) {
            return true;
          }
        }
      }
      return false;
    }
    /**
     * Get the matching content rule pattern for an item.
     * @param {HTMLElement} item - The post item element
     * @returns {{pattern: RegExp, categoryIndex: number}|null} The matching pattern and category index, or null
     */
    getMatchingContentRule(item) {
      if (!item || !this.state.rules) {
        return null;
      }
      const content = $(item).find('div[data-testid="postText"]').text();
      if (!content) return null;
      return this.getMatchingContentRuleForText(content);
    }
    /**
     * Get the matching content rule pattern for a text string.
     * @param {string} text - The text content to check
     * @returns {{pattern: RegExp, categoryIndex: number}|null} The first matching pattern and category index, or null
     */
    getMatchingContentRuleForText(text) {
      const results = this.getAllMatchingContentRulesForText(text);
      return results.length > 0 ? results[0] : null;
    }
    /**
     * Get ALL matching content rule patterns for a text string.
     * @param {string} text - The text content to check
     * @returns {Array<{pattern: RegExp, categoryIndex: number}>} All matching patterns with their category indices
     */
    getAllMatchingContentRulesForText(text) {
      if (!text || !this.state.rules) {
        return [];
      }
      const results = [];
      const categories = Object.keys(this.state.rules).filter((k) => !k.startsWith("_"));
      for (let i = 0; i < categories.length; i++) {
        const patterns = this.findAllMatchingContentPatterns(text, categories[i]);
        for (const pattern of patterns) {
          results.push({ pattern, categoryIndex: i });
        }
      }
      return results;
    }
    /**
     * Find the first matching content pattern in a category (including via includes).
     * @param {string} content - The content to check
     * @param {string} categoryName - The category to check
     * @param {Set} [visited] - Set of visited categories for circular dependency detection
     * @returns {RegExp|null} The matching pattern, or null
     * @private
     */
    findMatchingContentPattern(content, categoryName, visited = /* @__PURE__ */ new Set()) {
      const patterns = this.findAllMatchingContentPatterns(content, categoryName, visited);
      return patterns.length > 0 ? patterns[0] : null;
    }
    /**
     * Find ALL matching content patterns in a category (including via includes).
     * @param {string} content - The content to check
     * @param {string} categoryName - The category to check
     * @param {Set} [visited] - Set of visited categories for circular dependency detection
     * @returns {RegExp[]} All matching patterns
     * @private
     */
    findAllMatchingContentPatterns(content, categoryName, visited = /* @__PURE__ */ new Set()) {
      if (visited.has(categoryName)) {
        return [];
      }
      if (categoryName.startsWith("_")) {
        return [];
      }
      const rules = this.state.rules?.[categoryName];
      if (!rules || !Array.isArray(rules)) return [];
      visited.add(categoryName);
      const patterns = [];
      for (const rule of rules) {
        if (rule.type === "content") {
          try {
            const pattern = new RegExp(rule.value, "gi");
            if (pattern.test(content)) {
              patterns.push(new RegExp(rule.value, "gi"));
            }
          } catch (e) {
          }
        }
        if (rule.type === "include") {
          const includedPatterns = this.findAllMatchingContentPatterns(content, rule.value, new Set(visited));
          patterns.push(...includedPatterns);
        }
      }
      return patterns;
    }
    /**
     * Get the index of the first filter category that matches post content.
     * Returns -1 if content doesn't match any filter list.
     * @param {HTMLElement} item - The post item element
     * @returns {number} Index of the category, or -1 if not found
     */
    getFilterCategoryIndexForContent(item) {
      if (!item || !this.state.rules) {
        return -1;
      }
      const content = $(item).find('div[data-testid="postText"]').text();
      if (!content) return -1;
      const categories = Object.keys(this.state.rules).filter((k) => !k.startsWith("_"));
      for (let i = 0; i < categories.length; i++) {
        if (this.contentMatchesCategory(content, categories[i])) {
          return i;
        }
      }
      return -1;
    }
    /**
     * Hash a string to get a stable number (for default color assignment)
     * @param {string} str - The string to hash
     * @returns {number} A positive integer hash
     */
    hashString(str) {
      let hash = 0;
      for (let i = 0; i < str.length; i++) {
        hash = (hash << 5) - hash + str.charCodeAt(i);
        hash = hash & hash;
      }
      return Math.abs(hash);
    }
    /**
     * Get the color for a category by name, using custom color if set
     * @param {string} categoryName - The category name
     * @returns {string} The color hex code
     */
    getColorForCategory(categoryName) {
      try {
        const rulesetColors = JSON.parse(this.config.get("rulesetColors") || "{}");
        if (categoryName in rulesetColors) {
          const colorIndex = rulesetColors[categoryName] % this.FILTER_LIST_COLORS.length;
          return this.FILTER_LIST_COLORS[colorIndex];
        }
      } catch (e) {
      }
      return this.FILTER_LIST_COLORS[this.hashString(categoryName) % this.FILTER_LIST_COLORS.length];
    }
    /**
     * Get the color for a category by index, using custom color if set
     * @param {number} categoryIndex - The category index
     * @returns {string} The color hex code
     */
    getColorForCategoryIndex(categoryIndex) {
      if (!this.state.rules || categoryIndex < 0) {
        return this.FILTER_LIST_COLORS[0];
      }
      const categories = Object.keys(this.state.rules).filter((k) => !k.startsWith("_"));
      if (categoryIndex < categories.length) {
        const categoryName = categories[categoryIndex];
        return this.getColorForCategory(categoryName);
      }
      return this.FILTER_LIST_COLORS[0];
    }
    /**
     * Show notification that rule was added
     * Can be called with:
     * - (message) - info notification
     * - (message, type) - notification with type ('error', 'info', 'success')
     * - (handle, category, action) - rule added notification
     */
    showRuleAddedNotification(handleOrMessage, categoryOrType, action) {
      let message2, icon;
      if (categoryOrType === void 0) {
        message2 = handleOrMessage;
        icon = "\u2139";
      } else if (categoryOrType === "error" || categoryOrType === "info" || categoryOrType === "success") {
        message2 = handleOrMessage;
        icon = categoryOrType === "error" ? "\u2717" : categoryOrType === "success" ? "\u2713" : "\u2139";
      } else {
        message2 = `@${handleOrMessage} added to "${categoryOrType}" (${action})`;
        icon = action === "allow" ? "\u2713" : "\u2717";
      }
      const notification2 = $(`
      <div class="bsky-nav-rule-notification">
        <span class="bsky-nav-rule-notification-icon">${icon}</span>
        <span>${message2}</span>
      </div>
    `);
      $("body").append(notification2);
      setTimeout(() => notification2.addClass("visible"), 10);
      setTimeout(() => {
        notification2.removeClass("visible");
        setTimeout(() => notification2.remove(), 300);
      }, 3e3);
    }
    onFooterIntersection(entries) {
      entries.forEach((entry) => {
        if (entry.isIntersecting) {
          this.disableFooterObserver();
          this.loadOlderItems();
        }
      });
    }
    // ===========================================================================
    // Mouse Handling
    // ===========================================================================
    /**
     * Debounced mouse over handler for items - only focus when not scrolling
     */
    onItemMouseOver(event) {
      if (!this.config.get("hoverToFocus")) return;
      if (this.ignoreMouseMovement) return;
      const target2 = $(event.target).closest(this.selector);
      const index = this.getIndexFromItem(target2);
      if (this.hoverDebounceTimeout) {
        clearTimeout(this.hoverDebounceTimeout);
      }
      this.hoverDebounceTimeout = setTimeout(() => {
        if (this.ignoreMouseMovement) return;
        this.replyIndex = null;
        if (index !== this.index && index >= 0) {
          this.setIndex(index, false, false, false);
        } else if (index === this.index && index >= 0) {
          this.expandItem(this.selectedItem);
        }
      }, this.hoverDebounceDelay);
    }
    /**
     * Debounced mouse over handler for sidecar items
     */
    onSidecarItemMouseOver(event) {
      if (!this.config.get("hoverToFocus") || !this.config.get("hoverToFocusSidecar")) return;
      if (this.ignoreMouseMovement) return;
      const target2 = $(event.target).closest(".sidecar-post");
      const index = this.getSidecarIndexFromItem(target2);
      const isFixedSidecar = this.isFixedSidecar() && $("#fixed-sidecar-panel").hasClass("visible");
      if (this.hoverDebounceTimeout) {
        clearTimeout(this.hoverDebounceTimeout);
      }
      this.hoverDebounceTimeout = setTimeout(() => {
        if (this.ignoreMouseMovement) return;
        if (!isFixedSidecar) {
          const parent = target2.closest(".thread").find(".item");
          const parentIndex = this.getIndexFromItem(parent);
          if (parentIndex !== this.index && parentIndex >= 0) {
            this.setIndex(parentIndex, false, false, false);
          }
        }
        this.replyIndex = index;
      }, this.hoverDebounceDelay);
    }
    // ===========================================================================
    // Scroll & Navigation Helpers
    // ===========================================================================
    scrollToElement(target2, block2 = null) {
      this.ignoreMouseMovement = true;
      target2.scrollIntoView({
        behavior: this.config.get("enableSmoothScrolling") ? "smooth" : "instant",
        block: block2 == null ? "start" : block2
      });
      setTimeout(() => {
        this.ignoreMouseMovement = false;
      }, 500);
    }
    /**
     * Wait for an element's position to stabilize (no movement for stabilityMs)
     * @param {Element|jQuery} element - The element to monitor
     * @param {number} stabilityMs - How long position must be stable (default 100ms)
     * @param {number} maxWaitMs - Maximum time to wait (default 600ms)
     * @returns {Promise} Resolves when element position has stabilized
     */
    waitForElementStable(element, stabilityMs = 100, maxWaitMs = 600) {
      return new Promise((resolve) => {
        if (!this.config.get("enableSmoothScrolling")) {
          resolve();
          return;
        }
        const el = element instanceof $ ? element[0] : element;
        if (!el) {
          resolve();
          return;
        }
        let lastTop = el.getBoundingClientRect().top;
        let stableTime = 0;
        let elapsed = 0;
        const checkInterval = 16;
        const check2 = () => {
          elapsed += checkInterval;
          const currentTop = el.getBoundingClientRect().top;
          if (Math.abs(currentTop - lastTop) < 1) {
            stableTime += checkInterval;
            if (stableTime >= stabilityMs) {
              resolve();
              return;
            }
          } else {
            stableTime = 0;
            lastTop = currentTop;
          }
          if (elapsed >= maxWaitMs) {
            resolve();
            return;
          }
          requestAnimationFrame(check2);
        };
        requestAnimationFrame(check2);
      });
    }
    get scrollMargin() {
      return this.getToolbarHeight();
    }
    async updateItems() {
      if (this._expandPromise) {
        try {
          await this._expandPromise;
        } catch (e) {
        }
        this._expandPromise = null;
        await new Promise((resolve) => requestAnimationFrame(() => {
          requestAnimationFrame(resolve);
        }));
      }
      this.ignoreMouseMovement = true;
      if (this.index == 0) {
        window.scrollTo(0, 0);
      } else if ($(this.selectedItem).length) {
        this.scrollToElement($(this.selectedItem)[0]);
      }
      setTimeout(() => {
        this.ignoreMouseMovement = false;
      }, 500);
    }
    handleNewThreadPage(_element) {
      this.loadPageObserver.disconnect();
    }
    // ===========================================================================
    // Item Utilities
    // ===========================================================================
    postIdFromUrl() {
      return window.location.href.split("/")[6];
    }
    urlForItem(item) {
      const href = $(item).find("a[href*='/post/']").attr("href");
      if (!href) return null;
      return href.startsWith("https://") ? href : `https://bsky.app${href}`;
    }
    postIdForItem(item) {
      try {
        return extractPostIdFromUrl(this.urlForItem(item));
      } catch (_e) {
        return this.postIdFromUrl();
      }
    }
    handleFromItem(item) {
      return $.trim(
        $(item).find(constants.PROFILE_SELECTOR).find("span").eq(1).text().replace(/[\u200E\u200F\u202A-\u202E]/g, "")
      ).slice(1);
    }
    /**
     * Extract DID from a post's profile link.
     * Returns the DID if the profile link uses a DID, null otherwise.
     * @param {jQuery|Element} item - The post element
     * @returns {string|null} The author's DID or null
     */
    didFromItem(item) {
      const profileLink = $(item).find('a[href*="/profile/"]').first().attr("href");
      if (profileLink) {
        const match2 = profileLink.match(/\/profile\/(did:[^/]+)/);
        if (match2) return match2[1];
      }
      return null;
    }
    /**
     * Get the author handle from an item
     * Works for both feed items and post thread items
     * @param {jQuery|Element} item - The post element
     * @returns {string|null} The author's handle without @ prefix
     */
    getAuthorHandle(item) {
      let handle2 = this.handleFromItem(item);
      if (handle2) return handle2;
      const testId = $(item).attr("data-testid") || "";
      if (testId.startsWith("postThreadItem-by-")) {
        return testId.replace("postThreadItem-by-", "");
      }
      if (testId.startsWith("feedItem-by-")) {
        return testId.replace("feedItem-by-", "");
      }
      const profileLink = $(item).find('a[href*="/profile/"]').first().attr("href");
      if (profileLink) {
        const match2 = profileLink.match(/\/profile\/([^/]+)/);
        if (match2) return match2[1];
      }
      return null;
    }
    displayNameFromItem(item) {
      return $.trim(
        $(item).find(constants.PROFILE_SELECTOR).find("span").eq(0).text().replace(/[\u200E\u200F\u202A-\u202E]/g, "")
      );
    }
    async getThreadForItem(item) {
      const url = this.urlForItem(item);
      if (!url) return;
      const uri = await this.api.getAtprotoUri(url);
      if (!uri) return;
      try {
        const thread = await this.api.getThread(uri);
        if (thread?.post?.author?.handle && thread?.post?.author?.did) {
          this.handleToDidCache.set(thread.post.author.handle, thread.post.author.did);
        }
        if (thread?.replies) {
          for (const reply of thread.replies) {
            if (reply?.post?.author?.handle && reply?.post?.author?.did) {
              this.handleToDidCache.set(reply.post.author.handle, reply.post.author.did);
            }
          }
        }
        return thread;
      } catch (error) {
        if (error.message?.includes("not found") || error.name === "NotFoundError") {
          console.warn(`[ItemHandler] Post not found: ${uri}`);
          return null;
        }
        throw error;
      }
    }
    getHandles() {
      return Array.from(new Set(this.items.map((i, item) => this.handleFromItem(item))));
    }
    getDisplayNames() {
      return Array.from(new Set(this.items.map((i, item) => this.displayNameFromItem(item))));
    }
    getAuthors() {
      const authors = $(this.items).get().map((item) => ({
        handle: this.handleFromItem(item),
        displayName: this.displayNameFromItem(item)
      })).filter((author) => author.handle.length > 0);
      const uniqueMap = /* @__PURE__ */ new Map();
      authors.forEach((author) => uniqueMap.set(author.handle, author));
      return Array.from(uniqueMap.values());
    }
    getTimestampForItem(item) {
      const postTimestampElement = $(item).find('a[href^="/profile/"][data-tooltip*=" at "]').first();
      const postTimeString = postTimestampElement.attr("aria-label");
      if (!postTimeString) return null;
      return new Date(postTimeString.replace(" at", ""));
    }
    // ===========================================================================
    // Item Styling
    // ===========================================================================
    applyItemStyle(element, selected) {
      $(element).addClass("item");
      if (this.config.get("postActionButtonPosition") == "Left") {
        const postContainer = $(element).find(constants.POST_CONTENT_SELECTOR).prev();
        if (postContainer.length) {
          postContainer.css("flex", "");
        }
      }
      this.applyTimestampFormat(element);
      this.applyThreadStyling(element, selected);
      this.applySelectionStyling(element, selected);
      this.applyReadStatus(element);
      this.applyBlockStatus(element);
      this.applyRuleColorStyling(element);
    }
    applyTimestampFormat(element) {
      const postTimestampElement = $(element).find('a[href^="/profile/"][data-tooltip*=" at "]').first();
      if (!postTimestampElement.attr("data-bsky-navigator-age")) {
        postTimestampElement.attr("data-bsky-navigator-age", postTimestampElement.text());
      }
      const userFormat = this.config.get(
        this.state.mobileView ? "postTimestampFormatMobile" : "postTimestampFormat"
      );
      const postTimeString = postTimestampElement.attr("aria-label");
      if (postTimeString && userFormat) {
        const postTimestamp = new Date(postTimeString.replace(" at", ""));
        const formattedDate = format(postTimestamp, userFormat).replace("$age", postTimestampElement.attr("data-bsky-navigator-age"));
        if (this.config.get("showDebuggingInfo")) {
          postTimestampElement.text(
            `${formattedDate} (${$(element).parent().parent().attr("data-bsky-navigator-thread-index")}, ${$(element).attr("data-bsky-navigator-item-index")})`
          );
        } else {
          postTimestampElement.text(formattedDate);
        }
      }
    }
    applyThreadStyling(element, selected) {
      const threadIndicator = $(element).find("div.r-lchren, div.r-1mhb1uw > svg");
      const avatarDiv = $(element).find('div[data-testid="userAvatarImage"]');
      $(element).parent().parent().addClass("thread");
      const el = element instanceof $ ? element[0] : element.jquery ? element[0] : element;
      if (el && el.style) {
        el.style.setProperty("scroll-margin-top", `${this.scrollMargin}px`, "important");
      }
      if (selected) {
        $(element).parent().parent().addClass("thread-selection-active");
        $(element).parent().parent().removeClass("thread-selection-inactive");
      } else {
        $(element).parent().parent().removeClass("thread-selection-active");
        $(element).parent().parent().addClass("thread-selection-inactive");
      }
      if (threadIndicator.length) {
        const parent = threadIndicator.parents().has(avatarDiv).first();
        const children = parent.find("*");
        if (threadIndicator.length == 1) {
          if (children.index(threadIndicator) < children.index(avatarDiv)) {
            $(element).parent().parent().addClass("thread-last");
          } else {
            $(element).parent().parent().addClass("thread-first");
          }
        } else {
          $(element).parent().parent().addClass("thread-middle");
        }
      } else {
        $(element).parent().parent().addClass(["thread-first", "thread-middle", "thread-last"]);
      }
    }
    applySelectionStyling(element, selected) {
      if (selected) {
        const childFocused = this._threadIndex != null || this._replyIndex != null;
        if (childFocused) {
          $(element).addClass("item-selection-child-focused");
          $(element).removeClass("item-selection-active");
        } else {
          $(element).addClass("item-selection-active");
          $(element).removeClass("item-selection-child-focused");
        }
        $(element).removeClass("item-selection-inactive");
      } else {
        $(element).removeClass("item-selection-active");
        $(element).removeClass("item-selection-child-focused");
        $(element).addClass("item-selection-inactive");
      }
    }
    applyReadStatus(element) {
      const postId = this.postIdForItem($(element));
      if (postId != null && this.state.seen[postId]) {
        $(element).addClass("item-read");
        $(element).removeClass("item-unread");
      } else {
        $(element).addClass("item-unread");
        $(element).removeClass("item-read");
      }
    }
    applyRuleColorStyling(element) {
      const $el = $(element);
      const avatar = $el.find('div[data-testid="userAvatarImage"]').first();
      let postText = $el.find('div[data-testid="postText"]').first();
      if (!postText.length) {
        postText = $el.find('div[data-word-wrap="1"]').first();
      }
      const handle2 = this.getAuthorHandle(element);
      let profileLink = $el.find(constants.PROFILE_SELECTOR).first();
      if (!profileLink.length && handle2) {
        profileLink = $el.find(`a[href="/profile/${handle2}"]`).not(":has(img)").first();
      }
      let displayNameEl = null;
      if (profileLink.length) {
        const textDivs = profileLink.find('div[dir="auto"]');
        textDivs.each((i, div) => {
          const text = $(div).text().trim();
          if (text && !text.startsWith("@") && !displayNameEl) {
            displayNameEl = $(div);
          }
        });
        if (!displayNameEl) {
          displayNameEl = profileLink;
        }
      } else {
        displayNameEl = $();
      }
      const authorCategoryIndex = handle2 ? this.getFilterCategoryIndexForHandle(handle2) : -1;
      const $thread = $el.closest(".thread");
      const repostLink = $thread.find('a[aria-label*="Reposted by"]').first();
      let reposterHandle = null;
      let reposterCategoryIndex = -1;
      if (repostLink.length) {
        const href = repostLink.attr("href") || "";
        const reposterMatch = href.match(/\/profile\/([^/]+)/);
        if (reposterMatch) {
          reposterHandle = reposterMatch[1];
          reposterCategoryIndex = this.getFilterCategoryIndexForHandle(reposterHandle);
        }
      }
      if (!this.config.get("ruleColorCoding")) {
        if (displayNameEl.length) {
          displayNameEl.css({ "background-color": "", "border": "", "border-radius": "", "padding": "" });
        }
        if (avatar.length) avatar.css("box-shadow", "");
        if (repostLink.length) {
          const repostText = repostLink.find('div[dir="auto"]').first();
          if (repostText.length) {
            repostText.css({ "background-color": "", "border": "", "border-radius": "", "padding": "" });
          }
        }
        postText.find(".rule-content-highlight").each(function() {
          $(this).replaceWith($(this).text());
        });
        return;
      }
      if (authorCategoryIndex >= 0) {
        const color = this.getColorForCategoryIndex(authorCategoryIndex);
        if (displayNameEl.length) {
          displayNameEl[0].style.setProperty("background-color", `${color}80`, "important");
          displayNameEl[0].style.setProperty("border", `1px solid ${color}88`, "important");
          displayNameEl[0].style.setProperty("border-radius", "3px", "important");
          displayNameEl[0].style.setProperty("padding", "0 2px", "important");
        }
        if (avatar.length) {
          avatar.css({
            "box-shadow": `0 0 0 3px ${color}`,
            "border-radius": "50%"
          });
        }
      } else {
        if (displayNameEl.length) {
          displayNameEl.css({ "background-color": "", "border": "", "border-radius": "", "padding": "" });
        }
        if (avatar.length) avatar.css("box-shadow", "");
      }
      if (reposterCategoryIndex >= 0 && repostLink.length) {
        const color = this.getColorForCategoryIndex(reposterCategoryIndex);
        const repostText = repostLink.find('div[dir="auto"]').first();
        if (repostText.length) {
          repostText[0].style.setProperty("background-color", `${color}80`, "important");
          repostText[0].style.setProperty("border", `1px solid ${color}88`, "important");
          repostText[0].style.setProperty("border-radius", "3px", "important");
          repostText[0].style.setProperty("padding", "0 2px", "important");
        }
      } else if (repostLink.length) {
        const repostText = repostLink.find('div[dir="auto"]').first();
        if (repostText.length) {
          repostText.css({ "background-color": "", "border": "", "border-radius": "", "padding": "" });
        }
      }
      this.applyAllContentHighlights(postText);
      this.applyEmbeddedPostHighlighting($el);
    }
    /**
     * Apply all matching content rule highlights to a text container.
     * Clears previous highlights first, then applies all matching patterns.
     * @param {jQuery} $textContainer - The container element with text to highlight
     */
    applyAllContentHighlights($textContainer) {
      $textContainer.find(".rule-content-highlight").each(function() {
        $(this).replaceWith($(this).text());
      });
      const content = $textContainer.text();
      const allMatches = this.getAllMatchingContentRulesForText(content);
      for (const { pattern, categoryIndex } of allMatches) {
        const color = this.getColorForCategoryIndex(categoryIndex);
        this.highlightMatchingText($textContainer, pattern, color);
      }
    }
    /**
     * Apply rule highlighting to embedded/quote posts within a feed item
     */
    applyEmbeddedPostHighlighting($el) {
      const colorCodingEnabled = this.config.get("ruleColorCoding");
      const embeddedTexts = $el.find('div[data-word-wrap="1"]');
      if (embeddedTexts.length === 0) return;
      embeddedTexts.each((i, embedTextEl) => {
        const $embedText = $(embedTextEl);
        const $embedContainer = $embedText.closest("div[aria-label^='Post by']");
        if (!$embedContainer.length) return;
        const ariaLabel = $embedContainer.attr("aria-label") || "";
        const handleMatch = ariaLabel.match(/Post by (.+)/);
        const embedHandle = handleMatch ? handleMatch[1] : null;
        const embedAvatar = $embedContainer.find('div[data-testid="userAvatarImage"]').first();
        const embedProfileLink = $embedContainer.find(constants.PROFILE_SELECTOR).first();
        const embedCategoryIndex = embedHandle ? this.getFilterCategoryIndexForHandle(embedHandle) : -1;
        if (!colorCodingEnabled) {
          if (embedProfileLink.length) {
            embedProfileLink.css({ "background-color": "", "border": "", "border-radius": "", "padding": "" });
          }
          if (embedAvatar.length) embedAvatar.css("box-shadow", "");
          $embedText.find(".rule-content-highlight").each(function() {
            $(this).replaceWith($(this).text());
          });
          return;
        }
        this.applyAllContentHighlights($embedText);
        if (embedCategoryIndex >= 0) {
          const color = this.getColorForCategoryIndex(embedCategoryIndex);
          if (embedProfileLink.length) {
            embedProfileLink[0].style.setProperty("background-color", `${color}80`, "important");
            embedProfileLink[0].style.setProperty("border", `1px solid ${color}88`, "important");
            embedProfileLink[0].style.setProperty("border-radius", "3px", "important");
            embedProfileLink[0].style.setProperty("padding", "0 2px", "important");
          }
          if (embedAvatar.length) {
            embedAvatar.css({
              "box-shadow": `0 0 0 3px ${color}`,
              "border-radius": "50%"
            });
          }
        } else {
          if (embedProfileLink.length) {
            embedProfileLink.css({ "background-color": "", "border": "", "border-radius": "", "padding": "" });
          }
          if (embedAvatar.length) embedAvatar.css("box-shadow", "");
        }
      });
    }
    /**
     * Called when rules are updated (from config modal or quick filter popup).
     * Re-parses rules and refreshes all UI to reflect changes immediately.
     */
    onRulesChanged() {
      const rulesConfig = this.config.get("rulesConfig") || "";
      if (this.state && this.state.rules !== void 0) {
        this.state.rules = this.parseRulesForState(rulesConfig);
        this.state.rulesConfig = rulesConfig;
      }
      if (this.items && this.items.length) {
        for (let i = 0; i < this.items.length; i++) {
          const item = this.items[i];
          if (item) {
            this.applyItemStyle(item, i === this.index);
          }
        }
      }
      if (typeof this.updateScrollPosition === "function") {
        this.updateScrollPosition(true);
      }
    }
    /**
     * @deprecated Use onRulesChanged() instead
     */
    applyRuleStylingToAllItems() {
      this.onRulesChanged();
    }
    /**
     * Schedule a debounced refresh of rule color styling for all items.
     * Called when list cache is populated asynchronously.
     */
    scheduleHighlightRefresh() {
      if (this._highlightRefreshTimeout) {
        clearTimeout(this._highlightRefreshTimeout);
      }
      this._highlightRefreshTimeout = setTimeout(() => {
        this._highlightRefreshTimeout = null;
        this.refreshAllRuleColorStyling();
      }, 100);
    }
    /**
     * Re-applies rule color styling to all visible items.
     * Called after list cache is populated to update highlighting.
     */
    refreshAllRuleColorStyling() {
      if (!this.items || !this.items.length) return;
      for (let i = 0; i < this.items.length; i++) {
        const item = this.items[i];
        if (item) {
          this.applyRuleColorStyling(item);
        }
      }
    }
    /**
     * Highlight matching text within an element by wrapping matches in styled spans.
     * @param {jQuery} $container - The container element
     * @param {RegExp} pattern - The pattern to match
     * @param {string} color - The highlight color
     */
    highlightMatchingText($container, pattern, color) {
      if (!$container.length) return;
      const highlightStyle = `background-color: ${color}33;`;
      const processNode = (node) => {
        if (node.nodeType === Node.TEXT_NODE) {
          const text = node.textContent;
          if (!text || !pattern.test(text)) return;
          pattern.lastIndex = 0;
          const fragment = document.createDocumentFragment();
          let lastIndex = 0;
          let match2;
          while ((match2 = pattern.exec(text)) !== null) {
            if (match2.index > lastIndex) {
              fragment.appendChild(document.createTextNode(text.slice(lastIndex, match2.index)));
            }
            const span = document.createElement("span");
            span.className = "rule-content-highlight";
            span.style.cssText = highlightStyle;
            span.textContent = match2[0];
            fragment.appendChild(span);
            lastIndex = pattern.lastIndex;
          }
          if (lastIndex < text.length) {
            fragment.appendChild(document.createTextNode(text.slice(lastIndex)));
          }
          if (fragment.childNodes.length > 0) {
            node.parentNode.replaceChild(fragment, node);
          }
        } else if (node.nodeType === Node.ELEMENT_NODE && !$(node).hasClass("rule-content-highlight")) {
          Array.from(node.childNodes).forEach(processNode);
        }
      };
      $container.each(function() {
        Array.from(this.childNodes).forEach(processNode);
      });
    }
    applyBlockStatus(element) {
      if (!this.config.get("clearskyEnabled")) return;
      let did2 = this.didFromItem(element);
      const handle2 = this.getAuthorHandle(element);
      if (!did2 && handle2) {
        did2 = this.handleToDidCache.get(handle2);
        if (!did2) {
          this.resolveHandleToDidForClearsky(handle2).then((resolvedDid) => {
            if (resolvedDid) {
              this.handleToDidCache.set(handle2, resolvedDid);
              this.applyBlockStatusWithDid(element, resolvedDid);
            }
          }).catch(() => {
          });
        }
      }
      if (did2) {
        this.applyBlockStatusWithDid(element, did2);
      }
    }
    /**
     * Resolve a handle to DID for Clearsky block checking.
     * Uses AT Protocol API if available, otherwise falls back to Clearsky's API.
     */
    async resolveHandleToDidForClearsky(handle2) {
      if (this.api) {
        try {
          const did2 = await this.api.resolveHandleToDid(handle2);
          if (did2) return did2;
        } catch (_e) {
        }
      }
      return new Promise((resolve) => {
        GM_xmlhttpRequest({
          method: "GET",
          url: `https://api.clearsky.services/api/v1/anon/get-did/${encodeURIComponent(handle2)}`,
          headers: { Accept: "application/json" },
          onload: (response) => {
            try {
              const data = JSON.parse(response.responseText);
              resolve(data?.did || null);
            } catch (_e) {
              resolve(null);
            }
          },
          onerror: () => resolve(null)
        });
      });
    }
    getClearskyStyle(styleType, color) {
      if (styleType === "None" || !color) return null;
      switch (styleType) {
        case "Background":
          return { "background-color": color };
        case "Border":
          return { "border": `2px solid ${color}`, "border-radius": "4px" };
        case "Underline":
          return { "text-decoration": "underline", "text-decoration-color": color, "text-underline-offset": "2px" };
        case "Text color":
          return { "color": color };
        default:
          return null;
      }
    }
    /**
     * Get Clearsky block info for a handle (synchronous, uses cache).
     * Returns { type: 'all'|'recent'|null, color: string|null, styleType: string|null }
     */
    getClearskyBlockInfo(handle2) {
      if (!this.config.get("clearskyEnabled") || !handle2) {
        return { type: null, color: null, styleType: null };
      }
      const did2 = this.handleToDidCache.get(handle2);
      if (!did2) {
        return { type: null, color: null, styleType: null };
      }
      const allBlocks = this.state.blocks?.all?.dids || [];
      const recentBlocks = this.state.blocks?.recent?.dids || [];
      if (recentBlocks.includes(did2)) {
        return {
          type: "recent",
          color: this.config.get("clearskyColorRecent"),
          styleType: this.config.get("clearskyStyleTypeRecent")
        };
      }
      if (allBlocks.includes(did2)) {
        return {
          type: "all",
          color: this.config.get("clearskyColorAll"),
          styleType: this.config.get("clearskyStyleTypeAll")
        };
      }
      return { type: null, color: null, styleType: null };
    }
    applyBlockStatusWithDid(element, did2) {
      const allBlocks = this.state.blocks?.all?.dids || [];
      const recentBlocks = this.state.blocks?.recent?.dids || [];
      const $el = $(element);
      const avatar = $el.find('div[data-testid="userAvatarImage"]').first();
      const applyBlockStyle = (styleType, color) => {
        const style2 = this.getClearskyStyle(styleType, color);
        if (style2) {
          $el.find(constants.PROFILE_SELECTOR).css(style2);
        }
        if (avatar.length && color) {
          avatar.css({
            "box-shadow": `0 0 0 3px ${color}`,
            "border-radius": "50%"
          });
        }
      };
      if (allBlocks.includes(did2)) {
        applyBlockStyle(
          this.config.get("clearskyStyleTypeAll"),
          this.config.get("clearskyColorAll")
        );
      }
      if (recentBlocks.includes(did2)) {
        applyBlockStyle(
          this.config.get("clearskyStyleTypeRecent"),
          this.config.get("clearskyColorRecent")
        );
      }
    }
    // ===========================================================================
    // Item Loading
    // ===========================================================================
    filterItems() {
      return;
    }
    sortItems() {
      return;
    }
    showMessage(title, message2) {
      this.hideMessage();
      this.messageContainer = $('<div id="messageContainer">');
      if (title) {
        const messageTitle = $('<div class="messageTitle">');
        $(messageTitle).html(title);
        this.messageContainer.append(messageTitle);
      }
      const messageBody = $('<div class="messageBody">');
      this.messageContainer.append(messageBody);
      $(messageBody).html(message2);
      $(constants.FEED_CONTAINER_SELECTOR).filter(":visible").append(this.messageContainer);
      window.scrollTo(0, 0);
    }
    hideMessage() {
      $("#messageContainer").remove();
      this.messageContainer = null;
    }
    showFeedLoading() {
      if (this.initialLoadComplete) {
        if (this.config.get("showLoadingIndicator") !== false) {
          $("body").addClass("bsky-nav-loading-enabled").removeClass("bsky-nav-feed-ready");
        }
        return;
      }
      if (this.config.get("showLoadingIndicator") === false) {
        $("body").removeClass("bsky-nav-feed-ready bsky-nav-loading-enabled");
        $("#feedLoadingIndicator").remove();
        return;
      }
      $("body").addClass("bsky-nav-loading-enabled").removeClass("bsky-nav-feed-ready");
      if ($("#feedLoadingIndicator").length) return;
      const indicator = $(`
      <div id="feedLoadingIndicator" style="position:absolute;top:0;left:0;right:0;bottom:0;display:flex;flex-direction:column;justify-content:center;align-items:center;background:rgba(255,255,255,0.95);z-index:999;min-height:200px;">
        <div class="spinner" style="width:40px;height:40px;border:3px solid #e5e7eb;border-top-color:#3b82f6;border-radius:50%;animation:spin 0.8s linear infinite;"></div>
        <div class="loading-text" style="color:#6b7280;font-size:14px;margin-top:12px;">Loading...</div>
      </div>
    `);
      const container = $('main[role="main"]').first();
      if (container.length) {
        container.css("position", "relative").append(indicator);
      } else {
        indicator.css("position", "fixed");
        $("body").append(indicator);
      }
    }
    hideFeedLoading() {
      this.initialLoadComplete = true;
      $("body").addClass("bsky-nav-feed-ready");
      $("#feedLoadingIndicator").remove();
    }
    /**
     * Load items with retry for pages where feed loads asynchronously.
     * Used by Profile and Saved handlers.
     * @param {number} maxRetries - Maximum number of retry attempts (default: 10)
     * @param {number} retryDelay - Delay between retries in ms (default: 300)
     * @param {number} initialDelay - Initial delay before first attempt in ms (default: 500)
     */
    loadItemsWithRetry(maxRetries = 10, retryDelay = 300, initialDelay = 500) {
      let retryCount = 0;
      const tryLoad = () => {
        this.loadItems();
        const itemCount = this.items?.length || 0;
        if (itemCount === 0 && retryCount < maxRetries) {
          retryCount++;
          setTimeout(tryLoad, retryDelay);
        } else if (itemCount > 0) {
          this.updateScrollPosition(true);
        }
      };
      setTimeout(tryLoad, initialDelay);
    }
    /**
     * Load and process items in the feed
     * @param {string|object} restoreTarget - Either a post ID string, or an object with { postId, index }
     *   Post ID is tried first; index is used as fallback if post is not found
     */
    loadItems(restoreTarget) {
      this.perfLog("loadItems called");
      this.showFeedLoading();
      setTimeout(() => {
        this._doLoadItems(restoreTarget);
      }, 0);
    }
    _doLoadItems(restoreTarget) {
      const perfEnd = this.perfStart("_doLoadItems");
      try {
        this._doLoadItemsInner(restoreTarget);
      } finally {
        perfEnd();
      }
    }
    _doLoadItemsInner(restoreTarget) {
      const classes = ["thread-first", "thread-middle", "thread-last"];
      const set = [];
      const unrolledRepliesCount = $(".unrolled-replies").not(".post-view-modal *").length;
      const hasUnrolledContent = unrolledRepliesCount > 0;
      if (!hasUnrolledContent) {
        if (this.isFixedSidecar()) {
          $(".sidecar-replies").not(".post-view-modal *").not("#fixed-sidecar-panel *").each((i, el) => {
            try {
              if (el.parentNode) {
                el.parentNode.removeChild(el);
              }
            } catch (e) {
            }
          });
        }
        this.unrolledPostIds.clear();
        try {
          $(".unrolled-duplicate").removeClass("unrolled-duplicate");
        } catch (e) {
        }
        try {
          $(".unrolled-view-full-thread-hidden").removeClass("unrolled-view-full-thread-hidden").show();
        } catch (e) {
        }
      }
      $("div.thread").each((i, thread) => {
        try {
          if (!document.contains(thread)) return;
          const hasVisibleItems = $(thread).find(this.selector).filter(":visible").length > 0;
          if (!hasVisibleItems) {
            $(thread).css("display", "none");
          }
        } catch (e) {
        }
      });
      let itemIndex = 0;
      let threadIndex = 0;
      let threadOffset = 0;
      $(this.selector).filter(":visible").each((i, item) => {
        $(item).attr("data-bsky-navigator-item-index", itemIndex++);
        $(item).parent().parent().attr("data-bsky-navigator-thread-index", threadIndex);
        const threadDiv = $(item).parent().parent();
        if (classes.some((cls) => $(threadDiv).hasClass(cls))) {
          set.push(threadDiv[0]);
          $(item).attr("data-bsky-navigator-thread-offset", threadOffset);
          threadOffset++;
          if ($(threadDiv).hasClass("thread-last")) {
            threadIndex++;
            threadOffset = 0;
          }
        }
      });
      try {
        $(".self-thread-continuation").removeClass("filtered self-thread-continuation");
        $(".has-self-thread-continuation").removeClass("has-self-thread-continuation");
      } catch (e) {
      }
      const threadGroups = {};
      $(this.selector).filter(":visible").each((i, item) => {
        const threadIdx = $(item).closest(".thread").data("bsky-navigator-thread-index");
        if (threadIdx !== void 0) {
          if (!threadGroups[threadIdx]) {
            threadGroups[threadIdx] = [];
          }
          threadGroups[threadIdx].push(item);
        }
      });
      const unrollingEnabled = this.shouldUnroll && this.shouldUnroll();
      for (const [threadIdx, items] of Object.entries(threadGroups)) {
        if (items.length > 1) {
          const handles = items.map((item) => this.getAuthorHandle(item)).filter(Boolean);
          const uniqueHandles = new Set(handles);
          if (uniqueHandles.size === 1 && handles.length === items.length) {
            const getThreadPosition = (item) => {
              const threadIndicator = $(item).find("div.r-lchren, div.r-1mhb1uw > svg");
              const avatarDiv = $(item).find('div[data-testid="userAvatarImage"]');
              if (threadIndicator.length === 0) {
                return "standalone";
              }
              if (threadIndicator.length === 1) {
                const parent = threadIndicator.parents().has(avatarDiv).first();
                const children = parent.find("*");
                if (children.index(threadIndicator) < children.index(avatarDiv)) {
                  return "last";
                } else {
                  return "first";
                }
              }
              return "middle";
            };
            if (unrollingEnabled) {
              const positions = items.map((item) => ({ item, position: getThreadPosition(item), handle: this.getAuthorHandle(item) }));
              const hasRoot = positions.some((p) => p.position === "first");
              console.log("[bsky-navigator] Self-thread detection:", {
                threadIdx,
                itemCount: items.length,
                positions: positions.map((p) => p.position),
                hasRoot,
                handles: positions.map((p) => p.handle)
              });
              if (hasRoot) {
                items.forEach((item) => {
                  const position = getThreadPosition(item);
                  if (position === "last" || position === "middle") {
                    $(item).addClass("filtered self-thread-continuation");
                    $(item).closest(".thread").addClass("has-self-thread-continuation");
                  }
                });
              } else {
                const sortedByPosition = [...items].sort((a, b) => {
                  const posA = getThreadPosition(a);
                  const posB = getThreadPosition(b);
                  const priority = { "middle": 1, "last": 2, "standalone": 0 };
                  return (priority[posA] || 0) - (priority[posB] || 0);
                });
                const firstPost = sortedByPosition[0];
                sortedByPosition.slice(1).forEach((item) => {
                  $(item).addClass("filtered self-thread-continuation");
                  $(item).closest(".thread").addClass("has-self-thread-continuation");
                });
                if (!this._pendingProactiveUnrolls) {
                  this._pendingProactiveUnrolls = [];
                }
                this._pendingProactiveUnrolls.push(firstPost);
              }
            } else {
              const sortedItems = [...items].sort((a, b) => {
                const posA = getThreadPosition(a);
                const posB = getThreadPosition(b);
                const priority = { "first": 0, "standalone": 0, "middle": 1, "last": 2 };
                return (priority[posA] ?? 1) - (priority[posB] ?? 1);
              });
              const needsReorder = items.some((item, i) => item !== sortedItems[i]);
              if (needsReorder) {
                for (let i = 1; i < sortedItems.length; i++) {
                  const threadDiv = $(sortedItems[i]).closest(".thread");
                  const prevThreadDiv = $(sortedItems[i - 1]).closest(".thread");
                  threadDiv.insertAfter(prevThreadDiv);
                }
              }
            }
          }
        }
      }
      this.sortItems();
      this.filterItems();
      this.items = $(this.selector).filter(":visible").not(".filtered").filter((i, item) => {
        if (!item.isConnected || item.offsetParent === null) return false;
        if ($(item).parents(this.selector).length > 0) return false;
        const testId = $(item).attr("data-testid") || "";
        const ariaLabel = $(item).attr("aria-label") || "";
        const hasPostUI = $(item).find('[data-testid="postText"], [data-testid="likeBtn"]').length > 0;
        if (!testId.startsWith("feedItem-by-") && !testId.startsWith("postThreadItem-by-") && !ariaLabel.startsWith("Post by ") && !hasPostUI) return false;
        return true;
      });
      if (this.mainNavList) {
        this.mainNavList.setIndexSilent(this._index ?? 0);
      }
      this.visibleItems = [];
      this.setupIntersectionObserver();
      this.itemStats.oldest = this.itemStats.newest = null;
      $(this.selector).filter(":visible").each((i, item) => {
        const timestamp = this.getTimestampForItem(item);
        if (!this.itemStats.oldest || timestamp < this.itemStats.oldest) {
          this.itemStats.oldest = timestamp;
        }
        if (!this.itemStats.newest || timestamp > this.itemStats.newest) {
          this.itemStats.newest = timestamp;
        }
      });
      this.enableFooterObserver();
      if (this.index != null) {
        this.applyItemStyle(this.selectedItem, true);
      }
      this.applyThreadIndicatorStyles();
      $(this.selector).on("mouseover", this.onItemMouseOver);
      $(this.selector).closest("div.thread").addClass("bsky-navigator-seen");
      $(this.selector).closest("div.thread").removeClass(["loading-indicator-reverse", "loading-indicator-forward"]);
      this.refreshItems();
      this.loading = false;
      $("img#loadOlderIndicatorImage").addClass("image-highlight");
      $("img#loadOlderIndicatorImage").removeClass("toolbar-icon-pending");
      let targetPostId, preserveSelection;
      if (typeof restoreTarget === "string") {
        targetPostId = restoreTarget;
      } else if (restoreTarget && typeof restoreTarget === "object") {
        targetPostId = restoreTarget.postId;
        restoreTarget.index;
        preserveSelection = restoreTarget.preserveSelection;
      }
      if (preserveSelection) {
        if (this._index != null && this._index >= 0 && this.items?.length > 0) {
          const safeIndex = Math.min(this._index, this.items.length - 1);
          if (safeIndex !== this._index) {
            this._index = safeIndex;
            this.postId = this.postIdForItem(this.selectedItem);
          }
          this.applyItemStyle(this.selectedItem, true);
        } else if (this.items?.length > 0) {
          const statePostId = this.state?.focusedPostId;
          if (statePostId && this.jumpToPost(statePostId)) ;
          else {
            this.setIndex(0);
            this.updateItems();
            this.expandItem(this.selectedItem);
          }
        } else ;
      } else if (targetPostId && this.jumpToPost(targetPostId)) ;
      else if (this.items?.length > 0) {
        this.setIndex(0);
        this.updateItems();
        this.expandItem(this.selectedItem);
      } else ;
      this.updateInfoIndicator();
      this.enableFooterObserver();
      if ($(this.items).filter(":visible").length == 0) {
        this.showMessage(
          "No more unread posts.",
          `<p>You're all caught up.</p><div id="messageActions"/>`
        );
        if ($("#loadOlderAction").length == 0) {
          $("#messageActions").append($('<div id="loadOlderAction"><a>Load older posts</a></div>'));
          $("#loadOlderAction > a").on("click", () => this.loadOlderItems());
        }
        if (this.loadNewerButton && $("#loadNewerAction").length == 0) {
          $("#messageActions").append($('<div id="loadNewerAction"><a>Load newer posts</a></div>'));
          $("#loadNewerAction > a").on("click", () => this.loadNewerItems());
        }
        this.hideFixedSidecarPanel();
        this.clearFixedSidecarPanel();
      } else {
        this.hideMessage();
      }
      this.ignoreMouseMovement = false;
      this.hideFeedLoading();
      if (this._pendingProactiveUnrolls?.length > 0) {
        console.log("[bsky-navigator] Processing proactive unrolls:", this._pendingProactiveUnrolls.length);
        const pendingItems = this._pendingProactiveUnrolls;
        this._pendingProactiveUnrolls = [];
        this._processProactiveUnrolls(pendingItems);
      }
    }
    /**
     * Process proactive unrolls for self-thread continuation posts where the root is missing.
     * This fetches the full thread via API and renders an unrolled view starting from the root.
     * @param {Array} items - Array of DOM elements (continuation posts) to proactively unroll
     * @private
     */
    async _processProactiveUnrolls(items) {
      for (const item of items) {
        try {
          if (!document.contains(item)) {
            console.log("[bsky-navigator] Proactive unroll: item no longer in DOM");
            continue;
          }
          console.log("[bsky-navigator] Proactive unroll: fetching thread for item");
          const thread = await this.getThreadForItem(item);
          if (!thread) {
            console.log("[bsky-navigator] Proactive unroll: no thread data");
            continue;
          }
          console.log("[bsky-navigator] Proactive unroll: got thread, author:", thread.post?.author?.handle);
          let rootThread = thread;
          const authorDid = thread.post?.author?.did;
          while (rootThread.parent?.post?.author?.did === authorDid) {
            const parentThread = await this.api.getThread(rootThread.parent.post.uri);
            if (parentThread) {
              rootThread = parentThread;
            } else {
              break;
            }
          }
          if (rootThread.post?.author?.did === authorDid) {
            const unrolledPosts = await this.api.unrollThread(rootThread);
            if (unrolledPosts.length > 1) {
              await this._renderProactiveUnroll(item, rootThread, unrolledPosts);
            }
          }
        } catch (e) {
          console.warn("[bsky-navigator] Error in proactive unroll:", e);
        }
      }
    }
    /**
     * Render an unrolled thread view for a continuation post where the root was missing.
     * Shows all posts starting from the root (which may have been read/filtered).
     * @param {Element} item - The continuation post DOM element
     * @param {Object} rootThread - The thread data starting from the root post
     * @param {Array} unrolledPosts - Array of all posts in the self-thread
     * @private
     */
    async _renderProactiveUnroll(item, rootThread, unrolledPosts) {
      const parent = $(item).find('div[data-testid="contentHider-post"]').first().parent();
      if (!parent.length) return;
      parent.css({
        "overflow-y": "scroll",
        "max-height": "80vH",
        "padding-top": "1em",
        "overscroll-behavior": "contain",
        "padding-left": "44px",
        "position": "relative"
      });
      parent.find(".unrolled-replies").remove();
      parent.find(".unrolled-post-first").remove();
      parent.find(".proactive-unroll-root").remove();
      const totalPosts = unrolledPosts.length;
      const rootPost = unrolledPosts[0];
      const rootPostUrl = urlForPost(rootPost);
      const rootDiv = $('<div class="proactive-unroll-root"/>');
      rootDiv.append($(`<a href="${rootPostUrl}" class="unrolled-post-number unrolled-post-first" title="Post 1 of ${totalPosts}">1<span class="unrolled-post-total">/${totalPosts}</span></a>`));
      rootDiv.append($(this.bodyTemplate(formatPost(rootPost))));
      rootDiv.append($(this.footerTemplate(formatPost(rootPost))));
      parent.prepend(rootDiv);
      const rootPostId = rootPost.uri.split("/").slice(-1)[0];
      if (this.state.seen[rootPostId]) {
        rootDiv.addClass("item-read");
      }
      let div = parent.find("div.unrolled-replies");
      if (!div.length) {
        div = $('<div class="unrolled-replies"/>');
        parent.append(div);
      }
      const unrolledIds = [];
      unrolledPosts.slice(1).forEach((p, i) => {
        const postNum = i + 2;
        const postId = p.uri.split("/").slice(-1)[0];
        unrolledIds.push(postId);
        this.unrolledPostIds.add(postId);
        const reply = $('<div class="unrolled-reply"/>');
        reply.attr("data-unrolled-post-id", postId);
        reply.append($('<hr class="unrolled-divider"/>'));
        const isLastPost = postNum === totalPosts;
        const postNumberClass = isLastPost ? "unrolled-post-number unrolled-post-last" : "unrolled-post-number";
        reply.append(
          $(`<a href="${urlForPost(p)}" class="${postNumberClass}" title="Post ${postNum} of ${totalPosts}">${postNum}<span class="unrolled-post-total">/${totalPosts}</span></a>`)
        );
        reply.append($(this.bodyTemplate(formatPost(p))));
        reply.append($(this.footerTemplate(formatPost(p))));
        if (this.state.seen[postId]) {
          reply.addClass("item-read");
        }
        div.append(reply);
      });
      this.items.each((i, feedItem) => {
        const feedItemPostId = this.postIdForItem(feedItem);
        if (feedItemPostId && unrolledIds.includes(feedItemPostId)) {
          $(feedItem).addClass("filtered unrolled-duplicate");
          $(feedItem).closest(".thread").addClass("has-unrolled-duplicate");
        }
      });
      const currentPostId = this.postIdForItem(item);
      if (currentPostId) {
        this.selfThreadCache[currentPostId] = true;
      }
      this.selfThreadCache[rootPostId] = true;
    }
    applyThreadIndicatorStyles() {
      $("div.r-1mhb1uw").each((i, el) => {
        const ancestor = $(el).parent().parent().parent().parent();
        $(el).parent().parent().parent().addClass("item-selection-inactive");
        if ($(ancestor).prev().find("div.item-unread").length) {
          $(el).parent().parent().parent().addClass("item-unread");
          $(el).parent().parent().parent().removeClass("item-read");
        } else {
          $(el).parent().parent().parent().addClass("item-read");
          $(el).parent().parent().parent().removeClass("item-unread");
        }
      });
      $("div.r-1mhb1uw svg").each((i, el) => {
        $(el).find("line").attr("stroke", this.config.get("threadIndicatorColor"));
        $(el).find("circle").attr("fill", this.config.get("threadIndicatorColor"));
      });
    }
    refreshItems() {
      $(this.items).each((index, _item) => {
        this.applyItemStyle(this.items[index], index == this.index);
      });
      $(this.items).css("opacity", "100%");
    }
    updateInfoIndicator() {
      const allItems = this.items;
      const visibleItems = $(allItems).not(".filtered");
      const filteredItems = $(allItems).filter(".filtered");
      this.itemStats.unreadCount = visibleItems.filter(".item-unread").length;
      this.itemStats.filteredCount = filteredItems.length;
      this.itemStats.shownCount = visibleItems.length;
      const visibleIndex = visibleItems.index(this.selectedItem);
      const index = this.itemStats.shownCount ? visibleIndex + 1 : 0;
      const filterStats = this.itemStats.filteredCount > 0 ? `<strong>${this.itemStats.filteredCount}</strong> filtered, ` : "";
      $("div#infoIndicatorText").html(`
<div id="itemCountStats">
<strong>${index}</strong>${this.threadIndex != null ? `<span>.${this.threadIndex + 1}</span>` : ""}/<strong>${this.itemStats.shownCount}</strong> (${filterStats}<strong>${this.itemStats.unreadCount}</strong> new)
</div>
<div id="itemTimestampStats">
${this.itemStats.oldest ? `${format(this.itemStats.oldest, "yyyy-MM-dd hh:mmaaa")} - ${format(this.itemStats.newest, "yyyy-MM-dd hh:mmaaa")}</div>` : ``}`);
      if (this.config.get("showPostCounts") == "All" || this.selectedItem && this.config.get("showPostCounts") == "Selection") {
        const bannerDiv = $(this.selectedItem).find("div.item-banner").first().length ? $(this.selectedItem).find("div.item-banner").first() : $(this.selectedItem).find("div").first().prepend($('<div class="item-banner"/>')).children(".item-banner").last();
        $(bannerDiv).html(
          `<strong>${index}</strong>${this.threadIndex != null ? `<span>.${this.threadIndex + 1}/${this.unrolledReplies.length + 1}</span>` : ""}/<strong>${this.itemStats.shownCount}</strong>`
        );
      }
    }
    loadNewerItems() {
      if (!this.loadNewerButton) {
        const button = $(constants.LOAD_NEW_BUTTON_SELECTOR)[0];
        if (button) {
          this.loadNewerButton = button;
        } else {
          return;
        }
      }
      this.loadingNew = true;
      this.hideNewPostsPill();
      this.showFeedLoading();
      const oldPostId = this.selectedItem ? this.postIdForItem(this.selectedItem) : null;
      const oldIndex = this.index;
      try {
        if (this.selectedItem && $(this.selectedItem).length && document.contains($(this.selectedItem)[0])) {
          this.applyItemStyle(this.selectedItem, false);
        }
      } catch (e) {
        console.warn("[bsky-navigator] Error clearing selection:", e);
      }
      $(this.loadNewerButton).click();
      setTimeout(() => {
        try {
          this.loadItems({ postId: oldPostId, index: oldIndex });
        } catch (e) {
          console.warn("[bsky-navigator] Error in loadItems after loadNewer:", e);
        }
        $("img#loadNewerIndicatorImage").removeClass("image-highlight");
        $("img#loadNewerIndicatorImage").removeClass("toolbar-icon-pending");
        $("#loadNewerAction").remove();
        this.loadingNew = false;
        this.loadNewerButton = null;
        this.setupLoadNewerObserver();
      }, 1e3);
    }
    loadOlderItems() {
      if (this.loading) return;
      const loadMoreCallback = unsafeWindow.__bskyNavGetLoadMoreCallback?.();
      const loadMoreSentinel = unsafeWindow.__bskyNavGetLoadMoreSentinel?.();
      if (!loadMoreCallback) {
        return;
      }
      if (!loadMoreSentinel) {
        return;
      }
      this.showFeedLoading();
      $("img#loadOlderIndicatorImage").removeClass("image-highlight");
      $("img#loadOlderIndicatorImage").addClass("toolbar-icon-pending");
      this.loading = true;
      const reversed = this.state.feedSortReverse;
      const index = reversed ? 0 : this.items.length - 1;
      this.setIndex(index);
      this.updateItems();
      const indicatorElement = this.items.length ? this.items[index] : $(this.selector).eq(index)[0];
      $(indicatorElement).closest("div.thread").addClass(
        this.state.feedSortReverse ? "loading-indicator-forward" : "loading-indicator-reverse"
      );
      loadMoreCallback([
        {
          time: performance.now(),
          target: loadMoreSentinel,
          isIntersecting: true,
          intersectionRatio: 1,
          boundingClientRect: loadMoreSentinel.getBoundingClientRect(),
          intersectionRect: loadMoreSentinel.getBoundingClientRect(),
          rootBounds: document.documentElement.getBoundingClientRect()
        }
      ]);
      setTimeout(() => {
        if (this.loading) {
          this.loading = false;
          $("img#loadOlderIndicatorImage").addClass("image-highlight");
          $("img#loadOlderIndicatorImage").removeClass("toolbar-icon-pending");
          this.loadItems();
        }
      }, 3e3);
    }
  }
  const { waitForElement: waitForElement$1, announceToScreenReader } = utils$1;
  class FeedItemHandler extends ItemHandler {
    INDICATOR_IMAGES = {
      loadTop: [icons.circleUp],
      loadBottom: [icons.circleDown],
      loadTime: [icons.timeHistory],
      filter: [icons.mail, icons.mailUnread],
      sort: [icons.sortNumericDown, icons.sortNumericUp],
      preferences: [icons.preferencesOutline, icons.preferencesFilled],
      // Feed map content type icons
      contentVideo: icons.cameraMovie,
      contentImage: icons.imageAlt,
      contentEmbed: icons.linkExternal,
      contentText: icons.detail,
      contentRepost: icons.repost,
      contentReply: icons.reply,
      contentPost: icons.comment,
      contentThread: icons.spoolOfThread
    };
    constructor(name, config2, state2, api, selector) {
      super(name, config2, state2, api, selector);
      this.toggleSortOrder = this.toggleSortOrder.bind(this);
      this.onSearchAutocomplete = this.onSearchAutocomplete.bind(this);
      this.mediaCache = {};
      this.repostTimestampCache = {};
      this.reposterProfileCache = {};
      this.repostTimestampsFetched = false;
      this._toolbarObserver = null;
      this.feedTabObserver = waitForElement$1(constants.FEED_TAB_SELECTOR, (tab) => {
        observeChanges(
          tab,
          (attributeName, _oldValue, newValue, _target) => {
            if (attributeName == "class" && newValue.includes("r-13awgt0")) {
              this.onFeedChange();
            }
          },
          false
        );
      });
      waitForElement$1('div[data-testid="homeScreenFeedTabs"]', (feedTabs) => {
        $(feedTabs).on("click", 'div[role="tab"]', () => {
          setTimeout(() => this.onFeedChange(), 300);
        });
      });
      document.addEventListener("feedMapSettingChanged", (e) => {
        this.handleFeedMapSettingChange(e.detail);
      });
    }
    /**
     * Called when feed tab changes (e.g., Following -> Discover).
     * Resets the feed map and reloads items from DOM.
     */
    onFeedChange() {
      this.perfLog("onFeedChange");
      this.showFeedLoading();
      if (this.feedMap && this.feedMap.length) {
        this.feedMap.find(".feed-map-segment").remove();
        this.feedMap.find(".feed-map-viewport-indicator").remove();
        this.feedMap.find(".feed-map-empty").remove();
      }
      if (this.feedMapZoom) {
        this.feedMapZoom.find(".feed-map-segment-zoom").remove();
      }
      setTimeout(() => {
        this.loadItems();
        this.updateScrollPosition(true);
      }, 200);
    }
    /**
     * Fetch repost timestamps from AT Protocol API and cache them.
     * Only fetches once per session unless forced.
     */
    async fetchRepostTimestamps(force = false) {
      if (!this.api || this.repostTimestampsFetched && !force) {
        return;
      }
      try {
        if (!this.api.agent.session) {
          await this.api.login();
        }
        const result = await this.api.getRepostTimestamps();
        Object.assign(this.repostTimestampCache, result.timestamps);
        Object.assign(this.reposterProfileCache, result.reposterProfiles || {});
        this.repostTimestampsFetched = true;
        if (Object.keys(result.timestamps).length > 0) {
          this.refreshItems();
        }
      } catch (e) {
      }
    }
    /**
     * Override getTimestampForItem to use cached repost timestamps.
     * For reposts, returns the repost time instead of the original post time.
     * Falls back to estimated time based on adjacent posts if API hasn't fetched yet.
     */
    getTimestampForItem(item) {
      const $item = $(item);
      const isRepost = $item.closest(".thread").find('svg[aria-label*="Reposted"]').length > 0 || $item.closest(".thread").find('a[aria-label*="Reposted by"]').length > 0;
      if (isRepost) {
        const repostTime = this.getRepostTime(item);
        if (repostTime) return repostTime.time;
      }
      return super.getTimestampForItem(item);
    }
    /**
     * Get repost time for an item - from cache or estimated from adjacent posts.
     * Returns { time: Date, isEstimated: boolean } or null if unavailable.
     * Uses parent's getTimestampForItem for adjacent posts to avoid recursion.
     */
    getRepostTime(item) {
      const $item = $(item);
      const postId = this.postIdForItem($item);
      if (postId && this.repostTimestampCache[postId]) {
        return { time: this.repostTimestampCache[postId], isEstimated: false };
      }
      const itemIndex = typeof this.items.index === "function" ? this.items.index($item[0]) : Array.prototype.indexOf.call(this.items, $item[0]);
      if (itemIndex < 0) return null;
      const prevItem = itemIndex > 0 ? this.items[itemIndex - 1] : null;
      const nextItem = itemIndex < this.items.length - 1 ? this.items[itemIndex + 1] : null;
      const prevTime = prevItem ? super.getTimestampForItem(prevItem) : null;
      const nextTime = nextItem ? super.getTimestampForItem(nextItem) : null;
      if (prevTime && nextTime) {
        return { time: new Date((prevTime.getTime() + nextTime.getTime()) / 2), isEstimated: true };
      } else if (prevTime) {
        return { time: prevTime, isEstimated: true };
      } else if (nextTime) {
        return { time: nextTime, isEstimated: true };
      }
      return null;
    }
    /**
     * Override applyTimestampFormat to add repost timestamp after "Reposted by".
     * Original post timestamp stays in the post; repost time is shown in parentheses.
     */
    applyTimestampFormat(element) {
      super.applyTimestampFormat(element);
      const $element = $(element);
      const $thread = $element.closest(".thread");
      const repostLink = $thread.find('a[aria-label*="Reposted by"]').first();
      if (!repostLink.length) return;
      if ($thread.find(".repost-timestamp").length) return;
      const repostTimeResult = this.getRepostTime($element);
      if (!repostTimeResult) return;
      const { time: repostTime, isEstimated } = repostTimeResult;
      const userFormat = this.config.get(
        this.state.mobileView ? "postTimestampFormatMobile" : "postTimestampFormat"
      ) || "h:mmaaa";
      const repostAge = this.formatRelativeTime(repostTime);
      const formattedRepostTime = format(repostTime, userFormat).replace("$age", repostAge);
      const displayTime = isEstimated ? `~${formattedRepostTime}` : formattedRepostTime;
      const repostTextDiv = repostLink.children("div").first();
      if (repostTextDiv.length) {
        repostTextDiv.append(
          `<span class="repost-timestamp" style="margin-left: 4px; opacity: 0.8;">${displayTime}</span>`
        );
      }
    }
    /**
     * Handle dynamic feed map setting changes from config modal
     */
    handleFeedMapSettingChange(detail) {
      const { setting, value } = detail;
      this.config.set(setting, value);
      if (setting === "feedMapPosition") {
        this.moveScrollIndicator(value);
        return;
      }
      this.updateScrollPosition();
    }
    /**
     * Move the feed map to a new position dynamically
     */
    moveScrollIndicator(newPosition) {
      const indicator = this.feedMapWrapper || this.feedMapContainer;
      if (!indicator) return;
      indicator.detach();
      if (newPosition === "Hidden") {
        return;
      }
      if (this.feedMapContainer) {
        this.feedMapContainer.removeClass("feed-map-container-toolbar feed-map-container-statusbar");
        if (newPosition === "Top toolbar") {
          this.feedMapContainer.addClass("feed-map-container-toolbar");
        } else if (newPosition === "Bottom status bar") {
          this.feedMapContainer.addClass("feed-map-container-statusbar");
        }
      }
      if (this.feedMapWrapper) {
        this.feedMapWrapper.removeClass("feed-map-wrapper-statusbar");
        if (newPosition === "Bottom status bar") {
          this.feedMapWrapper.addClass("feed-map-wrapper-statusbar");
        }
      }
      if (newPosition === "Top toolbar" && this.toolbarDiv) {
        $(this.toolbarDiv).append(indicator);
        $(this.statusBar).removeClass("has-feed-map");
      } else if (newPosition === "Bottom status bar" && this.statusBar) {
        $(this.statusBar).prepend(indicator);
        $(this.statusBar).addClass("has-feed-map");
      }
      this.updateScrollPosition();
    }
    applyItemStyle(element, selected) {
      super.applyItemStyle(element, selected);
      const avatarDiv = $(element).find('div[data-testid="userAvatarImage"]');
      if (this.config.get("postActionButtonPosition") == "Left") {
        const buttonsDiv = $(element).find('button[data-testid="postDropdownBtn"]').parent().parent().parent();
        $(buttonsDiv).parent().css({
          "min-height": "160px",
          "min-width": "80px"
        });
        $(buttonsDiv).parent().children().first().css("flex", "");
        buttonsDiv.css({
          display: "flex",
          "flex-direction": "column",
          "align-items": "flex-start",
          position: "absolute",
          bottom: "0px",
          "z-index": "10"
        });
        $(buttonsDiv).find("> div").css({
          "margin-left": "0px",
          width: "100%"
        });
        $(buttonsDiv).find("> div > div").css({
          width: "100%"
        });
        const buttons = $(buttonsDiv).find('button[data-testid!="postDropdownBtn"]');
        buttons.each((i, button) => {
          $(button).css({
            display: "flex",
            "align-items": "center",
            "justify-content": "space-between",
            gap: "12px",
            width: "100%",
            padding: "5px 2px"
          });
          const div = $(button).find("> div").first();
          if (div.length) {
            $(div).css({
              display: "flex",
              "align-items": "center",
              "justify-content": "space-between",
              gap: "12px",
              padding: "0px"
            });
          }
          if ($(button).attr("aria-label").startsWith("Repost")) {
            $(div).css("width", "100%");
          }
          const svg = $(button).find("svg").first();
          $(svg).css({
            "flex-shrink": "0",
            display: "block"
          });
        });
        avatarDiv.closest("div.r-c97pre").children().eq(0).after(buttonsDiv);
      }
    }
    addToolbar(beforeDiv) {
      if (this._toolbarRemovalObserver) {
        this._toolbarRemovalObserver.disconnect();
        this._toolbarRemovalObserver = null;
      }
      this.toolbarDiv = $(`<div id="bsky-navigator-toolbar"/>`);
      $(beforeDiv).before(this.toolbarDiv);
      const indicatorPosition = this.config.get("feedMapPosition");
      const indicatorStyle = this.config.get("feedMapStyle") || "Advanced";
      const isAdvancedStyle = indicatorStyle === "Advanced";
      const styleClass = isAdvancedStyle ? "feed-map-advanced" : "feed-map-basic";
      const indicatorTheme = this.config.get("feedMapTheme") || "Default";
      const themeClass = `feed-map-theme-${indicatorTheme.toLowerCase()}`;
      const indicatorScale = parseInt(this.config.get("feedMapScale"), 10) || 100;
      const scaleValue = indicatorScale / 100;
      const animationInterval = parseInt(this.config.get("feedMapAnimationSpeed"), 10);
      const animationIntervalValue = (isNaN(animationInterval) ? 100 : animationInterval) / 100;
      const customPropsStyle = `--indicator-scale: ${scaleValue}; --zoom-animation-speed: ${animationIntervalValue};`;
      if (indicatorPosition === "Top toolbar") {
        this.feedMapContainer = $(`<div class="feed-map-container feed-map-container-toolbar"></div>`);
        this.feedMapLabelStart = $(`<span class="feed-map-label feed-map-label-start"></span>`);
        this.feedMapLabelEnd = $(`<span class="feed-map-label feed-map-label-end"></span>`);
        this.feedMap = $(`<div id="feed-map-position-indicator" class="feed-map-position-indicator" role="progressbar" aria-label="Feed position" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0"><div class="feed-map-position-fill"></div><div class="feed-map-position-zoom-highlight"></div></div>`);
        this.feedMapContainer.append(this.feedMapLabelStart);
        this.feedMapContainer.append(this.feedMap);
        this.feedMapContainer.append(this.feedMapLabelEnd);
        this.feedMapZoomHighlight = this.feedMap.find(".feed-map-position-zoom-highlight");
        this.feedMapWrapper = $(`<div class="feed-map-wrapper ${styleClass} ${themeClass}" style="${customPropsStyle}"></div>`);
        this.feedMapWrapper.append(this.feedMapContainer);
        this.feedMapConnector = $(`<div class="feed-map-connector">
        <svg class="feed-map-connector-svg" preserveAspectRatio="none">
          <path class="feed-map-connector-path feed-map-connector-left" fill="none"/>
          <path class="feed-map-connector-path feed-map-connector-right" fill="none"/>
        </svg>
      </div>`);
        this.feedMapWrapper.append(this.feedMapConnector);
        this.feedMapZoomContainer = $(`<div class="feed-map-container feed-map-container-toolbar feed-map-zoom-container"></div>`);
        this.feedMapZoomLabelStart = $(`<span class="feed-map-label feed-map-label-start"></span>`);
        this.feedMapZoomLabelEnd = $(`<span class="feed-map-label feed-map-label-end"></span>`);
        this.feedMapZoom = $(`<div id="feed-map-position-indicator-zoom" class="feed-map-position-indicator feed-map-position-indicator-zoom"></div>`);
        this.feedMapZoomInner = $(`<div class="feed-map-zoom-inner"></div>`);
        this.feedMapZoom.append(this.feedMapZoomInner);
        this.feedMapZoomContainer.append(this.feedMapZoomLabelStart);
        this.feedMapZoomContainer.append(this.feedMapZoom);
        this.feedMapZoomContainer.append(this.feedMapZoomLabelEnd);
        this.feedMapWrapper.append(this.feedMapZoomContainer);
        this.zoomWindowStart = null;
      }
      this.toolbarRow = $(`<div class="toolbar-row"/>`);
      $(this.toolbarDiv).append(this.toolbarRow);
      this.topLoadIndicator = $(`
<div id="topLoadIndicator" class="toolbar-icon css-175oi2r r-1loqt21 r-1otgn73 r-1oszu61 r-16y2uox r-1777fci r-gu64tb">
</div>`);
      $(this.toolbarRow).append(this.topLoadIndicator);
      this.sortIndicator = $(
        `<div id="sortIndicator" title="change sort order" class="toolbar-icon css-175oi2r r-1loqt21 r-1otgn73 r-1oszu61 r-16y2uox r-1777fci r-gu64tb"><img id="sortIndicatorImage" class="indicator-image" src="${this.INDICATOR_IMAGES.sort[+this.state.feedSortReverse]}"/></div>`
      );
      $(this.toolbarRow).append(this.sortIndicator);
      $(".indicator-image path").attr("fill", "currentColor");
      $("#sortIndicator").on("click", (event) => {
        event.preventDefault();
        this.toggleSortOrder();
      });
      this.filterIndicator = $(
        `<div id="filterIndicator" title="show all or unread" class="toolbar-icon css-175oi2r r-1loqt21 r-1otgn73 r-1oszu61 r-16y2uox r-1777fci r-gu64tb"><img id="filterIndicatorImage" class="indicator-image" src="${this.INDICATOR_IMAGES.filter[+this.state.feedHideRead]}"/></div>`
      );
      $(this.toolbarRow).append(this.filterIndicator);
      $("#filterIndicator").on("click", (event) => {
        event.preventDefault();
        this.toggleHideRead();
      });
      this.widthControls = $(`
      <div id="widthControls" class="width-controls">
        <button id="narrowWidth" title="Narrow content" class="width-btn">\u2212</button>
        <span id="widthDisplay" class="width-display">${this.config.get("postWidthDesktop") || 600}</span>
        <button id="widenWidth" title="Widen content" class="width-btn">+</button>
      </div>
    `);
      $(this.toolbarRow).append(this.widthControls);
      $("#narrowWidth").on("click", (event) => {
        event.preventDefault();
        this.adjustContentWidth(-50);
      });
      $("#widenWidth").on("click", (event) => {
        event.preventDefault();
        this.adjustContentWidth(50);
      });
      this.searchWrapper = $(`<div class="search-wrapper"></div>`);
      $(this.toolbarRow).append(this.searchWrapper);
      this.savedSearchesBtn = $(`
      <button id="saved-searches-btn" class="saved-searches-btn" title="Saved searches" aria-label="Saved searches" aria-haspopup="listbox">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon>
        </svg>
      </button>
    `);
      $(this.searchWrapper).append(this.savedSearchesBtn);
      this.searchField = $(`<input id="bsky-navigator-search" type="text" placeholder="Filter..."/>`);
      $(this.searchWrapper).append(this.searchField);
      this.saveSearchBtn = $(`
      <button id="save-search-btn" class="save-search-btn" title="Save current search" aria-label="Save current search">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <line x1="12" y1="5" x2="12" y2="19"></line>
          <line x1="5" y1="12" x2="19" y2="12"></line>
        </svg>
      </button>
    `);
      $(this.searchWrapper).append(this.saveSearchBtn);
      this.savedSearchesBtn.on("click", (e) => {
        e.preventDefault();
        e.stopPropagation();
        const searchInput = $("#bsky-navigator-search");
        searchInput.focus();
        searchInput.autocomplete("search", "");
      });
      this.saveSearchBtn.on("click", (e) => {
        e.preventDefault();
        e.stopPropagation();
        this.saveCurrentSearch();
      });
      const self = this;
      $("#bsky-navigator-search").autocomplete({
        minLength: 0,
        appendTo: this.searchWrapper,
        source: this.onSearchAutocomplete,
        focus: function(event, _ui) {
          event.preventDefault();
        },
        select: function(event, ui2) {
          if ($(event.originalEvent?.target).hasClass("autocomplete-delete-btn")) {
            event.preventDefault();
            return false;
          }
          event.preventDefault();
          const input = this;
          if (ui2.item.category === "saved") {
            input.value = ui2.item.value;
          } else {
            const terms = splitTerms(input.value);
            terms.pop();
            terms.push(ui2.item.value);
            input.value = terms.join(" ") + " ";
          }
          $(this).autocomplete("close");
        }
      });
      const autocompleteInstance = $("#bsky-navigator-search").autocomplete("instance");
      if (autocompleteInstance) {
        autocompleteInstance._renderItem = function(ul, item) {
          const li = $("<li>").addClass("ui-menu-item");
          if (item.category === "saved") {
            const content = $("<div>").addClass("autocomplete-item-content autocomplete-saved-item").append($("<span>").addClass("autocomplete-item-icon").text("\u2605")).append($("<span>").addClass("autocomplete-item-label").text(item.label)).append(
              $("<button>").addClass("autocomplete-delete-btn").attr("data-index", item.savedIndex).attr("title", "Delete saved search").text("\xD7")
            );
            li.append(content).data("ui-autocomplete-item", item);
          } else {
            const content = $("<div>").addClass("autocomplete-item-content").append($("<span>").addClass("autocomplete-item-label").text(item.label));
            li.append(content).data("ui-autocomplete-item", item);
          }
          return li.appendTo(ul);
        };
      } else {
        console.warn("[bsky-navigator] Autocomplete instance not available");
      }
      $(this.searchWrapper).on("click", ".autocomplete-delete-btn", (e) => {
        e.preventDefault();
        e.stopPropagation();
        const index = parseInt($(e.target).data("index"), 10);
        const searches = self.getSavedSearches();
        const removed = searches.splice(index, 1);
        self.saveSavedSearches(searches);
        announceToScreenReader(`Deleted saved search: ${removed[0]}`);
        $("#bsky-navigator-search").autocomplete("search", "");
      });
      $("#bsky-navigator-search").on("keydown", function(event) {
        if (event.key === "Escape") {
          event.preventDefault();
          $(this).autocomplete("close");
          $(this).blur();
        } else if (event.key === "Tab") {
          const autocompleteMenu = $(".ui-autocomplete:visible");
          const firstItem = autocompleteMenu.children(".ui-menu-item").first();
          if (firstItem.length) {
            const uiItem = firstItem.data("ui-autocomplete-item");
            $(this).autocomplete("close");
            const terms = splitTerms(this.value);
            terms.pop();
            terms.push(uiItem.value);
            this.value = terms.join(" ") + " ";
            event.preventDefault();
          }
        }
      });
      $(this.searchField).on("input", () => {
        const val = $(this.searchField).val();
        if (val === "/") {
          $("#bsky-navigator-search").val("");
          $(this.searchField).autocomplete("close");
          $("a[aria-label='Explore']")[0].click();
          return;
        }
        this.applyFilterDelayed();
      });
      $(this.searchField).on("keydown", (event) => {
        if (event.key === "Enter") {
          event.preventDefault();
          $(this.searchField).autocomplete("close");
          this.applyFilterImmediate();
        } else if (event.key === "Escape") {
          event.preventDefault();
          $(this.searchField).autocomplete("close");
          this.handleFilterEscape();
        } else if (event.altKey && !event.key.startsWith("Arrow")) {
          event.preventDefault();
          event.stopPropagation();
          this.handleInput(event);
        }
      });
      $(this.searchField).on("focus", function() {
        $(this).autocomplete("search", "");
      });
      $(this.searchField).on("autocompleteselect", (event, ui2) => {
        setTimeout(() => {
          this.commitFilter($(this.searchField).val());
        }, 0);
      });
      if (indicatorPosition === "Top toolbar" && this.feedMapWrapper) {
        $(this.toolbarDiv).append(this.feedMapWrapper);
        this.setupScrollIndicatorZoomClick();
        this.setupScrollIndicatorClick();
        this.setupScrollIndicatorScroll();
        this.setupFeedMapTooltipHandlers(this.feedMap);
        this.setupFeedMapTooltipHandlers(this.feedMapZoom);
      }
      this._toolbarRemovalObserver = waitForElement$1("#bsky-navigator-toolbar", null, (_div) => {
        this.addToolbar(beforeDiv);
      });
    }
    refreshToolbars() {
      if (this._toolbarObserver) {
        this._toolbarObserver.disconnect();
        this._toolbarObserver = null;
      }
      if (this._settingUpToolbars) {
        return;
      }
      const setupToolbar = () => {
        if (this.toolbarDiv && $.contains(document, this.toolbarDiv[0])) {
          return true;
        }
        $("#bsky-navigator-toolbar").remove();
        const feedTabs = $('div[data-testid="homeScreenFeedTabs"]').first();
        if (feedTabs.length) {
          this._settingUpToolbars = true;
          this.addToolbar(feedTabs);
          this._settingUpToolbars = false;
          return true;
        }
        return false;
      };
      const setupStatusBar = () => {
        if (this.statusBar && $.contains(document, this.statusBar[0])) {
          return true;
        }
        $("#statusBar").remove();
        const statusBarContainer = $(constants.STATUS_BAR_CONTAINER_SELECTOR).first();
        if (statusBarContainer.length) {
          this.addStatusBar(statusBarContainer.parent().parent().parent().parent().parent());
          return true;
        }
        return false;
      };
      const toolbarDone = setupToolbar();
      const statusBarDone = setupStatusBar();
      if (toolbarDone && statusBarDone) {
        this.setSortIcons();
        return;
      }
      this._toolbarObserver = new MutationObserver((mutations, obs) => {
        if (this._settingUpToolbars) {
          return;
        }
        const toolbar = setupToolbar();
        const statusBar = setupStatusBar();
        if (toolbar && statusBar) {
          obs.disconnect();
          this._toolbarObserver = null;
          this.setSortIcons();
        }
      });
      this._toolbarObserver.observe(document.body, {
        childList: true,
        subtree: true
      });
      setTimeout(() => {
        if (this._toolbarObserver) {
          this._toolbarObserver.disconnect();
          this._toolbarObserver = null;
        }
        if (setupToolbar() && setupStatusBar()) {
          this.setSortIcons();
        }
      }, 1e4);
    }
    onSearchAutocomplete(request, response) {
      const authors = this.getAuthors().sort(
        (a, b) => a.handle.localeCompare(b.handle, void 0, { sensitivity: "base" })
      );
      const rules = Object.keys(this.state.rules);
      const savedSearches = this.getSavedSearches();
      let term = extractLastTerm(request.term).toLowerCase();
      const isNegation = term.startsWith("!");
      if (isNegation) term = term.substring(1);
      let results = [];
      if (term === "") {
        const savedItems = savedSearches.map((search, index) => ({
          label: search,
          value: search,
          category: "saved",
          savedIndex: index
        }));
        const ruleItems = rules.map((r) => ({ label: `$${r}`, value: `$${r}`, category: "rule" }));
        results = [...savedItems, ...ruleItems];
      } else if (term.startsWith("@") || term.startsWith("$")) {
        const type = term.charAt(0);
        const search = term.substring(1).toLowerCase();
        if (type === "@") {
          results = authors.filter(
            (a) => a.handle.toLowerCase().includes(search) || a.displayName.toLowerCase().includes(search)
          ).map((a) => ({
            label: `${isNegation ? "!" : ""}@${a.handle} (${a.displayName})`,
            value: `${isNegation ? "!" : ""}@${a.handle}`,
            category: "author"
          }));
        } else if (type === "$") {
          results = rules.filter((r) => r.toLowerCase().includes(search)).map((r) => ({
            label: `${isNegation ? "!" : ""}$${r}`,
            category: "rule"
          }));
        }
      } else {
        const matchingSaved = savedSearches.filter((s) => s.toLowerCase().includes(term)).map((search, index) => ({
          label: search,
          value: search,
          category: "saved",
          savedIndex: savedSearches.indexOf(search)
        }));
        results = matchingSaved;
      }
      response(results);
    }
    addStatusBar(statusBarContainer) {
      this.statusBar = $(`<div id="statusBar"></div>`);
      this.statusBarLeft = $(`<div id="statusBarLeft"></div>`);
      this.statusBarCenter = $(`<div id="statusBarCenter"></div>`);
      this.statusBarRight = $(`<div id="statusBarRight"></div>`);
      const indicatorPosition = this.config.get("feedMapPosition");
      const indicatorStyle = this.config.get("feedMapStyle") || "Advanced";
      const isAdvancedStyle = indicatorStyle === "Advanced";
      const styleClass = isAdvancedStyle ? "feed-map-advanced" : "feed-map-basic";
      const indicatorTheme = this.config.get("feedMapTheme") || "Default";
      const themeClass = `feed-map-theme-${indicatorTheme.toLowerCase()}`;
      const indicatorScale = parseInt(this.config.get("feedMapScale"), 10) || 100;
      const scaleValue = indicatorScale / 100;
      const animationInterval = parseInt(this.config.get("feedMapAnimationSpeed"), 10);
      const animationIntervalValue = (isNaN(animationInterval) ? 100 : animationInterval) / 100;
      const customPropsStyle = `--indicator-scale: ${scaleValue}; --zoom-animation-speed: ${animationIntervalValue};`;
      if (indicatorPosition === "Bottom status bar") {
        this.feedMapContainer = $(`<div class="feed-map-container"></div>`);
        this.feedMapLabelStart = $(`<span class="feed-map-label feed-map-label-start"></span>`);
        this.feedMapLabelEnd = $(`<span class="feed-map-label feed-map-label-end"></span>`);
        this.feedMap = $(`<div id="feed-map-position-indicator" class="feed-map-position-indicator" role="progressbar" aria-label="Feed position" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0"><div class="feed-map-position-fill"></div><div class="feed-map-position-zoom-highlight"></div></div>`);
        this.feedMapContainer.append(this.feedMapLabelStart);
        this.feedMapContainer.append(this.feedMap);
        this.feedMapContainer.append(this.feedMapLabelEnd);
        this.feedMapZoomHighlight = this.feedMap.find(".feed-map-position-zoom-highlight");
        this.feedMapWrapper = $(`<div class="feed-map-wrapper feed-map-wrapper-statusbar ${styleClass} ${themeClass}" style="${customPropsStyle}"></div>`);
        this.feedMapZoomContainer = $(`<div class="feed-map-container feed-map-zoom-container"></div>`);
        this.feedMapZoomLabelStart = $(`<span class="feed-map-label feed-map-label-start"></span>`);
        this.feedMapZoomLabelEnd = $(`<span class="feed-map-label feed-map-label-end"></span>`);
        this.feedMapZoom = $(`<div id="feed-map-position-indicator-zoom" class="feed-map-position-indicator feed-map-position-indicator-zoom"></div>`);
        this.feedMapZoomInner = $(`<div class="feed-map-zoom-inner"></div>`);
        this.feedMapZoom.append(this.feedMapZoomInner);
        this.feedMapZoomContainer.append(this.feedMapZoomLabelStart);
        this.feedMapZoomContainer.append(this.feedMapZoom);
        this.feedMapZoomContainer.append(this.feedMapZoomLabelEnd);
        this.feedMapWrapper.append(this.feedMapZoomContainer);
        this.feedMapConnector = $(`<div class="feed-map-connector">
        <svg class="feed-map-connector-svg" preserveAspectRatio="none">
          <path class="feed-map-connector-path feed-map-connector-left" fill="none"/>
          <path class="feed-map-connector-path feed-map-connector-right" fill="none"/>
        </svg>
      </div>`);
        this.feedMapWrapper.append(this.feedMapConnector);
        this.feedMapWrapper.append(this.feedMapContainer);
        this.zoomWindowStart = null;
        $(this.statusBar).append(this.feedMapWrapper);
        this.setupScrollIndicatorZoomClick();
        this.setupScrollIndicatorClick();
        this.setupScrollIndicatorScroll();
        this.setupFeedMapTooltipHandlers(this.feedMap);
        this.setupFeedMapTooltipHandlers(this.feedMapZoom);
        $(this.statusBar).addClass("has-feed-map");
      }
      $(this.statusBar).append(this.statusBarLeft);
      $(this.statusBar).append(this.statusBarCenter);
      $(this.statusBar).append(this.statusBarRight);
      $(statusBarContainer).append(this.statusBar);
      this.bottomLoadIndicator = $(`
<div id="bottomLoadIndicator" class="toolbar-icon css-175oi2r r-1loqt21 r-1otgn73 r-1oszu61 r-16y2uox r-1777fci r-gu64tb"/>
`);
      $(this.statusBarLeft).append(this.bottomLoadIndicator);
      if (!this.infoIndicator) {
        this.infoIndicator = $(
          `<div id="infoIndicator" class="css-175oi2r r-1loqt21 r-1otgn73 r-1oszu61 r-16y2uox r-1777fci r-gu64tb"><div id="infoIndicatorText"/></div>`
        );
        $(this.statusBarCenter).append(this.infoIndicator);
      }
      if (!this.preferencesIcon) {
        this.preferencesIcon = $(
          `<div id="preferencesIndicator" class="toolbar-icon css-175oi2r r-1loqt21 r-1otgn73 r-1oszu61 r-16y2uox r-1777fci r-gu64tb"><div id="preferencesIcon"><img id="preferencesIconImage" class="indicator-image preferences-icon-overlay" src="${this.INDICATOR_IMAGES.preferences[0]}"/></div></div>`
        );
        $(this.preferencesIcon).on("click", () => {
          $("#preferencesIconImage").attr("src", this.INDICATOR_IMAGES.preferences[1]);
          this.config.open();
        });
        $(this.statusBarRight).append(this.preferencesIcon);
      }
    }
    activate() {
      super.activate();
      this.refreshToolbars();
      waitForElement$1("#bsky-navigator-search", (el) => {
        $(el).val(this.state.filter);
      });
      if (this.state.filter) {
        this.updateFilterPill();
        this.filterItems();
      }
      this.fetchRepostTimestamps();
      this._scrollHandler = this._throttledScrollUpdate.bind(this);
      window.addEventListener("scroll", this._scrollHandler, { passive: true });
      this.updateFilterEnforcement();
      this._timeoutCleanupInterval = setInterval(() => {
        const removed = this.cleanupExpiredTimeouts();
        if (removed > 0) {
          this.filterItems();
        }
      }, 60 * 1e3);
      this._timeoutClearedHandler = () => this.filterItems();
      window.addEventListener("bsky-nav-timeout-cleared", this._timeoutClearedHandler);
      const postId = this._savedPostId ?? this.state.focusedPostId;
      const index = this._savedIndex ?? this.state.focusedIndex;
      this.loadItems({ postId, index });
    }
    deactivate() {
      super.deactivate();
      this._savedPostId = this.postId;
      this._savedIndex = this.index;
      if (this._scrollHandler) {
        window.removeEventListener("scroll", this._scrollHandler);
        this._scrollHandler = null;
      }
      if (this._filterEnforcementInterval) {
        clearInterval(this._filterEnforcementInterval);
        this._filterEnforcementInterval = null;
      }
      if (this._timeoutCleanupInterval) {
        clearInterval(this._timeoutCleanupInterval);
        this._timeoutCleanupInterval = null;
      }
      if (this._timeoutClearedHandler) {
        window.removeEventListener("bsky-nav-timeout-cleared", this._timeoutClearedHandler);
        this._timeoutClearedHandler = null;
      }
      if (this._toolbarObserver) {
        this._toolbarObserver.disconnect();
        this._toolbarObserver = null;
      }
      if (this._toolbarRemovalObserver) {
        this._toolbarRemovalObserver.disconnect();
        this._toolbarRemovalObserver = null;
      }
      if (this.toolbarDiv) {
        this.toolbarDiv.remove();
        this.toolbarDiv = null;
      }
      if (this.statusBar) {
        this.statusBar.remove();
        this.statusBar = null;
      }
      this.statusBarLeft = null;
      this.statusBarCenter = null;
      this.statusBarRight = null;
      this.infoIndicator = null;
      this.preferencesIcon = null;
      this.bottomLoadIndicator = null;
      this.feedMap = null;
      this.feedMapWrapper = null;
      this.feedMapZoom = null;
      this.feedMapContainer = null;
      this.hideFeedMapTooltip();
      this.feedMapConnector = null;
      this.feedMapZoomContainer = null;
      this.feedMapZoomHighlight = null;
      this.feedMapLabelStart = null;
      this.feedMapLabelEnd = null;
      this.feedMapZoomLabelStart = null;
      this.feedMapZoomLabelEnd = null;
    }
    _throttledScrollUpdate() {
      if (this._scrollUpdatePending) return;
      this._scrollUpdatePending = true;
      requestAnimationFrame(() => {
        const indicator = this.feedMap;
        if (indicator && indicator.length && this.items.length) {
          this.updateViewportIndicator(indicator, this.items.length);
          if (this.feedMapZoom) {
            const indicatorStyle = this.config.get("feedMapStyle") || "Advanced";
            const isAdvancedStyle = indicatorStyle === "Advanced";
            const heatmapMode = isAdvancedStyle ? this.config.get("feedMapHeatmap") || "None" : "None";
            const showIcons = isAdvancedStyle ? this.config.get("feedMapIcons") !== false : false;
            const showAvatars = isAdvancedStyle ? this.config.get("feedMapAvatars") !== false : false;
            const avatarScale = this.config.get("feedMapAvatarScale") ?? 100;
            const showTimestamps = isAdvancedStyle ? this.config.get("feedMapTimestamps") !== false : false;
            const showHandles = isAdvancedStyle ? this.config.get("feedMapHandles") !== false : false;
            const showRuleColors = isAdvancedStyle && this.config.get("ruleColorCoding");
            const allItems = $(this.selector).filter((i, item) => {
              if (!item.isConnected || item.offsetParent === null) return false;
              const $item = $(item);
              if ($item.parents(this.selector).length > 0) return false;
              const testId = $item.attr("data-testid") || "";
              const ariaLabel = $item.attr("aria-label") || "";
              const hasPostUI = $item.find('[data-testid="postText"], [data-testid="likeBtn"]').length > 0;
              if (!testId.startsWith("feedItem-by-") && !testId.startsWith("postThreadItem-by-") && !ariaLabel.startsWith("Post by ") && !hasPostUI) return false;
              return true;
            }).toArray();
            let displayItems = [];
            let displayIndices = [];
            allItems.forEach((item, i) => {
              if (!$(item).hasClass("filtered")) {
                displayItems.push(item);
                displayIndices.push(i);
              }
            });
            let engagementData = [];
            let maxScore = 0;
            if (isAdvancedStyle && (heatmapMode !== "None" || showIcons || showAvatars || showHandles)) {
              engagementData = allItems.map((item) => {
                const engagement = this.getPostEngagement(item);
                const score = heatmapMode !== "None" ? this.calculateEngagementScore(engagement, heatmapMode) : 0;
                return { engagement, score };
              });
              displayItems.forEach((item, i) => {
                const actualIndex = displayIndices[i];
                if (engagementData[actualIndex]?.score > maxScore) {
                  maxScore = engagementData[actualIndex].score;
                }
              });
            }
            const selectedElement = this.items[this.index];
            const currentDisplayIndex = displayItems.indexOf(selectedElement);
            if (isAdvancedStyle) {
              this.updateFeedMapZoom(currentDisplayIndex, engagementData, heatmapMode, showIcons, showAvatars, avatarScale, showTimestamps, showHandles, showRuleColors, maxScore, displayItems.length, displayItems, displayIndices);
            } else {
              if (this.feedMapZoomContainer) this.feedMapZoomContainer.hide();
              if (this.feedMapConnector) this.feedMapConnector.hide();
              if (this.feedMapZoomHighlight) this.feedMapZoomHighlight.hide();
            }
          }
        }
        this._scrollUpdatePending = false;
      });
    }
    isActive() {
      return window.location.pathname == "/";
    }
    toggleSortOrder() {
      this.state.stateManager.updateState({ feedSortReverse: !this.state.feedSortReverse });
      this.setSortIcons();
      $(this.selector).closest("div.thread").removeClass("bsky-navigator-seen");
      this.loadItems();
    }
    setSortIcons() {
      ["top", "bottom"].forEach((bar) => {
        const which = !this.state.feedSortReverse && bar == "bottom" || this.state.feedSortReverse && bar == "top" ? "Older" : "Newer";
        const img = this.INDICATOR_IMAGES[`load${bar.toLowerCase().replace(/\b\w/g, (char) => char.toUpperCase())}`][0];
        $(`#${bar}LoadIndicator`).empty();
        $(`#${bar}LoadIndicator`).append(`
<div id="load${which}Indicator" title="Load ${which.toLowerCase()} items" class="toolbar-icon css-175oi2r r-1loqt21 r-1otgn73 r-1oszu61 r-16y2uox r-1777fci r-gu64tb">
      <a id="load${which}IndicatorLink">
<img id="load${which}IndicatorImage" class="indicator-image" src="${img}"/>
<img id="loadTime${which}IndicatorImage" class="indicator-image load-time-icon ${which == "Newer" ? "image-flip-x" : ""}" src="${this.INDICATOR_IMAGES.loadTime[0]}"/>
</a>
</div>
`);
      });
      $("img#loadOlderIndicatorImage").addClass("image-highlight");
      $("a#loadOlderIndicatorLink").on("click", () => this.loadOlderItems());
      $("a#loadNewerIndicatorLink").on("click", () => this.loadNewerItems());
      if (this.loadNewerButton) {
        $("img#loadNewerIndicatorImage").addClass("image-highlight");
      }
    }
    toggleHideRead() {
      this.state.stateManager.updateState({ feedHideRead: !this.state.feedHideRead });
      $(this.selector).closest("div.thread").removeClass("bsky-navigator-seen");
      this.loadItems();
    }
    adjustContentWidth(delta) {
      const currentWidth = this.config.get("postWidthDesktop") || 600;
      const newWidth = Math.max(400, Math.min(1200, currentWidth + delta));
      this.config.set("postWidthDesktop", newWidth);
      this.config.save();
      $("#widthDisplay").text(newWidth);
      this.updateContentWidthCSS(newWidth);
    }
    updateContentWidthCSS(contentWidth) {
      const styleId = "bsky-nav-width-style";
      let styleEl = document.getElementById(styleId);
      if (contentWidth !== 600) {
        if (!styleEl) {
          styleEl = document.createElement("style");
          styleEl.id = styleId;
          document.head.appendChild(styleEl);
        }
        const compactLayout = this.config.get("compactLayout");
        if (compactLayout) {
          const navWidthFull = 240;
          const navWidthCollapsed = 80;
          const gap = 20;
          styleEl.textContent = `
          /* Desktop: full nav width */
          @media (min-width: 1301px) {
            main[role="main"] [style*="max-width: 600px"],
            main[role="main"] [style*="max-width:600px"] {
              max-width: ${contentWidth}px !important;
              margin-left: ${navWidthFull + gap}px !important;
              margin-right: auto !important;
              transform: none !important;
            }
            #statusBar,
            #bsky-navigator-global-statusbar {
              max-width: ${contentWidth}px !important;
              margin-left: ${navWidthFull + gap}px !important;
              margin-right: auto !important;
              transform: none !important;
            }
          }
          /* Narrow: collapsed nav width */
          @media (max-width: 1300px) {
            main[role="main"] [style*="max-width: 600px"],
            main[role="main"] [style*="max-width:600px"] {
              max-width: ${contentWidth}px !important;
              margin-left: ${navWidthCollapsed + gap}px !important;
              margin-right: auto !important;
              transform: none !important;
            }
            #statusBar,
            #bsky-navigator-global-statusbar {
              max-width: ${contentWidth}px !important;
              margin-left: ${navWidthCollapsed + gap}px !important;
              margin-right: auto !important;
              transform: none !important;
            }
          }
          div[data-testid="homeScreenFeedTabs"],
          div[data-testid="profilePager"] {
            width: 100% !important;
            max-width: none !important;
          }
          /* Profile page: widen the profile content container */
          main[role="main"] div[data-testid="profilePager"] {
            width: ${contentWidth}px !important;
          }
          /* Also target the profile header/content wrapper */
          main[role="main"] [data-testid^="profile"] {
            max-width: ${contentWidth}px !important;
          }
          /* Position nav from left edge instead of center-relative */
          nav[role="navigation"] {
            left: 0 !important;
            transform: none !important;
            padding-left: 20px !important;
          }
        `;
        } else {
          const extraWidth = contentWidth - 600;
          const shiftRight = Math.floor(extraWidth / 2);
          styleEl.textContent = `
          main[role="main"] [style*="max-width: 600px"],
          main[role="main"] [style*="max-width:600px"] {
            max-width: ${contentWidth}px !important;
            transform: translateX(${shiftRight}px) !important;
          }
          div[data-testid="homeScreenFeedTabs"],
          div[data-testid="profilePager"] {
            width: 100% !important;
            max-width: none !important;
          }
          /* Profile page: widen the profile content container */
          main[role="main"] div[data-testid="profilePager"] {
            width: ${contentWidth}px !important;
            transform: translateX(${shiftRight}px) !important;
          }
          /* Also target the profile header/content wrapper */
          main[role="main"] [data-testid^="profile"] {
            max-width: ${contentWidth}px !important;
          }
          #statusBar,
          #bsky-navigator-global-statusbar {
            max-width: ${contentWidth}px !important;
            transform: translateX(${shiftRight}px) !important;
          }
        `;
        }
      } else if (styleEl) {
        styleEl.textContent = "";
      }
    }
    /**
     * Commits a filter - updates state, hides non-matching items, shows pill.
     * Only called on explicit user action (Enter, autocomplete select, saved search).
     */
    commitFilter(text) {
      const filterText = (text || "").trim();
      this.state.filter = filterText;
      this.state.stateManager.updateState({ filter: filterText });
      this.filterItems();
      this.updateFilterPill();
      this.updateFilterEnforcement();
      if (filterText) {
        announceToScreenReader(`Filter applied: ${filterText}`);
      }
    }
    /**
     * Starts or stops periodic filter enforcement.
     * React can replace DOM elements, losing our .filtered class.
     * This ensures TEXT-BASED filters stay applied.
     * Note: Read status and timeout filtering only happen on loadItems/refresh,
     * not continuously via this enforcement interval.
     */
    updateFilterEnforcement() {
      if (this._filterEnforcementInterval) {
        clearInterval(this._filterEnforcementInterval);
        this._filterEnforcementInterval = null;
      }
      if (this.state.filter) {
        this._filterEnforcementInterval = setInterval(() => {
          if (this.ignoreMouseMovement) return;
          const unfiltered = $(".item").not(".filtered").filter((i, item) => {
            return $(item).parents(".item").length === 0;
          });
          let itemsFiltered = false;
          if (unfiltered.length > 0) {
            unfiltered.each((i, item) => {
              const thread = $(item).closest(".thread");
              if (!this.filterItemTextOnly(item)) {
                $(item).addClass("filtered");
                itemsFiltered = true;
                if (thread.length && !this.filterThread(thread[0])) {
                  $(thread).addClass("filtered");
                }
              }
            });
          }
          if (itemsFiltered && !this.ignoreMouseMovement) {
            this.updateScrollPosition(true);
          }
        }, 200);
      }
    }
    /**
     * Filters an item based on text-based filter rules only.
     * Does NOT check read status or timeout status.
     * Used by filter enforcement interval to avoid hiding items automatically.
     * @param {Element} item - The feed item element
     * @returns {boolean} True if item passes text filter, false if filtered out
     */
    filterItemTextOnly(item) {
      if (!this.state.filter) {
        return true;
      }
      const activeRules = this.parseFilterRules(this.state.filter);
      const results = activeRules.map((rule) => this.evaluateFilterRule(item, rule));
      return results.every((result) => result === true);
    }
    /**
     * Applies filter after a short delay (debounced).
     * Called on input events while typing.
     */
    applyFilterDelayed() {
      if (this._filterTimeout) {
        clearTimeout(this._filterTimeout);
      }
      this._filterTimeout = setTimeout(() => {
        this.applyFilterImmediate();
      }, 500);
    }
    /**
     * Applies filter immediately (no delay).
     * Called on Enter key or after delay expires.
     */
    applyFilterImmediate() {
      if (this._filterTimeout) {
        clearTimeout(this._filterTimeout);
        this._filterTimeout = null;
      }
      const filterText = $(this.searchField).val().trim();
      this.commitFilter(filterText);
    }
    /**
     * Override onItemAdded to apply filter to newly added items.
     */
    onItemAdded(element) {
      super.onItemAdded(element);
      const hasActiveTimeouts = this.state.timeouts && Object.keys(this.state.timeouts).length > 0;
      if (this.state.filter || hasActiveTimeouts) {
        const thread = $(element).closest(".thread");
        const passes = this.filterItem(element, thread);
        if (!passes) {
          $(element).addClass("filtered");
          if (thread.length && !this.filterThread(thread[0])) {
            $(thread).addClass("filtered");
          }
        }
      }
    }
    /**
     * Handles Escape key in filter input.
     * If input differs from committed filter: revert to committed value.
     * If input matches committed filter: clear the filter entirely.
     */
    handleFilterEscape() {
      if (this._filterTimeout) {
        clearTimeout(this._filterTimeout);
        this._filterTimeout = null;
      }
      const inputValue = $(this.searchField).val().trim();
      const committedValue = this.state.filter || "";
      if (inputValue !== committedValue) {
        $(this.searchField).val(committedValue);
        this.filterItems();
        $(this.searchField).blur();
      } else {
        this.clearFilter();
        $(this.searchField).blur();
      }
    }
    updateFilterPill() {
      const existingPill = $("#bsky-navigator-filter-pill");
      if (!this.state.filter) {
        existingPill.remove();
        return;
      }
      if (!existingPill.length) {
        const pill = $(`
        <div id="bsky-navigator-filter-pill" class="filter-pill" role="status" aria-live="polite">
          <span class="filter-pill-text"></span>
          <button class="filter-pill-clear" aria-label="Clear filter" title="Clear filter">\xD7</button>
        </div>
      `);
        pill.find(".filter-pill-clear").on("click", (e) => {
          e.preventDefault();
          e.stopPropagation();
          this.clearFilter();
        });
        $(".search-wrapper").after(pill);
      }
      $("#bsky-navigator-filter-pill .filter-pill-text").text(this.state.filter);
      announceToScreenReader(`Filter active: ${this.state.filter}`);
    }
    clearFilter() {
      $("#bsky-navigator-search").val("");
      this.commitFilter("");
      announceToScreenReader("Filter cleared");
    }
    getSavedSearches() {
      try {
        const saved = this.config.get("savedSearches") || "[]";
        return JSON.parse(saved);
      } catch (e) {
        return [];
      }
    }
    saveSavedSearches(searches) {
      this.config.set("savedSearches", JSON.stringify(searches));
      this.config.save();
    }
    saveCurrentSearch() {
      const currentSearch = this.state.filter;
      if (!currentSearch || !currentSearch.trim()) {
        announceToScreenReader("No filter to save");
        return;
      }
      const searches = this.getSavedSearches();
      if (searches.includes(currentSearch)) {
        announceToScreenReader("Search already saved");
        return;
      }
      searches.push(currentSearch);
      this.saveSavedSearches(searches);
      announceToScreenReader(`Search "${currentSearch}" saved`);
      this.saveSearchBtn.addClass("save-search-btn-saved");
      setTimeout(() => this.saveSearchBtn.removeClass("save-search-btn-saved"), 300);
    }
    /**
     * Gets the reposter handle from a reposted item
     * @param {jQuery} $item - The feed item element wrapped in jQuery
     * @returns {string|null} Reposter handle or null if not a repost
     */
    getReposterHandle($item) {
      const repostLink = $item.closest(".thread").find('a[aria-label*="Reposted by"]').first();
      if (!repostLink.length) return null;
      const href = repostLink.attr("href") || "";
      const match2 = href.match(/\/profile\/([^/]+)/);
      return match2 ? match2[1] : null;
    }
    /**
     * Determines if an item should be shown based on read status and filter rules.
     * @param {Element} item - The feed item element
     * @param {Element} _thread - The parent thread element (unused)
     * @returns {boolean} True if item should be shown, false if filtered out
     */
    filterItem(item, _thread) {
      const $item = $(item);
      const handle2 = this.getAuthorHandle($item);
      if (handle2 && this.isTimedOut(handle2)) {
        return false;
      }
      const reposterHandle = this.getReposterHandle($item);
      if (reposterHandle && this.isTimedOut(reposterHandle)) {
        return false;
      }
      if (this.state.feedHideRead && this.name !== "post") {
        const postId = this.postIdForItem($item);
        if (postId && this.state.seen[postId]) {
          return false;
        }
      }
      if (!this.state.filter) {
        return true;
      }
      const activeRules = this.parseFilterRules(this.state.filter);
      const results = activeRules.map((rule) => this.evaluateFilterRule(item, rule));
      return results.every((result) => result === true);
    }
    /**
     * Parses filter text into structured rule objects.
     * @private
     */
    parseFilterRules(filterText) {
      return filterText.split(/[ ]+/).map((ruleStatement) => {
        const match2 = ruleStatement.match(/(!)?([$@%&])?"?([^"]+)"?/);
        return {
          invert: match2[1] === "!",
          matchType: match2[2] || null,
          query: match2[3]
        };
      });
    }
    /**
     * Evaluates a single filter rule against an item.
     * @private
     */
    evaluateFilterRule(item, rule) {
      let allowed = null;
      switch (rule.matchType) {
        case "$":
          allowed = this.evaluateNamedRule(item, rule.query);
          break;
        case "@":
          allowed = this.filterAuthor(item, rule.query);
          break;
        case "%":
          allowed = this.filterContent(item, rule.query);
          break;
        case "&":
          {
            const listName = rule.query;
            const listCache = this.state.listCache;
            if (!listCache) {
              console.warn("List rules require AT Protocol agent to be configured");
              allowed = false;
              break;
            }
            const authorHandle = this.getAuthorHandle(item);
            if (!authorHandle) {
              allowed = false;
              break;
            }
            const isInList = listCache.isInListSync?.(authorHandle, listName);
            if (isInList === void 0) {
              listCache.getMembers(listName);
              allowed = false;
            } else {
              allowed = isInList;
            }
          }
          break;
        default:
          allowed = this.filterAuthor(item, rule.query) || this.filterContent(item, rule.query);
      }
      return rule.invert ? !allowed : allowed;
    }
    /**
     * Evaluates a named rule set against an item.
     * @param {HTMLElement} item - The item to evaluate
     * @param {string} ruleName - The category name to evaluate
     * @param {Set} [visited] - Set of already visited categories (for circular dependency detection)
     * @private
     */
    evaluateNamedRule(item, ruleName, visited = /* @__PURE__ */ new Set()) {
      if (visited.has(ruleName)) {
        console.warn(`[Rules] Circular dependency detected: ${ruleName} already visited in chain: ${[...visited].join(" -> ")}`);
        return null;
      }
      const rules = this.state.rules?.[ruleName];
      if (!rules || !Array.isArray(rules)) {
        return null;
      }
      visited.add(ruleName);
      let allowed = null;
      const backingList = this.state.rules._backingLists?.[ruleName];
      if (backingList && this.state.listCache) {
        const authorHandle = this.getAuthorHandle(item);
        if (authorHandle) {
          const isInList = this.state.listCache.isInListSync?.(authorHandle, backingList);
          if (isInList === true) {
            return true;
          }
          if (isInList === void 0) {
            this.state.listCache.getMembers(backingList);
          }
        }
      }
      for (const rule of rules) {
        if (rule.type === "all") {
          allowed = rule.action === "allow";
        } else if (rule.type === "from" && this.filterAuthor(item, rule.value.substring(1))) {
          allowed = rule.action === "allow";
        } else if (rule.type === "content" && this.filterContent(item, rule.value)) {
          allowed = rule.action === "allow";
        } else if (rule.type === "include") {
          const includedResult = this.evaluateNamedRule(item, rule.value, visited);
          if (includedResult !== null) {
            allowed = rule.action === "allow" ? includedResult : !includedResult;
          }
        } else if (rule.type === "list") {
          const listCache = this.state.listCache;
          if (listCache) {
            const authorHandle = this.getAuthorHandle(item);
            if (authorHandle) {
              const isInList = listCache.isInListSync?.(authorHandle, rule.value);
              if (isInList !== void 0) {
                allowed = rule.action === "allow" ? isInList : !isInList;
              } else {
                listCache.getMembers(rule.value);
              }
            }
          }
        }
      }
      return allowed;
    }
    /**
     * Gets handle from item, with fallback to data-testid attribute.
     */
    getHandleForFilter(item) {
      let handle2 = this.handleFromItem(item);
      if (!handle2) {
        const testId = $(item).attr("data-testid") || "";
        const match2 = testId.match(/^feedItem-by-(.+)$/);
        if (match2) {
          handle2 = match2[1];
        }
      }
      return handle2;
    }
    /**
     * Extracts the author handle from a feed item
     * @param {Element} item - The feed item element
     * @returns {string|null} Author handle or null
     */
    getAuthorHandle(item) {
      return this.getHandleForFilter(item);
    }
    /**
     * Checks if an item's author matches a pattern.
     */
    filterAuthor(item, author) {
      const pattern = new RegExp(author, "i");
      const handle2 = this.getHandleForFilter(item);
      const displayName = this.displayNameFromItem(item);
      return pattern.test(handle2) || pattern.test(displayName);
    }
    filterContent(item, query) {
      const pattern = new RegExp(query, "i");
      const content = $(item).find('div[data-testid="postText"]').text();
      return pattern.test(content);
    }
    highlightFilterMatches(item) {
      $(item).find(".filter-highlight").contents().unwrap();
      if (!this.state.filter) return;
      const terms = this.state.filter.split(/\s+/).filter((term) => {
        return term && !term.startsWith("@") && !term.startsWith("$") && !term.startsWith("&") && !term.startsWith("!");
      }).map((term) => {
        return term.startsWith("%") ? term.substring(1) : term;
      });
      if (terms.length === 0) return;
      const postText = $(item).find('div[data-testid="postText"], .sidecar-post-content, .sidecar-quote-content');
      if (!postText.length) return;
      const pattern = new RegExp(`(${terms.map((t) => this.escapeRegex(t)).join("|")})`, "gi");
      postText.contents().each(function() {
        if (this.nodeType === Node.TEXT_NODE) {
          const text = this.textContent;
          if (pattern.test(text)) {
            const highlighted = text.replace(pattern, '<mark class="filter-highlight">$1</mark>');
            $(this).replaceWith(highlighted);
          }
        }
      });
    }
    escapeRegex(string2) {
      return string2.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }
    clearAllHighlights() {
      $(".filter-highlight").contents().unwrap();
    }
    filterThread(thread) {
      const items = $(thread).find("> div > .item");
      const filteredItems = items.filter(".filtered");
      return items.length !== filteredItems.length;
    }
    filterItems() {
      const perfEnd = this.perfStart("filterItems");
      const hideRead = this.state.feedHideRead;
      $("#filterIndicatorImage").attr("src", this.INDICATOR_IMAGES.filter[+hideRead]);
      $("#filterIndicator").attr(
        "title",
        `show all or unread (currently ${hideRead ? "unread" : "all"})`
      );
      this.clearAllHighlights();
      const allItems = $(".item").filter((i, item) => {
        return $(item).parents(".item").length === 0;
      });
      allItems.each((i, item) => {
        const thread = $(item).closest(".thread");
        const passes = this.filterItem(item, thread);
        if (passes) {
          $(item).removeClass("filtered");
          this.highlightFilterMatches(item);
        } else {
          $(item).addClass("filtered");
        }
      });
      const parent = $(this.selector).first().closest(".thread").parent();
      const unseenThreads = parent.find(".thread");
      $(unseenThreads).map((i, thread) => {
        if (this.filterThread(thread)) {
          $(thread).removeClass("filtered");
        } else {
          $(thread).addClass("filtered");
        }
      });
      if (!this.state.filter && !this.state.feedHideRead) {
        $(unseenThreads).map((i, thread) => {
          $(thread).find(".item").each((i2, item) => {
            const offset = parseInt($(item).data("bsky-navigator-thread-offset"));
            if (offset > 0 && $(item).hasClass("item-unread") && this.config.get("showReplyContext")) {
              const index = parseInt($(thread).data("bsky-navigator-thread-index"));
              const prev = $(
                `div[data-bsky-navigator-thread-index="${index}"] div[data-bsky-navigator-thread-offset="${offset - 1}"]`
              );
              $(prev).removeClass("filtered");
              $(prev).closest(".thread").removeClass("filtered");
            }
          });
        });
      }
      this.refreshItems();
      this.updateInfoIndicator();
      this.items = $(this.selector).filter(":visible").not(".filtered").filter((i, item) => {
        if (!item.isConnected || item.offsetParent === null) return false;
        const $item = $(item);
        if ($item.parents(this.selector).length > 0) return false;
        const testId = $item.attr("data-testid") || "";
        const ariaLabel = $item.attr("aria-label") || "";
        const hasPostUI = $item.find('[data-testid="postText"], [data-testid="likeBtn"]').length > 0;
        if (!testId.startsWith("feedItem-by-") && !testId.startsWith("postThreadItem-by-") && !ariaLabel.startsWith("Post by ") && !hasPostUI) return false;
        return true;
      });
      this.updateScrollPosition(true);
      if (hideRead && $(this.selectedItem).hasClass("item-read")) {
        this.jumpToNextUnseenItem();
      }
      perfEnd();
    }
    sortItems() {
      const perfEnd = this.perfStart("sortItems");
      const reversed = this.state.feedSortReverse;
      $("#sortIndicatorImage").attr("src", this.INDICATOR_IMAGES.sort[+reversed]);
      $("#sortIndicator").attr(
        "title",
        `change sort order (currently ${reversed ? "forward" : "reverse"} chronological)`
      );
      const parent = $(this.selector).closest(".thread").first().parent();
      const newItems = parent.children().filter((i, item) => $(item).hasClass("thread")).get().sort((a, b) => {
        const threadIndexA = parseInt($(a).data("bsky-navigator-thread-index"));
        const threadIndexB = parseInt($(b).data("bsky-navigator-thread-index"));
        const itemIndexA = parseInt($(a).find(".item").data("bsky-navigator-item-index"));
        const itemIndexB = parseInt($(b).find(".item").data("bsky-navigator-item-index"));
        if (threadIndexA !== threadIndexB) {
          return reversed ? threadIndexB - threadIndexA : threadIndexA - threadIndexB;
        }
        return itemIndexA - itemIndexB;
      });
      reversed ^ this.loadingNew ? parent.prepend(newItems) : parent.children(".thread").last().next().after(newItems);
      perfEnd();
    }
    updateInfoIndicator() {
      super.updateInfoIndicator();
      requestAnimationFrame(() => {
        this.updateScrollPosition();
      });
      this.updateBreadcrumb();
    }
    updateBreadcrumb() {
      let breadcrumb = $("#bsky-navigator-breadcrumb");
      if (!breadcrumb.length) {
        breadcrumb = $(`<nav id="bsky-navigator-breadcrumb" class="breadcrumb" aria-label="Current location"></nav>`);
        $(".toolbar-row").append(breadcrumb);
      }
      if (!this.selectedItem || !this.items.length) {
        breadcrumb.empty();
        return;
      }
      const parts = [];
      const activeTab = $('div[role="tablist"] [aria-selected="true"]').text().trim();
      if (activeTab) {
        parts.push({ label: activeTab, type: "feed" });
      } else {
        parts.push({ label: "Feed", type: "feed" });
      }
      const handle2 = this.handleFromItem(this.selectedItem);
      const displayName = this.displayNameFromItem(this.selectedItem);
      if (handle2) {
        parts.push({ label: displayName || `@${handle2}`, type: "author", handle: handle2 });
      }
      if (this.threadIndex != null && this.unrolledReplies.length > 0) {
        parts.push({ label: `Post ${this.threadIndex + 1}/${this.unrolledReplies.length + 1}`, type: "position" });
      } else if (this.replyIndex != null) {
        const replyCount = $(this.selectedItem).parent().find(".sidecar-post").length;
        parts.push({ label: `Reply ${this.replyIndex + 1}/${replyCount}`, type: "reply" });
      }
      const html = parts.map((part, i) => {
        const isLast = i === parts.length - 1;
        let content = "";
        if (part.type === "author" && part.handle) {
          content = `<a href="/profile/${part.handle}" class="breadcrumb-link">${this.escapeHtml(part.label)}</a>`;
        } else {
          content = `<span class="breadcrumb-text">${this.escapeHtml(part.label)}</span>`;
        }
        if (!isLast) {
          content += '<span class="breadcrumb-separator" aria-hidden="true">\u203A</span>';
        }
        return `<span class="breadcrumb-item">${content}</span>`;
      }).join("");
      breadcrumb.html(html);
    }
    escapeHtml(text) {
      const div = document.createElement("div");
      div.textContent = text;
      return div.innerHTML;
    }
    updateScrollPosition(forceRebuild = false) {
      const indicator = this.feedMap;
      if (!indicator || !indicator.length) return;
      const allItems = this.items.toArray ? this.items.toArray() : Array.from(this.items);
      let displayItems = [];
      let displayIndices = [];
      allItems.forEach((item, i) => {
        if (!$(item).hasClass("filtered")) {
          const $item = $(item);
          const testId = $item.attr("data-testid") || "";
          const ariaLabel = $item.attr("aria-label") || "";
          const hasPostUI = $item.find('[data-testid="postText"], [data-testid="likeBtn"]').length > 0;
          if (!testId.startsWith("feedItem-by-") && !testId.startsWith("postThreadItem-by-") && !ariaLabel.startsWith("Post by ") && !hasPostUI) {
            return;
          }
          displayItems.push(item);
          displayIndices.push(i);
        }
      });
      if (!displayItems.length) {
        indicator.find(".feed-map-segment").remove();
        indicator.find(".feed-map-viewport-indicator").remove();
        if (!indicator.find(".feed-map-empty").length) {
          indicator.append('<div class="feed-map-empty">No results</div>');
        }
        if (this.feedMapContainer) {
          this.feedMapContainer.show();
        }
        if (this.feedMapZoomContainer) {
          this.feedMapZoomContainer.hide();
        }
        if (this.feedMapConnector) {
          this.feedMapConnector.hide();
        }
        if (this.feedMapZoomHighlight) {
          this.feedMapZoomHighlight.hide();
        }
        return;
      }
      indicator.find(".feed-map-empty").remove();
      const indicatorStyle = this.config.get("feedMapStyle") || "Advanced";
      const isAdvancedStyle = indicatorStyle === "Advanced";
      if (isAdvancedStyle) {
        if (this.feedMapZoomContainer) {
          this.feedMapZoomContainer.show();
        }
        if (this.feedMapConnector) {
          this.feedMapConnector.show();
        }
        if (this.feedMapZoomHighlight) {
          this.feedMapZoomHighlight.show();
        }
      } else {
        if (this.feedMapZoomContainer) {
          this.feedMapZoomContainer.hide();
        }
        if (this.feedMapConnector) {
          this.feedMapConnector.hide();
        }
        if (this.feedMapZoomHighlight) {
          this.feedMapZoomHighlight.hide();
        }
      }
      this._displayItems = displayItems;
      const total = displayItems.length;
      const selectedElement = this.items[this.index];
      const currentDisplayIndex = displayItems.indexOf(selectedElement);
      let segments = indicator.find(".feed-map-segment");
      if (segments.length !== total) {
        if (!forceRebuild && (this.loading || this.loadingNew)) {
          return;
        }
        indicator.find(".feed-map-segment").remove();
        indicator.find(".feed-map-viewport-indicator").remove();
        for (let i = 0; i < total; i++) {
          const segment = $('<div class="feed-map-segment"></div>');
          segment.attr("data-index", i);
          indicator.append(segment);
        }
        indicator.append('<div class="feed-map-viewport-indicator"></div>');
        segments = indicator.find(".feed-map-segment");
      }
      const heatmapMode = isAdvancedStyle ? this.config.get("feedMapHeatmap") || "None" : "None";
      const iconsValue = this.config.get("feedMapIcons");
      const showIcons = isAdvancedStyle ? iconsValue === true || iconsValue === "true" || iconsValue === void 0 : false;
      const showAvatars = isAdvancedStyle ? this.config.get("feedMapAvatars") !== false : false;
      const avatarScale = this.config.get("feedMapAvatarScale") ?? 100;
      const showTimestamps = isAdvancedStyle ? this.config.get("feedMapTimestamps") !== false : false;
      const showHandles = isAdvancedStyle ? this.config.get("feedMapHandles") !== false : false;
      const showRuleColors = isAdvancedStyle && this.config.get("ruleColorCoding");
      let engagementData = [];
      let maxScore = 0;
      if (isAdvancedStyle && (heatmapMode !== "None" || showIcons || showAvatars || showHandles)) {
        engagementData = allItems.map((item) => {
          const engagement = this.getPostEngagement(item);
          const score = heatmapMode !== "None" ? this.calculateEngagementScore(engagement, heatmapMode) : 0;
          return { engagement, score };
        });
        displayItems.forEach((item, i) => {
          const actualIndex = displayIndices[i];
          if (engagementData[actualIndex]?.score > maxScore) {
            maxScore = engagementData[actualIndex].score;
          }
        });
      }
      segments.each((i, segment) => {
        const $segment = $(segment);
        $segment.empty();
        const item = displayItems[i];
        const actualIndex = displayIndices[i];
        $segment.data("item", item || null);
        if (!item || !document.contains(item)) {
          $segment.addClass("feed-map-segment-virtualized");
          return;
        }
        $segment.removeClass("feed-map-segment-virtualized");
        const isRead = $(item).hasClass("item-read");
        const isCurrent = i === currentDisplayIndex;
        $segment.removeClass(
          "feed-map-segment-read feed-map-segment-current feed-map-segment-ratioed feed-map-segment-heat-1 feed-map-segment-heat-2 feed-map-segment-heat-3 feed-map-segment-heat-4 feed-map-segment-heat-5 feed-map-segment-heat-6 feed-map-segment-heat-7 feed-map-segment-heat-8"
        );
        $segment.find(".feed-map-segment-icon, .feed-map-segment-progress").remove();
        if (isRead) {
          $segment.addClass("feed-map-segment-read");
        }
        if (isCurrent) {
          $segment.addClass("feed-map-segment-current");
        }
        if (engagementData[actualIndex]?.engagement?.isRatioed) {
          $segment.addClass("feed-map-segment-ratioed");
        } else if (heatmapMode !== "None" && engagementData[actualIndex]) {
          const heatLevel = this.getHeatLevel(engagementData[actualIndex].score, maxScore);
          if (heatLevel > 0) {
            $segment.addClass(`feed-map-segment-heat-${heatLevel}`);
          }
        }
        if (showIcons && engagementData[actualIndex]?.engagement) {
          const icon = this.getContentIcon(engagementData[actualIndex].engagement);
          if (icon) {
            $segment.append(`<span class="feed-map-segment-icon">${icon}</span>`);
          }
        }
        if (isAdvancedStyle && engagementData[actualIndex]?.engagement?.unrolledCount > 0) {
          const unrolledCount = engagementData[actualIndex].engagement.unrolledCount;
          const totalPosts = unrolledCount + 1;
          const currentThreadIndex = isCurrent && this.threadIndex != null ? this.threadIndex : -1;
          let segmentsHtml = "";
          for (let i2 = 0; i2 < totalPosts; i2++) {
            const isVisited = i2 <= currentThreadIndex;
            const segmentClass = isVisited ? "feed-map-thread-segment feed-map-thread-segment-visited" : "feed-map-thread-segment";
            segmentsHtml += `<div class="${segmentClass}"></div>`;
          }
          $segment.append(`<div class="feed-map-segment-progress" data-total="${totalPosts}">${segmentsHtml}</div>`);
        }
      });
      if (showIcons && total > 0) {
        const indicatorWidth = indicator.width();
        if (indicatorWidth > 0) {
          const segmentWidth = indicatorWidth / total;
          if (segmentWidth < 16) {
            indicator.css("--feed-map-icon-display", "none");
          } else {
            indicator.css("--feed-map-icon-display", "flex");
          }
        }
      }
      this.updateViewportIndicator(indicator, total);
      if (this.feedMapZoom && isAdvancedStyle) {
        this.updateFeedMapZoom(currentDisplayIndex, engagementData, heatmapMode, showIcons, showAvatars, avatarScale, showTimestamps, showHandles, showRuleColors, maxScore, total, displayItems, displayIndices);
      }
      this.updateFeedMapLabels();
      const position = currentDisplayIndex >= 0 ? currentDisplayIndex + 1 : 0;
      const percentage = total > 0 ? Math.round(position / total * 100) : 0;
      indicator.attr("aria-valuenow", percentage);
      indicator.attr("title", `${position} of ${total} items (${percentage}%)`);
    }
    updateFeedMapLabels() {
      if (!this.feedMapLabelStart || !this.feedMapLabelEnd) return;
      if (!this.items.length) return;
      const firstItem = this.items[0];
      const lastItem = this.items[this.items.length - 1];
      let firstTimestamp = this.getTimestampForItem(firstItem);
      let lastTimestamp = this.getTimestampForItem(lastItem);
      const reversed = this.state.feedSortReverse;
      if (firstTimestamp && lastTimestamp) {
        const shouldSwap = reversed ? firstTimestamp > lastTimestamp : firstTimestamp < lastTimestamp;
        if (shouldSwap) {
          [firstTimestamp, lastTimestamp] = [lastTimestamp, firstTimestamp];
        }
      }
      const formatCompact = (date) => {
        if (!date) return "";
        const now = /* @__PURE__ */ new Date();
        const isToday = date.toDateString() === now.toDateString();
        const isThisYear = date.getFullYear() === now.getFullYear();
        if (isToday) {
          return format(date, "h:mma").toLowerCase();
        } else if (isThisYear) {
          return format(date, "M/d h:mma").toLowerCase();
        } else {
          return format(date, "M/d/yy h:mma").toLowerCase();
        }
      };
      this.feedMapLabelStart.text(formatCompact(firstTimestamp));
      this.feedMapLabelEnd.text(formatCompact(lastTimestamp));
    }
    /**
     * Extract engagement metrics from a post element
     */
    getPostEngagement(item) {
      if (!item) return null;
      const $item = $(item);
      const getCount = (selector) => {
        const btn = $item.find(selector);
        if (!btn.length) {
          const threadBtn = $item.closest(".thread").find(selector);
          if (threadBtn.length) {
            const label2 = threadBtn.attr("aria-label") || "";
            const match3 = label2.match(/(\d+(?:,\d+)*(?:\.\d+)?[KMB]?)/i);
            if (match3) return this.parseCount(match3[1]);
            return this.parseCount(threadBtn.text().trim()) || 0;
          }
          return 0;
        }
        const label = btn.attr("aria-label") || "";
        const match2 = label.match(/(\d+(?:,\d+)*(?:\.\d+)?[KMB]?)/i);
        if (match2) {
          return this.parseCount(match2[1]);
        }
        const text = btn.text().trim();
        return this.parseCount(text) || 0;
      };
      const likes = getCount('button[data-testid="likeBtn"]');
      const reposts = getCount('button[data-testid="repostBtn"]');
      const replies = getCount('button[data-testid="replyBtn"]');
      const timestamp = this.getTimestampForItem(item);
      const hoursOld = timestamp ? (Date.now() - timestamp.getTime()) / (1e3 * 60 * 60) : 1;
      const postId = this.postIdForItem($item);
      const $thread = $item.closest(".thread");
      const $searchScope = $thread.length ? $thread : $item;
      let hasImage = $searchScope.find('img[src*="feed_thumbnail"], img[src*="feed_fullsize"]').length > 0;
      let hasVideo = $searchScope.find('video, div[data-testid*="video"], button[aria-label="Play Video"], [data-testid="videoPlayer"], img[src*="video.bsky"]').length > 0;
      const hasEmbed = $searchScope.find('div[data-testid="contentHider-embed"]').length > 0;
      if (!hasVideo) {
        $searchScope.find("img").each((i, img) => {
          if (img.src && img.src.includes("video")) {
            hasVideo = true;
            return false;
          }
        });
      }
      if (postId && this.mediaCache) {
        const cached = this.mediaCache[postId];
        if (cached) {
          hasImage = hasImage || cached.hasImage;
          hasVideo = hasVideo || cached.hasVideo;
        }
        if (hasImage || hasVideo) {
          this.mediaCache[postId] = { hasImage, hasVideo };
        }
      }
      const isRepost = $item.closest(".thread").find('svg[aria-label*="Reposted"]').length > 0 || $item.closest(".thread").find('a[aria-label*="Reposted by"]').length > 0;
      const isReply = $item.find('div[data-testid*="replyLine"]').length > 0 || $item.closest(".thread").find('a[href*="/post/"][aria-label*="Reply"]').length > 0;
      let isSelfThread = false;
      if (postId && this.selfThreadCache && this.selfThreadCache[postId]) {
        isSelfThread = true;
      }
      let unrolledCount = 0;
      if (!isSelfThread) {
        const unrolledInItem = $item.find(".unrolled-replies");
        const unrolledInThread = $thread.length ? $thread.find(".unrolled-replies") : $();
        if (unrolledInItem.length > 0 || unrolledInThread.length > 0) {
          isSelfThread = true;
          const unrolledReplies = (unrolledInItem.length > 0 ? unrolledInItem : unrolledInThread).find(".unrolled-reply");
          unrolledCount = unrolledReplies.length;
        } else {
          const unrolledGlobal = $(".unrolled-replies");
          if (unrolledGlobal.length > 0) {
            const unrolledParent = unrolledGlobal.closest('[data-testid^="feedItem-by-"]');
            const unrolledPostId = unrolledParent.length ? this.postIdForItem(unrolledParent) : null;
            if (unrolledPostId === postId) {
              isSelfThread = true;
              unrolledCount = unrolledGlobal.find(".unrolled-reply").length;
            }
          }
        }
      } else {
        const unrolledInItem = $item.find(".unrolled-replies");
        const unrolledInThread = $thread.length ? $thread.find(".unrolled-replies") : $();
        if (unrolledInItem.length > 0) {
          unrolledCount = unrolledInItem.find(".unrolled-reply").length;
        } else if (unrolledInThread.length > 0) {
          unrolledCount = unrolledInThread.find(".unrolled-reply").length;
        }
      }
      if (!isSelfThread && !isReply && !isRepost) {
        const threadLineDown = $item.find('.r-lchren[style*="margin-top"]');
        if (threadLineDown.length > 0) {
          const author = this.handleFromItem($item);
          const $container = $item.parent().parent();
          const $nextContainer = $container.next();
          if ($nextContainer.length) {
            const $nextItem = $nextContainer.find('[data-testid^="feedItem-by-"]');
            if ($nextItem.length) {
              const nextAuthor = this.handleFromItem($nextItem);
              if (author && nextAuthor && author === nextAuthor) {
                isSelfThread = true;
              }
            }
          }
        }
      }
      const isRatioed = replies > likes && likes + replies >= 10;
      const avatarImg = $item.find('div[data-testid="userAvatarImage"] img').first();
      const avatarUrl = avatarImg.length ? avatarImg.attr("src") : null;
      let handle2 = this.handleFromItem($item);
      if (!handle2) {
        const testId = $item.attr("data-testid") || "";
        const match2 = testId.match(/^feedItem-by-(.+)$/);
        if (match2) {
          handle2 = match2[1];
        }
      }
      let reposterAvatarUrl = null;
      let reposterHandle = null;
      if (isRepost && postId && this.reposterProfileCache) {
        const reposterProfile = this.reposterProfileCache[postId];
        if (reposterProfile) {
          reposterAvatarUrl = reposterProfile.avatar;
          reposterHandle = reposterProfile.handle;
        }
      }
      return {
        likes,
        reposts,
        replies,
        total: likes + reposts + replies,
        hoursOld: Math.max(0.1, hoursOld),
        // Minimum 6 minutes to avoid division issues
        hasImage,
        hasVideo,
        hasEmbed,
        hasMedia: hasImage || hasVideo,
        isRepost,
        isReply,
        isSelfThread,
        isRatioed,
        avatarUrl,
        handle: handle2,
        reposterAvatarUrl,
        reposterHandle,
        unrolledCount
        // Number of unrolled replies (0 if not unrolled)
      };
    }
    /**
     * Parse count strings like "1.2K", "5M", etc.
     */
    parseCount(str) {
      if (!str) return 0;
      str = String(str).trim().replace(/,/g, "");
      const match2 = str.match(/^(\d+(?:\.\d+)?)\s*([KMB])?$/i);
      if (!match2) return 0;
      let num = parseFloat(match2[1]);
      const suffix = (match2[2] || "").toUpperCase();
      if (suffix === "K") num *= 1e3;
      else if (suffix === "M") num *= 1e6;
      else if (suffix === "B") num *= 1e9;
      return Math.round(num);
    }
    /**
     * Calculate engagement score based on heatmap mode
     */
    calculateEngagementScore(engagement, mode) {
      if (!engagement) return 0;
      switch (mode) {
        case "Engagement Rate":
          return engagement.total / engagement.hoursOld;
        case "Raw Engagement":
          return engagement.total;
        case "Weighted Engagement":
          return (engagement.likes * 1 + engagement.reposts * 2 + engagement.replies * 3) / engagement.hoursOld;
        default:
          return 0;
      }
    }
    /**
     * Get heat level (1-8) for a score relative to all scores
     */
    getHeatLevel(score, maxScore) {
      if (maxScore === 0 || score === 0) return 0;
      const normalized = score / maxScore;
      return Math.min(8, Math.max(1, Math.ceil(normalized * 8)));
    }
    /**
     * Get icon/emoji for post content type
     */
    getContentIcon(engagement) {
      if (!engagement) return "";
      let postTypeIcon;
      if (engagement.isSelfThread) {
        postTypeIcon = `<img src="${this.INDICATOR_IMAGES.contentThread}" alt="thread">`;
      } else if (engagement.isRepost) {
        postTypeIcon = `<img src="${this.INDICATOR_IMAGES.contentRepost}" alt="repost">`;
      } else if (engagement.isReply) {
        postTypeIcon = `<img src="${this.INDICATOR_IMAGES.contentReply}" alt="reply">`;
      } else {
        postTypeIcon = `<img src="${this.INDICATOR_IMAGES.contentPost}" alt="post">`;
      }
      let mediaIcon;
      if (engagement.hasVideo) {
        mediaIcon = `<img src="${this.INDICATOR_IMAGES.contentVideo}" alt="video">`;
      } else if (engagement.hasImage) {
        mediaIcon = `<img src="${this.INDICATOR_IMAGES.contentImage}" alt="image">`;
      } else if (engagement.hasEmbed) {
        mediaIcon = `<img src="${this.INDICATOR_IMAGES.contentEmbed}" alt="embed">`;
      } else {
        mediaIcon = `<img src="${this.INDICATOR_IMAGES.contentText}" alt="text">`;
      }
      return `<span class="feed-map-icon-stack">${postTypeIcon}${mediaIcon}</span>`;
    }
    /**
     * Set up click handler for feed map to jump to posts
     */
    setupScrollIndicatorClick() {
      if (!this.feedMap) return;
      this.feedMap.css("cursor", "pointer");
      this.feedMap.on("mousedown", (event) => {
        event.preventDefault();
      });
      this.feedMap.on("click", (event) => {
        event.preventDefault();
        event.stopPropagation();
        const indicator = $(event.currentTarget);
        const indicatorWidth = indicator.width();
        const clickX = event.pageX - indicator.offset().left;
        const displayItems = this._displayItems || [];
        const total = displayItems.length || this.items.length;
        if (total === 0) return;
        const segmentWidth = indicatorWidth / total;
        const clickedDisplayIndex = Math.floor(clickX / segmentWidth);
        const clampedDisplayIndex = Math.max(0, Math.min(total - 1, clickedDisplayIndex));
        const targetElement = displayItems[clampedDisplayIndex];
        if (!targetElement) return;
        const targetIndex = this.items.index(targetElement);
        if (targetIndex === -1) return;
        if (targetIndex !== this.index) {
          this.setIndex(targetIndex, false, true);
          this.updateScrollPosition();
          this.updateBreadcrumb();
        }
      });
    }
    /**
     * Set up click handler for feed map zoom to jump to posts
     */
    setupScrollIndicatorZoomClick() {
      if (!this.feedMapZoom) return;
      this.feedMapZoom.css("cursor", "pointer");
      this.feedMapZoom.on("click", (event) => {
        const zoomIndicator = $(event.currentTarget);
        const indicatorWidth = zoomIndicator.width();
        const clickX = event.pageX - zoomIndicator.offset().left;
        if (!this.config.get("feedMapZoomEnabled")) return;
        const zoomWindowSize = parseInt(this.config.get("feedMapZoom"), 10) || 5;
        const displayItems = this._displayItems || [];
        const total = displayItems.length || this.items.length;
        if (total === 0) return;
        const windowStart = this.zoomWindowStart || 0;
        const segmentWidth = indicatorWidth / zoomWindowSize;
        const clickedOffset = Math.floor(clickX / segmentWidth);
        const displayIndex = Math.max(0, Math.min(total - 1, windowStart + clickedOffset));
        const targetElement = displayItems[displayIndex];
        if (!targetElement) return;
        const targetIndex = this.items.index(targetElement);
        if (targetIndex === -1) return;
        if (targetIndex !== this.index) {
          this.setIndex(targetIndex, false, true);
          this.updateScrollPosition();
          this.updateBreadcrumb();
        }
      });
    }
    /**
     * Set up horizontal scroll handler for feed map
     * Allows panning the feed map view by using mouse wheel while hovering over it
     */
    setupScrollIndicatorScroll() {
      let accumulatedDelta = 0;
      let scrollTimeout = null;
      const handleWheel = (event) => {
        event.preventDefault();
        event.stopPropagation();
        const displayItems = this._displayItems || [];
        const total = displayItems.length || this.items.length;
        if (total === 0) return;
        const zoomEnabled = this.config.get("feedMapZoomEnabled");
        let zoomWindowSize = parseInt(this.config.get("feedMapZoom"), 10) || 5;
        if (event.originalEvent.ctrlKey || event.originalEvent.metaKey) {
          const delta2 = event.originalEvent.deltaY;
          const zoomThreshold = 50;
          accumulatedDelta += delta2;
          if (Math.abs(accumulatedDelta) >= zoomThreshold) {
            const zoomChange = accumulatedDelta > 0 ? -1 : 1;
            accumulatedDelta = 0;
            const newZoomSize = Math.max(3, Math.min(20, zoomWindowSize + zoomChange));
            if (newZoomSize !== zoomWindowSize) {
              if (!zoomEnabled) {
                this.config.set("feedMapZoomEnabled", true);
              }
              this.config.set("feedMapZoom", newZoomSize);
              this.updateScrollPosition(true);
            }
          }
          return;
        }
        if (!zoomEnabled || total <= zoomWindowSize) return;
        const delta = event.originalEvent.deltaX !== 0 ? event.originalEvent.deltaX : event.originalEvent.deltaY;
        accumulatedDelta += delta;
        const threshold = 50;
        if (scrollTimeout) {
          clearTimeout(scrollTimeout);
        }
        const steps = Math.trunc(accumulatedDelta / threshold);
        if (steps !== 0) {
          accumulatedDelta = accumulatedDelta % threshold;
          const currentStart = this.zoomWindowStart || 0;
          const maxStart = total - zoomWindowSize;
          const newWindowStart = Math.max(0, Math.min(maxStart, currentStart + steps));
          if (newWindowStart !== currentStart) {
            this.zoomWindowManualPan = true;
            this.zoomWindowStart = newWindowStart;
            this.updateFeedMapZoomDirect(newWindowStart, zoomWindowSize, total, displayItems);
          }
        }
        scrollTimeout = setTimeout(() => {
          accumulatedDelta = 0;
        }, 150);
      };
      if (this.feedMap) {
        this.feedMap.on("wheel", handleWheel);
      }
      if (this.feedMapZoom) {
        this.feedMapZoom.on("wheel", handleWheel);
      }
    }
    /**
     * Direct update of feed map zoom for smooth panning (bypasses full updateScrollPosition)
     */
    updateFeedMapZoomDirect(windowStart, zoomWindowSize, total, displayItems) {
      const zoomIndicator = this.feedMapZoom;
      const zoomInner = this.feedMapZoomInner;
      if (!zoomIndicator || !zoomInner) return;
      const windowEnd = Math.min(total - 1, windowStart + zoomWindowSize - 1);
      const selectedElement = this.items[this.index];
      const currentIndex = displayItems.indexOf(selectedElement);
      const indicatorStyle = this.config.get("feedMapStyle") || "Advanced";
      const isAdvancedStyle = indicatorStyle === "Advanced";
      const heatmapMode = isAdvancedStyle ? this.config.get("feedMapHeatmap") || "None" : "None";
      const iconsValue = this.config.get("feedMapIcons");
      const showIcons = isAdvancedStyle ? iconsValue === true || iconsValue === "true" || iconsValue === void 0 : false;
      const showAvatars = isAdvancedStyle ? this.config.get("feedMapAvatars") !== false : false;
      const avatarScale = this.config.get("feedMapAvatarScale") ?? 100;
      const showTimestamps = isAdvancedStyle ? this.config.get("feedMapTimestamps") !== false : false;
      const showHandles = isAdvancedStyle ? this.config.get("feedMapHandles") !== false : false;
      const showRuleColors = isAdvancedStyle && this.config.get("ruleColorCoding");
      let maxScore = 0;
      const windowEngagement = [];
      for (let i = 0; i < zoomWindowSize; i++) {
        const displayIndex = windowStart + i;
        const item = displayItems[displayIndex];
        if (item && (heatmapMode !== "None" || showIcons || showAvatars || showHandles)) {
          const engagement = this.getPostEngagement(item);
          const score = heatmapMode !== "None" ? this.calculateEngagementScore(engagement, heatmapMode) : 0;
          if (score > maxScore) maxScore = score;
          windowEngagement[i] = { engagement, score };
        } else {
          windowEngagement[i] = null;
        }
      }
      const segments = zoomInner.find(".feed-map-segment");
      segments.each((i, segment) => {
        const $segment = $(segment);
        $segment.empty();
        const displayIndex = windowStart + i;
        const item = displayItems[displayIndex];
        const hasItem = displayIndex >= 0 && displayIndex < total && item;
        const isRead = item && $(item).hasClass("item-read");
        const isCurrent = displayIndex === currentIndex;
        $segment.data("item", hasItem ? item : null);
        $segment.removeClass(
          "feed-map-segment-read feed-map-segment-current feed-map-segment-empty feed-map-segment-ratioed feed-map-segment-heat-1 feed-map-segment-heat-2 feed-map-segment-heat-3 feed-map-segment-heat-4 feed-map-segment-heat-5 feed-map-segment-heat-6 feed-map-segment-heat-7 feed-map-segment-heat-8"
        );
        $segment.find(".feed-map-segment-icon, .feed-map-segment-avatar, .feed-map-segment-handle, .feed-map-segment-time, .feed-map-segment-progress").remove();
        if (!hasItem) {
          $segment.addClass("feed-map-segment-empty");
          return;
        }
        if (isRead) $segment.addClass("feed-map-segment-read");
        if (isCurrent) $segment.addClass("feed-map-segment-current");
        const engData = windowEngagement[i];
        if (engData?.engagement?.isRatioed) {
          $segment.addClass("feed-map-segment-ratioed");
        } else if (heatmapMode !== "None" && engData) {
          const heatLevel = this.getHeatLevel(engData.score, maxScore);
          if (heatLevel > 0) {
            $segment.addClass(`feed-map-segment-heat-${heatLevel}`);
          }
        }
        if (showIcons && engData?.engagement) {
          const icon = this.getContentIcon(engData.engagement);
          if (icon) {
            $segment.append(`<span class="feed-map-segment-icon">${icon}</span>`);
          }
        }
        if (showAvatars && engData?.engagement?.avatarUrl) {
          const avatarHeight = Math.round(32 * (avatarScale / 100));
          let avatarStyle = `height: ${avatarHeight}px`;
          if (showRuleColors && engData?.engagement?.handle) {
            const categoryIndex = this.getFilterCategoryIndexForHandle(engData.engagement.handle);
            if (categoryIndex >= 0) {
              const color = this.getColorForCategoryIndex(categoryIndex);
              avatarStyle += `; box-shadow: 0 0 0 2px ${color}; border-radius: 50%`;
            }
          }
          const blockInfo = this.getClearskyBlockInfo(engData?.engagement?.handle);
          if (blockInfo.type && blockInfo.color) {
            avatarStyle += `; box-shadow: 0 0 0 3px ${blockInfo.color}; border-radius: 50%`;
          }
          if (engData?.engagement?.isRepost && engData?.engagement?.reposterAvatarUrl) {
            const reposterHeight = Math.round(avatarHeight * 0.5);
            let reposterStyle = `height: ${reposterHeight}px`;
            if (showRuleColors && engData?.engagement?.reposterHandle) {
              const reposterCategoryIndex = this.getFilterCategoryIndexForHandle(engData.engagement.reposterHandle);
              if (reposterCategoryIndex >= 0) {
                const color = this.getColorForCategoryIndex(reposterCategoryIndex);
                reposterStyle += `; box-shadow: 0 0 0 1px ${color}`;
              }
            }
            const reposterBlockInfo = this.getClearskyBlockInfo(engData?.engagement?.reposterHandle);
            if (reposterBlockInfo.type && reposterBlockInfo.color) {
              reposterStyle += `; box-shadow: 0 0 0 2px ${reposterBlockInfo.color}`;
            }
            $segment.append(`
            <span class="feed-map-segment-avatar-container">
              <img class="feed-map-segment-avatar" src="${engData.engagement.avatarUrl}" alt="" style="${avatarStyle}">
              <img class="feed-map-segment-reposter-avatar" src="${engData.engagement.reposterAvatarUrl}" alt="" style="${reposterStyle}">
            </span>
          `);
          } else {
            $segment.append(`<img class="feed-map-segment-avatar" src="${engData.engagement.avatarUrl}" alt="" style="${avatarStyle}">`);
          }
        }
        if (showHandles && engData?.engagement?.handle) {
          const handle2 = engData.engagement.handle;
          const dotIndex = handle2.indexOf(".");
          const handleHtml = dotIndex > 0 ? `<span class="feed-map-segment-handle-name">${handle2.substring(0, dotIndex)}</span><span class="feed-map-segment-handle-domain">${handle2.substring(dotIndex)}</span>` : `<span class="feed-map-segment-handle-name">${handle2}</span>`;
          let handleStyle = "";
          if (showRuleColors) {
            const categoryIndex = this.getFilterCategoryIndexForHandle(handle2);
            if (categoryIndex >= 0) {
              const color = this.getColorForCategoryIndex(categoryIndex);
              handleStyle = ` style="background-color: ${color}55; border: 1px solid ${color}88; border-radius: 3px; padding: 0 2px;"`;
            }
          }
          const blockInfo = this.getClearskyBlockInfo(handle2);
          if (blockInfo.type && blockInfo.color) {
            handleStyle = ` style="background-color: ${blockInfo.color}55; border: 2px solid ${blockInfo.color}; border-radius: 3px; padding: 0 2px;"`;
          }
          $segment.append(`<span class="feed-map-segment-handle"${handleStyle}>${handleHtml}</span>`);
        }
        if (showTimestamps) {
          const timestamp = this.getTimestampForItem(item);
          if (timestamp) {
            const relativeTime = this.formatRelativeTime(timestamp);
            let timeStyle = "";
            if (showRuleColors) {
              const categoryIndex = this.getFilterCategoryIndexForContent(item);
              if (categoryIndex >= 0) {
                const color = this.getColorForCategoryIndex(categoryIndex);
                timeStyle = ` style="background-color: ${color}55; border: 1px solid ${color}88; border-radius: 3px; padding: 0 2px;"`;
              }
            }
            $segment.append(`<span class="feed-map-segment-time"${timeStyle}>${relativeTime}</span>`);
          }
        }
        if (engData?.engagement?.unrolledCount > 0) {
          const unrolledCount = engData.engagement.unrolledCount;
          const totalPosts = unrolledCount + 1;
          const currentThreadIndex = isCurrent && this.threadIndex != null ? this.threadIndex : -1;
          let segmentsHtml = "";
          for (let i2 = 0; i2 < totalPosts; i2++) {
            const isVisited = i2 <= currentThreadIndex;
            const segmentClass = isVisited ? "feed-map-thread-segment feed-map-thread-segment-visited" : "feed-map-thread-segment";
            segmentsHtml += `<div class="${segmentClass}"></div>`;
          }
          $segment.append(`<div class="feed-map-segment-progress" data-total="${totalPosts}">${segmentsHtml}</div>`);
        }
      });
      this.updateFeedMapZoomLabels(windowStart, windowEnd);
      const atStart = windowStart === 0;
      const atEnd = windowStart + zoomWindowSize >= total;
      zoomIndicator.toggleClass("feed-map-zoom-at-start", atStart);
      zoomIndicator.toggleClass("feed-map-zoom-at-end", atEnd);
      this.updateFeedMapZoomConnector(windowStart, windowEnd, total);
    }
    /**
     * Update the feed map zoom showing posts around the current selection
     */
    updateFeedMapZoom(currentIndex, engagementData, heatmapMode, showIcons, showAvatars, avatarScale, showTimestamps, showHandles, showRuleColors, maxScore, displayTotal, displayItems, displayIndices) {
      const zoomIndicator = this.feedMapZoom;
      const zoomInner = this.feedMapZoomInner;
      if (!zoomIndicator || !zoomInner) return;
      if (this.loading || this.loadingNew) return;
      if (!this.config.get("feedMapZoomEnabled")) return;
      const zoomWindowSize = parseInt(this.config.get("feedMapZoom"), 10) || 5;
      const total = displayTotal;
      if (total <= zoomWindowSize) {
        if (this.feedMapContainer) {
          this.feedMapContainer.hide();
        }
        if (this.feedMapConnector) {
          this.feedMapConnector.hide();
        }
        if (this.feedMapZoomHighlight) {
          this.feedMapZoomHighlight.hide();
        }
        this.feedMapZoomContainer.show();
      } else {
        if (this.feedMapContainer) {
          this.feedMapContainer.show();
        }
        this.feedMapZoomContainer.show();
        if (this.feedMapConnector) {
          this.feedMapConnector.show();
        }
        if (this.feedMapZoomHighlight) {
          this.feedMapZoomHighlight.show();
        }
      }
      if (total === 0) return;
      const edgeMargin = Math.max(1, Math.floor(zoomWindowSize * 0.2));
      let windowStart = this.zoomWindowStart;
      if (windowStart === null) {
        const halfWindow = Math.floor(zoomWindowSize / 2);
        windowStart = Math.max(0, currentIndex - halfWindow);
      } else if (this.zoomWindowManualPan) {
        const windowEnd2 = windowStart + zoomWindowSize - 1;
        if (currentIndex < windowStart || currentIndex > windowEnd2) {
          const halfWindow = Math.floor(zoomWindowSize / 2);
          windowStart = Math.max(0, currentIndex - halfWindow);
          this.zoomWindowManualPan = false;
        }
      } else {
        const windowEnd2 = windowStart + zoomWindowSize - 1;
        if (currentIndex < windowStart + edgeMargin) {
          windowStart = Math.max(0, currentIndex - edgeMargin);
        } else if (currentIndex > windowEnd2 - edgeMargin) {
          windowStart = currentIndex - (zoomWindowSize - 1 - edgeMargin);
        }
      }
      windowStart = Math.max(0, windowStart);
      if (windowStart + zoomWindowSize > total) {
        windowStart = Math.max(0, total - zoomWindowSize);
      }
      let segments = zoomInner.find(".feed-map-segment");
      if (segments.length !== zoomWindowSize) {
        zoomInner.find(".feed-map-segment").remove();
        for (let i = 0; i < zoomWindowSize; i++) {
          const segment = $('<div class="feed-map-segment feed-map-segment-zoom"></div>');
          zoomInner.append(segment);
        }
        segments = zoomInner.find(".feed-map-segment");
      }
      if (this.zoomWindowStart !== null && this.zoomWindowStart !== windowStart) {
        const shift = windowStart - this.zoomWindowStart;
        const segmentWidth = zoomIndicator.width() / zoomWindowSize;
        const offsetPx = -shift * segmentWidth;
        zoomInner.removeClass("feed-map-zoom-animating");
        zoomInner.css("transform", `translateX(${offsetPx}px)`);
        zoomInner[0].offsetHeight;
        zoomInner.addClass("feed-map-zoom-animating");
        zoomInner.css("transform", "translateX(0)");
      }
      this.zoomWindowStart = windowStart;
      const windowEnd = Math.min(total - 1, windowStart + zoomWindowSize - 1);
      segments.each((i, segment) => {
        const $segment = $(segment);
        $segment.empty();
        const displayIndex = windowStart + i;
        const item = displayItems[displayIndex];
        const actualIndex = displayIndices ? displayIndices[displayIndex] : displayIndex;
        const hasItem = displayIndex >= 0 && displayIndex < total && item;
        const isRead = item && $(item).hasClass("item-read");
        const isCurrent = displayIndex === currentIndex;
        $segment.data("item", hasItem ? item : null);
        $segment.removeClass(
          "feed-map-segment-read feed-map-segment-current feed-map-segment-empty feed-map-segment-ratioed feed-map-segment-heat-1 feed-map-segment-heat-2 feed-map-segment-heat-3 feed-map-segment-heat-4 feed-map-segment-heat-5 feed-map-segment-heat-6 feed-map-segment-heat-7 feed-map-segment-heat-8"
        );
        $segment.find(".feed-map-segment-icon, .feed-map-segment-avatar, .feed-map-segment-handle, .feed-map-segment-time, .feed-map-segment-progress").remove();
        if (!hasItem) {
          $segment.addClass("feed-map-segment-empty");
          return;
        }
        if (isRead) {
          $segment.addClass("feed-map-segment-read");
        }
        if (isCurrent) {
          $segment.addClass("feed-map-segment-current");
        }
        if (engagementData[actualIndex]?.engagement?.isRatioed) {
          $segment.addClass("feed-map-segment-ratioed");
        } else if (heatmapMode !== "None" && engagementData[actualIndex]) {
          const heatLevel = this.getHeatLevel(engagementData[actualIndex].score, maxScore);
          if (heatLevel > 0) {
            $segment.addClass(`feed-map-segment-heat-${heatLevel}`);
          }
        }
        if (showIcons && engagementData[actualIndex]?.engagement) {
          const icon = this.getContentIcon(engagementData[actualIndex].engagement);
          if (icon) {
            $segment.append(`<span class="feed-map-segment-icon">${icon}</span>`);
          }
        }
        if (showAvatars && engagementData[actualIndex]?.engagement?.avatarUrl) {
          const engData = engagementData[actualIndex];
          const avatarUrl = engData.engagement.avatarUrl;
          const avatarHeight = Math.round(32 * (avatarScale / 100));
          let avatarStyle = `height: ${avatarHeight}px`;
          if (showRuleColors && engData?.engagement?.handle) {
            const categoryIndex = this.getFilterCategoryIndexForHandle(engData.engagement.handle);
            if (categoryIndex >= 0) {
              const color = this.getColorForCategoryIndex(categoryIndex);
              avatarStyle += `; box-shadow: 0 0 0 2px ${color}; border-radius: 50%`;
            }
          }
          const blockInfo = this.getClearskyBlockInfo(engData?.engagement?.handle);
          if (blockInfo.type && blockInfo.color) {
            avatarStyle += `; box-shadow: 0 0 0 3px ${blockInfo.color}; border-radius: 50%`;
          }
          if (engData?.engagement?.isRepost && engData?.engagement?.reposterAvatarUrl) {
            const reposterHeight = Math.round(avatarHeight * 0.5);
            let reposterStyle = `height: ${reposterHeight}px`;
            if (showRuleColors && engData?.engagement?.reposterHandle) {
              const reposterCategoryIndex = this.getFilterCategoryIndexForHandle(engData.engagement.reposterHandle);
              if (reposterCategoryIndex >= 0) {
                const color = this.getColorForCategoryIndex(reposterCategoryIndex);
                reposterStyle += `; box-shadow: 0 0 0 1px ${color}`;
              }
            }
            const reposterBlockInfo = this.getClearskyBlockInfo(engData?.engagement?.reposterHandle);
            if (reposterBlockInfo.type && reposterBlockInfo.color) {
              reposterStyle += `; box-shadow: 0 0 0 2px ${reposterBlockInfo.color}`;
            }
            $segment.append(`
            <span class="feed-map-segment-avatar-container">
              <img class="feed-map-segment-avatar" src="${avatarUrl}" alt="" style="${avatarStyle}">
              <img class="feed-map-segment-reposter-avatar" src="${engData.engagement.reposterAvatarUrl}" alt="" style="${reposterStyle}">
            </span>
          `);
          } else {
            $segment.append(`<img class="feed-map-segment-avatar" src="${avatarUrl}" alt="" style="${avatarStyle}">`);
          }
        }
        if (showHandles && engagementData[actualIndex]?.engagement?.handle) {
          const handle2 = engagementData[actualIndex].engagement.handle;
          const dotIndex = handle2.indexOf(".");
          let handleHtml;
          if (dotIndex > 0) {
            handleHtml = `<span class="feed-map-segment-handle-name">${handle2.substring(0, dotIndex)}</span><span class="feed-map-segment-handle-domain">${handle2.substring(dotIndex)}</span>`;
          } else {
            handleHtml = `<span class="feed-map-segment-handle-name">${handle2}</span>`;
          }
          let handleStyle = "";
          if (showRuleColors) {
            const categoryIndex = this.getFilterCategoryIndexForHandle(handle2);
            if (categoryIndex >= 0) {
              const color = this.getColorForCategoryIndex(categoryIndex);
              handleStyle = ` style="background-color: ${color}55; border: 1px solid ${color}88; border-radius: 3px; padding: 0 2px;"`;
            }
          }
          const blockInfo = this.getClearskyBlockInfo(handle2);
          if (blockInfo.type && blockInfo.color) {
            handleStyle = ` style="background-color: ${blockInfo.color}55; border: 2px solid ${blockInfo.color}; border-radius: 3px; padding: 0 2px;"`;
          }
          $segment.append(`<span class="feed-map-segment-handle"${handleStyle}>${handleHtml}</span>`);
        }
        if (showTimestamps) {
          const timestamp = this.getTimestampForItem(item);
          if (timestamp) {
            const relativeTime = this.formatRelativeTime(timestamp);
            let timeStyle = "";
            if (showRuleColors) {
              const categoryIndex = this.getFilterCategoryIndexForContent(item);
              if (categoryIndex >= 0) {
                const color = this.getColorForCategoryIndex(categoryIndex);
                timeStyle = ` style="background-color: ${color}55; border: 1px solid ${color}88; border-radius: 3px; padding: 0 2px;"`;
              }
            }
            $segment.append(`<span class="feed-map-segment-time"${timeStyle}>${relativeTime}</span>`);
          }
        }
        if (engagementData[actualIndex]?.engagement?.unrolledCount > 0) {
          const unrolledCount = engagementData[actualIndex].engagement.unrolledCount;
          const totalPosts = unrolledCount + 1;
          const currentThreadIndex = isCurrent && this.threadIndex != null ? this.threadIndex : -1;
          let segmentsHtml = "";
          for (let i2 = 0; i2 < totalPosts; i2++) {
            const isVisited = i2 <= currentThreadIndex;
            const segmentClass = isVisited ? "feed-map-thread-segment feed-map-thread-segment-visited" : "feed-map-thread-segment";
            segmentsHtml += `<div class="${segmentClass}"></div>`;
          }
          $segment.append(`<div class="feed-map-segment-progress" data-total="${totalPosts}">${segmentsHtml}</div>`);
        }
      });
      zoomIndicator.css("--feed-map-icon-display", "flex");
      this.updateFeedMapZoomLabels(windowStart, windowEnd);
      const atStart = windowStart === 0;
      const atEnd = windowStart + zoomWindowSize >= total;
      zoomIndicator.toggleClass("feed-map-zoom-at-start", atStart);
      zoomIndicator.toggleClass("feed-map-zoom-at-end", atEnd);
      this.updateFeedMapZoomConnector(windowStart, windowEnd, total);
    }
    /**
     * Update the curved connector lines between the main feed map and feed map zoom
     */
    updateFeedMapZoomConnector(windowStart, windowEnd, total) {
      if (!this.feedMapConnector || !this.feedMap || !this.feedMapZoom) {
        return;
      }
      const connectorDiv = this.feedMapConnector[0];
      if (!connectorDiv) return;
      const svg = connectorDiv.querySelector(".feed-map-connector-svg");
      if (!svg) return;
      const wrapperWidth = this.feedMapWrapper ? this.feedMapWrapper.width() : 1e3;
      const labelWidth = this.feedMapLabelStart ? this.feedMapLabelStart.outerWidth() || 0 : 0;
      const zoomLabelWidth = this.feedMapZoomLabelStart ? this.feedMapZoomLabelStart.outerWidth() || 0 : 0;
      const mainWidth = this.feedMap.width() || wrapperWidth - labelWidth * 2;
      const zoomWidth = this.feedMapZoom.width() || wrapperWidth - zoomLabelWidth * 2;
      const startPercent = windowStart / total;
      const endPercent = (windowEnd + 1) / total;
      const mainStartX = labelWidth + mainWidth * startPercent;
      const mainEndX = labelWidth + mainWidth * endPercent;
      const zoomStartX = zoomLabelWidth;
      const zoomEndX = zoomLabelWidth + zoomWidth;
      const isStatusbar = this.feedMapWrapper && this.feedMapWrapper.hasClass("feed-map-wrapper-statusbar");
      const height = isStatusbar ? 16 : 20;
      const svgWidth = wrapperWidth;
      svg.setAttribute("viewBox", `0 0 ${svgWidth} ${height}`);
      const leftPath = svg.querySelector(".feed-map-connector-left");
      const rightPath = svg.querySelector(".feed-map-connector-right");
      const midY = height / 2;
      if (leftPath) {
        if (isStatusbar) {
          leftPath.setAttribute(
            "d",
            `M ${zoomStartX} 0 C ${zoomStartX} ${midY}, ${mainStartX} ${midY}, ${mainStartX} ${height}`
          );
        } else {
          leftPath.setAttribute(
            "d",
            `M ${mainStartX} 0 C ${mainStartX} ${midY}, ${zoomStartX} ${midY}, ${zoomStartX} ${height}`
          );
        }
      }
      if (rightPath) {
        if (isStatusbar) {
          rightPath.setAttribute(
            "d",
            `M ${zoomEndX} 0 C ${zoomEndX} ${midY}, ${mainEndX} ${midY}, ${mainEndX} ${height}`
          );
        } else {
          rightPath.setAttribute(
            "d",
            `M ${mainEndX} 0 C ${mainEndX} ${midY}, ${zoomEndX} ${midY}, ${zoomEndX} ${height}`
          );
        }
      }
      if (this.feedMapZoomHighlight) {
        const highlightLeft = startPercent * 100;
        const highlightWidth = (endPercent - startPercent) * 100;
        this.feedMapZoomHighlight.css({
          left: `${highlightLeft}%`,
          width: `${highlightWidth}%`
        });
      }
    }
    /**
     * Update the date/time labels for the feed map zoom
     */
    updateFeedMapZoomLabels(windowStart, windowEnd) {
      if (!this.feedMapZoomLabelStart || !this.feedMapZoomLabelEnd) return;
      if (!this.items.length) return;
      const firstItem = this.items[windowStart];
      const lastItem = this.items[windowEnd];
      let firstTimestamp = this.getTimestampForItem(firstItem);
      let lastTimestamp = this.getTimestampForItem(lastItem);
      const reversed = this.state.feedSortReverse;
      if (firstTimestamp && lastTimestamp) {
        const shouldSwap = reversed ? firstTimestamp > lastTimestamp : firstTimestamp < lastTimestamp;
        if (shouldSwap) {
          [firstTimestamp, lastTimestamp] = [lastTimestamp, firstTimestamp];
        }
      }
      const formatCompact = (date) => {
        if (!date) return "";
        const now = /* @__PURE__ */ new Date();
        const isToday = date.toDateString() === now.toDateString();
        const isThisYear = date.getFullYear() === now.getFullYear();
        if (isToday) {
          return format(date, "h:mma").toLowerCase();
        } else if (isThisYear) {
          return format(date, "M/d h:mma").toLowerCase();
        } else {
          return format(date, "M/d/yy h:mma").toLowerCase();
        }
      };
      this.feedMapZoomLabelStart.text(formatCompact(firstTimestamp));
      this.feedMapZoomLabelEnd.text(formatCompact(lastTimestamp));
    }
    updateViewportIndicator(indicator, total) {
      const viewportIndicator = indicator.find(".feed-map-viewport-indicator");
      if (!viewportIndicator.length || total === 0) return;
      const indicatorWidth = indicator.width();
      const segmentWidth = indicatorWidth / total;
      let topOffset = 0;
      if (this.toolbarDiv) {
        const toolbarRect = this.toolbarDiv[0].getBoundingClientRect();
        topOffset = Math.max(0, toolbarRect.bottom);
      }
      const bskyTabBar = document.querySelector('[data-testid="homeScreenFeedTabs"]');
      if (bskyTabBar) {
        const tabBarRect = bskyTabBar.getBoundingClientRect();
        topOffset = Math.max(topOffset, tabBarRect.bottom);
      }
      const viewportTop = topOffset;
      const viewportBottom = window.innerHeight;
      let firstVisible = -1;
      let lastVisible = -1;
      for (let i = 0; i < this.items.length; i++) {
        const item = this.items[i];
        if (!item) continue;
        const rect = item.getBoundingClientRect();
        const itemTop = rect.top;
        const itemBottom = rect.bottom;
        const itemHeight = rect.height;
        const minVisible = Math.min(itemHeight * 0.2, 20);
        const visibleTop = Math.max(itemTop, viewportTop);
        const visibleBottom = Math.min(itemBottom, viewportBottom);
        const visibleHeight = visibleBottom - visibleTop;
        if (visibleHeight >= minVisible) {
          if (firstVisible === -1) firstVisible = i;
          lastVisible = i;
        }
      }
      if (firstVisible === -1) {
        viewportIndicator.css({ display: "none" });
        return;
      }
      const left = firstVisible * segmentWidth;
      const width = (lastVisible - firstVisible + 1) * segmentWidth;
      viewportIndicator.css({
        display: "block",
        left: `${left}px`,
        width: `${width}px`
      });
    }
    /**
     * Create and return the singleton tooltip element
     */
    getFeedMapTooltip() {
      if (!this._feedMapTooltip) {
        this._feedMapTooltip = $(`
        <div class="feed-map-tooltip">
          <div class="feed-map-tooltip-header">
            <img class="feed-map-tooltip-avatar" style="display: none;">
            <div class="feed-map-tooltip-header-text">
              <span class="feed-map-tooltip-handle"></span>
              <span class="feed-map-tooltip-time"></span>
            </div>
          </div>
          <div class="feed-map-tooltip-author"></div>
          <div class="feed-map-tooltip-content"></div>
          <div class="feed-map-tooltip-engagement"></div>
        </div>
      `);
        $("body").append(this._feedMapTooltip);
      }
      return this._feedMapTooltip;
    }
    /**
     * Show the feed map tooltip for a given item
     */
    showFeedMapTooltip(item, segment) {
      if (!item) return;
      if (this._tooltipHideTimer) {
        clearTimeout(this._tooltipHideTimer);
        this._tooltipHideTimer = null;
      }
      const tooltip = this.getFeedMapTooltip();
      const $item = $(item);
      let handle2 = this.handleFromItem(item);
      let displayName = this.displayNameFromItem(item);
      if (!handle2) {
        const testId = $item.attr("data-testid") || "";
        const match2 = testId.match(/^feedItem-by-(.+)$/);
        if (match2) {
          handle2 = match2[1];
        }
      }
      if (!displayName) {
        const $thread = $item.closest(".thread");
        if ($thread.length) {
          const profileLink = $thread.find('a[aria-label="View profile"]').first();
          if (profileLink.length) {
            displayName = $.trim(profileLink.text().replace(/[\u200E\u200F\u202A-\u202E]/g, ""));
            if (displayName.includes("@")) {
              displayName = displayName.split("@")[0].trim();
            }
          }
        }
      }
      const timestamp = this.getTimestampForItem(item);
      const engagement = this.getPostEngagement(item);
      const postText = $item.find('div[data-testid="postText"]').text() || "";
      const isRead = $item.hasClass("item-read");
      const relativeTime = timestamp ? this.formatRelativeTime(timestamp) : "";
      const truncatedText = postText.length > 150 ? postText.substring(0, 150).trim() + "..." : postText;
      const avatarImg = tooltip.find(".feed-map-tooltip-avatar");
      if (this.config.get("feedMapAvatars") !== false && engagement?.avatarUrl) {
        avatarImg.attr("src", engagement.avatarUrl).show();
      } else {
        avatarImg.hide();
      }
      tooltip.find(".feed-map-tooltip-handle").text(`@${handle2}`);
      tooltip.find(".feed-map-tooltip-time").text(relativeTime ? ` \xB7 ${relativeTime}` : "");
      tooltip.find(".feed-map-tooltip-author").text(displayName || handle2);
      tooltip.find(".feed-map-tooltip-content").text(truncatedText || "(no text)");
      const engagementHtml = this.buildEngagementHtml(engagement);
      tooltip.find(".feed-map-tooltip-engagement").html(engagementHtml);
      tooltip.removeClass("feed-map-tooltip-read feed-map-tooltip-ratioed");
      if (isRead) tooltip.addClass("feed-map-tooltip-read");
      if (engagement?.isRatioed) tooltip.addClass("feed-map-tooltip-ratioed");
      this.positionFeedMapTooltip(tooltip, segment);
      tooltip.addClass("visible");
    }
    /**
     * Hide the feed map tooltip
     */
    hideFeedMapTooltip() {
      if (this._tooltipTimer) {
        clearTimeout(this._tooltipTimer);
        this._tooltipTimer = null;
      }
      if (this._tooltipHideTimer) {
        clearTimeout(this._tooltipHideTimer);
        this._tooltipHideTimer = null;
      }
      if (this._feedMapTooltip) {
        this._feedMapTooltip.removeClass("visible");
      }
    }
    /**
     * Position the tooltip relative to a segment
     */
    positionFeedMapTooltip(tooltip, segment) {
      $(segment);
      const segmentRect = segment.getBoundingClientRect();
      const tooltipWidth = 280;
      const tooltipHeight = tooltip.outerHeight() || 120;
      const padding = 8;
      let left = segmentRect.left + segmentRect.width / 2 - tooltipWidth / 2;
      if (left < padding) left = padding;
      if (left + tooltipWidth > window.innerWidth - padding) {
        left = window.innerWidth - tooltipWidth - padding;
      }
      let top;
      const spaceAbove = segmentRect.top;
      const spaceBelow = window.innerHeight - segmentRect.bottom;
      if (spaceAbove >= tooltipHeight + padding) {
        top = segmentRect.top - tooltipHeight - padding;
      } else if (spaceBelow >= tooltipHeight + padding) {
        top = segmentRect.bottom + padding;
      } else {
        top = Math.max(padding, segmentRect.top - tooltipHeight - padding);
      }
      tooltip.css({
        left: `${left}px`,
        top: `${top}px`,
        maxWidth: `${tooltipWidth}px`
      });
    }
    /**
     * Format a timestamp as relative time (e.g., "2h ago", "yesterday")
     */
    formatRelativeTime(date) {
      if (!date) return "";
      const now = /* @__PURE__ */ new Date();
      const diffMs = now - date;
      const diffMins = Math.floor(diffMs / 6e4);
      const diffHours = Math.floor(diffMs / 36e5);
      const diffDays = Math.floor(diffMs / 864e5);
      if (diffMins < 1) return "now";
      if (diffMins < 60) return `${diffMins}m`;
      if (diffHours < 24) return `${diffHours}h`;
      if (diffDays === 1) return "yesterday";
      if (diffDays < 7) return `${diffDays}d`;
      return format(date, "M/d");
    }
    /**
     * Build HTML for engagement stats row
     */
    buildEngagementHtml(engagement) {
      if (!engagement) return "";
      const items = [];
      items.push(`
      <span class="feed-map-tooltip-stat">
        <img src="${this.INDICATOR_IMAGES.filter[0]}" alt="likes" class="feed-map-tooltip-icon">
        <span>${this.formatCount(engagement.likes)}</span>
      </span>
    `);
      items.push(`
      <span class="feed-map-tooltip-stat">
        <img src="${this.INDICATOR_IMAGES.contentRepost}" alt="reposts" class="feed-map-tooltip-icon">
        <span>${this.formatCount(engagement.reposts)}</span>
      </span>
    `);
      items.push(`
      <span class="feed-map-tooltip-stat">
        <img src="${this.INDICATOR_IMAGES.contentReply}" alt="replies" class="feed-map-tooltip-icon">
        <span>${this.formatCount(engagement.replies)}</span>
      </span>
    `);
      if (engagement.hasVideo) {
        items.push(`<img src="${this.INDICATOR_IMAGES.contentVideo}" alt="video" class="feed-map-tooltip-media-icon">`);
      } else if (engagement.hasImage) {
        items.push(`<img src="${this.INDICATOR_IMAGES.contentImage}" alt="image" class="feed-map-tooltip-media-icon">`);
      }
      return items.join("");
    }
    /**
     * Format count for display (e.g., 1200 -> "1.2K")
     */
    formatCount(num) {
      if (num >= 1e6) return (num / 1e6).toFixed(1).replace(/\.0$/, "") + "M";
      if (num >= 1e3) return (num / 1e3).toFixed(1).replace(/\.0$/, "") + "K";
      return String(num);
    }
    /**
     * Set up hover handlers for feed map segments
     */
    setupFeedMapTooltipHandlers(indicator) {
      if (!indicator) return;
      indicator.off("mouseenter", ".feed-map-segment");
      indicator.off("mouseleave", ".feed-map-segment");
      indicator.off("mouseleave");
      indicator.on("mouseenter", ".feed-map-segment", (e) => {
        const segment = e.currentTarget;
        const $segment = $(segment);
        const item = $segment.data("item");
        clearTimeout(this._tooltipHideTimer);
        if (!item) return;
        const tooltipMode = this.config.get("feedMapTooltip") || "Instant";
        const delay = tooltipMode === "Delayed" ? 300 : 0;
        if (this._tooltipTimer) {
          clearTimeout(this._tooltipTimer);
        }
        if (delay === 0) {
          this.showFeedMapTooltip(item, segment);
        } else {
          this._tooltipTimer = setTimeout(() => {
            const currentItem = $segment.data("item");
            if (currentItem) {
              this.showFeedMapTooltip(currentItem, segment);
            }
          }, delay);
        }
      });
      indicator.on("mouseleave", ".feed-map-segment", () => {
        clearTimeout(this._tooltipTimer);
        this._tooltipTimer = null;
        clearTimeout(this._tooltipHideTimer);
        this._tooltipHideTimer = setTimeout(() => {
          this.hideFeedMapTooltip();
        }, 100);
      });
      indicator.on("mouseleave", () => {
        clearTimeout(this._tooltipTimer);
        this._tooltipTimer = null;
        clearTimeout(this._tooltipHideTimer);
        this._tooltipHideTimer = setTimeout(() => {
          this.hideFeedMapTooltip();
        }, 50);
      });
    }
    handleInput(event) {
      if (isUserTyping()) {
        return true;
      }
      if (isModalOpen()) {
        return true;
      }
      const item = this.selectedItem;
      if (event.key == "A") {
        $(item).find(constants.PROFILE_SELECTOR)[0].click();
      } else if (event.key == "a") {
        this.toggleAuthorHoverCard(item);
      } else if (event.key == "u") {
        this.loadNewerItems();
      } else if (event.key == ":") {
        this.toggleSortOrder();
      } else if (event.key == '"') {
        this.toggleHideRead();
      } else if (event.key == "/") {
        event.preventDefault();
        $("input#bsky-navigator-search").focus();
      } else if (event.key == ",") {
        this.loadItems();
      } else {
        super.handleInput(event);
      }
    }
  }
  class PostItemHandler extends ItemHandler {
    constructor(name, config2, state2, api, selector) {
      super(name, config2, state2, api, selector);
      this.indexMap = {};
      this.handleInput = this.handleInput.bind(this);
    }
    get index() {
      return this.indexMap?.[this.postId] ?? 0;
    }
    set index(value) {
      this.indexMap[this.postId] = value;
    }
    activate() {
      super.activate();
      this.postId = this.postIdFromUrl();
    }
    deactivate() {
      super.deactivate();
    }
    isActive() {
      return window.location.pathname.match(/\/post\//);
    }
    get scrollMargin() {
      return $('div[data-testid="postThreadScreen"] > div:visible').eq(0).outerHeight();
    }
    handleInput(event) {
      if (isUserTyping()) {
        return true;
      }
      if (isModalOpen()) {
        return true;
      }
      const item = this.selectedItem;
      if (["o", "Enter"].includes(event.key) && !(event.altKey || event.metaKey)) {
        const inner = $(item).find("div[aria-label^='Post by']");
        inner.click();
      }
      if (super.handleInput(event)) {
        return;
      }
      if (this.isPopupVisible || event.altKey || event.metaKey) {
        return;
      }
      if (event.key == "A") {
        const handle2 = $.trim($(item).attr("data-testid").split("postThreadItem-by-")[1]);
        $(item).find("div").filter(
          (i, el) => $.trim($(el).text()).replace(/[\u200E\u200F\u202A-\u202E]/g, "") == `@${handle2}`
        )[0].click();
      } else if (event.key == "a") {
        this.toggleAuthorHoverCard(item);
      }
    }
  }
  function getFeedMapConfig(config2) {
    const position = config2.get("feedMapPosition");
    const style2 = config2.get("feedMapStyle") || "Advanced";
    const isAdvanced = style2 === "Advanced";
    const theme = config2.get("feedMapTheme") || "Default";
    const scale = parseInt(config2.get("feedMapScale"), 10) || 100;
    const animationSpeed = parseInt(config2.get("feedMapAnimationSpeed"), 10);
    return {
      position,
      style: style2,
      isAdvanced,
      styleClass: isAdvanced ? "feed-map-advanced" : "feed-map-basic",
      theme,
      themeClass: `feed-map-theme-${theme.toLowerCase()}`,
      scale,
      scaleValue: scale / 100,
      animationSpeed: isNaN(animationSpeed) ? 100 : animationSpeed,
      animationSpeedValue: (isNaN(animationSpeed) ? 100 : animationSpeed) / 100,
      customPropsStyle: `--indicator-scale: ${scale / 100}; --zoom-animation-speed: ${(isNaN(animationSpeed) ? 100 : animationSpeed) / 100};`
    };
  }
  function createFeedMapElements(feedMapConfig, options = {}) {
    const { styleClass, themeClass, customPropsStyle } = feedMapConfig;
    const { isToolbar = false } = options;
    const containerClass = isToolbar ? "feed-map-container feed-map-container-toolbar" : "feed-map-container";
    const zoomContainerClass = isToolbar ? "feed-map-container feed-map-container-toolbar feed-map-zoom-container" : "feed-map-container feed-map-zoom-container";
    const container = $(`<div class="${containerClass}"></div>`);
    const labelStart = $(`<span class="feed-map-label feed-map-label-start"></span>`);
    const labelEnd = $(`<span class="feed-map-label feed-map-label-end"></span>`);
    const map = $(
      `<div id="feed-map-position-indicator" class="feed-map-position-indicator" role="progressbar" aria-label="Feed position" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0"><div class="feed-map-position-fill"></div><div class="feed-map-position-zoom-highlight"></div></div>`
    );
    container.append(labelStart);
    container.append(map);
    container.append(labelEnd);
    const zoomHighlight = map.find(".feed-map-position-zoom-highlight");
    const wrapperClass = isToolbar ? `feed-map-wrapper ${styleClass} ${themeClass}` : `feed-map-wrapper feed-map-wrapper-statusbar ${styleClass} ${themeClass}`;
    const wrapper = $(`<div class="${wrapperClass}" style="${customPropsStyle}"></div>`);
    wrapper.append(container);
    const connector = $(`<div class="feed-map-connector">
    <svg class="feed-map-connector-svg" preserveAspectRatio="none">
      <path class="feed-map-connector-path feed-map-connector-left" fill="none"/>
      <path class="feed-map-connector-path feed-map-connector-right" fill="none"/>
    </svg>
  </div>`);
    wrapper.append(connector);
    const zoomContainer = $(`<div class="${zoomContainerClass}"></div>`);
    const zoomLabelStart = $(`<span class="feed-map-label feed-map-label-start"></span>`);
    const zoomLabelEnd = $(`<span class="feed-map-label feed-map-label-end"></span>`);
    const zoom = $(
      `<div id="feed-map-position-indicator-zoom" class="feed-map-position-indicator feed-map-position-indicator-zoom"></div>`
    );
    let zoomInner = null;
    if (isToolbar) {
      zoomInner = $(`<div class="feed-map-zoom-inner"></div>`);
      zoom.append(zoomInner);
    }
    zoomContainer.append(zoomLabelStart);
    zoomContainer.append(zoom);
    zoomContainer.append(zoomLabelEnd);
    wrapper.append(zoomContainer);
    return {
      container,
      labelStart,
      labelEnd,
      map,
      wrapper,
      connector,
      zoomContainer,
      zoomLabelStart,
      zoomLabelEnd,
      zoom,
      zoomInner,
      zoomHighlight
    };
  }
  function attachFeedMapToHandler(handler, elements) {
    handler.feedMapContainer = elements.container;
    handler.feedMapLabelStart = elements.labelStart;
    handler.feedMapLabelEnd = elements.labelEnd;
    handler.feedMap = elements.map;
    handler.feedMapWrapper = elements.wrapper;
    handler.feedMapConnector = elements.connector;
    handler.feedMapZoomContainer = elements.zoomContainer;
    handler.feedMapZoomLabelStart = elements.zoomLabelStart;
    handler.feedMapZoomLabelEnd = elements.zoomLabelEnd;
    handler.feedMapZoom = elements.zoom;
    handler.feedMapZoomInner = elements.zoomInner;
    handler.feedMapZoomHighlight = elements.zoomHighlight;
    handler.zoomWindowStart = null;
  }
  function setupFeedMapHandlers(handler, feedMap, feedMapZoom) {
    handler.setupScrollIndicatorZoomClick();
    handler.setupScrollIndicatorClick();
    handler.setupScrollIndicatorScroll();
    handler.setupFeedMapTooltipHandlers(feedMap);
    handler.setupFeedMapTooltipHandlers(feedMapZoom);
  }
  class ProfileItemHandler extends FeedItemHandler {
    constructor(name, config2, state2, api, selector) {
      super(name, config2, state2, api, selector);
      this.uiManagerStatusBar = null;
      this.uiManagerStatusBarLeft = null;
      this._toolbarObserver = null;
    }
    /**
     * Called by ProfileUIAdapter to provide UIManager's status bar
     * This is called after activate(), and also when navigating between profiles
     * (where context doesn't change but URL does)
     */
    setUIManagerStatusBar(statusBar, statusBarLeft) {
      this.uiManagerStatusBar = statusBar;
      this.uiManagerStatusBarLeft = statusBarLeft;
      if (!$.contains(document, statusBar[0])) {
        setTimeout(() => this.setUIManagerStatusBar(statusBar, statusBarLeft), 100);
        return;
      }
      statusBar.show();
      statusBar.find(".feed-map-wrapper").remove();
      statusBar.removeClass("has-feed-map");
      this.addFeedMapToStatusBar(statusBar);
      const toolbarEl = this.toolbarDiv ? this.toolbarDiv[0] : null;
      const toolbarValid = toolbarEl && toolbarEl.isConnected && toolbarEl.offsetParent !== null;
      if (!toolbarValid) {
        this.refreshToolbars();
      }
      this.loadItemsWithRetry();
    }
    activate() {
      this.setIndex(0);
      super.activate();
      this._watchForProfileButtons();
    }
    /**
     * Watch for profile buttons container and insert our button when ready
     */
    _watchForProfileButtons() {
      if (this._profileButtonObserver) {
        this._profileButtonObserver.disconnect();
        this._profileButtonObserver = null;
      }
      const tryInsert = () => {
        const existingBtn = $(".bsky-nav-profile-rules-btn");
        if (existingBtn.length) {
          const rect = existingBtn[0].getBoundingClientRect();
          if (rect.width > 0 && rect.height > 0) {
            return true;
          }
          existingBtn.closest(".bsky-nav-profile-rules-wrapper").remove();
          existingBtn.remove();
        }
        const allMoreOptionsBtns = document.querySelectorAll('button[data-testid="profileHeaderDropdownBtn"]');
        let moreOptionsBtn = null;
        for (const btn of allMoreOptionsBtns) {
          const rect = btn.getBoundingClientRect();
          if (btn.isConnected && rect.width > 0 && rect.height > 0) {
            moreOptionsBtn = $(btn);
            break;
          }
        }
        if (!moreOptionsBtn) {
          return false;
        }
        const moreOptionsWrapper = moreOptionsBtn.parent();
        if (!moreOptionsWrapper.length) return false;
        const path = window.location.pathname;
        const handleMatch = path.match(/^\/profile\/([^/]+)/);
        if (!handleMatch) return false;
        const handle2 = handleMatch[1];
        const addButton = $(`
        <div class="css-g5y9jx bsky-nav-profile-rules-wrapper">
          <button class="bsky-nav-profile-rules-btn" aria-label="Add @${handle2} to filter rules" title="Add @${handle2} to filter rules" type="button">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M12 5v14M5 12h14"/>
            </svg>
          </button>
        </div>
      `);
        moreOptionsWrapper.before(addButton);
        const insertedBtn = addButton.find(".bsky-nav-profile-rules-btn")[0];
        const insertedRect = insertedBtn.getBoundingClientRect();
        if (insertedRect.width === 0 || insertedRect.height === 0) {
          addButton.remove();
          return false;
        }
        addButton.find(".bsky-nav-profile-rules-btn").on("click", (e) => {
          e.preventDefault();
          e.stopPropagation();
          const btnRect = e.currentTarget.getBoundingClientRect();
          this.showAddToRulesDropdown(btnRect, handle2);
        });
        return true;
      };
      if (tryInsert()) return;
      this._profileButtonObserver = new MutationObserver(() => {
        if (tryInsert()) ;
      });
      this._profileButtonObserver.observe(document.body, {
        childList: true,
        subtree: true
      });
    }
    deactivate() {
      if (this._toolbarObserver) {
        this._toolbarObserver.disconnect();
        this._toolbarObserver = null;
      }
      if (this._profileButtonObserver) {
        this._profileButtonObserver.disconnect();
        this._profileButtonObserver = null;
      }
      $(".bsky-nav-profile-rules-wrapper").remove();
      this.feedMap = null;
      this.feedMapWrapper = null;
      this.feedMapZoom = null;
      super.deactivate();
      this.uiManagerStatusBar = null;
      this.uiManagerStatusBarLeft = null;
    }
    isActive() {
      return window.location.pathname.match(/^\/profile\//);
    }
    /**
     * Override refreshToolbars to use profile-specific selectors
     * Uses UIManager's fixed status bar instead of creating our own
     */
    refreshToolbars() {
      if (this._toolbarObserver) {
        this._toolbarObserver.disconnect();
        this._toolbarObserver = null;
      }
      if (this._settingUpToolbars) {
        return;
      }
      const toolbarEl = this.toolbarDiv ? this.toolbarDiv[0] : null;
      const toolbarValid = toolbarEl && toolbarEl.isConnected && toolbarEl.offsetParent !== null;
      if (toolbarValid) {
        this.setSortIcons();
        return;
      }
      $("#bsky-navigator-toolbar").remove();
      this.toolbarDiv = null;
      const profileFeedTabs = this._findVisibleProfilePager();
      if (profileFeedTabs) {
        this._settingUpToolbars = true;
        this.addToolbar(profileFeedTabs);
        this._settingUpToolbars = false;
        this.setSortIcons();
        this.applyProfileWidth();
        this.loadItemsWithRetry();
        return;
      }
      this._toolbarObserver = new MutationObserver((mutations, obs) => {
        if (this._settingUpToolbars) {
          return;
        }
        const toolbarEl2 = this.toolbarDiv ? this.toolbarDiv[0] : null;
        const toolbarValid2 = toolbarEl2 && toolbarEl2.isConnected && toolbarEl2.offsetParent !== null;
        if (toolbarValid2) {
          obs.disconnect();
          this._toolbarObserver = null;
          return;
        }
        $("#bsky-navigator-toolbar").remove();
        this.toolbarDiv = null;
        const profilePager = this._findVisibleProfilePager();
        if (profilePager) {
          obs.disconnect();
          this._toolbarObserver = null;
          this._settingUpToolbars = true;
          this.addToolbar(profilePager);
          this._settingUpToolbars = false;
          this.setSortIcons();
          this.applyProfileWidth();
          this.loadItemsWithRetry();
        }
      });
      this._toolbarObserver.observe(document.body, {
        childList: true,
        subtree: true
      });
      setTimeout(() => {
        if (this._toolbarObserver) {
          this._toolbarObserver.disconnect();
          this._toolbarObserver = null;
        }
      }, 1e4);
    }
    /**
     * Find a visible, connected profilePager element.
     * During SPA navigation, React may leave stale elements in the DOM,
     * so we filter to only elements that are connected and visible.
     * @returns {jQuery|null} - jQuery-wrapped visible profilePager or null
     */
    _findVisibleProfilePager() {
      const allProfilePagers = document.querySelectorAll('div[data-testid="profilePager"]');
      for (const pager of allProfilePagers) {
        if (pager.isConnected && pager.offsetParent !== null) {
          return $(pager);
        }
      }
      return null;
    }
    /**
     * Add feed map elements to an existing status bar (UIManager's)
     */
    addFeedMapToStatusBar(statusBar) {
      const feedMapConfig = getFeedMapConfig(this.config);
      if (feedMapConfig.position !== "Bottom status bar") {
        return;
      }
      const elements = createFeedMapElements(feedMapConfig, { isToolbar: false });
      attachFeedMapToHandler(this, elements);
      statusBar.prepend(elements.wrapper);
      statusBar.addClass("has-feed-map");
      setupFeedMapHandlers(this, elements.map, elements.zoom);
      this.statusBar = statusBar;
    }
    /**
     * Apply configured width to profile page elements
     */
    applyProfileWidth() {
      const contentWidth = this.config.get("postWidthDesktop") || 600;
      if (contentWidth === 600) {
        return;
      }
      const profilePager = $('div[data-testid="profilePager"]');
      if (profilePager.length) {
        profilePager.css("width", contentWidth + "px");
      }
    }
    handleInput(event) {
      if (super.handleInput(event)) {
        return;
      }
      if (event.altKey || event.metaKey) {
        return;
      }
      if (event.key == "f") {
        this.showProfileFollowConfirmation(true);
      } else if (event.key == "F") {
        this.showProfileFollowConfirmation(false);
      } else if (event.key == "L") {
        $("button[aria-label^='More options']").click();
        setTimeout(function() {
          $("div[data-testid='profileHeaderDropdownListAddRemoveBtn']").click();
        }, 200);
      } else if (event.key == "M") {
        $("button[aria-label^='More options']").click();
        setTimeout(function() {
          $("div[data-testid='profileHeaderDropdownMuteBtn']").click();
        }, 200);
      } else if (event.key == "B") {
        $("button[aria-label^='More options']").click();
        setTimeout(function() {
          $("div[data-testid='profileHeaderDropdownBlockBtn']").click();
        }, 200);
      } else if (event.key == "R") {
        $("button[aria-label^='More options']").click();
        setTimeout(function() {
          $("div[data-testid='profileHeaderDropdownReportBtn']").click();
        }, 200);
      }
    }
    /**
     * Show confirmation popup for following/unfollowing on profile page
     * @param {boolean} isFollow - True for follow, false for unfollow
     */
    showProfileFollowConfirmation(isFollow) {
      $(".bsky-nav-follow-popup").remove();
      const pathParts = window.location.pathname.split("/");
      const profileIndex = pathParts.indexOf("profile");
      const handle2 = profileIndex >= 0 ? pathParts[profileIndex + 1] : null;
      if (!handle2) {
        console.warn("Could not get profile handle for follow action");
        return;
      }
      const action = isFollow ? "Follow" : "Unfollow";
      const buttonTestId = isFollow ? "followBtn" : "unfollowBtn";
      const targetBtn = $(`button[data-testid='${buttonTestId}']`);
      if (!targetBtn.length) {
        console.warn(`${action} button not found - user may already be ${isFollow ? "followed" : "unfollowed"}`);
        return;
      }
      const popup = $(`
      <div class="bsky-nav-follow-popup bsky-nav-timeout-popup">
        <div class="bsky-nav-timeout-header">
          ${action} @${handle2}?
        </div>
        <div class="bsky-nav-timeout-buttons">
          <button class="bsky-nav-timeout-btn cancel">Cancel</button>
          <button class="bsky-nav-timeout-btn confirm">${action}</button>
        </div>
      </div>
    `);
      popup.css({
        position: "fixed",
        top: "50%",
        left: "50%",
        transform: "translate(-50%, -50%)",
        zIndex: 10002
      });
      $("body").append(popup);
      popup.find(".bsky-nav-timeout-btn.confirm").on("click", () => {
        popup.remove();
        $(document).off(".follow");
        $(`button[data-testid='${buttonTestId}']`).click();
      });
      popup.find(".bsky-nav-timeout-btn.cancel").on("click", () => {
        popup.remove();
        $(document).off(".follow");
      });
      setTimeout(() => {
        $(document).on("mousedown.follow", (e) => {
          if (!$(e.target).closest(".bsky-nav-follow-popup").length) {
            popup.remove();
            $(document).off(".follow");
          }
        });
      }, 100);
      $(document).on("keydown.follow", (e) => {
        if (e.key === "Escape") {
          popup.remove();
          $(document).off(".follow");
        } else if (e.key === "Enter") {
          e.preventDefault();
          popup.remove();
          $(document).off(".follow");
          $(`button[data-testid='${buttonTestId}']`).click();
        }
      });
    }
  }
  class SavedItemHandler extends FeedItemHandler {
    constructor(name, config2, state2, api, selector) {
      super(name, config2, state2, api, selector);
      this.uiManagerStatusBar = null;
      this.uiManagerStatusBarLeft = null;
    }
    /**
     * Called by SavedUIAdapter to provide UIManager's status bar
     * This is called after activate(), so we setup feed map here
     */
    setUIManagerStatusBar(statusBar, statusBarLeft) {
      this.uiManagerStatusBar = statusBar;
      this.uiManagerStatusBarLeft = statusBarLeft;
      if (!$.contains(document, statusBar[0])) {
        setTimeout(() => this.setUIManagerStatusBar(statusBar, statusBarLeft), 100);
        return;
      }
      statusBar.show();
      statusBar.find(".feed-map-wrapper").remove();
      statusBar.removeClass("has-feed-map");
      this.addFeedMapToStatusBar(statusBar);
      this.loadItemsWithRetry();
    }
    /**
     * Add feed map elements to UIManager's status bar
     */
    addFeedMapToStatusBar(statusBar) {
      const feedMapConfig = getFeedMapConfig(this.config);
      if (feedMapConfig.position !== "Bottom status bar") {
        return;
      }
      const elements = createFeedMapElements(feedMapConfig, { isToolbar: false });
      attachFeedMapToHandler(this, elements);
      statusBar.prepend(elements.wrapper);
      statusBar.addClass("has-feed-map");
      setupFeedMapHandlers(this, elements.map, elements.zoom);
      this.statusBar = statusBar;
    }
    isActive() {
      const path = window.location.pathname;
      return path.includes("/saved") || path.includes("/bookmarks") || document.querySelector('div[data-testid="bookmarksScreen"]') !== null;
    }
    /**
     * Override refreshToolbars to use saved-page-specific selectors.
     * The saved page doesn't have homeScreenFeedTabs, so we find the
     * feed container and insert the toolbar at the top.
     * Note: Status bar is handled by UIManager via SavedUIAdapter.
     */
    refreshToolbars() {
      if (this._toolbarObserver) {
        this._toolbarObserver.disconnect();
        this._toolbarObserver = null;
      }
      if (this._settingUpToolbars) {
        return;
      }
      if (this.toolbarDiv && $.contains(document, this.toolbarDiv[0])) {
        return;
      }
      $("#bsky-navigator-toolbar").remove();
      const insertPoint = this._findToolbarInsertPoint();
      if (insertPoint) {
        this._settingUpToolbars = true;
        this.addToolbar(insertPoint);
        this._settingUpToolbars = false;
        this._hideSavedPageControls();
        return;
      }
      this._toolbarObserver = new MutationObserver(() => {
        if (this._settingUpToolbars) {
          return;
        }
        if (this.toolbarDiv && $.contains(document, this.toolbarDiv[0])) {
          this._toolbarObserver.disconnect();
          this._toolbarObserver = null;
          return;
        }
        $("#bsky-navigator-toolbar").remove();
        const point = this._findToolbarInsertPoint();
        if (point) {
          this._toolbarObserver.disconnect();
          this._toolbarObserver = null;
          this._settingUpToolbars = true;
          this.addToolbar(point);
          this._settingUpToolbars = false;
          this._hideSavedPageControls();
        }
      });
      this._toolbarObserver.observe(document.body, {
        childList: true,
        subtree: true
      });
    }
    /**
     * Find the correct insertion point for the toolbar on the saved page.
     * Insert inside the max-width container to inherit correct width styling.
     * Uses native DOM to filter to visible, connected elements (avoid stale React elements).
     */
    _findToolbarInsertPoint() {
      const allScreens = document.querySelectorAll('div[data-testid="bookmarksScreen"]');
      let bookmarksScreen = null;
      for (const screen of allScreens) {
        if (screen.isConnected && screen.offsetParent !== null) {
          bookmarksScreen = $(screen);
          break;
        }
      }
      if (!bookmarksScreen) {
        return null;
      }
      const feedContainer = bookmarksScreen.find('div[style*="max-width"]').first();
      if (feedContainer.length && feedContainer[0].isConnected) {
        const firstChild2 = feedContainer.children().first();
        if (firstChild2.length && firstChild2[0].isConnected) {
          return firstChild2;
        }
      }
      const firstPost = bookmarksScreen.find('div[role="link"][tabindex="0"]').first();
      if (firstPost.length && firstPost[0].isConnected) {
        return firstPost;
      }
      const firstChild = bookmarksScreen.children().first();
      if (firstChild.length && firstChild[0].isConnected) {
        const firstGrandchild = firstChild.children().first();
        if (firstGrandchild.length && firstGrandchild[0].isConnected) {
          return firstGrandchild;
        }
        return firstChild;
      }
      return null;
    }
    /**
     * Hide controls that don't apply to the saved page
     */
    _hideSavedPageControls() {
      if (!this.toolbarDiv) return;
      this.toolbarDiv.find(".sort-order-btn").hide();
      this.toolbarDiv.find("#sortIndicator").hide();
      this.toolbarDiv.find("#bsky-navigator-new-posts-pill").hide();
      this.toolbarDiv.find(".saved-searches-btn").hide();
      this.toolbarDiv.find("#topLoadIndicator").hide();
      this.toolbarDiv.find("#bottomLoadIndicator").hide();
    }
    /**
     * Override activate to load items with retry since saved page loads async
     */
    activate() {
      super.activate();
      this.loadItemsWithRetry();
    }
    deactivate() {
      if (this._toolbarObserver) {
        this._toolbarObserver.disconnect();
        this._toolbarObserver = null;
      }
      this.feedMap = null;
      this.feedMapWrapper = null;
      this.feedMapZoom = null;
      super.deactivate();
      this.uiManagerStatusBar = null;
      this.uiManagerStatusBarLeft = null;
    }
  }
  class UIManager {
    constructor(config2, state2) {
      this.config = config2;
      this.state = state2;
      this.currentContext = null;
      this.currentAdapter = null;
      this.adapters = /* @__PURE__ */ new Map();
      this.toolbarDiv = null;
      this.toolbarRow1 = null;
      this.toolbarRow2 = null;
      this.statusBar = null;
      this.statusBarLeft = null;
      this.statusBarCenter = null;
      this.statusBarRight = null;
      this.preferencesIcon = null;
      this.initialized = false;
    }
    /**
     * Register a context adapter for a specific page type
     * @param {string} contextName - Name of the context (e.g., 'feed', 'post', 'profile')
     * @param {object} adapter - Adapter object with activate/deactivate methods
     */
    registerAdapter(contextName, adapter) {
      this.adapters.set(contextName, adapter);
      adapter.setUIManager(this);
    }
    /**
     * Initialize the UIManager - creates DOM elements and inserts into page
     * Should be called after main[role="main"] is available
     */
    async initialize() {
      if (this.initialized) return;
      await waitForElement$3(constants.MAIN_SELECTOR, async (main) => {
        this.createToolbar();
        this.createStatusBar();
        await this.insertIntoDOM();
        this.initialized = true;
      });
    }
    /**
     * Create the toolbar DOM structure
     */
    createToolbar() {
      this.toolbarDiv = $(`<div id="bsky-navigator-global-toolbar" class="bsky-navigator-global-toolbar"/>`);
      this.toolbarRow1 = $(`<div class="toolbar-row toolbar-row-1 global-toolbar-row-1"/>`);
      this.toolbarDiv.append(this.toolbarRow1);
      this.toolbarRow2 = $(`<div class="toolbar-row toolbar-row-2 global-toolbar-row-2"/>`);
      this.toolbarDiv.append(this.toolbarRow2);
      this.toolbarDiv.hide();
    }
    /**
     * Create the status bar DOM structure
     */
    createStatusBar() {
      this.statusBar = $(`<div id="bsky-navigator-global-statusbar" class="bsky-navigator-global-statusbar"/>`);
      this.statusBarLeft = $(`<div class="statusBarLeft global-statusbar-left"></div>`);
      this.statusBarCenter = $(`<div class="statusBarCenter global-statusbar-center"></div>`);
      this.statusBarRight = $(`<div class="statusBarRight global-statusbar-right"></div>`);
      this.statusBar.append(this.statusBarLeft);
      this.statusBar.append(this.statusBarCenter);
      this.statusBar.append(this.statusBarRight);
      this.infoIndicator = $(
        `<div class="global-info-indicator css-175oi2r r-1loqt21 r-1otgn73 r-1oszu61 r-16y2uox r-1777fci r-gu64tb"><div class="global-info-indicator-text"/></div>`
      );
      this.statusBarCenter.append(this.infoIndicator);
      this.preferencesIcon = $(
        `<div id="globalPreferencesIndicator" class="toolbar-icon css-175oi2r r-1loqt21 r-1otgn73 r-1oszu61 r-16y2uox r-1777fci r-gu64tb"><div id="globalPreferencesIcon"><img id="globalPreferencesIconImage" class="indicator-image preferences-icon-overlay" src="${icons.preferencesOutline}"/></div></div>`
      );
      this.preferencesIcon.on("click", () => {
        $("#globalPreferencesIconImage").attr("src", icons.preferencesFilled);
        this.config.open();
      });
      this.statusBarRight.append(this.preferencesIcon);
      this.statusBar.hide();
    }
    /**
     * Insert toolbar and status bar into the DOM
     */
    insertIntoDOM() {
      const main = $(constants.MAIN_SELECTOR);
      if (!main.length) {
        console.warn('[UIManager] main[role="main"] not found');
        return;
      }
      let contentContainer = main.find("> div").first();
      if (!contentContainer.length) {
        contentContainer = main;
      }
      contentContainer.prepend(this.toolbarDiv);
      contentContainer.append(this.statusBar);
    }
    /**
     * Set the current context and activate appropriate adapter
     * @param {string} contextName - Name of the context
     * @param {object} handler - The handler for this context (optional)
     */
    setContext(contextName, handler = null) {
      if (this.initialized) {
        const toolbarInDOM = $.contains(document, this.toolbarDiv[0]);
        const statusBarInDOM = $.contains(document, this.statusBar[0]);
        if (!toolbarInDOM || !statusBarInDOM) {
          this.insertIntoDOM();
        }
      }
      if (this.currentAdapter) {
        this.currentAdapter.deactivate();
      }
      this.currentContext = contextName;
      this.currentAdapter = this.adapters.get(contextName) || this.adapters.get("default");
      if (this.currentAdapter) {
        this.currentAdapter.activate(handler);
      } else {
        this.showMinimalUI();
      }
    }
    /**
     * Show minimal UI when no adapter is available
     */
    showMinimalUI() {
      this.hideToolbarRow1();
      this.hideToolbarRow2();
      this.setInfoText("");
    }
    /**
     * Show/hide toolbar row 1 (indicators)
     */
    showToolbarRow1() {
      this.toolbarRow1.show();
    }
    hideToolbarRow1() {
      this.toolbarRow1.hide();
    }
    /**
     * Show/hide toolbar row 2 (search and controls)
     */
    showToolbarRow2() {
      this.toolbarRow2.show();
    }
    hideToolbarRow2() {
      this.toolbarRow2.hide();
    }
    /**
     * Set info text in status bar center
     * @param {string} html - HTML content to display
     */
    setInfoText(html) {
      this.infoIndicator.find(".global-info-indicator-text").html(html);
    }
    /**
     * Get toolbar row 1 element for adapter to populate
     */
    getToolbarRow1() {
      return this.toolbarRow1;
    }
    /**
     * Get toolbar row 2 element for adapter to populate
     */
    getToolbarRow2() {
      return this.toolbarRow2;
    }
    /**
     * Get status bar left section for adapter to populate
     */
    getStatusBarLeft() {
      return this.statusBarLeft;
    }
    /**
     * Get status bar right section for adapter to populate
     */
    getStatusBarRight() {
      return this.statusBarRight;
    }
    /**
     * Get the toolbar div for adding feed map or other elements
     */
    getToolbarDiv() {
      return this.toolbarDiv;
    }
    /**
     * Get the status bar element
     */
    getStatusBar() {
      return this.statusBar;
    }
    /**
     * Check if UIManager is initialized
     */
    isInitialized() {
      return this.initialized;
    }
    /**
     * Reposition UI elements (call when DOM structure changes)
     */
    async reposition() {
      this.toolbarDiv.detach();
      this.statusBar.detach();
      await this.insertIntoDOM();
    }
    /**
     * Clean up - remove UI elements from DOM
     */
    destroy() {
      if (this.toolbarDiv) {
        this.toolbarDiv.remove();
      }
      if (this.statusBar) {
        this.statusBar.remove();
      }
      this.initialized = false;
    }
  }
  class DefaultUIAdapter {
    constructor() {
      this.uiManager = null;
      this.handler = null;
    }
    /**
     * Set reference to UIManager
     */
    setUIManager(uiManager) {
      this.uiManager = uiManager;
    }
    /**
     * Activate this adapter - called when switching to this context
     * @param {object} handler - The handler for this page (may be null)
     */
    activate(handler) {
      this.handler = handler;
      const toolbar = this.uiManager.getToolbarDiv();
      const statusBar = this.uiManager.getStatusBar();
      toolbar.hide();
      statusBar.show();
      this.uiManager.hideToolbarRow1();
      this.uiManager.hideToolbarRow2();
      $("#fixed-sidecar-toggle").removeClass("visible");
      $("#fixed-sidecar-panel").removeClass("visible");
      this.uiManager.getStatusBarLeft().empty();
      this.updateInfoText();
    }
    /**
     * Deactivate this adapter - called when switching away
     */
    deactivate() {
      this.handler = null;
    }
    /**
     * Update info text based on current page
     */
    updateInfoText() {
      const path = window.location.pathname;
      let pageInfo = "";
      if (path.includes("/notifications")) {
        pageInfo = "Notifications";
      } else if (path.includes("/search")) {
        pageInfo = "Explore";
      } else if (path.includes("/settings")) {
        pageInfo = "Settings";
      } else if (path.includes("/messages")) {
        pageInfo = "Messages";
      } else if (path.includes("/lists")) {
        pageInfo = "Lists";
      } else if (path.includes("/feeds")) {
        pageInfo = "Feeds";
      } else if (path.includes("/saved") || path.includes("/bookmarks") || $('div[data-testid="bookmarksScreen"]').length) {
        pageInfo = "Saved";
      } else {
        pageInfo = "Bluesky";
      }
      this.uiManager.setInfoText(pageInfo);
    }
  }
  class FeedUIAdapter {
    constructor() {
      this.uiManager = null;
      this.handler = null;
    }
    /**
     * Set reference to UIManager
     */
    setUIManager(uiManager) {
      this.uiManager = uiManager;
    }
    /**
     * Activate this adapter - called when switching to feed context
     * @param {object} handler - The FeedItemHandler instance
     */
    activate(handler) {
      this.handler = handler;
      this.uiManager.getToolbarDiv().hide();
      this.uiManager.getStatusBar().hide();
    }
    /**
     * Deactivate this adapter - called when switching away from feed context
     */
    deactivate() {
      this.uiManager.getToolbarDiv().show();
      this.uiManager.getStatusBar().show();
      this.handler = null;
    }
  }
  class PostUIAdapter {
    constructor() {
      this.uiManager = null;
      this.handler = null;
    }
    /**
     * Set reference to UIManager
     */
    setUIManager(uiManager) {
      this.uiManager = uiManager;
    }
    /**
     * Activate this adapter - called when switching to post context
     * @param {object} handler - The PostItemHandler instance
     */
    activate(handler) {
      this.handler = handler;
      this.uiManager.getToolbarDiv().hide();
      this.uiManager.getStatusBar().show();
      this.uiManager.hideToolbarRow1();
      this.uiManager.hideToolbarRow2();
      this.uiManager.getStatusBarLeft().empty();
      this.updateInfoText();
    }
    /**
     * Deactivate this adapter
     */
    deactivate() {
      this.handler = null;
    }
    /**
     * Update status bar with post info
     */
    updateInfoText() {
      const path = window.location.pathname;
      const match2 = path.match(/\/profile\/([^/]+)\/post\//);
      if (match2) {
        const author = match2[1];
        this.uiManager.setInfoText(`Post by @${author}`);
      } else {
        this.uiManager.setInfoText("Post detail");
      }
    }
  }
  class ProfileUIAdapter {
    constructor() {
      this.uiManager = null;
      this.handler = null;
    }
    /**
     * Set reference to UIManager
     */
    setUIManager(uiManager) {
      this.uiManager = uiManager;
    }
    /**
     * Activate this adapter - called when switching to profile context
     * @param {object} handler - The ProfileItemHandler instance
     */
    activate(handler) {
      this.handler = handler;
      this.uiManager.getToolbarDiv().hide();
      this.uiManager.getStatusBar().show();
      this.uiManager.getStatusBarLeft().empty();
      this.updateInfoText();
      if (handler && handler.setUIManagerStatusBar) {
        handler.setUIManagerStatusBar(this.uiManager.getStatusBar(), this.uiManager.getStatusBarLeft());
      }
    }
    /**
     * Update info text with profile username
     */
    updateInfoText() {
      const path = window.location.pathname;
      const match2 = path.match(/\/profile\/([^/]+)/);
      if (match2) {
        const handle2 = match2[1];
        const displayName = handle2.startsWith("did:") ? "" : `@${handle2}`;
        this.uiManager.setInfoText(`Profile: ${displayName}`.trim());
      } else {
        this.uiManager.setInfoText("Profile");
      }
    }
    /**
     * Deactivate this adapter - called when switching away from profile context
     */
    deactivate() {
      const statusBar = this.uiManager.getStatusBar();
      statusBar.find(".feed-map-wrapper").remove();
      statusBar.removeClass("has-feed-map");
      this.uiManager.getToolbarDiv().show();
      this.uiManager.getStatusBar().show();
      this.handler = null;
    }
  }
  class SavedUIAdapter {
    constructor() {
      this.uiManager = null;
      this.handler = null;
    }
    /**
     * Set reference to UIManager
     */
    setUIManager(uiManager) {
      this.uiManager = uiManager;
    }
    /**
     * Activate this adapter - called when switching to saved context
     * @param {object} handler - The SavedItemHandler instance
     */
    activate(handler) {
      this.handler = handler;
      this.uiManager.getToolbarDiv().hide();
      this.uiManager.getStatusBar().show();
      this.uiManager.getStatusBarLeft().empty();
      this.uiManager.setInfoText("Saved Posts");
      if (handler && handler.setUIManagerStatusBar) {
        handler.setUIManagerStatusBar(this.uiManager.getStatusBar(), this.uiManager.getStatusBarLeft());
      }
    }
    /**
     * Deactivate this adapter - called when switching away from saved context
     */
    deactivate() {
      const statusBar = this.uiManager.getStatusBar();
      statusBar.find(".feed-map-wrapper").remove();
      statusBar.removeClass("has-feed-map");
      this.uiManager.getToolbarDiv().show();
      this.uiManager.getStatusBar().show();
      this.handler = null;
    }
  }
  const { waitForElement, observeVisibilityChange } = utils$1;
  GM_addStyle(style);
  const storedConfig = JSON.parse(GM_getValue("bluesky_navigator_config", "{}"));
  const showLoadingIndicator = storedConfig.showLoadingIndicator === true;
  if (showLoadingIndicator) {
    const addLoadingClass = () => document.body.classList.add("bsky-nav-loading-enabled");
    if (document.body) {
      addLoadingClass();
    } else {
      document.addEventListener("DOMContentLoaded", addLoadingClass);
    }
    const indicator = document.createElement("div");
    indicator.id = "feedLoadingIndicator";
    indicator.style.cssText = "position:fixed;top:0;left:0;right:0;bottom:0;display:flex;flex-direction:column;justify-content:center;align-items:center;background:rgba(255,255,255,0.95);z-index:99999;";
    indicator.innerHTML = `
    <div class="spinner" style="width:40px;height:40px;border:3px solid #e5e7eb;border-top-color:#3b82f6;border-radius:50%;animation:spin 0.8s linear infinite;"></div>
    <div class="loading-text" style="color:#6b7280;font-size:14px;margin-top:12px;">Loading...</div>
  `;
    if (document.body) {
      document.body.appendChild(indicator);
    } else {
      document.addEventListener("DOMContentLoaded", () => document.body.appendChild(indicator));
    }
  }
  let config;
  let handlers;
  (function proxyIntersectionObserverEarly() {
    const OriginalIntersectionObserver = unsafeWindow.IntersectionObserver;
    let disableLoadMore = false;
    let loadMoreCallback = null;
    let loadMoreSentinel = null;
    unsafeWindow.__bskyNavSetDisableLoadMore = (value) => {
      disableLoadMore = value;
    };
    unsafeWindow.__bskyNavGetLoadMoreCallback = () => loadMoreCallback;
    unsafeWindow.__bskyNavGetLoadMoreSentinel = () => loadMoreSentinel;
    class ProxyIntersectionObserver {
      constructor(callback, options) {
        this.callback = callback;
        this.options = options;
        this.realObserver = new OriginalIntersectionObserver((entries, observer) => {
          if (!disableLoadMore) {
            callback(entries, observer);
            return;
          }
          const filteredEntries = entries.filter((entry) => {
            const target2 = entry.target;
            if (target2.classList && (target2.classList.contains("thread") || target2.classList.contains("item"))) {
              return true;
            }
            if (target2.matches && // Common infinite scroll sentinel patterns
            (target2.matches('[data-testid="feedLoadMore"]') || target2.matches('[data-testid*="loader"]') || target2.matches('[data-testid*="Loader"]') || // Empty divs used as sentinels often have minimal height
            target2.tagName === "DIV" && target2.children.length === 0 && target2.offsetHeight < 50)) {
              if (entry.isIntersecting) {
                return false;
              }
            }
            return true;
          });
          if (filteredEntries.length > 0) {
            callback(filteredEntries, observer);
          }
        }, options);
      }
      observe(target2) {
        if (target2 && target2.matches) {
          const isFeedSentinel = target2.matches('[data-testid="feedLoadMore"]') || target2.matches('[data-testid*="loader"]') || target2.matches('[data-testid*="Loader"]') || // Empty divs near feed content are often sentinels
          target2.tagName === "DIV" && target2.children.length === 0;
          if (isFeedSentinel) {
            loadMoreSentinel = target2;
            loadMoreCallback = this.callback;
          }
        }
        this.realObserver.observe(target2);
      }
      unobserve(target2) {
        this.realObserver.unobserve(target2);
      }
      disconnect() {
        this.realObserver.disconnect();
      }
      takeRecords() {
        return this.realObserver.takeRecords();
      }
    }
    unsafeWindow.IntersectionObserver = ProxyIntersectionObserver;
  })();
  const screenPredicateMap = {
    search: (element) => $(element).find('div[data-testid="searchScreen"]').length,
    notifications: (element) => $(element).find('div[data-testid="notificationsScreen"]').length,
    chat: (element) => $(element).find('div:contains("Messages")').length,
    feeds: (element) => $(element).find('div[data-testid="FeedsScreen"]').length,
    lists: (element) => $(element).find('div[data-testid="listsScreen"]').length,
    profile: (element) => $(element).find('div[data-testid="profileScreen"]').length,
    settings: (element) => $(element).find('a[aria-label="Account"]').length,
    home: (element) => true
  };
  function getScreenFromElement(element) {
    for (const [page, predicate2] of Object.entries(screenPredicateMap)) {
      if (predicate2(element)) {
        return page;
      }
    }
    return "unknown";
  }
  (function() {
    let current_url = null;
    let context = null;
    function parseRulesConfig(configText) {
      const lines = configText.split("\n");
      const rules = {};
      let rulesName = null;
      for (let line of lines) {
        line = line.trim();
        if (!line || line.startsWith(";") || line.startsWith("#")) continue;
        const sectionMatch = line.match(/^\[([^\]]+?)(?:\s*(?:->|)\s*(.*?))?\]$/);
        if (sectionMatch) {
          rulesName = sectionMatch[1].trim();
          const backingList = sectionMatch[2]?.trim() || null;
          rules[rulesName] = [];
          if (!rules._backingLists) rules._backingLists = {};
          if (backingList) rules._backingLists[rulesName] = backingList;
          continue;
        }
        if (!rulesName) continue;
        const ruleMatch = line.match(/(allow|deny) (all|from|content|include|list) "?([^"]+)"?/);
        if (ruleMatch) {
          const [_, action, type, value] = ruleMatch;
          rules[rulesName].push({ action, type, value });
          continue;
        }
        if (line.startsWith("$")) {
          rules[rulesName].push({ action: "allow", type: "include", value: line.substring(1) });
        } else if (line.startsWith("&")) {
          const listMatch = line.match(/^&"?([^"]+)"?$/);
          if (listMatch) {
            rules[rulesName].push({ action: "allow", type: "list", value: listMatch[1] });
          }
        } else if (line.startsWith("@")) {
          rules[rulesName].push({ action: "allow", type: "from", value: line });
        } else {
          rules[rulesName].push({ action: "allow", type: "content", value: line });
        }
      }
      return rules;
    }
    function onConfigInit() {
      const stateManagerConfig = {
        stateSyncEnabled: config.get("stateSyncEnabled"),
        stateSyncConfig: config.get("stateSyncConfig"),
        stateSaveTimeout: config.get("stateSaveTimeout"),
        maxEntries: config.get("historyMax")
      };
      if (unsafeWindow.__bskyNavSetDisableLoadMore) {
        unsafeWindow.__bskyNavSetDisableLoadMore(config.get("disableLoadMoreOnScroll"));
      }
      state.init(constants.STATE_KEY, stateManagerConfig, onStateInit);
    }
    function onConfigSave() {
      state.stateManager.saveStateImmediately(true, true);
      updateContentWidth();
      if (config.get("toastNotifications")) {
        createToastContainer();
      }
      config.close();
      setTimeout(() => {
        if (handlers) {
          for (const handler of Object.values(handlers)) {
            if (handler.isActive() && typeof handler.onRulesChanged === "function") {
              handler.onRulesChanged();
            }
          }
        }
      }, 100);
    }
    function updateContentWidth() {
      const hideRightSidebar = config.get("hideRightSidebar");
      const maxWidth = config.get("postWidthDesktop");
      const contentWidth = maxWidth || 600;
      const styleId = "bsky-nav-width-style";
      let styleEl = document.getElementById(styleId);
      if (hideRightSidebar && contentWidth !== 600) {
        if (!styleEl) {
          styleEl = document.createElement("style");
          styleEl.id = styleId;
          document.head.appendChild(styleEl);
        }
        const compactLayout = config.get("compactLayout");
        if (compactLayout) {
          const navWidthFull = 240;
          const navWidthCollapsed = 80;
          const gap = 20;
          styleEl.textContent = `
          /* Desktop: full nav width */
          @media (min-width: 1301px) {
            main[role="main"] [style*="max-width: 600px"],
            main[role="main"] [style*="max-width:600px"] {
              max-width: ${contentWidth}px !important;
              margin-left: ${navWidthFull + gap}px !important;
              margin-right: auto !important;
              transform: none !important;
            }
            #statusBar,
            #bsky-navigator-global-statusbar {
              max-width: ${contentWidth}px !important;
              margin-left: ${navWidthFull + gap}px !important;
              margin-right: auto !important;
              transform: none !important;
            }
          }
          /* Narrow: collapsed nav width */
          @media (max-width: 1300px) {
            main[role="main"] [style*="max-width: 600px"],
            main[role="main"] [style*="max-width:600px"] {
              max-width: ${contentWidth}px !important;
              margin-left: ${navWidthCollapsed + gap}px !important;
              margin-right: auto !important;
              transform: none !important;
            }
            #statusBar,
            #bsky-navigator-global-statusbar {
              max-width: ${contentWidth}px !important;
              margin-left: ${navWidthCollapsed + gap}px !important;
              margin-right: auto !important;
              transform: none !important;
            }
          }
          div[data-testid="homeScreenFeedTabs"] {
            width: 100% !important;
          }
          /* Position nav from left edge instead of center-relative */
          nav[role="navigation"] {
            left: 0 !important;
            transform: none !important;
            padding-left: 20px !important;
          }
        `;
        } else {
          const extraWidth = contentWidth - 600;
          const shiftRight = Math.floor(extraWidth / 2);
          styleEl.textContent = `
          main[role="main"] [style*="max-width: 600px"],
          main[role="main"] [style*="max-width:600px"] {
            max-width: ${contentWidth}px !important;
            transform: translateX(${shiftRight}px) !important;
          }
          div[data-testid="homeScreenFeedTabs"] {
            width: 100% !important;
          }
          #statusBar,
          #bsky-navigator-global-statusbar {
            max-width: ${contentWidth}px !important;
            transform: translateX(${shiftRight}px) !important;
          }
        `;
        }
      } else if (styleEl) {
        styleEl.textContent = "";
      }
      updatePostMaxHeight();
    }
    function updatePostMaxHeight() {
      const postMaxHeight = config.get("postMaxHeight");
      const styleId = "bsky-nav-post-height-style";
      let styleEl = document.getElementById(styleId);
      if (postMaxHeight && postMaxHeight !== "Off") {
        if (!styleEl) {
          styleEl = document.createElement("style");
          styleEl.id = styleId;
          document.head.appendChild(styleEl);
        }
        styleEl.textContent = `
        /* Collapse unfocused posts */
        div[data-testid="contentHider-post"] {
          max-height: ${postMaxHeight} !important;
          overflow: hidden !important;
          position: relative !important;
        }
        /* Fade overlay to indicate more content */
        div[data-testid="contentHider-post"]::after {
          content: '';
          position: absolute;
          bottom: 0;
          left: 0;
          right: 0;
          height: 40px;
          background: linear-gradient(transparent, var(--background-color, white));
          pointer-events: none;
        }
        /* Expand when post is selected */
        .item-selection-active div[data-testid="contentHider-post"],
        .item-selection-child-focused div[data-testid="contentHider-post"] {
          max-height: none !important;
          overflow: visible !important;
        }
        .item-selection-active div[data-testid="contentHider-post"]::after,
        .item-selection-child-focused div[data-testid="contentHider-post"]::after {
          display: none;
        }
      `;
      } else if (styleEl) {
        styleEl.textContent = "";
      }
    }
    const seenNotifications = /* @__PURE__ */ new Set();
    let toastContainer = null;
    let notificationPollInterval = null;
    let toastApi = null;
    let lastSeenAt = null;
    function initToastNotifications(api) {
      if (!config.get("toastNotifications")) {
        return;
      }
      toastApi = api;
      createToastContainer();
      if (toastApi) {
        startNotificationPolling();
        if (config.get("toastTestMode")) {
          setTimeout(() => {
            fetchAndShowTestNotification();
          }, 2e3);
        }
      }
    }
    function createToastContainer() {
      if (toastContainer) {
        toastContainer.remove();
      }
      const position = config.get("toastPosition") || "Top Right";
      const positionClass = position.toLowerCase().replace(" ", "-");
      toastContainer = $(`<div class="bsky-nav-toast-container ${positionClass}"></div>`);
      $("body").append(toastContainer);
      $(document).off("keydown.toastDismiss");
      setupToastKeyboardHandler();
    }
    function dismissOldestToast() {
      if (!toastContainer) return;
      const $oldest = toastContainer.find(".bsky-nav-toast").first();
      if ($oldest.length) {
        removeToast($oldest, true);
      }
    }
    function setupToastKeyboardHandler() {
      $(document).on("keydown.toastDismiss", (e) => {
        if (e.key !== "x") return;
        if (isUserTyping()) return;
        if (isModalOpen()) return;
        dismissOldestToast();
      });
    }
    function parseApiNotification(apiNotification) {
      const notification2 = {
        id: apiNotification.uri || apiNotification.cid || Date.now().toString(),
        indexedAt: apiNotification.indexedAt
      };
      const author = apiNotification.author;
      if (author) {
        notification2.author = author.displayName || author.handle;
        notification2.handle = author.handle;
        notification2.avatar = author.avatar || "";
      }
      const reason = apiNotification.reason;
      switch (reason) {
        case "like":
          notification2.type = "like";
          notification2.action = "liked your post";
          break;
        case "like-via-repost":
          notification2.type = "like";
          notification2.action = "liked your repost";
          break;
        case "repost":
          notification2.type = "repost";
          notification2.action = "reposted your post";
          break;
        case "repost-via-repost":
          notification2.type = "repost";
          notification2.action = "reposted your repost";
          break;
        case "reply":
          notification2.type = "reply";
          notification2.action = "replied to your post";
          break;
        case "follow":
          notification2.type = "follow";
          notification2.action = "followed you";
          break;
        case "quote":
          notification2.type = "quote";
          notification2.action = "quoted your post";
          break;
        case "mention":
          notification2.type = "mention";
          notification2.action = "mentioned you";
          break;
        case "starterpack-joined":
          notification2.type = "follow";
          notification2.action = "joined your starter pack";
          break;
        default:
          return null;
      }
      if (apiNotification.record?.text) {
        notification2.preview = apiNotification.record.text.substring(0, 100);
      }
      if (!notification2.preview && apiNotification.reasonSubject) {
        notification2.subjectUri = apiNotification.reasonSubject;
      }
      if (apiNotification.indexedAt) {
        const date = new Date(apiNotification.indexedAt);
        const now = /* @__PURE__ */ new Date();
        const diffMs = now - date;
        const diffMins = Math.floor(diffMs / 6e4);
        const diffHours = Math.floor(diffMs / 36e5);
        const diffDays = Math.floor(diffMs / 864e5);
        if (diffMins < 1) {
          notification2.time = "now";
        } else if (diffMins < 60) {
          notification2.time = `${diffMins}m`;
        } else if (diffHours < 24) {
          notification2.time = `${diffHours}h`;
        } else {
          notification2.time = `${diffDays}d`;
        }
      }
      if (apiNotification.reasonSubject) {
        const parts = apiNotification.reasonSubject.split("/");
        const postId = parts[parts.length - 1];
        const did2 = parts[2];
        notification2.url = `/profile/${did2}/post/${postId}`;
      } else if (apiNotification.uri && reason !== "follow") {
        const parts = apiNotification.uri.split("/");
        const postId = parts[parts.length - 1];
        notification2.url = `/profile/${notification2.handle}/post/${postId}`;
      } else if (reason === "follow") {
        notification2.url = `/profile/${notification2.handle}`;
      }
      return notification2;
    }
    function showToast2(notification2) {
      if (!toastContainer || !notification2) return;
      const iconSvgs = {
        like: '<svg fill="none" viewBox="0 0 24 24" width="16" height="16"><path fill="currentColor" d="M12.489 21.372c8.528-4.78 10.626-10.47 9.022-14.47-.779-1.941-2.414-3.333-4.342-3.763-1.697-.378-3.552.003-5.169 1.287-1.617-1.284-3.472-1.665-5.17-1.287-1.927.43-3.562 1.822-4.34 3.764-1.605 4 .493 9.69 9.021 14.47a1 1 0 0 0 .978 0Z"></path></svg>',
        repost: '<svg fill="none" viewBox="0 0 24 24" width="16" height="16"><path fill="currentColor" d="M17.957 2.293a1 1 0 1 0-1.414 1.414L17.836 5H6a3 3 0 0 0-3 3v3a1 1 0 1 0 2 0V8a1 1 0 0 1 1-1h11.836l-1.293 1.293a1 1 0 0 0 1.414 1.414l2.47-2.47a1.75 1.75 0 0 0 0-2.474l-2.47-2.47ZM20 12a1 1 0 0 1 1 1v3a3 3 0 0 1-3 3H6.164l1.293 1.293a1 1 0 1 1-1.414 1.414l-2.47-2.47a1.75 1.75 0 0 1 0-2.474l2.47-2.47a1 1 0 0 1 1.414 1.414L6.164 17H18a1 1 0 0 0 1-1v-3a1 1 0 0 1 1-1Z"></path></svg>',
        reply: '<svg fill="none" viewBox="0 0 24 24" width="16" height="16"><path fill="currentColor" d="M20.002 7a2 2 0 0 0-2-2h-12a2 2 0 0 0-2 2v8a2 2 0 0 0 2 2h2a1 1 0 0 1 1 1v1.918l3.375-2.7a1 1 0 0 1 .625-.218h5a2 2 0 0 0 2-2V7Zm2 8a4 4 0 0 1-4 4h-4.648l-4.727 3.781A1.001 1.001 0 0 1 7.002 22v-3h-1a4 4 0 0 1-4-4V7a4 4 0 0 1 4-4h12a4 4 0 0 1 4 4v8Z"></path></svg>',
        follow: '<svg fill="none" viewBox="0 0 24 24" width="16" height="16"><path fill="currentColor" d="M12 4a4 4 0 1 0 0 8 4 4 0 0 0 0-8ZM6 8a6 6 0 1 1 12 0A6 6 0 0 1 6 8Zm2 10a3 3 0 0 0-3 3 1 1 0 1 1-2 0 5 5 0 0 1 5-5h8a5 5 0 0 1 5 5 1 1 0 1 1-2 0 3 3 0 0 0-3-3H8Z"></path></svg>',
        mention: '<svg fill="none" viewBox="0 0 24 24" width="16" height="16"><path fill="currentColor" d="M12 4a8 8 0 1 0 4.906 14.32 1 1 0 0 1 1.218 1.588A10 10 0 1 1 22 12v1.5a3.5 3.5 0 0 1-6.063 2.395A5 5 0 1 1 17 12v1.5a1.5 1.5 0 0 0 3 0V12a8 8 0 0 0-8-8Zm3 8a3 3 0 1 0-6 0 3 3 0 0 0 6 0Z"></path></svg>',
        quote: '<svg fill="none" viewBox="0 0 24 24" width="16" height="16"><path fill="currentColor" d="M10 7H6a2 2 0 0 0-2 2v4a2 2 0 0 0 2 2h2v2a2 2 0 0 1-2 2 1 1 0 1 0 0 2 4 4 0 0 0 4-4V9a2 2 0 0 0-2-2Zm10 0h-4a2 2 0 0 0-2 2v4a2 2 0 0 0 2 2h2v2a2 2 0 0 1-2 2 1 1 0 1 0 0 2 4 4 0 0 0 4-4V9a2 2 0 0 0-2-2Z"></path></svg>'
      };
      const durationValues = [1, 2, 3, 4, 5, 10, 15, 30, 60, 300, Infinity];
      const sliderPos = config.get("toastDuration") ?? 4;
      const durationSeconds = durationValues[sliderPos] ?? 5;
      const duration = durationSeconds === Infinity ? null : durationSeconds * 1e3;
      const $toast = $(`
      <div class="bsky-nav-toast" data-indexed-at="${notification2.indexedAt || ""}">
        <div class="bsky-nav-toast-icon ${notification2.type}">
          ${iconSvgs[notification2.type] || ""}
        </div>
        <div class="bsky-nav-toast-content">
          <div class="bsky-nav-toast-header">
            ${notification2.avatar ? `<img class="bsky-nav-toast-avatar" src="${notification2.avatar}" alt="">` : ""}
            <span class="bsky-nav-toast-author">${notification2.author || "Someone"}</span>
            ${notification2.handle ? `<span class="bsky-nav-toast-handle">@${notification2.handle}</span>` : ""}
          </div>
          <span class="bsky-nav-toast-action">${notification2.action}</span>
          ${notification2.preview ? `<div class="bsky-nav-toast-preview">${notification2.preview}</div>` : ""}
          ${notification2.time ? `<span class="bsky-nav-toast-time">${notification2.time}</span>` : ""}
        </div>
        <button class="bsky-nav-toast-close" aria-label="Dismiss">\xD7</button>
      </div>
    `);
      $toast.on("click", (e) => {
        if (!$(e.target).is(".bsky-nav-toast-close")) {
          window.location.href = "/notifications";
          removeToast($toast, true);
        }
      });
      $toast.find(".bsky-nav-toast-close").on("click", (e) => {
        e.stopPropagation();
        removeToast($toast, true);
      });
      toastContainer.append($toast);
      setTimeout(() => $toast.addClass("visible"), 10);
      if (duration !== null) {
        setTimeout(() => removeToast($toast, false), duration);
      }
    }
    function removeToast($toast, markAsRead = false) {
      if (markAsRead && toastApi) {
        const toastEl = $toast[0];
        const indexedAt = toastEl?.getAttribute("data-indexed-at");
        console.log("removeToast indexedAt:", indexedAt, "type:", typeof indexedAt);
        if (indexedAt && indexedAt.length > 0) {
          markNotificationsSeenUpTo(indexedAt);
        }
      }
      $toast.removeClass("visible");
      setTimeout(() => $toast.remove(), 300);
    }
    async function markNotificationsSeenUpTo(indexedAt) {
      if (!toastApi) return;
      console.log("markNotificationsSeenUpTo called with:", indexedAt, "type:", typeof indexedAt);
      if (!indexedAt || typeof indexedAt !== "string") {
        console.warn("markNotificationsSeenUpTo: invalid indexedAt:", indexedAt);
        return;
      }
      try {
        const notifDate = new Date(indexedAt);
        notifDate.setMilliseconds(notifDate.getMilliseconds() + 1);
        const seenAt = notifDate.toISOString();
        console.log("Calling markNotificationsSeen with:", seenAt, "(original:", indexedAt, ")");
        await toastApi.markNotificationsSeen(seenAt);
        const notificationDate = new Date(indexedAt);
        if (!lastSeenAt || notificationDate > lastSeenAt) {
          lastSeenAt = notificationDate;
        }
        updateNotificationBadge();
      } catch (error) {
        console.warn("Failed to mark notification as read:", error);
      }
    }
    function updateNotificationBadge() {
      const notifLink = $('a[aria-label="Notifications"]');
      if (!notifLink.length) return;
      const badge = notifLink.find('div[aria-label*="unread"]');
      if (!badge.length) return;
      const ariaLabel = badge.attr("aria-label") || "";
      const match2 = ariaLabel.match(/(\d+)\s+unread/);
      if (!match2) return;
      const currentCount = parseInt(match2[1], 10);
      const newCount = Math.max(0, currentCount - 1);
      if (newCount === 0) {
        badge.remove();
      } else {
        badge.text(newCount);
        badge.attr("aria-label", `${newCount} unread item${newCount === 1 ? "" : "s"}`);
      }
    }
    function startNotificationPolling() {
      if (notificationPollInterval) {
        clearInterval(notificationPollInterval);
      }
      const pollIntervalMs = 3e4;
      fetchNotifications();
      notificationPollInterval = setInterval(() => {
        if (config.get("toastNotifications") && toastApi) {
          fetchNotifications();
        }
      }, pollIntervalMs);
    }
    async function fetchNotifications() {
      if (!toastApi) return;
      try {
        if (!toastApi.agent.session) {
          await toastApi.login();
        }
        const result = await toastApi.getNotifications(20);
        const notifications = result.notifications || [];
        if (result.seenAt) {
          lastSeenAt = new Date(result.seenAt);
        }
        for (const apiNotification of notifications) {
          const notification2 = parseApiNotification(apiNotification);
          if (!notification2) continue;
          if (seenNotifications.has(notification2.id)) {
            continue;
          }
          seenNotifications.add(notification2.id);
          if (lastSeenAt && notification2.indexedAt) {
            const notificationDate = new Date(notification2.indexedAt);
            if (notificationDate <= lastSeenAt) {
              continue;
            }
          }
          if (!notification2.preview && notification2.subjectUri) {
            try {
              const thread = await toastApi.getThread(notification2.subjectUri);
              if (thread?.post?.record?.text) {
                notification2.preview = thread.post.record.text.substring(0, 100);
              }
            } catch (err) {
              console.warn("Failed to fetch post for notification preview:", err);
            }
          }
          showToast2(notification2);
        }
        if (seenNotifications.size > 1e3) {
          const iterator = seenNotifications.values();
          for (let i = 0; i < 500; i++) {
            seenNotifications.delete(iterator.next().value);
          }
        }
      } catch (error) {
        console.error("Failed to fetch notifications:", error);
      }
    }
    async function fetchAndShowTestNotification() {
      if (!toastApi) {
        return;
      }
      try {
        if (!toastApi.agent.session) {
          await toastApi.login();
        }
        const result = await toastApi.getNotifications(1);
        const notifications = result.notifications || [];
        if (notifications.length > 0) {
          const notification2 = parseApiNotification(notifications[0]);
          if (notification2) {
            seenNotifications.clear();
            showToast2(notification2);
          }
        }
      } catch (error) {
        console.error("Toast test: Failed to fetch notification:", error);
      }
    }
    function onStateInit() {
      let widthWatcher;
      let api;
      if (config.get("atprotoService") && config.get("atprotoIdentifier") && config.get("atprotoPassword")) {
        api = new BlueskyAPI(
          config.get("atprotoService"),
          config.get("atprotoIdentifier"),
          config.get("atprotoPassword")
        );
        api.login();
        async function loadSidecarTemplate(selector, html) {
          try {
            const popupContainer = $(selector).append(html);
            $(".close-btn").on("click", function() {
              $("#bluesky-popup").hide();
            });
          } catch (error) {
            console.error("Failed to load popup:", error);
          }
        }
        loadSidecarTemplate("body", sidecarTemplatesHtml);
      }
      let listCache = null;
      if (api) {
        listCache = new ListCache(api);
      }
      state.listCache = listCache;
      state.mobileView = window.innerWidth <= 800;
      handlers = {
        feed: new FeedItemHandler("feed", config, state, api, constants.FEED_ITEM_SELECTOR),
        post: new PostItemHandler("post", config, state, api, constants.POST_ITEM_SELECTOR),
        profile: new ProfileItemHandler("profile", config, state, api, constants.FEED_ITEM_SELECTOR),
        saved: new SavedItemHandler("saved", config, state, api, constants.FEED_ITEM_SELECTOR),
        input: new Handler("input", config, state, api)
      };
      const hasActiveItemHandler = ["feed", "post", "profile", "saved"].some((name) => handlers[name]?.isActive());
      if (!hasActiveItemHandler) {
        const indicator = document.getElementById("feedLoadingIndicator");
        if (indicator) indicator.remove();
        document.body.classList.remove("bsky-nav-loading-enabled");
        document.body.classList.add("bsky-nav-feed-ready");
      }
      if (state.rulesConfig) {
        config.set("rulesConfig", state.rulesConfig);
      }
      state.rules = parseRulesConfig(config.get("rulesConfig"));
      state.parseRulesConfig = parseRulesConfig;
      initToastNotifications(api);
      const uiManager = new UIManager(config, state);
      const defaultAdapter = new DefaultUIAdapter();
      const feedAdapter = new FeedUIAdapter();
      const postAdapter = new PostUIAdapter();
      const profileAdapter = new ProfileUIAdapter();
      const savedAdapter = new SavedUIAdapter();
      uiManager.registerAdapter("default", defaultAdapter);
      uiManager.registerAdapter("input", defaultAdapter);
      uiManager.registerAdapter("feed", feedAdapter);
      uiManager.registerAdapter("saved", savedAdapter);
      uiManager.registerAdapter("post", postAdapter);
      uiManager.registerAdapter("profile", profileAdapter);
      uiManager.initialize().then(() => {
        if (context && uiManager.isInitialized()) {
          uiManager.setContext(context, handlers[context] || null);
        }
      });
      if (config.get("showDebuggingInfo")) {
        let appendLog = function(type, args) {
          const message2 = `[${type.toUpperCase()}] ${args.map((arg) => typeof arg === "object" ? JSON.stringify(arg, null, 2) : arg).join(" ")}`;
          $("#logContent").append(`<div style="margin-bottom: 5px;">${message2}</div>`);
          $("#logContent").scrollTop($("#logContent")[0].scrollHeight);
        };
        const logContainer = $(`<div id="logContainer"></div>`);
        $("body").append(logContainer);
        const logHeader = $(`<div id="logHeader"></div>`);
        logHeader.append($(`<button id="clearLogs"/>Clear</button>`));
        logContainer.append(logHeader);
        logContainer.append($(`<div id="logContent"></div>`));
        $("#clearLogs").on("click", function() {
          $("#logContent").empty();
        });
        const originalConsole = {};
        ["log", "warn", "error", "info"].forEach((type) => {
          originalConsole[type] = console[type];
          unsafeWindow.console[type] = function(...args) {
            appendLog(type, args);
            originalConsole[type].apply(console, args);
          };
        });
        window.console = unsafeWindow.console;
      }
      function applyAccessibilityStyles() {
        const reducedMotion = config.get("reducedMotion");
        const highContrast = config.get("highContrastMode");
        const focusRingColor = config.get("focusRingColor") || "#0066cc";
        const focusRingWidth = config.get("focusRingWidth") || 2;
        let accessibilityStyles = `:root {
        --focus-ring-color: ${focusRingColor};
        --focus-ring-width: ${focusRingWidth}px;
      }`;
        if (reducedMotion === "Always") {
          accessibilityStyles += `
          :root {
            --transition-duration: 0ms;
            --animation-duration: 0ms;
          }
          *, *::before, *::after {
            animation-duration: 0.01ms !important;
            animation-iteration-count: 1 !important;
            transition-duration: 0.01ms !important;
          }
        `;
        } else if (reducedMotion === "Never") {
          accessibilityStyles += `
          :root {
            --transition-duration: 200ms;
            --animation-duration: 300ms;
          }
        `;
        }
        if (highContrast) {
          accessibilityStyles += `
          :root {
            --focus-ring-color: #000000;
            --focus-ring-width: 3px;
          }
        `;
        }
        let accessibilityStyleEl = document.getElementById("bsky-nav-accessibility-styles");
        if (!accessibilityStyleEl) {
          accessibilityStyleEl = document.createElement("style");
          accessibilityStyleEl.id = "bsky-nav-accessibility-styles";
          document.head.appendChild(accessibilityStyleEl);
        }
        accessibilityStyleEl.textContent = accessibilityStyles;
      }
      applyAccessibilityStyles();
      const stylesheet = `

        /* Feed itmes may be sorted, so we hide them visually and show them later */
        div[data-testid$="FeedPage"] ${constants.FEED_ITEM_SELECTOR} {
            opacity: 0%;
        }

        ${config.get("hideLoadNewButton") ? `
            ${constants.LOAD_NEW_BUTTON_SELECTOR} {
                display: none;
            }
            ` : ``}

        ${config.get("hideSuggestedFollows") ? `
            /* Hide "Suggested for you" section - uses .bsky-nav-suggested-hidden class applied by JS */
            .bsky-nav-suggested-hidden {
                display: none !important;
            }
            ` : ``}

        .item  {
            margin: 3px;
            ${config.get("posts")}
        }

        .item > div {
            border: none;
        }

        .item-selection-active {
            ${config.get("selectionActive")}
        }

        .item-selection-inactive {
            ${config.get("selectionInactive")}
        }

        .item-selection-child-focused {
            ${config.get("selectionChildFocused")}
        }

        .reply-selection-active {
            ${config.get("replySelectionActive")};
        }

        .reply-selection-child-focused {
            outline: 1px color-mix(in srgb, var(--focus-ring-color, #0066cc) 35%, transparent) solid !important;
        }

        .sidecar-collapsed {
            border-right: 3px dashed var(--focus-ring-color, #0066cc) !important;
        }

        .sidecar-post {
            margin: 1px;
            ${config.get("replySelectionInactive")}
        }

        /* Sidecar width configuration - only apply when using inline sidecar */
        ${config.get("fixedSidecar") !== true && config.get("fixedSidecar") !== "Fixed" ? `
        @media only screen and (min-width: 801px) {
            /* Only narrow items that have sidecar content */
            .item.has-sidecar {
                flex: ${100 - (config.get("sidecarWidthPercent") || 30)} !important;
            }
            .sidecar-replies {
                flex: ${config.get("sidecarWidthPercent") || 30} !important;
            }
            /* Reset item width when inline sidecar is hidden */
            body.inline-sidecar-hidden .item.has-sidecar {
                flex: 1 !important;
            }
            body.inline-sidecar-hidden .sidecar-replies {
                display: none !important;
            }
        }
        ` : ""}

        @media (prefers-color-scheme:light){
            .item-unread {
                ${config.get("unreadPosts")};
                ${config.get("unreadPostsLightMode")};
            }

            .item-read {
                ${config.get("readPosts")};
                ${config.get("readPostsLightMode")};
            }

        }

        @media (prefers-color-scheme:dark){
            .item-unread {
                ${config.get("unreadPosts")};
                ${config.get("unreadPostsDarkMode")};
            }

            .item-read {
                ${config.get("readPosts")};
                ${config.get("readPostsDarkMode")};
            }
        }

        .thread-first {
            margin-top: ${config.get("threadMargin")};
            border-top: 1px rgb(212, 219, 226) solid;
        }

        .thread-last {
            margin-bottom: ${config.get("threadMargin")};
        }

        /* hack to fix last thread item indicator being offset */
        .thread-last div.r-lchren {
            left: 10px;
        }

        div.r-m5arl1 {
            width: ${config.get("threadIndicatorWidth")}px;
            background-color: ${config.get("threadIndicatorColor")} !important;
        }

        div:has(main) {
            overflow-x: clip;
        }

        ${constants.POST_CONTENT_SELECTOR} {
            margin: 1em 1px 1px 1px;
        }

        ${constants.HOME_SCREEN_SELECTOR} .item > div:first-of-type > div:last-of-type > div:last-of-type > div:first-of-type {
            flex: unset !important;
        }



`;
      const styleElement = document.createElement("style");
      styleElement.type = "text/css";
      styleElement.textContent = stylesheet;
      document.head.appendChild(styleElement);
      function onWindowResize(_element) {
      }
      function updateScreen(screen) {
        if (state.screen == screen) {
          return;
        }
        state.screen = screen;
        if (screen == "search") {
          if ($(":focus") != $('input[role="search"]')) {
            $('input[role="search"]').focus();
          }
        }
        if (!widthWatcher && !state.mobileView) {
          widthWatcher = waitForElement(constants.WIDTH_SELECTOR, onWindowResize);
        }
      }
      waitForElement(constants.SCREEN_SELECTOR, (element) => {
        updateScreen(getScreenFromElement(element));
        observeVisibilityChange($(element), (isVisible) => {
          if (isVisible) {
            updateScreen(getScreenFromElement(element));
          }
        });
      });
      function setContext(ctx, forceRefresh = false) {
        const contextChanged = context !== ctx;
        if (contextChanged) {
          context = ctx;
          for (const [name, handler] of Object.entries(handlers)) {
            handler.deactivate();
          }
          if (handlers[context]) {
            handlers[context].activate();
          }
        }
        if ((contextChanged || forceRefresh) && uiManager.isInitialized()) {
          uiManager.setContext(ctx, handlers[ctx] || null);
        }
      }
      function setContextFromUrl() {
        const newUrl = window.location.href;
        const urlChanged = newUrl !== current_url;
        current_url = newUrl;
        let matched = false;
        for (const [name, handler] of Object.entries(handlers)) {
          if (name === "input") continue;
          if (handler.isActive()) {
            setContext(name, urlChanged);
            matched = true;
            break;
          }
        }
        if (!matched) {
          setContext("default", urlChanged);
          const indicator = document.getElementById("feedLoadingIndicator");
          if (indicator) indicator.remove();
          document.body.classList.remove("bsky-nav-loading-enabled");
          document.body.classList.add("bsky-nav-feed-ready");
        }
      }
      function onFocus(e) {
        const target2 = e.target;
        if (typeof target2.tagName === "undefined") {
          return false;
        }
        if ($(target2).closest("#bsky-navigator-toolbar, .bsky-nav-rules-dropdown").length) {
          return;
        }
        const targetTagName = target2.tagName.toLowerCase();
        switch (targetTagName) {
          case "input":
          case "textarea":
            setContext("input");
            break;
          case "div": {
            const maybeTiptap = $(target2).closest(".tiptap");
            if (maybeTiptap.length) {
              waitForElement(
                ".tiptap",
                () => null,
                () => onBlur({ target: maybeTiptap[0] })
              );
              setContext("input");
            } else {
              setContextFromUrl();
            }
            break;
          }
          default:
            setContextFromUrl();
        }
      }
      function onBlur(e) {
        const target2 = e.target;
        if (typeof target2.tagName === "undefined") {
          return false;
        }
        const targetTagName = target2.tagName.toLowerCase();
        switch (targetTagName) {
          case "input":
          case "textarea":
            setContextFromUrl();
            break;
          case "div":
            if ($(target2).closest(".tiptap").length) {
              setContextFromUrl();
            }
            break;
          default:
            setContextFromUrl();
            break;
        }
      }
      document.addEventListener("focus", onFocus, true);
      document.addEventListener("blur", onBlur, true);
      function startMonitor() {
        setInterval(function() {
          if (window.location.href !== current_url) {
            setContextFromUrl();
          }
        }, constants.URL_MONITOR_INTERVAL);
      }
      waitForElement(
        `${constants.DRAWER_MENU_SELECTOR}, ${constants.LEFT_SIDEBAR_SELECTOR}`,
        (element) => {
          const isMobileByElement = $(element).is(constants.DRAWER_MENU_SELECTOR);
          const isMobileByWidth = window.innerWidth <= 800;
          state.mobileView = isMobileByElement || isMobileByWidth;
          startMonitor();
          setContextFromUrl();
          if (!state.mobileView) {
            applyDesktopFullWidth();
          }
        }
      );
      function applyDesktopFullWidth() {
        const hideRightSidebar = config.get("hideRightSidebar");
        if (hideRightSidebar) {
          document.body.classList.add("bsky-nav-hide-right-sidebar");
          updateContentWidth();
        }
        if (config.get("hideSuggestedFollows")) {
          hideSuggestedFollows();
        }
      }
      function hideSuggestedFollows() {
        const observer = new MutationObserver(() => {
          document.querySelectorAll('div[dir="auto"]').forEach((el) => {
            if (el.textContent === "Suggested for you") {
              let container = el.closest('div[style*="background-color: rgb(249, 250, 251)"]');
              if (container && !container.classList.contains("bsky-nav-suggested-hidden")) {
                container.classList.add("bsky-nav-suggested-hidden");
              }
            }
          });
        });
        observer.observe(document.body, { childList: true, subtree: true });
        document.querySelectorAll('div[dir="auto"]').forEach((el) => {
          if (el.textContent === "Suggested for you") {
            let container = el.closest('div[style*="background-color: rgb(249, 250, 251)"]');
            if (container) {
              container.classList.add("bsky-nav-suggested-hidden");
            }
          }
        });
      }
    }
    config = new ConfigWrapper({
      id: "bluesky_navigator",
      onInit: onConfigInit,
      onSave: onConfigSave
    });
    unsafeWindow.config = config;
    unsafeWindow.blueskyNavigatorState = state;
    unsafeWindow.bskyDebug = {
      rulesSync: () => handlers.feed?.debugRulesSync(),
      handleMatch: (handle2, category) => handlers.feed?.debugHandleMatch(handle2, category),
      state: () => state,
      rules: () => state.rules,
      config: () => config.get("rulesConfig")
    };
    $(document).ready(function(e) {
      const originalPlay = HTMLMediaElement.prototype.play;
      HTMLMediaElement.prototype.play = function() {
        const isUserInitiated = this.dataset.allowPlay === "true";
        if (isUserInitiated || config.get("videoPreviewPlayback") == "Play all") {
          delete this.dataset.allowPlay;
          return originalPlay.apply(this, arguments);
        } else if ($(document.activeElement).is('button[aria-label^="Play"]')) {
          return originalPlay.apply(this, arguments);
        } else {
          return Promise.resolve();
        }
      };
    });
  })();
})();
